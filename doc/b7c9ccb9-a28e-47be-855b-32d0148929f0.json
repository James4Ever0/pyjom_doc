{
    "summary": "The code creates a COCO-PIP dataset by generating four identical images, adjusting parameters randomly. It utilizes numpy arrays and defines functions for gradient images and background colors. It generates bounding boxes, resizes images, and prepares image canvas for data export and preview.",
    "details": [
        {
            "comment": "Code imports necessary libraries and defines variables for creating a COCO-PIP dataset. It uses four identical images, adjusts image size and positioning parameters randomly, and sets maximum image count.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tests/anime_highlight_cuts/theme_collector/create_coco_pip_dataset.py\":0-33",
            "content": "# use what? better use some standard library.\n# you must know where you have put all these images.\n# TODO: remember to upload dataset creation things to kaggle as separate python scripts and execute it in separate process to prevent memory leaks (hopefully)\nimport cv2\nimport numpy as np\nimport os\nfrom string import punctuation\nimport random\nimport itertools\nfrom PIL import Image, ImageDraw\nimageBasePath = \"/Users/jamesbrown/Desktop/\"\nimagePaths = [\n    \"Screen Shot 2023-01-17 at 15.35.29.png\"\n] * 4  # let's all be the same, for testing.\nwidth = 800\nhalf_width = int(width / 2)  # either use 1,2,4 images.\ntextTotalHeight = 300  # either add to top or bottom.\ngetMarginRatio = lambda: random.choice(\n    [0, random.random() * 0.15, random.random() * 0.1, random.random() * 0.05]\n)  # this margin is used randomly. we can make it 0 or as is.\ntextOrigin = (-30, 30)\nfontScale = 1\nfont = cv2.FONT_HERSHEY_SIMPLEX\nfontThickness = 2\ngetRadius = lambda: random.randint(1, 30)\nimageIndex = 0  # shall be increased on demand.\nMAX_COCO_PIP_IMAGE_COUNT = 10000  # well, super huge. is it?"
        },
        {
            "comment": "This code generates random characters, lines of characters, and sets up variables for image, text, and background formats along with colors. It uses a lambda function to generate random characters, joining them into lines. The code also includes a list of color options and converts them into numpy arrays. However, while testing, the code is not choosing random values from imageFormats, textFormats, and backgroundFormats.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tests/anime_highlight_cuts/theme_collector/create_coco_pip_dataset.py\":35-67",
            "content": "alphabets = \"abcdefghijklmnopqrstuvwxyz\"\nALPHABETS = alphabets.upper()\nnumbers = \"0123456789\"\ncharacterList = list(alphabets + ALPHABETS + numbers + punctuation + \" \")\ngetRandomCharacter = lambda: random.choice(characterList)\ngetRandomCharacters = lambda charCount: \"\".join(\n    [getRandomCharacter() for _ in range(charCount)]\n)\ngetRandomLinesOfCharacters = lambda lineCount, charCount: \"\\r\".join(\n    [getRandomCharacters(charCount) for _ in range(lineCount)]\n)\nimageFormats = [1, 2, 4]\ntextFormats = [\"up\", \"down\", \"none\"]\nbackgroundFormats = [\"solidColor\", \"horizontalStripes\", \"verticalStripes\", \"gradients\"]\ncolors = [\n    (0, 0, 0),\n    (255, 255, 255),\n    (0, 0, 192),\n    (255, 255, 64),\n    (0, 255, 0),\n    (0, 0, 255),\n    (255, 0, 0),\n]\ncolorsNumpyArray = [np.array(color) for color in colors]\ncolorsWithIndex = [(index, color) for index, color in enumerate(colors)]\n# we are not doing this while testing.\n# imageFormat = random.choice(imageFormats)\n# textFormat = random.choice(textFormats)\n# backgroundFormat = random.choice(backgroundFormats)"
        },
        {
            "comment": "This code defines two functions: `get_gradient_2d` and `get_gradient_3d`. The former creates a 2D gradient image based on a start, stop value, width, height, and whether the gradient should be horizontal or vertical. The latter function generates a 3D gradient image by applying the former function to multiple pairs of start/stop values in different layers. The code then uses `itertools.product` to generate combinations of image, text, and background formats for creating test output picture names. It reads images from `imageBasePath` based on the selected imagePaths and applies colorDistance calculations.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tests/anime_highlight_cuts/theme_collector/create_coco_pip_dataset.py\":70-94",
            "content": "def get_gradient_2d(start, stop, width, height, is_horizontal):\n    if is_horizontal:\n        return np.tile(np.linspace(start, stop, width), (height, 1))\n    else:\n        return np.tile(np.linspace(start, stop, height), (width, 1)).T\ndef get_gradient_3d(width, height, start_list, stop_list, is_horizontal_list):\n    result = np.zeros((height, width, len(start_list)), dtype=np.float64)\n    for i, (start, stop, is_horizontal) in enumerate(\n        zip(start_list, stop_list, is_horizontal_list)\n    ):\n        result[:, :, i] = get_gradient_2d(start, stop, width, height, is_horizontal)\n    return result.astype(np.uint8)\nfor imageFormat, textFormat, backgroundFormat in itertools.product(\n    imageFormats, textFormats, backgroundFormats\n):  # you can use these things to get test output picture names.\n    colorDistances = {}\n    selectedImages = [\n        cv2.imread(os.path.join(imageBasePath, imagePath), cv2.IMREAD_COLOR)\n        for imagePath in random.sample(imagePaths, k=imageFormat)\n    ]\n    for image in selectedImages:"
        },
        {
            "comment": "This code calculates the average color of an image, then compares it to a set of colors to determine their distances. It sorts these colors by distance and uses the furthest as the main background color. If the format requires more than one color (stripes or gradients), it also takes the second-closest color as the sub color.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tests/anime_highlight_cuts/theme_collector/create_coco_pip_dataset.py\":95-117",
            "content": "        averageColor = np.average(image.reshape((-1, 3)), axis=0)\n        for index, colorNumpyArray in enumerate(colorsNumpyArray):\n            colorDistances[index] = colorDistances.get(index, []) + [\n                np.sum(np.abs(averageColor - colorNumpyArray))\n            ]\n    sortedColorsWithIndex = sorted(\n        colorsWithIndex, key=lambda element: -np.sum(colorDistances[element[0]])\n    )  # the further the better.\n    # sortedColors = [color for _, color in sortedColorsWithIndex]\n    ## create background first.\n    imageCanvasHeight = half_width if imageFormat == 2 else width\n    textCanvasHeight = 0 if textFormat == \"none\" else textTotalHeight\n    backgroundShape = (imageCanvasHeight + textCanvasHeight, width, 3)  # height, width\n    _, color_main = sortedColorsWithIndex[0]\n    if backgroundFormat in [\"horizontalStripes\", \"verticalStripes\", \"gradients\"]:\n        # fill background with color_main first.\n        _, color_sub = sortedColorsWithIndex[1]\n        if backgroundFormat in [\"horizontalStripes\", \"verticalStripes\"]:"
        },
        {
            "comment": "This code creates a background image with vertical or horizontal stripes based on the 'backgroundFormat' parameter. It first initializes a background image, then randomly determines the number of stripes (2-5) using 'stripeCount'. Depending on the format, it slices the image width or height into equal parts and assigns colors to each stripe section with 'arr', 'width_start', 'width_end' or 'height_start', 'height_end' variables.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tests/anime_highlight_cuts/theme_collector/create_coco_pip_dataset.py\":119-138",
            "content": "            backgroundImage = np.zeros(backgroundShape, dtype=np.uint8)\n            backgroundImage[:, :, 0] = color_main[0]\n            backgroundImage[:, :, 1] = color_main[1]\n            backgroundImage[:, :, 2] = color_main[2]\n            stripeCount = random.randint(2, 5)\n            if backgroundFormat == \"verticalStripes\":  # slice width\n                arr = np.linspace(0, backgroundShape[1], stripeCount + 1)\n                for width_start, width_end in [\n                    (int(arr[i]), int(arr[i + 1]))\n                    for i in range(stripeCount)\n                    if i % 2 == 1\n                ]:\n                    backgroundImage[:, width_start:width_end, 0] = color_sub[0]\n                    backgroundImage[:, width_start:width_end, 1] = color_sub[1]\n                    backgroundImage[:, width_start:width_end, 2] = color_sub[2]\n            else:  # horizontal. slice height.\n                arr = np.linspace(0, backgroundShape[0], stripeCount + 1)\n                for height_start, height_end in ["
        },
        {
            "comment": "This code determines the background image of the image by either assigning a solid color, gradient or pure color depending on the input. It also paints text if the format is not \"none\".",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tests/anime_highlight_cuts/theme_collector/create_coco_pip_dataset.py\":139-163",
            "content": "                    (int(arr[i]), int(arr[i + 1]))\n                    for i in range(stripeCount)\n                    if i % 2 == 1\n                ]:\n                    backgroundImage[height_start:height_end, :, 0] = color_sub[0]\n                    backgroundImage[height_start:height_end, :, 1] = color_sub[1]\n                    backgroundImage[height_start:height_end, :, 2] = color_sub[2]\n        else:  # gradient!\n            is_horizontal = [False, False, False]\n            is_horizontal[random.randint(0, 2)] = True\n            backgroundImage = get_gradient_3d(\n                backgroundShape[1],\n                backgroundShape[0],\n                color_main,\n                color_sub,\n                is_horizontal,\n            )\n    else:  # pure color.\n        backgroundImage = np.zeros(backgroundShape, dtype=np.uint8)\n        backgroundImage[:, :, 0] = color_main[0]\n        backgroundImage[:, :, 1] = color_main[1]\n        backgroundImage[:, :, 2] = color_main[2]\n    ## next, paint text!\n    if textFormat != \"none\":"
        },
        {
            "comment": "This code calculates a text color that is complementary to the background image. It then generates random texts and places them on the image with varying positions and sizes, using OpenCV's putText function.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tests/anime_highlight_cuts/theme_collector/create_coco_pip_dataset.py\":164-188",
            "content": "        ## only calculate text color when needed.\n        backgroundAverageColor = np.average(backgroundImage.reshape((-1, 3)), axis=0)\n        textColorNumpyArray = sorted(\n            colorsNumpyArray,\n            key=lambda colorNumpyArray: -np.sum(\n                np.abs(backgroundAverageColor - np.array(colorNumpyArray))\n            ),\n        )[0]\n        textColor = textColorNumpyArray.tolist()\n        # let's paint it all over the place!\n        textShift = 40\n        # TODO: check if string is **just enough** to fill the background.\n        for textLineIndex in range(\n            int((backgroundShape[0] / (textTotalHeight + width)) * 27)\n        ):\n            baseNumber = 50\n            baseNumber2 = random.randint(1, baseNumber)\n            textContent = random.choice(\n                [\n                    \"\",\n                    (\" \" * baseNumber2)\n                    + getRandomCharacters(random.randint(0, baseNumber - baseNumber2)),\n                ]\n            )\n            backgroundImage = cv2.putText("
        },
        {
            "comment": "This code prepares an image canvas for a specific image format. It creates an image mask with the same dimensions as the canvas and fills it with black color. It then initializes the main image canvas with zeros and starts preparing an array of coordinates for drawing images onto the canvas based on the selected image format.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tests/anime_highlight_cuts/theme_collector/create_coco_pip_dataset.py\":189-220",
            "content": "                backgroundImage,\n                textContent,\n                (textOrigin[0], textOrigin[1] + textShift * textLineIndex),\n                font,\n                fontScale,\n                textColor,\n                fontThickness,\n                cv2.LINE_AA,\n            )\n    ## put pictures!\n    imageCanvasShape = (imageCanvasHeight, width, 3)\n    imageMask = Image.new(\n        \"RGB\", (imageCanvasShape[1], imageCanvasShape[0]), \"black\"\n    )  # width, height?\n    draw = ImageDraw.Draw(imageMask)\n    imageCanvas = np.zeros(imageCanvasShape, dtype=np.uint8)\n    imageCoordinates = []\n    if imageFormat == 1:\n        image = selectedImages[0]\n        imageShape = image.shape\n        margin = getMarginRatio()\n        base = width * (1 - margin * 2)\n        imageHeight, imageWidth = imageShape[:2]\n        if imageHeight > imageWidth:\n            imageShape = (int(base * (imageWidth / imageHeight)), int(base))\n        else:\n            imageShape = (int(base), int(base * (imageHeight / imageWidth)))\n        # print(image.shape)"
        },
        {
            "comment": "The code resizes an image, generates a bounding box around the image, and randomly chooses between drawing a rectangle or rounded rectangle with white fill color. It then combines the image and the canvas by assigning the image to specific coordinates on the canvas and appends the bounding box coordinates to the imageCoordinates list.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tests/anime_highlight_cuts/theme_collector/create_coco_pip_dataset.py\":221-253",
            "content": "        image = cv2.resize(image, imageShape)\n        x0 = int((width - imageShape[0]) / 2)\n        x1 = x0 + imageShape[0]\n        y0 = int((width - imageShape[1]) / 2)\n        y1 = y0 + imageShape[1]\n        if random.random() > 0.5:\n            draw.rectangle((x0, y0, x1, y1), fill=\"white\")\n        else:\n            draw.rounded_rectangle(\n                (x0, y0, x1, y1),\n                fill=\"white\",\n                radius=min(int(x1 - x0) / 2, int(y1 - y0) / 2, getRadius()),\n            )\n        # print(\"___\")\n        # print(imageShape)\n        # print(imageCanvas.shape)\n        # print(image.shape)\n        # print(x0,x1,x1-x0)\n        # print(y0,y1,y1-y0)\n        # print(\"___\")\n        # cv2.imshow(\"mask\", np.array(imageMask))\n        # cv2.waitKey(0)\n        imageCanvas[y0 : image.shape[0] + y0, x0 : image.shape[1] + x0, :] = image\n        imageCoordinates.append(\n            (\n                x0 + image.shape[1] / 2,\n                y0 + image.shape[0] / 2,\n                image.shape[1],\n                image.shape[0],"
        },
        {
            "comment": "This code resizes images to fit a specified rectangle shape and randomly colors the rectangles white or leaves them transparent.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tests/anime_highlight_cuts/theme_collector/create_coco_pip_dataset.py\":254-280",
            "content": "            )\n        )  # x_center, y_center, width, height\n    else:\n        basePoints = [\n            (x * half_width, y * half_width)\n            for x, y in [(0, 0), (1, 0), (1, 1), (0, 1)]\n        ]  # width, height\n        for index, image in enumerate(selectedImages):\n            imageShape = image.shape\n            margin = getMarginRatio()\n            base = half_width * (1 - margin * 2)\n            imageHeight, imageWidth = imageShape[:2]\n            if imageHeight > imageWidth:\n                imageShape = (int(base * (imageWidth / imageHeight)), int(base))\n            else:\n                imageShape = (int(base), int(base * (imageHeight / imageWidth)))\n            image = cv2.resize(image, imageShape)\n            x0 = int((half_width - imageShape[0]) / 2) + basePoints[index][0]\n            x1 = x0 + imageShape[0]\n            y0 = int((half_width - imageShape[1]) / 2) + basePoints[index][1]\n            y1 = y0 + imageShape[1]\n            if random.random() > 0.5:\n                draw.rectangle((x0, y0, x1, y1), fill=\"white\")"
        },
        {
            "comment": "This code creates a rounded rectangle with white fill, then combines it with an image and stores the coordinates. It also adjusts mask images and blends them into a background image using numpy arrays.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tests/anime_highlight_cuts/theme_collector/create_coco_pip_dataset.py\":281-307",
            "content": "            else:\n                draw.rounded_rectangle(\n                    (x0, y0, x1, y1),\n                    fill=\"white\",\n                    radius=min(int(x1 - x0) / 2, int(y1 - y0) / 2, getRadius()),\n                )\n            imageCanvas[y0 : image.shape[0] + y0, x0 : image.shape[1] + x0, :] = image\n            imageCoordinates.append(\n                (\n                    x0 + image.shape[1] / 2,\n                    y0 + image.shape[0] / 2,\n                    image.shape[1],\n                    image.shape[0],\n                )\n            )  # x_center, y_center, width, height\n    ## mix images with mask\n    imageMaskNumpyArray = np.array(imageMask) / 255  # float64\n    imageMaskNumpyArrayInverted = 1 - imageMaskNumpyArray\n    x0 = 0\n    y0 = textTotalHeight if textFormat == \"up\" else 0\n    backgroundImage[y0 : y0 + imageCanvasShape[0], x0 : x0 + imageCanvasShape[1], :] = (\n        backgroundImage[y0 : y0 + imageCanvasShape[0], x0 : x0 + imageCanvasShape[1], :]\n        * imageMaskNumpyArrayInverted"
        },
        {
            "comment": "This code segment performs image manipulation, extracts coordinates, and generates labels for data export. It also creates a preview image before saving.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tests/anime_highlight_cuts/theme_collector/create_coco_pip_dataset.py\":308-328",
            "content": "    ).astype(np.uint8) + (imageCanvas * imageMaskNumpyArray).astype(np.uint8)\n    print()\n    ## get labels which will be exported to txt\n    for coord in imageCoordinates:\n        x_center_relative, y_center_relative, imWidth, imHeight = coord\n        x_center, y_center = x_center_relative + x0, y_center_relative + y0\n        dataPoints = [\n            x_center / backgroundShape[1],\n            y_center / backgroundShape[0],\n            imWidth / backgroundShape[1],\n            imHeight / backgroundShape[0],\n        ]\n        labelString = \" \".join(([\"0\"] + [f\"{number:.3f}\" for number in dataPoints]))\n        print(\"LABELSTRING?\", labelString)\n    ## preview\n    previewImageName = f\"{imageFormat}_{textFormat}_{backgroundFormat}.png\"\n    cv2.imshow(previewImageName, backgroundImage)\n    cv2.waitKey(0)"
        }
    ]
}