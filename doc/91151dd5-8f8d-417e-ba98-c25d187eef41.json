{
    "summary": "The code imports libraries, handles data operations and errors, interacts with Redis caching, supports debug mode, and maps media file extensions. It detects corrupted content, checks server availability, utilizes ffprobe and mediainfo for media details, configures YOLOv5 model, writes to a file, and prints log path.",
    "details": [
        {
            "comment": "The code imports various libraries and defines several functions. It connects to Milvus and Redis databases, gets the current JSTimeStamp, and provides functions for connecting to these databases and removing a Redis value by key. The redis connection is cached using LRU cache for performance optimization.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/commons.py\":0-57",
            "content": "import traceback\nfrom pyjom.config import *\nfrom typing import Union\nfrom pyjom.mathlib import checkMinMaxDict\nimport datetime\nimport os\nimport shutil\nimport socket\nimport json\nimport mimetypes\nimport jinja2\nimport copy\nimport uuid\nimport numpy as np\nimport torch\nimport pathlib\nimport site\nimport sys\nimport random\n# from functools import lru_cache\ncommonRedisPort = 9291\nos.system(\"ulimit -n 1048576\")\nfrom lazero.utils.logger import sprint\nfrom functools import lru_cache\nimport time\ndef getJSTimeStamp():\n    return int(time.time() * 1000)\nfrom pymilvus import connections\n@lru_cache(maxsize=1)\ndef connectMilvusDatabase(alias=\"default\", host=\"localhost\", port=\"19530\"):\n    connection = connections.connect(\n        alias=alias, host=host, port=port\n    )  # can we reconnect?\n    print(\"milvus connected\")\n    return connection\n# what is the redis connection?\nimport redis\n@lru_cache(maxsize=1)\ndef getRedisConnection(host=\"localhost\", port=commonRedisPort):\n    connection = redis.Redis(host=host, port=port)\n    return connection\ndef removeRedisValueByKey("
        },
        {
            "comment": "This code includes two functions, one for deleting a single key from Redis and the other for deleting multiple keys. It also has constants for data types and imports necessary libraries for handling data serialization and evaluation. The getSafeEvalEnvironment function is likely used to cache an environment for safe evaluation, although it is not currently utilized. The safe_eval function uses the evalidate library to evaluate input code within a restricted environment. Common iterable and non-iterable data types are defined for potential usage throughout the codebase.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/commons.py\":58-95",
            "content": "    key: str, debug: bool = False, host=\"localhost\", port=commonRedisPort\n):\n    connection = getRedisConnection(host=host, port=port)\n    returnCode = connection.delete(key)\n    messages = {\n        0: \"key {} not found\".format(key),\n        1: \"delete key {} successfully\".format(key),\n    }\n    if debug:\n        print(messages.get(returnCode, \"unknown return code: {}\".format(returnCode)))\n    return returnCode\ndef removeRedisValueByKeys(\n    keys: list[str], debug: bool = False, host=\"localhost\", port=commonRedisPort\n):\n    for key in keys:\n        removeRedisValueByKey(key, debug=debug, host=host, port=port)\n# @lru_cache(maxsize=1)\n# def getSafeEvalEnvironment():\n#     return sf\ndef safe_eval(\n    code, safenodes=[\"List\", \"Dict\", \"Tuple\", \"Set\", \"Expression\", \"Constant\", \"Load\"]\n):  # strange.\n    from evalidate import safeeval\n    result = safeeval(code, {}, safenodes=safenodes)\n    return result\nimport pickle, dill\ncommonIterableDataTypes = [tuple, list, dict, set]\ncommonNonIterableDataTypes = [int, float, str, bool]"
        },
        {
            "comment": "This code defines functions for handling data types and communicating with Redis. It checks if a value is stringifiable, encodes it, and stores it in Redis based on the provided data type. If no data type is given, it automatically determines the type and performs encoding if necessary.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/commons.py\":96-134",
            "content": "commonDataTypes = commonNonIterableDataTypes + commonIterableDataTypes\ndef stringifiableCheck(value, debug: bool = False):\n    try:\n        str_value = repr(value)\n        restored_value = safe_eval(value)\n        return restored_value == value\n    except:\n        if debug:\n            traceback.print_exc()\n    return False\ndef setRedisValueByKey(\n    key: str,\n    value,\n    dataType=None,\n    encoding: str = \"utf-8\",\n    host=\"localhost\",\n    port=commonRedisPort,\n    debug: bool = False,\n):\n    def stringifyAndEncode(value):\n        data = repr(value)\n        data = data.encode(encoding)\n        return data\n    connection = getRedisConnection(host=host, port=port)\n    if dataType is None:\n        dataType = type(value)\n        if dataType in commonDataTypes and stringifiableCheck(\n            value, debug=debug\n        ):  # this automation only happens when leaving blank for dataType.\n            data = stringifyAndEncode(value)\n        else:\n            dataType = \"dill\"\n            data = dill.dumps(value)\n    else:"
        },
        {
            "comment": "The code handles data storage and retrieval from Redis. It checks the data type, encodes or serializes the value accordingly (using stringifyAndEncode, dill, or pickle), and stores it in Redis using set method. The getRedisValueByKey function retrieves a value by key and decodes it based on the specified data type, if provided. It returns None if the value is not found or the data type is not specified. The code also handles debugging messages and exceptions for unknown data types.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/commons.py\":135-168",
            "content": "        if dataType in commonDataTypes:\n            data = stringifyAndEncode(value)\n        elif dataType == \"dill\":\n            data = dill.dumps(value)\n        elif dataType == \"pickle\":\n            data = pickle.dumps(value)\n        else:\n            raise Exception(\"unknown dataType:\", dataType)\n    connection.set(key, data)\n    return dataType\ndef getRedisValueByKey(\n    key: str,\n    dataType=None,\n    encoding: str = \"utf-8\",\n    debug: bool = False,\n    host=\"localhost\",\n    port=commonRedisPort,\n):\n    connection = getRedisConnection(host=host, port=port)\n    value = connection.get(key)\n    if value is not None:\n        if debug:\n            print('data \"{}\" is not None'.format(key))\n        if dataType == None:\n            return dataType\n        elif dataType in commonDataTypes:\n            decoded_value = value.decode(encoding)\n            if dataType in commonNonIterableDataTypes:\n                if dataType == str:\n                    return decoded_value\n                else:\n                    return dataType(decoded_value)"
        },
        {
            "comment": "This code defines functions to interact with Redis cached sets. The `getRedisCachedSet` function retrieves a set from Redis, deserializing the data using either pickle or dill depending on the specified data type. If the data is None, it returns an empty set. The `addToRedisCachedSet` function adds an item to a Redis cached set after first retrieving the existing set and updating it with the new item before saving it back to Redis. Both functions support debug mode and have default values for host, port, and data type (dill).",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/commons.py\":169-209",
            "content": "            else:\n                # safe eval using nsjail?\n                return safe_eval(decoded_value)\n        elif dataType == \"pickle\":\n            return pickle.loads(value)\n        elif dataType == \"dill\":\n            return dill.loads(value)\n        else:\n            raise Exception(\"unknown dataType:\", dataType)\n    if debug:\n        print('data \"{}\" is None'.format(key))\ndef getRedisCachedSet(\n    setName: str,\n    debug: bool = False,\n    host=\"localhost\",\n    port=commonRedisPort,\n    dataType=\"dill\",\n) -> set:\n    # so we know this datatype is set!\n    # but what is our plan? we use dill by default.\n    data = getRedisValueByKey(\n        setName, debug=debug, host=host, port=port, dataType=dataType\n    )\n    if data is None:\n        return set()\n    assert type(data) == set\n    return data\ndef addToRedisCachedSet(\n    item,\n    setName: str,\n    debug: bool = False,\n    host=\"localhost\",\n    port=commonRedisPort,\n    dataType=\"dill\",\n):\n    cachedSet = getRedisCachedSet(\n        setName, debug=debug, host=host, port=port, dataType=dataType"
        },
        {
            "comment": "1. Defines functions for caching, shuffling lists, and retrieving media bitrate.\n2. Uses Redis to store sets of data with configurable host and port.\n3. Shuffles a list of items and returns the first item in the new order.\n4. Retrieves the bitrate of a video or audio stream using ffprobe, then prints it in JSON format.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/commons.py\":210-254",
            "content": "    )\n    cachedSet.add(item)\n    setRedisValueByKey(setName, cachedSet, dataType=dataType, host=host, port=port)\n    return cachedSet\ndef shuffleAndPopFromList(mlist):\n    import random\n    random.shuffle(mlist)\n    return mlist.pop(0)\ndef getMediaBitrate(mediaPath, audioOnly=False, videoOnly=False):\n    # demo output:\n    # {'programs': [], 'streams': [{'bit_rate': '130770'}]}\n    commandArguments = [\n        \"ffprobe\",\n        \"-i\",\n        mediaPath,\n        \"-v\",\n        \"quiet\",\n    ]\n    if audioOnly:\n        commandArguments += [\n            \"-select_streams\",\n            \"a:0\",\n        ]\n    elif videoOnly:\n        commandArguments += [\n            \"-select_streams\",\n            \"v:0\",\n        ]\n    commandArguments += [\n        \"-show_entries\",\n        \"stream=bit_rate\",\n        \"-hide_banner\",\n        \"-print_format\",\n        \"json\",\n    ]\n    result = subprocess.run(commandArguments, capture_output=True, encoding=\"UTF-8\")\n    stdout = result.stdout\n    stderr = result.stderr\n    try:\n        assert result.returncode == 0"
        },
        {
            "comment": "This code loads a JSON from stdout, handles potential errors by printing them and returns an empty dictionary. It also defines a function to create a file extension to meaning dictionary using input string lines. Lastly, it caches a media file extension to meaning dictionary with the help of @lru_cache decorator.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/commons.py\":255-289",
            "content": "        stdout_json = json.loads(stdout)\n        return stdout_json\n    except:\n        import traceback\n        traceback.print_exc()\n        print(\"potential error logs:\")\n        print(stderr)\n        print(\"error when getting media bitrate\")\n        return {}\ndef getFileExtensionToMeaningDictFromString(inputString):\n    inputStringList = inputString.split(\"\\n\")\n    fileExtensionToMeaningDict = {}\n    for line in inputStringList:\n        line = line.strip()\n        if len(line) < 5:\n            continue\n        # try:\n        meaning, extensions = line.split(\" - \")  # problem fixed.\n        # except:\n        #     print('line:',[line])\n        #     breakpoint()\n        meaning = meaning.strip()\n        extensions = extensions.split(\" or \")\n        for extension in extensions:\n            extension = extension.strip()\n            if len(extension) > 0:\n                fileExtensionToMeaningDict.update({extension: meaning})\n    return fileExtensionToMeaningDict\n@lru_cache(maxsize=1)\ndef getMediaFileExtensionToMeaningDict():"
        },
        {
            "comment": "The code defines various file extensions for video, image, document, and audio formats. It includes common extension types for each category, allowing the codebase to identify and handle different file types appropriately.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/commons.py\":290-322",
            "content": "    # no input needed.\n    videoExtensions = \"\"\"MP4 or MPEG4 video file - .mp4\n264 video file - .h264\nAVI video file - .avi\nMKV or Matroska Multimedia Container - .mkv\nMPEG video file - .mpeg or .mpg\nMOV or Apple QuickTime video file - .mov\nApple MP4 video file - .m4v\nAdobe flash video - .flv\n3GP video file - .3gp\nWindows Media Video file - .wmv\nDVD Video Object - .vob\"\"\"\n    imageExtensions = \"\"\"JPEG image - .jpeg or .jpg\nPNG image - .png\nGIF image - .gif\nPhotoshop or PSD image - .psd\nAdobe Illustrator image - .ai\nTIFF image - .tif or .tiff\"\"\"\n    documentExtensions = \"\"\"Microsoft Word file - .doc or .docx\nPDF file - .pdf\nText file - .txt\nMicrosoft Excel file - .xls\nMicrosoft Excel Open XML file - .xlsx\nMicrosoft Excel file with macros - .xlsm\nMicrosoft PowerPoint presentation - .ppt\nMicrosoft PowerPoint slide show - .pps\nMicrosoft PowerPoint Open XML presentation - .pptx\"\"\"\n    audioExtensions = \"\"\"MP3 audio file - .mp3\nAAC audio file - .aac\nAC3 audio file - .ac3\nWAV audio file - .wav\nWMA audio file - .wma\nOgg Vorbis audio file - .ogg"
        },
        {
            "comment": "This code defines a function getMediaFileExtensionToMeaningDict() that maps file extensions to their meanings (video, audio, image, document). It also includes a determineMediaTypeByExtension() function which takes an extension as input, checks it against the mapping and returns the corresponding media type. This code suggests that caching is necessary for efficiency.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/commons.py\":323-352",
            "content": "MIDI audio file - .midi or .mid\nCD audio file - .cda\nAIF audio file - .aif\"\"\"\n    mapping = [\n        (\"video\", videoExtensions),\n        (\"audio\", audioExtensions),\n        (\"image\", imageExtensions),  # gif could be video.\n        (\"document\", documentExtensions),\n    ]\n    mediaFileExtensionToMeaningDict = {\n        key: getFileExtensionToMeaningDictFromString(value) for key, value in mapping\n    }\n    return mediaFileExtensionToMeaningDict\ndef determineMediaTypeByExtension(extension):\n    extension = extension.strip()\n    if not extension.startswith(\".\"):\n        extension = \".\" + extension\n    extension_lower = extension.lower()\n    # this has to be cached.\n    mediaFileExtensionToMeaningDict = getMediaFileExtensionToMeaningDict()\n    for (\n        mediaType,\n        fileExtensionToMeaningDict,\n    ) in mediaFileExtensionToMeaningDict.items():\n        for fileExtension, meaning in fileExtensionToMeaningDict.items():\n            if fileExtension.lower == extension_lower:\n                return mediaType\n    return \"unknown\""
        },
        {
            "comment": "This function named 'corruptMediaFilter' takes the path of a media file and checks for potentially corrupted content by scanning the ffmpeg output. If any 'bad words' found in stderr, it considers the file corrupted. If no issues found, it declares the video as fine and returns True. It also prints status updates to stdout about file existence, corruption status, and video condition.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/commons.py\":355-391",
            "content": "def corruptMediaFilter(\n    mediaPath, tag: str = \"media\", bad_words: list[str] = [\"invalid\", \"failed\", \"error\"]\n):\n    if not os.path.exists(mediaPath):\n        print(\"{} file does not exist\".format(tag))\n    import ffmpeg\n    not_nice = [word.lower() for word in bad_words]\n    corrupted = False\n    try:\n        stdout, stderr = (\n            ffmpeg.input(mediaPath)\n            .output(\"null\", f=\"null\")\n            .run(capture_stdout=True, capture_stderr=True)\n        )\n        stderr_lower = stderr.decode(\"utf-8\").lower()\n        for word in not_nice:\n            if word in stderr_lower:\n                print(\"{} is corrupted\".format(tag))\n                corrupted = True\n                break\n    except:\n        import traceback\n        traceback.print_exc()\n        corrupted = True\n        print(\"corrupt {}\".format(tag))\n    if not corrupted:\n        print(\"video is fine\")\n    # return True for fine video.\n    valid = not corrupted\n    sprint(\"{} file path:\".format(tag), mediaPath)\n    return valid\n## bring about 'redis cache' for faster testing."
        },
        {
            "comment": "This code defines a function `redisLRUCache` that utilizes Redis LRU cache for storing data with Time-To-Live (TTL) and optional parameters like TTL, redisAddress, redisPort, max_size, and debug. It also includes a helper function `frameSizeFilter` that checks the dimensions of a frame against specified width and height ranges from a frame_size_filter dictionary. If both dimensions are filtered out, it prints a message indicating an invalid video shape.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/commons.py\":392-422",
            "content": "import redis\nfrom redis_lru import RedisLRU\n# from functools import lru_cache\noneDay = 60 * 60 * 24  # one day?\nredisExpire = oneDay * 7  # god damn it!\n# @lru_cache(maxsize=1)\ndef redisLRUCache(\n    ttl=redisExpire,\n    redisAddress=\"127.0.0.1\",\n    redisPort=commonRedisPort,\n    max_size=20,\n    debug=True,\n):\n    client = redis.StrictRedis(host=redisAddress, port=redisPort)\n    cache = RedisLRU(client, max_size=max_size, debug=debug)\n    return cache(ttl=ttl)\n# this is root. this is not site-packages.\ndef frameSizeFilter(frameMeta, frame_size_filter):\n    width, height = frameMeta[\"width\"], frameMeta[\"height\"]\n    flagWidth, (minWidth, maxWidth) = checkMinMaxDict(\n        width, frame_size_filter.get(\"width\", {}), getMinMaxVal=True\n    )  # type: ignore\n    flagHeight, (minHeight, maxHeight) = checkMinMaxDict(\n        height, frame_size_filter.get(\"height\", {}), getMinMaxVal=True\n    )  # type: ignore\n    if not (flagWidth and flagHeight):\n        print(\"Filter out invalid video with shape of {}x{}\".format(width, height))"
        },
        {
            "comment": "This code checks if the OpenCV library is installed correctly and sets the system path accordingly. It also initializes mimetypes and defines a function waitForServerUp that makes HTTP requests to localhost on a specified port, waiting for a response until the timeout is reached. The function accepts optional parameters for message and messageLength (for netease).",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/commons.py\":423-456",
            "content": "        print(\n            \"Valid Width and Height are {}-{}x{}-{}\".format(\n                minWidth, maxWidth, minHeight, maxHeight\n            )\n        )\n        return False\n    return True\n# site_path = pathlib.Path([x for x in site.getsitepackages() if \"site-packages\" in x][0])\nos.environ[\"USE_NVIDIA_OPENCV\"] = \"yes\"\nif os.environ[\"USE_NVIDIA_OPENCV\"] == \"yes\":\n    site_path = pathlib.Path(\"/usr/local/lib/python3.9/site-packages\")\n    cv2_libs_dir = (\n        site_path / \"cv2\" / f\"python-{sys.version_info.major}.{sys.version_info.minor}\"\n    )\n    print(cv2_libs_dir)\n    cv2_libs = sorted(cv2_libs_dir.glob(\"*.so\"))\n    if len(cv2_libs) == 1:\n        print(\"INSERTING:\", cv2_libs[0].parent)\n        sys.path.insert(1, str(cv2_libs[0].parent))\nmimetypes.init()\ndef waitForServerUp(\n    port, message, timeout=1, messageLength: Union[None, int] = None  # for netease.\n):  # this messageLength is the length of the binary message.\n    import requests\n    while True:\n        try:\n            url = \"http://localhost:{}\".format(port)"
        },
        {
            "comment": "Code fetches a message from server using URL, checks its length against expected length and prints the received response. If there is a mismatch, it raises an error. If the connection fails, it waits for a second before trying again.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/commons.py\":457-489",
            "content": "            with requests.get(url, timeout=timeout) as r:\n                if messageLength is not None:\n                    contentLength = len(r.content)\n                    if messageLength <= contentLength:\n                        break\n                else:\n                    if type(message) == str:\n                        text = r.text.strip('\"').strip(\"'\")\n                    else:\n                        text = r.json()\n                    print(\"SERVER AT PORT %d RESPONDS:\" % port, [text])\n                    assert text == message\n                    print(\"SERVER AT PORT %d IS UP\" % port)\n                    break\n        except:\n            import traceback\n            traceback.print_exc()\n            print(\"SERVER AT PORT %d MIGHT NOT BE UP\" % port)\n            print(\"EXPECTED MESSAGE:\", [message])\n            import time\n            time.sleep(1)\nclass D2Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\ndef doRectOverlap(l1, r1, l2, r2):\n    # if rectangle has area 0, no overlap"
        },
        {
            "comment": "The code checks for rectangle overlap, returns the overlapping rectangle if exists, and clamps values within a given range.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/commons.py\":490-525",
            "content": "    if l1.x == r1.x or l1.y == r1.y or r2.x == l2.x or l2.y == r2.y:\n        return False\n    # If one rectangle is on left side of other\n    if l1.x >= r2.x or l2.x >= r1.x:\n        return False\n    if l1.y >= r2.y or l2.y >= r1.y:\n        return False\n    return True\ndef checkRectOverlap(rect0, rect1):\n    assert len(rect0) == 2\n    assert len(rect1) == 2\n    return doRectOverlap(\n        D2Point(*rect0[0]), D2Point(*rect0[1]), D2Point(*rect1[0]), D2Point(*rect1[1])\n    )\ndef getOverlapRect(rect0, rect1):\n    if checkRectOverlap(rect0, rect1):\n        leftXList = (rect0[0][0], rect1[0][0])\n        leftYList = (rect0[0][1], rect1[0][1])\n        rightXList = (rect0[1][0], rect1[1][0])\n        rightYList = (rect0[1][1], rect1[1][1])\n        leftX = max(leftXList)\n        leftY = max(leftYList)\n        rightX = min(rightXList)\n        rightY = min(rightYList)\n        return [(leftX, leftY), (rightX, rightY)]\n    else:\n        return None\ndef makeValueInRange(value, minVal, maxVal):\n    assert minVal < maxVal\n    return min(max(minVal, value), maxVal)"
        },
        {
            "comment": "The code defines a function \"infiniteShuffle\" that shuffles and yields data from an access list, either stopping when the list ends or if set to infinite mode. Function \"inRange\" checks if a target value falls within specified range boundaries with optional tolerance. Function \"overlapRange\" calculates the overlap between two given ranges. The code also updates JSON functions (\"walk\", \"locate\", and \"update\") under the json module. Finally, a function named \"replacer\" is defined, but its functionality isn't clear from the given code snippet.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/commons.py\":528-564",
            "content": "# this sucks...\ndef infiniteShuffle(access_list, shuffle=True, infinite=True, endMark=True):\n    flag = True\n    while flag:\n        if shuffle:\n            random.shuffle(access_list)\n        for data in access_list:\n            yield data\n        if endMark and infinite:\n            yield None\n        if not infinite:\n            flag = False\ndef inRange(target, mRange, tolerance=1):\n    assert tolerance <= 1\n    assert tolerance > 0\n    start, end = mRange\n    start, end = start * tolerance, end / tolerance\n    return target >= start and target <= end\ndef overlapRange(range_a, range_b):\n    begin_a, end_a = range_a\n    begin_b, end_b = range_b\n    possible_overlap = (max(begin_a, begin_b), min(end_a, end_b))\n    if possible_overlap[0] < possible_overlap[1]:  # overlapping\n        return possible_overlap\n    # return common range.\nfrom lazero.utils.json import jsonWalk2, jsonify, jsonWalk, jsonLocate, jsonUpdate\njson.__dict__.update({\"walk\": jsonWalk, \"locate\": jsonLocate, \"update\": jsonUpdate})\ndef replacer(content, sources=[], target=\"\"):"
        },
        {
            "comment": "The code appears to be a combination of functions that replace specific strings within a given content, update JSON objects by converting certain string types to either float or int, and potentially include some math-related operations. It seems to involve the use of external libraries such as MediaInfo and subprocess for possibly retrieving additional information or performing computations.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/commons.py\":565-599",
            "content": "    for source in sources:\n        content = content.replace(source, target)\n    return content\ndef multi_replacer(content, replacer_list=[[[], \"\"]]):\n    for sources, target in replacer_list:\n        content = replacer(content, sources=sources, target=target)\n    return content\nfrom pyjom.mathlib import extract_span, convoluted\nimport MediaInfo\nimport subprocess\ndef json_auto_float_int(jsonObj):\n    jsonObj = jsonify(jsonObj)\n    for location, content in jsonWalk(jsonObj):\n        # content = jsonLocate(jsonObj,location)\n        if type(content) == str:\n            if \"/\" in content:\n                try:\n                    content = eval(content)  # could be dangerous!\n                    if type(content) in [float, int]:\n                        jsonUpdate(jsonObj, location=location, update_content=content)\n                except:\n                    pass\n            elif \".\" in content:\n                try:\n                    content = float(content)\n                    jsonUpdate(jsonObj, location=location, update_content=content)"
        },
        {
            "comment": "The code contains functions for retrieving media information. It uses ffprobe and mediainfo commands to extract video format, codec, size, duration, bitrate, and other details from the specified file. The information is returned in JSON format after converting floating-point numbers to integers if needed. The getTextFileLength function reads a text file's length using Python's built-in open() function.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/commons.py\":600-633",
            "content": "                except:\n                    pass\n            else:\n                try:\n                    content = int(content)\n                    jsonUpdate(jsonObj, location=location, update_content=content)\n                except:\n                    pass\n    return jsonObj\ndef ffprobe_media_info(filename, video_size: Union[None, str] = None):\n    cmd = \"ffprobe{} -v quiet -print_format json -show_format -show_streams\".format(\n        \" -video_size {}\".format(video_size.strip()) if video_size else \"\"\n    )\n    cmd = cmd.split(\" \")\n    cmd = cmd + [filename]\n    output = subprocess.check_output(cmd)\n    return json_auto_float_int(json.loads(output))\ndef json_media_info(filename):\n    cmd = [\"mediainfo\", \"--Output=JSON\", filename]\n    output = subprocess.check_output(cmd)\n    return json_auto_float_int(json.loads(output))\ndef get_media_info(filename):\n    mdf = MediaInfo.MediaInfo(filename=filename)\n    return json_auto_float_int(mdf.getInfo())\ndef getTextFileLength(path):\n    with open(path, \"r\", encoding=\"utf-8\") as f:"
        },
        {
            "comment": "This code defines functions for working with dictionaries and JSON files. It includes functions to append a sublist, update a subdictionary, read a JSON file, and convert a list of elements into ranges based on their differences. These functions can be used together or separately depending on the specific task at hand.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/commons.py\":634-675",
            "content": "        return len(f.read())\ndef append_sublist(main_dict, sublist_key, item):\n    main_dict[sublist_key] = main_dict.get(sublist_key, []) + [item]\ndef update_subdict(mdict, key, subdict):\n    # print(\"UPDATING SUBDICT\", mdict,key, subdict)\n    if key not in mdict:\n        mdict[key] = subdict\n    else:\n        mdict[key].update(subdict)\n    return mdict\ndef read_json(filepath):\n    with open(filepath, \"r\") as f:\n        return json.loads(f.read())\ndef list_to_range(mlist, rangeLimit):\n    mlist = set(mlist)\n    mlist = list(sorted(mlist))\n    currentRange = []\n    lastElem = None\n    myRanges = []\n    for elem in mlist:\n        if lastElem == None:\n            lastElem = elem\n            currentRange = [elem]\n            continue\n        myRange = elem - lastElem\n        if rangeLimit >= myRange:\n            lastElem = elem\n            if len(currentRange) == 2:\n                currentRange[1] = elem\n            else:\n                currentRange.append(elem)\n        else:\n            myRanges.append(currentRange)\n            lastElem = elem"
        },
        {
            "comment": "This code defines several functions related to lists, image conversion, and OCR configuration. It checks if a list starts or ends with another list, converts an image's shape from HWC to CHW, and configures the OCR engine with language options. The global ocrCore and ocrConfig variables store the OCR engine and its configurations, which can be updated using the configOCR function.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/commons.py\":676-726",
            "content": "            currentRange = [elem]\n    if len(myRanges) > 0:\n        if myRanges[-1] != currentRange:\n            myRanges.append(currentRange)\n    else:\n        myRanges.append(currentRange)\n    return myRanges\n# from youtube science.\ndef list_startswith(a, b):\n    value = 0\n    if len(a) < len(b):\n        return False\n    for i, v in enumerate(b):\n        v0 = a[i]\n        if v == v0:\n            value += 1\n    return value == len(b)\ndef list_endswith(a, b):\n    value = 0\n    if len(a) < len(b):\n        return False\n    c = a[-len(b) :]\n    for i, v in enumerate(b):\n        v0 = c[i]\n        if v == v0:\n            value += 1\n    return value == len(b)\ndef cv2_HWC2CHW(frame):\n    if len(frame.shape) == 3:\n        img = frame[:, :, ::-1].transpose((2, 0, 1))\n    else:\n        img = frame[np.newaxis, :, :]\n    return img\nocrCore = None\nocrConfig = {\n    \"use_angle_cls\": True,\n    \"lang\": \"ch\",\n}  # it can detect english too. but no space included.\ndef configOCR(**kwargs):\n    global ocrCore, ocrConfig\n    if ocrCore is not None:"
        },
        {
            "comment": "This code snippet defines a function \"configYolov5\" that retrieves the YOLOv5 model configuration. It first checks if the global variable \"yolov5_model\" is set, and if not, it sets it based on the given \"model\" parameter. The function also includes the paths to the YOLOv5 model directory using the \"getScriptFileBaseDir\" and \"getTemplateFileBaseDir\" functions. Finally, an LRU cache decorator ensures efficient retrieval of the model configuration.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/commons.py\":727-763",
            "content": "        if kwargs == ocrConfig:\n            pass\n    else:\n        ocrConfig = kwargs\n        from paddleocr import PaddleOCR\n        # breakpoint()\n        ocrCore = PaddleOCR(**kwargs)\n        # breakpoint() # this is not the problem. maybe.\n    return ocrCore\ndef getScriptFileBaseDir(script_file):\n    basepath = os.path.abspath(script_file)\n    basepath = basepath.replace(os.path.basename(basepath), \"\")\n    return basepath\ndef getTemplateFileBaseDir(tmpDir=\"templates\"):\n    basedir = getScriptFileBaseDir(__file__)\n    basedir = os.path.join(basedir, tmpDir)\n    assert os.path.exists(basedir)\n    return basedir\nyolov5_model = None\n@lru_cache(maxsize=1)\ndef configYolov5(model=\"yolov5s\"):\n    global yolov5_model  # not the same\n    if yolov5_model == None:\n        basedir = getTemplateFileBaseDir(tmpDir=\"models/yolov5\")\n        os.environ[\"YOLOV5_MODEL_DIR\"] = basedir\n        localModelPath = os.path.join(\n            basedir, \"ultralytics_yolov5_master/\"\n        )  # required to load it. we have modified this shit somehow."
        },
        {
            "comment": "Code snippet defines several functions:\n- `getTemplatePath()` joins template directory paths and asserts if the resulting path exists.\n- `joinScriptFileBaseDir()` combines script file base directory with a local file path.\n- `renderTemplate()` renders a Jinja2 template, optionally converting dictionaries/lists to JSON.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/commons.py\":764-794",
            "content": "        modelPath = model\n        # we set enviorment variable instead.\n        # breakpoint()\n        yolov5_model = torch.hub.load(localModelPath, modelPath, source=\"local\")\n    return yolov5_model\ndef getTemplatePath(template_dirs, template_path):\n    basedir = getTemplateFileBaseDir()\n    for template_dir in template_dirs:\n        basedir = os.path.join(basedir, template_dir)\n        assert os.path.exists(basedir)\n    template_path = os.path.join(basedir, template_path)\n    assert os.path.exists(template_path)\n    return template_path\ndef joinScriptFileBaseDir(script_file, local_file_path):\n    basepath = getScriptFileBaseDir(script_file)\n    file_path = os.path.join(basepath, local_file_path)\n    return file_path\ndef renderTemplate(template, template_args, enable_json=True):\n    template = jinja2.Template(template)\n    if enable_json:\n        for key in template_args.keys():\n            data = template_args[key]\n            if type(data) in [dict, list, tuple]:\n                try:\n                    data = json.dumps(data)"
        },
        {
            "comment": "commons.py file contains various utility functions, including a template rendering function with exception handling, a decorator that uses a specific configuration file, a function to pretty print JSON data with optional indentation, and a function for guessing the type of a file based on its extension.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/commons.py\":795-832",
            "content": "                    template_args[key] = data\n                except:\n                    pass\n    script = template.render(**template_args)\n    return script\ndef configDecorator(func, config=\"config.json\"):\n    def mytarget(*args, **kwargs):\n        return func(*args, **(kwargs | {\"config\": config}))\n    return mytarget\ndef jsonPrettyPrint(feedback, indent=4):\n    assert type(indent) == int\n    mtype = \"json\"\n    feedback_type = type(feedback)\n    if feedback_type != str:\n        try:\n            mfeedback_content = json.dumps(feedback, indent=indent)\n        except:\n            mfeedback_content = str(feedback)\n            mtype = str(feedback_type)\n    else:\n        mfeedback_content = feedback\n        mtype = \"str\"\n    return mtype, mfeedback_content\ndef getFileType(fbase0):\n    # quick dirty fix.\n    # for gif we have a hard fix.\n    translateTable = {\"gif\": \"video\"}  # force conversion.\n    # print(\"FBASE:\", fbase0)\n    suffix = fbase0.split(\".\")[-1]\n    guessedType = translateTable.get(suffix, None)\n    # breakpoint()"
        },
        {
            "comment": "This code includes functions for getting file types, extensions, and local file names. It also includes a decorator for tracing source locations and a function to get the hostname. The \"getFileType\" function uses the guessed type or the mimetype of the file if it exists. The \"getAbsoluteFilePath\" returns an absolute path if given, otherwise it returns the absolute path of the relative path. The \"getFileExtension\" gets the extension of a file name. The \"getLocalFileType\" guesses the file type based on its name. The \"getHostname\" function retrieves the hostname of the current machine. Finally, the \"keywordDecorator\" is used for traceable source locations.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/commons.py\":833-873",
            "content": "    if guessedType:\n        return guessedType\n    mimestart = mimetypes.guess_type(fbase0)[0]\n    if mimestart != None:\n        mimestart = mimestart.split(\"/\")[0]\n        return mimestart\n    return \"unknown\"\ndef getAbsoluteFilePath(fpath):\n    assert os.path.exists(fpath)\n    if os.path.isabs(fpath):\n        return fpath\n    return os.path.abspath(fpath)\ndef getFileExtension(fpath):\n    basename = os.path.basename(fpath)\n    assert \".\" in basename\n    return basename.split(\".\")[-1]\ndef getLocalFileType(fpath):  # this is guessing, not file probing.\n    fbase = os.path.basename(fpath)\n    return getFileType(fbase)\ndef getHostname():\n    return socket.gethostname()\ndef keywordDecorator(func, **kwargs2):\n    def mytarget(*margs, **kwargs):\n        if \"trace_source\" in kwargs.keys():\n            if kwargs2[\"trace_source\"]:\n                return func(*margs, **(kwargs | kwargs2)), \".\".join(\n                    [__name__, func.__name__]\n                )\n        return func(*margs, **(kwargs | kwargs2))\n    return mytarget"
        },
        {
            "comment": "This code includes functions for a decorator, Chinese detector, timestamp generation, removing trash directories, and writing files. The decorator function takes a function as an argument and returns a wrapper function. The ChineseDetector function checks if a string contains Chinese characters. The getTimestamp function returns the current timestamp. The dumpTrashDir function removes the specified trash directory if it exists and is a directory. The writeFileWithPath function writes content to a file with the given path, filename, and mode.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/commons.py\":876-916",
            "content": "def decorator(func):\n    def mytarget(*args, **kwargs):\n        return func(*args, **kwargs), \".\".join([__name__, func.__name__])\n    return mytarget\ndef chineseDetector(string):\n    base, celi = 0x4E00, 0x9FA5\n    for elem in string:\n        mydata = ord(elem)\n        if mydata >= base and mydata <= celi:\n            return True\n    return False\ndef getTimestamp():\n    return datetime.datetime.now().timestamp()\ndef dumpTrashDir(trash_dir):\n    if os.path.exists(trash_dir):\n        if os.path.isdir(trash_dir):\n            shutil.rmtree(trash_dir)\n        else:\n            os.remove(trash_dir)\ndef writeFileWithPath(path, fname, content, mode, encoding=None):\n    if not os.path.exists(path):\n        os.makedirs(path)\n    log_path = os.path.join(path, fname)\n    if \"b\" not in mode:\n        if encoding == None:\n            with open(log_path, mode) as f:\n                f.write(content)\n        else:\n            with open(log_path, mode, encoding=encoding) as f:\n                f.write(content)\n    else:\n        with open(log_path, mode) as f:"
        },
        {
            "comment": "Writes the content to a file, then prints the log path indicating successful file writing.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/commons.py\":917-918",
            "content": "            f.write(content)\n    print(\"file written at:\\n{}\".format(log_path))"
        }
    ]
}