{
    "summary": "This code uses a Kalman Filter for time series smoothing, provides utility functions, manages overlapping intervals, handles range merging and sorting, includes Bezier curve function, applies exponential network to multiple inputs, and has a window-based maximum average finding function.",
    "details": [
        {
            "comment": "This code defines several utility functions for numerical operations, including mean, max, min, unique values (with optional ordering and shuffling), Exponential Moving Average (EMA), and a Kalman Filter. It imports necessary libraries like numpy and pykalman.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/mathlib.py\":0-39",
            "content": "# moved to lazero.utils.mathlib\nfrom lazero.utils.mathlib import *\n# # not overriding math.\n# # do some ranged stuff here...\n# from pykalman import KalmanFilter\n# import numpy as np\n# def superMean(mList:list,default=0):\n#     if len(mList) == 0: return  default\n#     return np.mean(mList)\n# def superMax(mList:list,default=0):\n#     if len(mList) == 0: return default\n#     return max(mList)\n# def superMin(mList:list,default=0):\n#     if len(mList) == 0: return default\n#     return min(mList)\n# def uniq(mList, ordered=True, random=False):\n#     if ordered:\n#         result = []\n#         for elem in mList:\n#             if elem not in result:\n#                 result.append(elem)\n#     else:\n#         result = list(set(mList))\n#     if random:\n#         import random\n#         random.shuffle(result)\n#     return result\n# def get1DArrayEMA(mArray, N=5):\n#     weights = np.exp(np.linspace(0, 1, N))\n#     weights = weights / np.sum(weights)\n#     ema = np.convolve(weights, mArray, mode=\"valid\")\n#     return ema\n# def Kalman1D(observations, damping=0.2):"
        },
        {
            "comment": "The code snippet initializes a KalmanFilter object for smoothing time series data. It defines the observation_covariance, transition_covariance, and other parameters before creating the KalmanFilter instance. The function then calls `kf.smooth(observations)` to perform the smoothing operation and returns the smoothed state. Additionally, there's a helper function that converts a sympy Union set to a list of (left_boundary, right_boundary) tuples.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/mathlib.py\":40-65",
            "content": "#     # To return the smoothed time series data\n#     observation_covariance = damping\n#     initial_value_guess = observations[0]\n#     transition_matrix = 1\n#     transition_covariance = 0.1\n#     initial_value_guess\n#     kf = KalmanFilter(\n#         initial_state_mean=initial_value_guess,\n#         initial_state_covariance=observation_covariance,\n#         observation_covariance=observation_covariance,\n#         transition_covariance=transition_covariance,\n#         transition_matrices=transition_matrix,\n#     )\n#     pred_state, state_cov = kf.smooth(observations)\n#     return pred_state\n# def getContinualNonSympyMergeResult(inputMSetCandidates):\n#     # basically the same example.\n#     # assume no overlapping here.\n#     import sympy\n#     def unionToTupleList(myUnion):\n#         unionBoundaries = list(myUnion.boundary)\n#         unionBoundaries.sort()\n#         leftBoundaries = unionBoundaries[::2]\n#         rightBoundaries = unionBoundaries[1::2]\n#         return list(zip(leftBoundaries, rightBoundaries))"
        },
        {
            "comment": "This code defines two functions: \"tupleSetToUncertain\" and \"mergeOverlappedInIntervalTupleList\". The first function takes a set of intervals represented as tuples, converts them into a Sympy Interval object representing the union of these intervals, and returns both the object and its type. The second function merges overlapping intervals from a list of interval tuples and returns the merged intervals as a list of start-end pairs. It uses the first function to convert the input intervals into a Sympy Interval object, extracts the boundary points, sorts them, and then zips them back into start-end pairs for the output list.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/mathlib.py\":67-93",
            "content": "#     def tupleSetToUncertain(mSet):\n#         mUncertain = None\n#         for start, end in mSet:\n#             if mUncertain is None:\n#                 mUncertain = sympy.Interval(start, end)\n#             else:\n#                 mUncertain += sympy.Interval(start, end)\n#         typeUncertain = type(mUncertain)\n#         return mUncertain, typeUncertain\n#     def mergeOverlappedInIntervalTupleList(intervalTupleList):\n#         mUncertain, _ = tupleSetToUncertain(intervalTupleList)\n#         mUncertainBoundaryList = list(mUncertain.boundary)\n#         mUncertainBoundaryList.sort()\n#         mergedIntervalTupleList = list(\n#             zip(mUncertainBoundaryList[::2], mUncertainBoundaryList[1::2])\n#         )\n#         return mergedIntervalTupleList\n#     # mSet = mergeOverlappedInIntervalTupleList([(0, 1), (2, 3)])\n#     # mSet2 = mergeOverlappedInIntervalTupleList([(0.5, 1.5), (1.6, 2.5)])\n#     # print(\"MSET\", mSet)\n#     # print(\"MSET2\", mSet2)\n#     mSetCandidates = [\n#         mergeOverlappedInIntervalTupleList(x) for x in inputMSetCandidates"
        },
        {
            "comment": "This code creates a dictionary of markers for left and right boundaries. It first combines all set candidates into one list, then creates sets for the left and right boundary lists. It then populates the \"enter\" and \"exit\" dictionaries with the indices where each boundary is encountered. This information can be used for further processing, such as merging nearby intervals or identifying overlapping boundaries.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/mathlib.py\":94-112",
            "content": "#     ]\n#     mSetUnified = [x for y in mSetCandidates for x in y]\n#     leftBoundaryList = set([x[0] for x in mSetUnified])\n#     rightBoundaryList = set([x[1] for x in mSetUnified])\n#     # they may freaking overlap.\n#     # if want nearby-merge strategy, simply just expand all intervals, merge them with union and shrink the individual intervals inside union respectively.\n#     markers = {\n#         \"enter\": {k: [] for k in leftBoundaryList},\n#         \"exit\": {k: [] for k in rightBoundaryList},\n#     }\n#     for index, mSetCandidate in enumerate(mSetCandidates):\n#         leftBoundaryListOfCandidate = [x[0] for x in mSetCandidate]\n#         rightBoundaryListOfCandidate = [x[1] for x in mSetCandidate]\n#         for leftBoundaryOfCandidate in leftBoundaryListOfCandidate:\n#             markers[\"enter\"][leftBoundaryOfCandidate].append(index)  # remap this thing!\n#         for rightBoundaryOfCandidate in rightBoundaryListOfCandidate:\n#             markers[\"exit\"][rightBoundaryOfCandidate].append(index)  # remap this thing!"
        },
        {
            "comment": "This code is iterating through the boundaries of two lists, unifying them into a sorted list called `unifiedBoundaryList`. It then creates empty dictionaries `unifiedBoundaryMarks` and `finalMappings`. The `markers` dictionary is used to determine which markers correspond to the current boundary. The code calculates the current mark by combining previous markers, entering markers for the current boundary, and removing any exiting markers for the current boundary. It then updates `unifiedBoundaryMarks` with the new index and current marker list. If the previous marker list was empty (indicating an empty range), it does something (code missing).",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/mathlib.py\":114-135",
            "content": "#     # now, iterate through the boundaries of mSetUnified.\n#     unifiedBoundaryList = leftBoundaryList.union(\n#         rightBoundaryList\n#     )  # call me a set instead of a list please? now we must sort this thing\n#     unifiedBoundaryList = list(unifiedBoundaryList)\n#     unifiedBoundaryList.sort()\n#     unifiedBoundaryMarks = {}\n#     finalMappings = {}\n#     # print(\"MARKERS\", markers)\n#     # breakpoint()\n#     for index, boundary in enumerate(unifiedBoundaryList):\n#         previousMark = unifiedBoundaryMarks.get(index - 1, [])\n#         enterList = markers[\"enter\"].get(boundary, [])\n#         exitList = markers[\"exit\"].get(boundary, [])\n#         currentMark = set(previousMark + enterList).difference(set(exitList))\n#         currentMark = list(currentMark)\n#         unifiedBoundaryMarks.update({index: currentMark})\n#         # now, handle the change? or not?\n#         # let's just deal those empty ones, shall we?\n#         if previousMark == []:  # inside it is empty range.\n#             # elif currentMark == []:"
        },
        {
            "comment": "This code appears to be working with a list of intervals and categorizing them into different types. It checks for the start of each interval, updates a dictionary (finalMappings) accordingly, and then handles the end of an interval by assigning it to the previous category. Finally, it processes the finalMappings dictionary to create the final output (finalCats).",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/mathlib.py\":136-162",
            "content": "#             if index == 0:\n#                 continue  # just the start, no need to note this down.\n#             else:\n#                 finalMappings.update(\n#                     {\n#                         \"empty\": finalMappings.get(\"empty\", [])\n#                         + [(unifiedBoundaryList[index - 1], boundary)]\n#                     }\n#                 )\n#             # the end of previous mark! this interval belongs to previousMark\n#         else:\n#             key = previousMark.copy()\n#             key.sort()\n#             key = tuple(key)\n#             finalMappings.update(\n#                 {\n#                     key: finalMappings.get(key, [])\n#                     + [(unifiedBoundaryList[index - 1], boundary)]\n#                 }\n#             )\n#             # also the end of previous mark! belongs to previousMark.\n#     ### NOW THE FINAL OUTPUT ###\n#     finalCats = {}\n#     for key, value in finalMappings.items():\n#         # value is an array containing subInterval tuples.\n#         value = mergeOverlappedInIntervalTupleList(value)"
        },
        {
            "comment": "This code defines two functions, `getContinualMappedNonSympyMergeResult` and `getContinualMappedNonSympyMergeResultWithRangedEmpty`. These functions merge overlapping ranges of values into a single range. They can be used to handle cases where the input is a list of ranges, and we want to merge all ranges that overlap. The merged result is returned as a dictionary with keys being concatenated keys (in the first function) or including non-tuple keys if `noEmpty` flag is set (in the second function).",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/mathlib.py\":163-189",
            "content": "#         valueCorrected = [(mStart, mEnd) for mStart, mEnd in value if mStart < mEnd]\n#         finalCats.update({key: valueCorrected})\n#     # print(\"______________FINAL CATS______________\")\n#     # print(finalCats)\n#     return finalCats\n# def getContinualMappedNonSympyMergeResult(mRangesDict, concatSymbol=\"|\", noEmpty=True):\n#     mKeyMaps = list(mRangesDict.keys())\n#     mSetCandidates = [mRangesDict[key] for key in mKeyMaps]\n#     # the next step will automatically merge all overlapped candidates.\n#     finalCats = getContinualNonSympyMergeResult(mSetCandidates)\n#     finalCatsMapped = {\n#         concatSymbol.join([mKeyMaps[k] for k in mTuple]): finalCats[mTuple]\n#         for mTuple in finalCats.keys()\n#         if type(mTuple) == tuple\n#     }\n#     if not noEmpty:\n#         finalCatsMapped.update(\n#             {k: finalCats[k] for k in finalCats.keys() if type(k) != tuple}\n#         )\n#     return finalCatsMapped\n#     # default not to output empty set?\n# def getContinualMappedNonSympyMergeResultWithRangedEmpty("
        },
        {
            "comment": "This code creates a new dictionary by filtering and merging overlapping ranges. It copies the input dictionary, adds an empty set range, filters non-overlapping ranges, removes empty sets, and finally merges overlapping empty sets.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/mathlib.py\":190-218",
            "content": "#     mRangesDict, start, end, concatSymbol=\"|\"\n# ):\n#     import uuid\n#     emptySetName = str(uuid.uuid4())\n#     newRangesDict = mRangesDict.copy()\n#     newRangesDict.update({emptySetName: [(start, end)]})\n#     newRangesDict = getContinualMappedNonSympyMergeResult(\n#         newRangesDict, concatSymbol=\"|\", noEmpty=True\n#     )\n#     newRangesDict = {\n#         key: [\n#             (mStart, mEnd)\n#             for mStart, mEnd in newRangesDict[key]\n#             if mStart >= start and mEnd <= end and mStart < mEnd\n#         ]\n#         for key in newRangesDict.keys()\n#     }\n#     newRangesDict = {\n#         key: newRangesDict[key]\n#         for key in newRangesDict.keys()\n#         if newRangesDict[key] != []\n#     }\n#     finalNewRangesDict = {}\n#     for key in newRangesDict.keys():\n#         mergedEmptySetName = \"{}{}\".format(concatSymbol, emptySetName)\n#         if mergedEmptySetName in key:\n#             newKey = key.replace(mergedEmptySetName,\"\")\n#             finalNewRangesDict.update({newKey:newRangesDict[key]})"
        },
        {
            "comment": "This code seems to handle the merging and sorting of ranges for a set of commands based on their start and end times. It appears that `mergedRangesToSequential` takes a dictionary of command strings and time spans, sorts the command time spans by start time, and then creates a new list with each command and its sorted time span. The code also includes functions for updating a dictionary based on specific conditions and converting a sorted sequence back into merged ranges.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/mathlib.py\":219-243",
            "content": "#         elif key == emptySetName:\n#             finalNewRangesDict.update({'empty':newRangesDict[key]})\n#         else:\n#             finalNewRangesDict.update({key:newRangesDict[key]})\n#     return finalNewRangesDict\n# def mergedRangesToSequential(renderDict):\n#     renderList = []\n#     for renderCommandString in renderDict.keys():\n#         commandTimeSpans = renderDict[renderCommandString].copy()\n#         # commandTimeSpan.sort(key=lambda x: x[0])\n#         for commandTimeSpan in commandTimeSpans:\n#             mStart, mEnd = commandTimeSpan\n#             if mStart < mEnd:\n#                 renderList.append([renderCommandString, commandTimeSpan].copy())\n#     renderList.sort(key=lambda x: x[1][0])\n#     return renderList\n#     # for renderCommandString, commandTimeSpan in renderList:\n#     #     print(renderCommandString, commandTimeSpan)\n#     # so this is arranged as such:\n#     # [(renderCommandString, commandTimeSpan), ...]\n# def sequentialToMergedRanges(sequence):\n#     mergedRanges = {}\n#     for commandString, commandTimeSpan in sequence:"
        },
        {
            "comment": "This code defines a function `bezierCurve` that takes three arguments: start, end, and skew. It then uses the given values to create a Bezier curve by defining nodes based on the input parameters and returns the created curve along with a dictionary of curve parameters. The separate function `evaluateBezierCurve` is defined to evaluate a previously created Bezier curve at a specific input value, taking as arguments the input value, the created curve, and the dictionary of curve parameters. The function checks if the input value falls within the start and end points of the curve before returning the evaluated x-coordinate.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/mathlib.py\":244-273",
            "content": "#         mergedRanges.update({commandString: mergedRanges.get(commandString,[])+[commandTimeSpan]})\n#     mergedRanges = getContinualMappedNonSympyMergeResult(mergedRanges)\n#     return mergedRanges\n# import bezier\n# def bezierCurve(start=(0, 0), end=(1, 1), skew=0):\n#     # skew: (-0.5,0.5) otherwise this shit will look ugly.\n#     assert skew >= -0.5\n#     assert skew <= 0.5\n#     x_start, y_start = start\n#     x_end, y_end = end\n#     x_diff = x_end - x_start\n#     y_diff = y_end - y_start\n#     nodes1 = np.asfortranarray(\n#         [\n#             [x_start, x_diff * (0.5 + skew), x_end],\n#             [y_start, y_diff * (0.5 - skew), y_end],\n#         ]\n#     )\n#     curve1 = bezier.Curve(nodes1, degree=2)\n#     curve_params = {\"x_start\": x_start, \"x_diff\": x_diff, \"x_end\": x_end}\n#     return curve1, curve_params\n# def evaluateBezierCurve(input_value: float, curve, curve_params: dict):\n#     x_start = curve_params[\"x_start\"]\n#     x_end = curve_params[\"x_end\"]\n#     assert x_start <= input_value\n#     assert x_end >= input_value"
        },
        {
            "comment": "The code defines a function `multiParameterExponentialNetwork` that takes multiple inputs and applies an exponential network function to each of them. The result is the average value after applying the function to all inputs. Another function, `getCursorOfMaxAverageInWindow`, calculates the cursor of maximum average in a given window size for a dataset, asserting that the window size is less than the data duration.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/mathlib.py\":274-302",
            "content": "#     x_diff = curve_params[\"x_diff\"]\n#     s = (input_value - x_start) / x_diff\n#     points = curve.evaluate(s)\n#     # we only get the single point.\n#     point = points.T[0]\n#     x, y = point\n#     result = y\n#     return result\n# def multiParameterExponentialNetwork(\n#     *args,\n#     input_bias=0.05,\n#     curve_function=bezierCurve,\n#     curve_function_kwargs={\"start\": (0, 0), \"end\": (1, 1), \"skew\": 0},\n#     evaluate_function=evaluateBezierCurve\n# ):\n#     curve, curve_params = curve_function(**curve_function_kwargs)\n#     value = evaluate_function(input_bias, curve, curve_params)\n#     for index, input_value in enumerate(args):\n#         apply_list = [input_value] * (index + 1)\n#         for apply_item in apply_list:\n#             value += (1 - value) * evaluate_function(apply_item, curve, curve_params)\n#     return value\n# def getCursorOfMaxAverageInWindow(referenceData, windowSize, dataDuration, superSampleRate=8):\n#     assert windowSize<dataDuration\n#     # we supersample this reference data?\n#     fp = referenceData"
        },
        {
            "comment": "This code interpolates data, applies a moving average window, and returns the cursor value at the peak of the smoothed signal.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/mathlib.py\":303-321",
            "content": "#     xp = np.linspace(0,dataDuration, len(fp))\n#     interpolated_xp = np.linspace(0, dataDuration, len(fp)*superSampleRate)\n#     fp = np.array(fp)\n#     interpolated_fp = []\n#     for x in interpolated_xp:\n#         interpolated_value = np.interp(x, xp, fp)\n#         interpolated_fp.append(interpolated_value)\n#     interpolated_fp = np.array(interpolated_fp)\n#     moving_sum_span = 0\n#     for index, value in enumerate(interpolated_xp):\n#         if value - windowSize >=0: break\n#         moving_sum_span = index\n#     moving_sum_span +=1\n#     moving_sum = np.convolve(interpolated_fp, np.ones(moving_sum_span),'valid')\n#     max_index = np.argmax(moving_sum)\n#     cursor = interpolated_fp[max_index]\n#     cursor = min(dataDuration-windowSize,cursor)\n#     return cursor"
        }
    ]
}