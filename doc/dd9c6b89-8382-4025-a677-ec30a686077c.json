{
    "summary": "The code utilizes SymPy to handle intervals, merges overlapping ones, and reorganizes finalMappings and sorts finalCats before printing.",
    "details": [
        {
            "comment": "This code defines functions for handling intervals and merging overlapping intervals. It uses SymPy library to perform interval operations. The \"unionToTupleList\" function converts a set of intervals into a list of left and right boundaries in ascending order. The \"tupleSetToUncertain\" function converts a tuple set of intervals into a single uncertain interval using SymPy. The \"mergeOverlappedInIntervalTupleList\" function merges overlapping intervals in the given tuple set and returns the merged result as a list of boundaries. Finally, it uses these functions to merge two example sets of intervals.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tests/interval_set_math_operations/continual_less_sympy.py\":0-32",
            "content": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# basically the same example.\n# assume no overlapping here.\nimport sympy\ndef unionToTupleList(myUnion):\n  unionBoundaries = list(myUnion.boundary)\n  unionBoundaries.sort()\n  leftBoundaries = unionBoundaries[::2]\n  rightBoundaries = unionBoundaries[1::2]\n  return list(zip(leftBoundaries, rightBoundaries))\ndef tupleSetToUncertain(mSet):\n  mUncertain = None\n  for start, end in mSet:\n    if mUncertain is None:\n      mUncertain = sympy.Interval(start,end)\n    else:\n      mUncertain += sympy.Interval(start,end)\n  typeUncertain = type(mUncertain)\n  return mUncertain, typeUncertain\ndef mergeOverlappedInIntervalTupleList(intervalTupleList):\n  mUncertain, _ = tupleSetToUncertain(intervalTupleList)\n  mUncertainBoundaryList = list(mUncertain.boundary)\n  mUncertainBoundaryList.sort()\n  mergedIntervalTupleList = list(zip(mUncertainBoundaryList[::2], mUncertainBoundaryList[1::2]))\n  return mergedIntervalTupleList\nmSet = mergeOverlappedInIntervalTupleList([(0,1), (2,3)])\nmSet2 = mergeOverlappedInIntervalTupleList([(0.5,1.5),(1.6,2.5)])"
        },
        {
            "comment": "This code initializes two sets of boundary lists, 'leftBoundaryList' and 'rightBoundaryList', from a merged list of intervals, 'mSetUnified'. It then creates a dictionary, 'markers', with two keys 'enter' and 'exit' to track the occurrences of these boundaries in each original interval, 'mSetCandidates'. The code remaps the indices of the 'mSetCandidates' where the left and right boundaries appear. This is done for every candidate in 'mSetCandidates', and the information is stored in 'markers'.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tests/interval_set_math_operations/continual_less_sympy.py\":34-54",
            "content": "print(\"MSET\", mSet)\nprint(\"MSET2\", mSet2)\nmSetCandidates = [mSet, mSet2]\nmSetUnified = [x for y in mSetCandidates for x in y]\nleftBoundaryList = set([x[0] for x in mSetUnified])\nrightBoundaryList = set([x[1] for x in mSetUnified])\n# they may freaking overlap.\n# if want nearby-merge strategy, simply just expand all intervals, merge them with union and shrink the individual intervals inside union respectively.\nmarkers = {\"enter\":{k:[] for k in leftBoundaryList}, \"exit\":{k:[] for k in rightBoundaryList}}\nfor index, mSetCandidate in enumerate(mSetCandidates):\n  leftBoundaryListOfCandidate = [x[0] for x in mSetCandidate]\n  rightBoundaryListOfCandidate = [x[1] for x in mSetCandidate]\n  for leftBoundaryOfCandidate in leftBoundaryListOfCandidate:\n    markers[\"enter\"][leftBoundaryOfCandidate].append(index) # remap this thing!\n  for rightBoundaryOfCandidate in rightBoundaryListOfCandidate:\n    markers[\"exit\"][rightBoundaryOfCandidate].append(index) # remap this thing!\n# now, iterate through the boundaries of mSetUnified."
        },
        {
            "comment": "Code is iterating over unifiedBoundaryList, checking for changes in markers at each boundary. If a marker is empty or if the current boundary is the first one, it continues without noting anything down. Otherwise, it updates finalMappings with previous empty ranges.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tests/interval_set_math_operations/continual_less_sympy.py\":55-77",
            "content": "unifiedBoundaryList = leftBoundaryList.union(rightBoundaryList) # call me a set instead of a list please? now we must sort this thing\nunifiedBoundaryList = list(unifiedBoundaryList)\nunifiedBoundaryList.sort()\nunifiedBoundaryMarks = {}\nfinalMappings = {}\n# print(\"MARKERS\", markers)\n# breakpoint()\nfor index, boundary in enumerate(unifiedBoundaryList):\n  previousMark = unifiedBoundaryMarks.get(index-1, [])\n  enterList = markers[\"enter\"].get(boundary,[])\n  exitList = markers[\"exit\"].get(boundary,[])\n  currentMark = set(previousMark + enterList).difference(set(exitList))\n  currentMark = list(currentMark)\n  unifiedBoundaryMarks.update({index:currentMark})\n  # now, handle the change? or not?\n  # let's just deal those empty ones, shall we?\n  if previousMark == []: # inside it is empty range.\n  # elif currentMark == []:\n    if index == 0: continue # just the start, no need to note this down.\n    else:\n      finalMappings.update({\"empty\":finalMappings.get(\"empty\",[])+[(unifiedBoundaryList[index-1], boundary)]})\n    # the end of previous mark! this interval belongs to previousMark"
        },
        {
            "comment": "Updates finalMappings with previous mark, sorts and converts to tuple. Updates finalCats using merged overlapped intervals from finalMappings. Prints finalCats for output.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tests/interval_set_math_operations/continual_less_sympy.py\":78-93",
            "content": "  else:\n    key = previousMark.copy()\n    key.sort()\n    key = tuple(key)\n    finalMappings.update({key:finalMappings.get(key,[])+[(unifiedBoundaryList[index-1], boundary)]})\n    # also the end of previous mark! belongs to previousMark.\n### NOW THE FINAL OUTPUT ###\nfinalCats = {}\nfor key, value in finalMappings.items():\n  # value is an array containing subInterval tuples.\n  value = mergeOverlappedInIntervalTupleList(value)\n  finalCats.update({key: value})\nprint(\"______________FINAL CATS______________\")\nprint(finalCats)"
        }
    ]
}