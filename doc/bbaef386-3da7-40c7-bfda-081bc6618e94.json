{
    "summary": "The code loads an input image, preprocesses it, resizes using argparse, detects text with OpenCV and EAST Detector, calculates prediction time, filters low-confidence detections, extracts scores & geometrical data, applies non-maxima suppression, scales coordinates, draws bounding boxes on the original image, and displays it.",
    "details": [
        {
            "comment": "This code loads an input image and applies preprocessing steps. It utilizes the argparse module to accept command-line arguments, allowing users to specify the input image path and the East text detector model file. It also sets default values for confidence threshold and resized image dimensions, which can be overridden by command-line options.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tests/still_watermark_auto_removal/EAST-Detector-for-text-detection-using-OpenCV-master/opencv_text_detection_image.py\":0-25",
            "content": "# USAGE\n# python3 opencv_text_detection_image.py --image images/lebron_james.jpg --east frozen_east_text_detection.pb\n# import the necessary packages\nfrom imutils.object_detection import non_max_suppression\nimport numpy as np\nimport argparse\nimport time\nimport cv2\n# construct the argument parser and parse the arguments\nap = argparse.ArgumentParser()\nap.add_argument(\"-i\", \"--image\", type=str,\n                help=\"path to input image\")\nap.add_argument(\"-east\", \"--east\", type=str,\n                help=\"path to input EAST text detector\")\nap.add_argument(\"-c\", \"--min-confidence\", type=float, default=0.5,\n                help=\"minimum probability required to inspect a region\")\nap.add_argument(\"-w\", \"--width\", type=int, default=320,\n                help=\"resized image width (should be multiple of 32)\")\nap.add_argument(\"-e\", \"--height\", type=int, default=320,\n                help=\"resized image height (should be multiple of 32)\")\nargs = vars(ap.parse_args())\n# load the input image and grab the image dimensions\nimage = cv2.imread(args[\"image\"])"
        },
        {
            "comment": "This code performs image preprocessing, resizing and loads the EAST text detector model for text detection. It sets the original image copy, calculates new width and height based on arguments, resizes the image, gets updated dimensions, defines output layer names for the model, loads the pre-trained EAST text detector model, constructs a blob from the image, performs a forward pass of the model to obtain two output layers.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tests/still_watermark_auto_removal/EAST-Detector-for-text-detection-using-OpenCV-master/opencv_text_detection_image.py\":26-54",
            "content": "orig = image.copy()\n(H, W) = image.shape[:2]\n# set the new width and height and then determine the ratio in change\n# for both the width and height\n(newW, newH) = (args[\"width\"], args[\"height\"])\nrW = W / float(newW)\nrH = H / float(newH)\n# resize the image and grab the new image dimensions\nimage = cv2.resize(image, (newW, newH))\n(H, W) = image.shape[:2]\n# define the two output layer names for the EAST detector model that\n# we are interested -- the first is the output probabilities and the\n# second can be used to derive the bounding box coordinates of text\nlayerNames = [\n    \"feature_fusion/Conv_7/Sigmoid\",\n    \"feature_fusion/concat_3\"]\n# load the pre-trained EAST text detector\nprint(\"[INFO] loading EAST text detector...\")\nnet = cv2.dnn.readNet(args[\"east\"])\n# construct a blob from the image and then perform a forward pass of\n# the model to obtain the two output layer sets\nblob = cv2.dnn.blobFromImage(image, 1.0, (W, H),\n                             (123.68, 116.78, 103.94), swapRB=True, crop=False)\nstart = time.time()"
        },
        {
            "comment": "Code performs text detection using OpenCV and EAST Detector. It calculates the time taken for text prediction, extracts scores and geometrical data, filters out low-confidence detections, and stores bounding box rectangles and corresponding confidence scores in lists.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tests/still_watermark_auto_removal/EAST-Detector-for-text-detection-using-OpenCV-master/opencv_text_detection_image.py\":55-85",
            "content": "net.setInput(blob)\n(scores, geometry) = net.forward(layerNames)\nend = time.time()\n# show timing information on text prediction\nprint(\"[INFO] text detection took {:.6f} seconds\".format(end - start))\n# grab the number of rows and columns from the scores volume, then\n# initialize our set of bounding box rectangles and corresponding\n# confidence scores\n(numRows, numCols) = scores.shape[2:4]\nrects = []\nconfidences = []\n# loop over the number of rows\nfor y in range(0, numRows):\n    # extract the scores (probabilities), followed by the geometrical\n    # data used to derive potential bounding box coordinates that\n    # surround text\n    scoresData = scores[0, 0, y]\n    xData0 = geometry[0, 0, y]\n    xData1 = geometry[0, 1, y]\n    xData2 = geometry[0, 2, y]\n    xData3 = geometry[0, 3, y]\n    anglesData = geometry[0, 4, y]\n    # loop over the number of columns\n    for x in range(0, numCols):\n        # if our score does not have sufficient probability, ignore it\n        if scoresData[x] < args[\"min_confidence\"]:\n            continue"
        },
        {
            "comment": "This code computes the bounding box coordinates and confidence scores for text predictions, using input data such as angles, offsets, xData values. It then applies non-maxima suppression to suppress weak overlapping bounding boxes, likely for further processing or object detection purposes.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tests/still_watermark_auto_removal/EAST-Detector-for-text-detection-using-OpenCV-master/opencv_text_detection_image.py\":87-114",
            "content": "        # compute the offset factor as our resulting feature maps will\n        # be 4x smaller than the input image\n        (offsetX, offsetY) = (x * 4.0, y * 4.0)\n        # extract the rotation angle for the prediction and then\n        # compute the sin and cosine\n        angle = anglesData[x]\n        cos = np.cos(angle)\n        sin = np.sin(angle)\n        # use the geometry volume to derive the width and height of\n        # the bounding box\n        h = xData0[x] + xData2[x]\n        w = xData1[x] + xData3[x]\n        # compute both the starting and ending (x, y)-coordinates for\n        # the text prediction bounding box\n        endX = int(offsetX + (cos * xData1[x]) + (sin * xData2[x]))\n        endY = int(offsetY - (sin * xData1[x]) + (cos * xData2[x]))\n        startX = int(endX - w)\n        startY = int(endY - h)\n        # add the bounding box coordinates and probability score to\n        # our respective lists\n        rects.append((startX, startY, endX, endY))\n        confidences.append(scoresData[x])\n# apply non-maxima suppression to suppress weak, overlapping bounding"
        },
        {
            "comment": "This code performs non-maximum suppression on bounding box coordinates, scales the coordinates based on image ratios, draws bounding boxes on the original image using OpenCV, and displays the resulting image.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tests/still_watermark_auto_removal/EAST-Detector-for-text-detection-using-OpenCV-master/opencv_text_detection_image.py\":115-132",
            "content": "# boxes\nboxes = non_max_suppression(np.array(rects), probs=confidences)\n# loop over the bounding boxes\nfor (startX, startY, endX, endY) in boxes:\n    # scale the bounding box coordinates based on the respective\n    # ratios\n    startX = int(startX * rW)\n    startY = int(startY * rH)\n    endX = int(endX * rW)\n    endY = int(endY * rH)\n    # draw the bounding box on the image\n    cv2.rectangle(orig, (startX, startY), (endX, endY), (0, 255, 0), 2)\n# show the output image\ncv2.imshow(\"Text Detection\", orig)\ncv2.waitKey(0)"
        }
    ]
}