{
    "summary": "The code reads CSV data, calculates statistics for video scene lengths, generates FFmpeg commands with duration threshold handling, filters and selects scenes based on even spacing criteria using random functions. The `getNeighborIndexs` function helps find neighboring values that meet specific thresholds.",
    "details": [
        {
            "comment": "This code reads data from two CSV files and performs calculations on the \"Length (seconds)\" values for each scene in a video. It calculates the standard deviation, mean, minimum, and maximum of these lengths. The resulting values are then printed to the console.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tests/calculate_separate_video_scene_duration_in_dog_video_with_bgm/load_data_do_experiment.py\":0-45",
            "content": "import pandas\nmetric = \"video.stats.csv\"\nmetric = pandas.read_csv(metric)\nscenes = \"sample_scenes.csv\"\nwith open(scenes, \"r\") as f:\n    content = f.read()\n    lines = content.split(\"\\n\")\n    timecodeList = lines[0]\n    scenes = \"\\n\".join(lines[1:])\n    from io import StringIO\n    scenes = StringIO(scenes)\ntimecodeList = timecodeList.split(\",\")\ntimecodeList[0] = \"00:00:00.000\"\nscenes = pandas.read_csv(scenes)\nlengths = []\nsceneCuts = []\nfor index, row in scenes.iterrows():\n    # print(row)\n    # breakpoint()\n    start, end = row[\"Start Timecode\"], row[\"End Timecode\"]\n    length = row[\"Length (seconds)\"]\n    sceneCuts.append((start, end, length))\n    # print(start, end)\n    # please calculate the length!\n    lengths.append(length)\n    # print(length, type(length)) # float.\nflag = \"filter\"\nfilename = \"sample.mp4\"\nif flag == \"calculate_statistics\":\n    import numpy\n    std = numpy.std(lengths)\n    mean = numpy.mean(lengths)\n    print(std, mean)\n    # 1.6674874515595588 2.839698412698412\n    print(min(lengths), max(lengths))"
        },
        {
            "comment": "This code segment is responsible for generating FFmpeg commands to play and render video scenes, with additional handling of scene duration threshold. It also checks if the output directory exists and creates it if necessary. The code adjusts start and end times by subtracting or adding 0.2 seconds from the original duration and compares the estimated duration to a given threshold before proceeding with FFmpeg commands.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tests/calculate_separate_video_scene_duration_in_dog_video_with_bgm/load_data_do_experiment.py\":46-72",
            "content": "    min(lengths), max(lengths)\n    # 0.6 7.833\n    # strange though.\n    # shall we adjust this accordingly? how to generate this shit?\nelif flag == \"generate_ffplay\":\n    for (start, end, duration) in sceneCuts:\n        print(\"ffplay -ss %s -t %s -i %s -autoexit \" % (start, duration, filename))\n        print(\"sleep 3\")\nelif flag == \"render\":\n    import os\n    import datetime\n    durationThreshold = 0.6674874515595588\n    mTimeDelta = datetime.timedelta(milliseconds=100)  # 0.1 seconds\n    getTimeObject = lambda timeString: datetime.datetime.strptime(\n        timeString, \"%H:%M:%S.%f\"\n    )\n    getTimeString = lambda timeObject: timeObject.strftime(\"%H:%M:%S.%f\")\n    if not os.path.exists(\"output\"):\n        os.mkdir(\"output\")\n    for index, (start, end, duration) in enumerate(sceneCuts):\n        estimatedDuration = duration - 0.2\n        if estimatedDuration < durationThreshold:\n            continue\n        start2 = getTimeObject(start) + mTimeDelta\n        end2 = getTimeObject(end) - mTimeDelta\n        start2, end2 = getTimeString(start2), getTimeString(end2)"
        },
        {
            "comment": "This code snippet is responsible for filtering and selecting video scenes based on specific duration criteria. It ensures that the selected set of scenes is evenly spaced, with no two elements being closer than 5 seconds. The code uses random functions to generate duration thresholds and filters candidate scenes accordingly. It also includes time-related functions for converting between string and datetime formats, and calculating timestamps from datetimes.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tests/calculate_separate_video_scene_duration_in_dog_video_with_bgm/load_data_do_experiment.py\":73-98",
            "content": "        output = \"output/%d.flv\" % index\n        print(\"ffmpeg -y -ss %s -to %s -i %s %s\" % (start2, end2, filename, output))\nelif (\n    flag == \"filter\"\n):  # to make sure the selected set will be evenly spaced. no two elements will get closer to each other than 5 seconds.\n    import random\n    durationMinThreshold = 0.6\n    durationMaxThreshold = 7.833\n    fakeQualificationFunction = lambda: random.uniform(\n        durationMinThreshold, durationMaxThreshold\n    )\n    fakeAcceptFunction = lambda: random.random() > 0.5\n    # select the closest one! must be closer than 0.9 to 1.1\n    candidates = []\n    import datetime\n    getTimeObject = lambda timeString: datetime.datetime.strptime(\n        timeString, \"%H:%M:%S.%f\"\n    )\n    getTimeString = lambda timeObject: timeObject.strftime(\"%H:%M:%S.%f\")\n    mTimeDelta = datetime.timedelta(milliseconds=100)  # 0.1 seconds\n    standardStartDatetime = datetime.datetime(year=1900, month=1, day=1)\n    standardStartTimestamp = standardStartDatetime.timestamp()\n    getTimestamp = lambda timeObject: timeObject.timestamp() - standardStartTimestamp"
        },
        {
            "comment": "Iterates through scene cuts, filters based on duration threshold, converts timestamps to Unix timestamps, appends as candidates, shuffles the candidates and assigns index.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tests/calculate_separate_video_scene_duration_in_dog_video_with_bgm/load_data_do_experiment.py\":100-126",
            "content": "    for index, (start, end, duration) in enumerate(sceneCuts):\n        estimatedDurationAfterCut = duration - 0.2\n        if (\n            estimatedDurationAfterCut < durationMinThreshold\n            or estimatedDurationAfterCut > durationMaxThreshold\n        ):\n            continue\n        startCutDatetime = getTimeObject(start) + mTimeDelta\n        endCutDatetime = getTimeObject(end) - mTimeDelta\n        # print(getTimeStamp(startDatetime), getTimeStamp(endDatetime))\n        # print(startDatetime, endDatetime)\n        startCutTimestamp, endCutTimestamp = getTimestamp(\n            startCutDatetime\n        ), getTimestamp(endCutDatetime)\n        candidates.append(\n            (startCutTimestamp, endCutTimestamp, estimatedDurationAfterCut)\n        )\n    shuffledCandidates = [\n        (index, startCutDatetime, endCutDatetime, estimatedDurationAfterCut)\n        for index, (\n            startCutDatetime,\n            endCutDatetime,\n            estimatedDurationAfterCut,\n        ) in enumerate(candidates)\n    ]\n    random.shuffle(shuffledCandidates)"
        },
        {
            "comment": "This function, `getNeighborIndexs`, takes an index, a list of candidates, and two parameters: `neighborThreshold` and `checkNeighbor`. It checks the neighboring values from both sides of the given index, appending their indices to the list if they satisfy a certain condition defined by `checkNeighbor`. It prints the left indices found while iterating through the candidates.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tests/calculate_separate_video_scene_duration_in_dog_video_with_bgm/load_data_do_experiment.py\":127-149",
            "content": "    bannedIndexs = set()\n    neighborThreshold = 5\n    def getNeighborIndexs(index, candidates, neighborThreshold, checkNeighbor):\n        assert neighborThreshold > 0\n        assert index < len(candidates) and index >= 0\n        leftNeighbors = candidates[:index][::-1]\n        rightNeighbors = candidates[index + 1 :]\n        neighborIndexs = []\n        for mIndex, neighbor in enumerate(leftNeighbors):\n            currentIndex = index - mIndex - 1\n            assert candidates[currentIndex] == neighbor\n            assert currentIndex >= 0 and currentIndex < len(candidates)\n            if checkNeighbor(neighbor, candidates[index]):\n                neighborIndexs.append(currentIndex)\n                print(\"left index:\", currentIndex)\n            else:\n                break\n        for mIndex, neighbor in enumerate(rightNeighbors):\n            currentIndex = index + mIndex + 1\n            assert candidates[currentIndex] == neighbor\n            assert currentIndex >= 0 and currentIndex < len(candidates)\n            if checkNeighbor(neighbor, candidates[index]):"
        },
        {
            "comment": "The code is iterating over candidate indexes and checking if they are neighbors. It appends the current index to a list of neighborIndexs, and checks if two clips are neighbors using a threshold value. If there are no available candidates left, it breaks the loop.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tests/calculate_separate_video_scene_duration_in_dog_video_with_bgm/load_data_do_experiment.py\":150-179",
            "content": "                neighborIndexs.append(currentIndex)\n                print(\"right index:\", currentIndex)\n            else:\n                break\n        return neighborIndexs\n    def checkNeighborForClipCandiates(clip_a, clip_b, threshold):\n        assert threshold > 0\n        s_a, e_a, l_a = clip_a\n        s_b, e_b, l_b = clip_b\n        e_min = min(e_a, e_b)\n        s_max = max(s_a, s_b)\n        distance = s_max - e_min\n        return distance < threshold  # check if is neighbor\n    while True:\n        print(\"BANNED:\", len(bannedIndexs), \"TOTAL:\", len(candidates))\n        target = fakeQualificationFunction()\n        isSimilar = lambda a, b, threshold: min(a, b) / max(a, b) >= threshold\n        similarThreshold = 0.9\n        if len(bannedIndexs) == len(shuffledCandidates):\n            print(\"No avaliable candidates\")\n            break\n        for (\n            index,\n            startCutDatetime,\n            endCutDatetime,\n            estimatedDurationAfterCut,\n        ) in shuffledCandidates:\n            if index in bannedIndexs:"
        },
        {
            "comment": "This code continues until finding a candidate that meets the similarity threshold, then accepts it if the fake acceptance function returns true. If accepted, it prints information about the candidate and its neighbors, along with the target duration.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tests/calculate_separate_video_scene_duration_in_dog_video_with_bgm/load_data_do_experiment.py\":180-204",
            "content": "                continue\n            if isSimilar(estimatedDurationAfterCut, target, similarThreshold):\n                accept = fakeAcceptFunction()\n                if accept:\n                    print(\n                        \"Accepting candidate\",\n                        (\n                            index,\n                            startCutDatetime,\n                            endCutDatetime,\n                            estimatedDurationAfterCut,\n                        ),\n                    )\n                    print(\"target:\", target)\n                    bannedIndexs.add(index)\n                    neighborIndexs = getNeighborIndexs(\n                        index,\n                        candidates,\n                        neighborThreshold,\n                        lambda a, b: checkNeighborForClipCandiates(\n                            a, b, neighborThreshold\n                        ),\n                    )\n                    print(\"NEIGHBOR INDEXS:\", neighborIndexs)\n                    for neighborIndex in neighborIndexs:"
        },
        {
            "comment": "The code adds the current neighbor index to a list of banned indices, prints it along with the candidate at that index, and then shuffles the remaining candidates.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tests/calculate_separate_video_scene_duration_in_dog_video_with_bgm/load_data_do_experiment.py\":205-207",
            "content": "                        bannedIndexs.add(neighborIndex)\n                        print(\"also banned:\", neighborIndex, candidates[neighborIndex])\n        random.shuffle(shuffledCandidates)"
        }
    ]
}