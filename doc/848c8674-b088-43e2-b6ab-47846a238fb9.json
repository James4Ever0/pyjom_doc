{
    "summary": "The code imports libraries, defines an audio analysis function using ShazamIO and Midomi API for identifying music. It handles temporary files, extracts duration, segments audio if needed, performs recognition using multiple backends until successful. The function retrieves and checks music URLs, lyrics, and downloaded files' status from NetEase API, implementing search functionality and error handling.",
    "details": [
        {
            "comment": "This code imports necessary libraries and functions, defines the `audioOwlAnalysis` function which retrieves audio sample rate from a music file using `get_media_info()`, sets the sample rate for `audioowl.get_waveform()`, and then calls the waveform function to generate a waveform representation of the audio.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/musictoolbox.py\":0-30",
            "content": "# you will have a better name for other toolboxs.\n# for now, the musictoolbox is responsible for music/lyric retrieval/download, track separation, bpm, music recognition\n# pitch shift, speedup/slowdown is for audiotoolbox\n# voice change/synthesis is for voicetoolbox.\n# diffusion based painter, ai colorization, video editing is for artworktoolbox. maybe the naming is not right/necessary.\n# check AmadeusCore, /root/Desktop/works/pyjom/tests/music_recognization/AmadeusCore/src/components/app/models/\nfrom types import FunctionType\nfrom typing import Union\nimport audioowl\nimport math\nfrom pyjom.commons import *\nfrom pyjom.lyrictoolbox import read_lrc, getLyricNearbyBpmCandidates\nfrom pyjom.audiotoolbox import getAudioDuration\nimport ffmpeg\n# musictoolbox\ndef audioOwlAnalysis(myMusic):\n    # get sample rate\n    # info = MediaInfo(filename = myMusic)\n    # info = info.getInfo()\n    info = get_media_info(myMusic)\n    audioSampleRate = info[\"audioSamplingRate\"]\n    audioSampleRate = int(audioSampleRate)\n    waveform = audioowl.get_waveform(myMusic, sr=audioSampleRate)"
        },
        {
            "comment": "The code performs audio analysis on a given music file using the audioOwlAnalysis function and obtains beat data, tempo, and beats per minute (BPM). If a lyric path is provided and exists, it reads the lyrics and sorts their timings. Then, it filters out any lyric time that is less than the minimum allowed time (mtime). Finally, it returns the list of beat times and BPM.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/musictoolbox.py\":31-67",
            "content": "    data = audioowl.analyze_file(myMusic, sr=audioSampleRate)  # how fucking long?\n    a, b, c, d = [\n        data[k] for k in [\"beat_samples\", \"duration\", \"sample_rate\", \"tempo_float\"]\n    ]\n    bpm = data[\"tempo_float\"]\n    # single_bpm_time = 60/d\n    beat_times = [x / c for x in a]\n    return beat_times, bpm\n# musictoolbox\ndef getMusicCutSpansCandidates(\n    music, lyric_path, maxtime, mintime, mbeat_time_tolerance=0.8\n):\n    beats, bpm = audioOwlAnalysis(music[\"filepath\"])\n    if (\n        lyric_path is not None\n        and type(lyric_path) == str\n        and os.path.exists(lyric_path)\n    ):\n        lyric = read_lrc(lyric_path)\n        # print(lyric)\n        # breakpoint()\n        lyric_times = [x[\"time\"] for x in lyric]\n        lyric_times.sort()\n    else:\n        lyric_times = []\n    new_lyric_times = []\n    last_time = 0\n    for mtime in lyric_times:\n        if mtime - last_time > mintime:\n            new_lyric_times.append(mtime)\n            last_time = mtime\n    lyric_times = new_lyric_times\n    beat_duration = 60 / bpm"
        },
        {
            "comment": "This code generates bpm spans for music and lyrics, considering a certain beat duration. It takes in music, maximum and minimum time values, lyric path, and optional parameters like mbeat_time_tolerance, gaussian function arguments. The code first calculates the standard bpm spans based on the given parameters. Then it calls getLyricNearbyBpmCandidates to get sorted nearby bpm candidates from lyrics. It combines all bpm candidates and returns them along with the calculated standard bpm spans.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/musictoolbox.py\":69-103",
            "content": "    # this is static, not dynamic.\n    # we can make this 'standard bpm spans' into a generator instead.\n    standard_bpm_spans = [\n        x * beat_duration\n        for x in range(0, math.ceil(maxtime / beat_duration) + 1)\n        if x * beat_duration >= mintime * mbeat_time_tolerance\n        and x * beat_duration <= maxtime / mbeat_time_tolerance\n    ]\n    (\n        sorted_lyrics_nearby_bpm_candidates,\n        sorted_remained_bpm_candidates,\n    ) = getLyricNearbyBpmCandidates(lyric_times, beats)\n    candidates = sorted_lyrics_nearby_bpm_candidates + sorted_remained_bpm_candidates\n    return candidates, standard_bpm_spans\n# musictoolbox\ndef getMusicCutSpans(\n    music,\n    music_duration,\n    lyric_path,\n    maxtime,\n    mintime,\n    mbeat_time_tolerance=0.8,\n    gaussian=False,\n    gaussian_args={\"std\": 1.6674874515595588, \"mean\": 2.839698412698412},\n):\n    assert mintime > 0\n    assert maxtime > mintime\n    candidates, standard_bpm_spans = getMusicCutSpansCandidates(\n        music,\n        lyric_path,\n        maxtime,"
        },
        {
            "comment": "This code calculates the minimum and maximum time boundaries for a piece of music. If the gaussian parameter is set, it uses a truncated normal distribution to randomly select a standard BPM span within the specified time range. The code then processes cue points based on this selected standard BPM span, possibly adjusting the rate or creating cut points.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/musictoolbox.py\":104-132",
            "content": "        mintime,\n        mbeat_time_tolerance=mbeat_time_tolerance,\n    )\n    assert len(standard_bpm_spans) >= 1\n    if gaussian:\n        from lazero.utils.mathlib import getTruncatedNormalDistribution\n        std, mean = gaussian_args[\"std\"], gaussian_args[\"mean\"]\n        # scale, loc = std, mean\n        myStart, myEnd = mintime, maxtime\n        randomFunction = getTruncatedNormalDistribution(std, mean, myStart, myEnd)\n        # myclip_a, myclip_b = mintime, maxtime\n        # from scipy.stats import truncnorm\n        # a, b = (myclip_a - loc) / scale, (myclip_b - loc) / scale\n        # randVar = truncnorm(a, b)\n        # randomFunction = lambda: randVar.rvs(1)[0] * scale + loc\n    # now we engage with the cue points.\n    demanded_cut_points = [0]\n    # startingPoint=0\n    remaining_time = music_duration\n    counter = 0\n    oldCandidateLength = None\n    while True:\n        if gaussian:\n            standard_bpm_span_min_selected = randomFunction()\n            doubleRate = max(min(2, maxtime / standard_bpm_span_min_selected), 1)"
        },
        {
            "comment": "Code selects a minimum BPM span for music processing based on the number of available options. If there's only one option, it is selected with a double rate (1.2x). If multiple options exist, it randomly selects from all but the last option and calculates the corresponding double rate. The code also checks for an excessive loop count to prevent potential deadlocks and increments a counter for tracking purposes. It then selects candidates greater than the previous cut point and continues processing if any candidates remain.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/musictoolbox.py\":133-157",
            "content": "        elif len(standard_bpm_spans) == 1:\n            standard_bpm_span_min_selected = standard_bpm_spans[0]\n            doubleRate = 1.2\n        else:\n            standard_bpm_span_min_selected = random.choice(standard_bpm_spans[:-1])\n            doubleRate = max(1, min(2, maxtime / standard_bpm_span_min_selected))\n        if counter > 10000:  # some dangerous deadloop.\n            breakpoint()\n            print(\"LOOPCOUNT\", counter)\n            print(len(demanded_cut_points), remaining_time, standard_bpm_spans[0])\n        counter += 1\n        startingPoint = demanded_cut_points[-1]\n        # try:\n        selected_candidates = [\n            x for x in candidates if x > startingPoint\n        ]  # unsupported comparation between 'float' and 'list'?\n        # except:\n        #     import traceback\n        #     traceback.print_exc()\n        #     breakpoint()\n        newCandidateLength = len(selected_candidates)\n        if newCandidateLength == 0:\n            # nothing left.\n            break\n        if oldCandidateLength is None:"
        },
        {
            "comment": "This code segment compares the old and new candidate lengths, appending selected points to demanded_cut_points based on a specified range of timespan lengths. It also updates oldCandidateLength and checks for remaining time after adding points.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/musictoolbox.py\":158-183",
            "content": "            oldCandidateLength = newCandidateLength\n        else:\n            if (\n                oldCandidateLength == newCandidateLength\n            ):  # force append those points without progress\n                # demanded_cut_points.append(selected_candidates) # this is wrong.\n                demanded_cut_points.append(selected_candidates[0])\n                # no need to update the oldCandidateLength since it is the same as the new\n                continue\n            else:\n                oldCandidateLength = newCandidateLength\n        for elem in selected_candidates:\n            timespan_length = elem - startingPoint\n            if inRange(\n                timespan_length,\n                (\n                    standard_bpm_span_min_selected,\n                    standard_bpm_span_min_selected * doubleRate,\n                ),\n                tolerance=mbeat_time_tolerance,\n            ):\n                # select this element.\n                demanded_cut_points.append(elem)\n                break\n        remaining_time = music_duration - demanded_cut_points[-1]"
        },
        {
            "comment": "The code segment checks if there is enough remaining time for the standard BPM spans. It removes unnecessary cut points, appends the music duration as a cut point, and generates the demanded music cut spans list. The function `getMusicInfoParsed` retrieves music information with optional configuration parameters for font, gaussian usage, policy, and defaults if not specified.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/musictoolbox.py\":184-211",
            "content": "        if remaining_time < standard_bpm_span_min_selected:\n            break\n    demanded_cut_points = list(set(demanded_cut_points))\n    demanded_cut_points.sort()\n    for elem in demanded_cut_points.copy()[::-1]:\n        if music_duration - elem < standard_bpm_spans[0]:\n            demanded_cut_points.remove(elem)\n    demanded_cut_points.append(music_duration)\n    demanded_cut_spans = list(zip(demanded_cut_points[0:-1], demanded_cut_points[1:]))\n    # somehow it was wrong.\n    # print(\"DEMANDED MUSIC CUT SPANS GENERATED\")\n    # breakpoint()\n    return demanded_cut_spans, standard_bpm_spans\n# musictoolbox\n# fix long loading time.\n@redisLRUCache()\ndef getMusicInfoParsed(config, mintime=2, maxtime=7.8):  # these are defaults.\n    music = config[\"music\"]\n    gaussian = config.get(\n        \"gaussian\", True\n    )  # this is different. default to use gaussian instead.\n    # check if music is corrupted?\n    font = config.get(\"font\", None)\n    policy = config.get(\"policy\", {})\n    policy_names = [x for x in policy.keys()]"
        },
        {
            "comment": "This code retrieves music metadata, including duration and lyric path. It then checks if the lyric path exists and updates it accordingly. The function `getMusicCutSpans` is called to obtain demanded cut spans and standard BPM spans for certain use cases like midomi, shazam, or shazamio. It imports necessary types and libraries for processing music information.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/musictoolbox.py\":212-248",
            "content": "    # get music duration here.\n    music_metadata = get_media_info(music[\"filepath\"])\n    music_duration = music_metadata[\"duration\"]\n    maxtime = config.get(\"maxtime\", maxtime)\n    mintime = config.get(\"mintime\", mintime)\n    lyric_path = music.get(\"lyric_path\", None)\n    if type(lyric_path) == str:\n        if not os.path.exists(lyric_path):\n            lyric_path = None\n    elif lyric_path is not None:\n        lyric_path = None\n    demanded_cut_spans, standard_bpm_spans = getMusicCutSpans(\n        music, music_duration, lyric_path, maxtime, mintime, gaussian=gaussian\n    )\n    return (\n        music,\n        font,\n        policy,\n        policy_names,\n        music_metadata,\n        music_duration,\n        maxtime,\n        mintime,\n        lyric_path,\n        demanded_cut_spans,\n        standard_bpm_spans,\n    )\n# for midomi we need to chop music apart.\n# for shazam, nope.\n# shazamio needs event loop. be careful!\nfrom typing import Literal\nimport subprocess\nimport traceback\nfrom lazero.program.subprocess import runCommandGetJson"
        },
        {
            "comment": "The function `runCommandAndProcessSongRecognizationJson` takes a command line, processing method, and optional parameters, then runs the command, processes the resulting JSON data, and returns success and processed data. The `shazamSongRecognizationResultProcessMethod` extracts artist and track name from the Shazam API's JSON response for song recognition. The `recognizeMusicFromFileSongrec` function calls the previous functions to recognize music from a filepath, providing optional raw data output and timeout settings.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/musictoolbox.py\":251-283",
            "content": "def runCommandAndProcessSongRecognizationJson(\n    commandLine: list[str],\n    processMethod: FunctionType,\n    raw_data: bool = False,\n    debug: bool = False,\n    timeout: int = 5,\n    workingDirectory: Union[None, str] = None,\n):\n    success, data = runCommandGetJson(\n        commandLine, debug=debug, timeout=timeout, workingDirectory=workingDirectory\n    )\n    if success:\n        if not raw_data:\n            # more processing. may alter the success flag.\n            try:\n                data = processMethod(data)\n            except:\n                success = False\n                if debug:\n                    traceback.print_exc()\n    return success, data\ndef shazamSongRecognizationResultProcessMethod(data):\n    artist = data[\"track\"][\"subtitle\"]\n    trackName = data[\"track\"][\"title\"]\n    data = {\"artist\": artist, \"trackName\": trackName}\n    return data\n# you can choose to return raw data or not. which is the raw json data.\ndef recognizeMusicFromFileSongrec(filepath, raw_data=False, timeout=6, debug=False):\n    commandLine = [\"songrec\", \"audio-file-to-recognized-song\", filepath]"
        },
        {
            "comment": "This code uses the ShazamIO library to recognize music from a file. It takes the file path, optional raw data flag, timeout value, and debug mode as inputs. It runs a command line using subprocess to execute the shazamio_recognize_music.py script with the specified file path. The function returns the processed song recognition JSON result using the shazamSongRecognizationResultProcessMethod.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/musictoolbox.py\":284-317",
            "content": "    return runCommandAndProcessSongRecognizationJson(\n        commandLine,\n        shazamSongRecognizationResultProcessMethod,\n        raw_data=raw_data,\n        debug=debug,\n        timeout=timeout,\n    )\ndef recognizeMusicFromFileShazamIO(\n    filepath, raw_data=False, timeout=20, debug: bool = False\n):\n    # how to timeout this shit? use subprocess again?\n    # maybe yes.\n    commandLine = [\n        \"python3\",\n        \"/root/Desktop/works/pyjom/tests/soundhound_houndify_midomi_sound_recognize_music/shazamio_recognize_music.py\",\n        \"--file\",\n        filepath,\n    ]\n    return runCommandAndProcessSongRecognizationJson(\n        commandLine,\n        shazamSongRecognizationResultProcessMethod,\n        raw_data=raw_data,\n        debug=debug,\n        timeout=timeout,\n    )\ndef midomiSongRecognizationResultProcessMethod(data):\n    trackData = data[\"AllResults\"][0][\"NativeData\"][\"Tracks\"][0]\n    artist = trackData[\"ArtistName\"]\n    trackName = trackData[\"TrackName\"]\n    data = {\"artist\": artist, \"trackName\": trackName}"
        },
        {
            "comment": "This function recognizes music from a given file using Midomi API. It accepts the file path, optional raw data flag, timeout value, debug mode, maximum number of retries, segment length, and extension type as parameters. The function generates a random temporary file name, extracts the audio duration, segments the audio if necessary based on length, and performs the recognition for the specified number of retries. If in debug mode, it prints the trial number for Midomi API calls.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/musictoolbox.py\":318-353",
            "content": "    return data\n# what is the correct timeout for this one?\nfrom lazero.filesystem.temp import tmpfile, getRandomFileNameUnderDirectoryWithExtension\ndef recognizeMusicFromFileMidomi(\n    filepath,\n    raw_data=False,\n    timeout=10,\n    debug: bool = False,\n    maxRetry=3,\n    segmentLength: int = 10,\n    extension: Union[str, None] = None,\n):  # this one is different. maybe we can wait.\n    success, data = False, {}\n    if extension == None:\n        extension = \"\"\n        splitedFilePath = os.path.basename(filepath).split(\".\")\n        if len(splitedFilePath) > 1:\n            extension = splitedFilePath[-1]\n    if len(extension) == 0:\n        extension = \"mp3\"\n    musicLength = getAudioDuration(filepath)\n    needSegment = musicLength > segmentLength\n    if not needSegment:\n        maxRetry = 1\n    for index in range(maxRetry):\n        if debug:\n            print(\"trial {} for midomi\".format(index + 1))\n        segmentName = getRandomFileNameUnderDirectoryWithExtension(\n            extension, \"/dev/shm\"\n        )\n        with tmpfile(segmentName):"
        },
        {
            "comment": "This code segment is responsible for recognizing music from a given file using different backends. It first checks if there is a need to segment the audio and then uses FFmpeg to extract a segment or touches an existing file as the input. Next, it runs a command line with various arguments including the input file, backend type, raw data, debug mode, timeout, and working directory. The function returns success status and processed data if successful, otherwise continues trying with different backends until success is achieved.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/musictoolbox.py\":354-380",
            "content": "            if needSegment:\n                start = random.uniform(0, musicLength - segmentLength)\n                end = start + segmentLength\n                ffmpeg.input(filepath, ss=start, to=end).output(segmentName).run(\n                    overwrite_output=True\n                )\n            else:\n                pathlib.Path(segmentName).touch()\n                segmentName = filepath\n            # you will change to given directory, will you?\n            commandLine = [\"npx\", \"ts-node\", \"midomi_music_recognize.ts\", segmentName]\n            success, data = runCommandAndProcessSongRecognizationJson(\n                commandLine,\n                midomiSongRecognizationResultProcessMethod,\n                raw_data=raw_data,\n                debug=debug,\n                timeout=timeout,\n                workingDirectory=\"/root/Desktop/works/pyjom/tests/music_recognization/AmadeusCore\",\n            )\n        if success:\n            break\n    return success, data\ndef recognizeMusicFromFile(\n    filepath,\n    backend: Literal[\"songrec\", \"shazamio\", \"midomi\", None] = None,"
        },
        {
            "comment": "This function uses a series of methods to recognize music from a file and returns track data, artist data, and raw data if specified. It checks the duration of the audio file and chooses the appropriate method (midomi, songrec, or shazamio) based on the duration. If no backend is specified, it automatically selects the best method for the given file duration. The code also prints debug information if requested.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/musictoolbox.py\":381-407",
            "content": "    raw_data=False,\n    debug=False,\n):  # if not returning raw_data, only track data and artist data are returned.\n    assert os.path.exists(filepath)\n    # if returning raw_data, must also return the provider name, for easy parsing.\n    # you can try all methods. but if all three methods fails, you know what to do. what indicates the recognizer has failed?\n    # you can try something erotic.\n    if backend is None:  # auto\n        musicDuration = getAudioDuration(filepath)\n        if musicDuration <= 15:\n            backend = \"midomi\"\n        else:\n            backend = \"songrec\"\n    methods = {\n        \"midomi\": recognizeMusicFromFileMidomi,\n        \"songrec\": recognizeMusicFromFileSongrec,\n        \"shazamio\": recognizeMusicFromFileShazamIO,\n    }\n    keys = list(methods.keys())\n    keys.sort(key=lambda x: -int(x == backend))\n    for key in keys:\n        method = methods[key]\n        success, data = method(filepath, debug=debug)\n        if debug:\n            print(\"DATA:\")\n            print(data)\n            print(\"RETURN FROM MUSIC RECOGNIZE METHOD: %s\" % key)"
        },
        {
            "comment": "Imports necessary libraries and defines a class for interacting with Netease Music. The class has a constructor to set the port, and methods to search music, get similar music by ID, download music and lyrics. It also handles exceptions and checks response codes.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/musictoolbox.py\":408-442",
            "content": "            print(\"SUCCESS:\", success)\n        if success:\n            if raw_data:\n                return success, data, key\n            else:\n                return success, data\n        if debug:\n            break  # no retry then.\n    if raw_data:\n        return False, {}, \"\"\n    return False, {}\n############ SEARCH NETEASE MUSIC, GET SIMILAR MUSIC BY ID, DOWNLOAD MUSIC AND LYRICS ############\nimport requests\nfrom lazero.program.functools import suppressException\nclass neteaseMusic:\n    def __init__(self, port: int = 4042):\n        self.baseUrl = \"http://localhost:{}\".format(port)\n    def verifyResponseCodeAndGetJson(\n        self, response, debug: bool = False, success_codes: list[int] = [200]\n    ):\n        response_json = response.json()  # check search_result.json\n        if success_codes != []:\n            code = response_json[\"code\"]\n            if not code in success_codes:\n                if debug:\n                    print(response_json)\n                import traceback\n                traceback.print_exc()"
        },
        {
            "comment": "This code defines a class method to request data from a Netease API using GET requests and handle the response. It takes parameters like suffix, query, debug flag, success codes, and refresh flag. The method handles refreshing timestamps if needed, constructs the URL, makes a GET request with the parameters, verifies the response code, and returns the JSON data or raises an exception if an error occurs.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/musictoolbox.py\":443-473",
            "content": "                raise Exception(\"ERROR CODE IN NETEASE API RESPONSE:\", code)\n        return response_json\n    def requestWithParamsGetJson(\n        self,\n        suffix: str,\n        params: dict = {},\n        debug: bool = False,\n        success_codes: list[int] = [200],\n        refresh: bool = False,\n    ):\n        if refresh:\n            params.update({\"timestamp\": getJSTimeStamp()})\n        suffix = suffix.strip()\n        if not suffix.startswith(\"/\"):\n            suffix = \"/\" + suffix\n        link = self.baseUrl + suffix\n        result = requests.get(link, params=params)\n        result_json = self.verifyResponseCodeAndGetJson(\n            result, debug=debug, success_codes=success_codes\n        )\n        return result_json\n    @suppressException(tries=2, defaultReturn={})\n    def searchNeteaseMusicByQuery(\n        self, query: Union[list, str], debug: bool = False, refresh: bool = False\n    ):\n        if type(query) == str:\n            query = query.strip()\n        else:\n            query = [elem.strip() for elem in query]"
        },
        {
            "comment": "The code contains functions to search and retrieve similar music by ID, as well as fetching the URL of a specific song from the Netease API. It makes requests with parameters, handles exceptions, and returns search results or song IDs.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/musictoolbox.py\":474-504",
            "content": "            query = \" \".join([elem for elem in query if len(elem) > 0])\n        assert len(query) > 0\n        search_result_json = self.requestWithParamsGetJson(\n            \"/search\",\n            params={\"keywords\": query},\n            debug=debug,\n            refresh=refresh,\n        )\n        return search_result_json\n    @suppressException(defaultReturn=[])\n    def getSimilarMusicByIdFromNetease(\n        self, music_id: int, debug: bool = False, refresh: bool = False\n    ):\n        r_json = self.requestWithParamsGetJson(\n            \"/simi/song\", params={\"id\": music_id}, debug=debug, refresh=refresh\n        )\n        song_ids = []\n        for song in r_json[\"songs\"]:\n            name = song[\"name\"]\n            song_id = song[\"id\"]\n            song_ids.append(song_id)\n            # what you want?\n        return song_ids\n    @suppressException()\n    def getMusicUrlFromNetease(\n        self, music_id: int, debug: bool = False, refresh: bool = False\n    ):\n        r_json = self.requestWithParamsGetJson(\n            \"/song/url\", params={\"id\": music_id}, debug=debug, refresh=refresh"
        },
        {
            "comment": "The code defines two functions: `checkMusicFromNetEase` and `getMusicLyricFromNetease`. The first function checks if a music URL exists by sending a GET request to the \"check/music\" endpoint with the given music ID. It returns True if the response is successful. The second function retrieves the lyrics of the specified music ID from the \"/lyric\" endpoint and raises exceptions for errors. Both functions use the `requestWithParamsGetJson` method, which sends a GET request to an endpoint, receives JSON data, and handles success codes or exceptions based on parameters provided.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/musictoolbox.py\":505-539",
            "content": "        )  # this song might expire. warning!\n        # expire in a few seconds.\n        url = r_json[\"data\"][0].get(\"url\", None)\n        return url  # you may test this url. later.\n    @suppressException(defaultReturn=False)\n    def checkMusicFromNetEase(\n        self, music_id: int, debug: bool = False, refresh: bool = False\n    ):\n        # {\n        #   \"success\": true,\n        #   \"message\": \"ok\"\n        # }\n        # no need to check the return code.\n        r_json = self.requestWithParamsGetJson(\n            \"check/music\",\n            params={\"id\": music_id},\n            debug=debug,\n            refresh=refresh,\n            success_codes=[],\n        )\n        assert r_json[\"success\"] == True\n        assert r_json[\"message\"] == \"ok\"\n        return True\n    @suppressException()\n    def getMusicLyricFromNetease(\n        self,\n        music_id: int,\n        debug: bool = False,\n        refresh: bool = False,\n        minLyricStringLength: int = 50,\n    ):\n        r_json = self.requestWithParamsGetJson(\n            \"/lyric\","
        },
        {
            "comment": "This code defines a function that searches for music and its corresponding lyrics using keywords. It also includes error suppression and checks if the downloaded file is stored or not. The function takes in parameters such as keywords, similarity flag, debug mode, minimum and maximum audio lengths. It uses Pyjq to query the music data and extracts song IDs from the search results.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/musictoolbox.py\":540-566",
            "content": "            params={\"id\": music_id},\n            debug=debug,\n            refresh=refresh,\n        )\n        # warning: the fetched lrc could be not so clean. clean it somehow!\n        lyric_string = r_json[\"lrc\"][\"lyric\"]\n        if lyric_string != None and type(lyric_string) == str:\n            if len(lyric_string) > minLyricStringLength:\n                return lyric_string\n    @suppressException(tries=2, defaultReturn=((None, None), None))\n    def getMusicAndLyricWithKeywords(\n        self,\n        keywords: str,\n        similar: bool = False,\n        debug: bool = False,\n        min_audio_length: float = 2 * 60,\n        max_audio_length: float = 5 * 60\n    ):  # minimum 2.5 minutes of music.\n        import pyjq\n        # store the downloaded file in some place please?\n        search_data_json = self.searchNeteaseMusicByQuery(keywords, debug=debug)\n        # print(search_data_json)\n        song_ids = pyjq.all(\n            \".result.songs[] | select (.id !=null) | .id\", search_data_json\n        )  # incorrect. use pyjq.all"
        },
        {
            "comment": "This code randomly selects a song, if similar music is specified, it chooses one from the similar list. It then downloads the selected music and stores it temporarily for later use. The song duration is determined using a helper function.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/musictoolbox.py\":567-593",
            "content": "        # print(song_ids)\n        # breakpoint()\n        song_id = random.choice(song_ids)\n        # how to parse this shit?\n        if similar:\n            similar_song_ids = self.getSimilarMusicByIdFromNetease(song_id, debug=debug)\n            song_id = random.choice(similar_song_ids)\n        # now download the music.\n        music_url = self.getMusicUrlFromNetease(song_id, debug=debug, refresh=True)\n        # download the music right now.\n        r = requests.get(music_url)\n        if debug:\n            print(\"download music status code:\", r.status_code)\n        assert r.status_code == 200  # are you sure the code is ok?\n        music_format = music_url.split(\".\")[-1]\n        music_content = r.content\n        # how to get song duration?\n        import tempfile\n        with tempfile.NamedTemporaryFile(\n            mode=\"wb\", suffix=\".{}\".format(music_format)\n        ) as f:\n            name = f.name\n            name = os.path.abspath(name)\n            f.write(music_content)\n            song_duration = getAudioDuration(name)"
        },
        {
            "comment": "This code checks the song duration against specified minimum and maximum audio lengths, raises exceptions if necessary, retrieves lyrics from Netease using getMusicLyricFromNetease method, prints or logs the lyric string if in debug mode, checks if the lyric string is a non-empty string, cleans the LRC from web by calling cleanLrcFromWeb function and passing song duration as argument, and returns music content, format, and cleaned lyrics.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/musictoolbox.py\":594-610",
            "content": "        if song_duration < min_audio_length:\n            raise Exception(\"audio too short, total {} seconds\".format(song_duration))\n        elif song_duration > max_audio_length:\n            raise Exception(\"audio too long, total {} seconds\".format(song_duration))\n        lyric_string = self.getMusicLyricFromNetease(song_id)\n        if debug:\n            print(\"LYRICS:\", lyric_string)\n        if type(lyric_string) ==str and lyric_string.strip() !=\"\":\n            from pyjom.lyrictoolbox import (\n                cleanLrcFromWeb,\n            )  # cleaning needs song duration.\n            lyric_string = cleanLrcFromWeb(lyric_string, song_duration)\n        return (music_content, music_format), lyric_string\n############ SEARCH NETEASE MUSIC, GET SIMILAR MUSIC BY ID, DOWNLOAD MUSIC AND LYRICS ############"
        }
    ]
}