{
    "summary": "This code detects audio duration and volume using audioread library, adjusts media file volume with ffmpeg, normalizes audio, and handles errors.",
    "details": [
        {
            "comment": "This code retrieves the audio duration and volume average from an input media file using the audioread library. The getAudioDuration function returns the total duration in seconds, while the detect_volume_average function processes the media path to obtain the volume average. However, it may encounter exceptions if the audio track is not available or the track cannot be captured properly.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/audiotoolbox.py\":0-31",
            "content": "# first and foremost is the audio correction, the volume detector, the audio detector.\n# https://trac.ffmpeg.org/wiki/AudioVolume\n# but first how to get the audio duration?\n# for video we have caer. but for audio?\nimport audioread\nfrom lazero.utils.logger import sprint\nimport ffmpeg\nfrom typing import Literal\nfrom pyjom.commons import *\nimport parse\ndef getAudioBitrate(mediaPath):\n    return int(getMediaBitrate(mediaPath, audioOnly=True)[\"streams\"][0][\"bit_rate\"])\ndef getAudioDuration(audioFilePath):\n    with audioread.audio_open(audioFilePath) as f:\n        totalSeconds = f.duration\n    return totalSeconds  # is this float number or integer?\n    # how about let's test this?\ndef detect_volume_average(mediapath, debug=False):\n    # ffmpeg -i input.wav -filter:a volumedetect -f null /dev/null\n    # audio = ffmpeg.input(mediapath)\n    audio = ffmpeg.input(mediapath).audio\n    # does not have audio track, so error occurs.\n    # don't know how to capture the track. anyway, do put the audio into the test video.\n    # might have exception. what to do with it then??"
        },
        {
            "comment": "This code attempts to detect the volume of audio files and stores the volume details in a dictionary. It uses the \"volumedetect\" filter, redirects output to \"/dev/null\", captures both stdout and stderr, and parses the error output for volume information. If there's no audio in the media container, it will show an error message. Debug mode prints the media path and volume dictionary if set.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/audiotoolbox.py\":32-60",
            "content": "    volDict = {}\n    error = False\n    try:\n        stdout, stderr = (\n            audio.filter(\"volumedetect\")\n            .output(\"/dev/null\", f=\"null\")\n            .run(capture_stdout=True, capture_stderr=True)\n        )\n        # where is the output?\n        stderr = stderr.decode(\"utf-8\")\n        stderr_lines = stderr.split(\"\\n\")\n        formatString = \"[Parsed_volumedetect{}] {volumeType}_volume: {value:g} dB\"\n        for line in stderr_lines:\n            line = line.strip()\n            result = parse.parse(formatString, line)\n            if result is not None:\n                volumeType, value = result[\"volumeType\"], result[\"value\"]\n                volDict.update({volumeType: value})\n    except:\n        import traceback\n        traceback.print_exc()\n        # print(stderr)\n        # nothing will be shown in stderr, if there is no audio in the media container.\n        print(\"error when detecting volume for: %s\" % mediapath)\n        error = True\n    if debug:\n        print(\"MEDIA PATH: %s\" % mediapath)\n        print(\"VOLUME:\", volDict)"
        },
        {
            "comment": "The function adjusts the volume of media files located at a specific path. It accepts parameters for output file path, target volume levels (mean and max), overwrite option, bitrate, and algorithm type. It uses ffmpeg-normalize command line tool to normalize the audio, and returns a dictionary containing mean and max volume values upon successful execution. If an error occurs, it returns the error status as well.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/audiotoolbox.py\":61-96",
            "content": "        sprint(\"ERROR STATUS:\", error)\n    return volDict, error\ndef adjustVolumeInMedia(\n    mediaPath,\n    outputPath,\n    targets={\n        \"mean\": -10.8,  # -13.2 fuck.\n        \"max\": 0.0,\n    },  # what is the real value anyway? we want the volume fetched from web.\n    overwrite_output=False,\n    bitrate=320000,\n    algorithm: Literal[\"rms\", \"ebu\", \"peak\"] = \"rms\",\n):  # must set target volume.\n    # use ffmpeg-normalize?\n    # use aac for mp4 output. let's do it!\n    target_level = targets.get(\"mean\", None)\n    true_peak = targets.get(\"max\", None)\n    commandline = [\n        \"ffmpeg-normalize\",\n        \"-o\",\n        outputPath,\n        \"-pr\",\n        \"-nt\",\n        algorithm,\n    ]\n    commandline += [\"-b:a\", str(bitrate)]  # the bitrate part.\n    # now much better. let's see if we have other methods.\n    # VOLUME NORMALIZATION SUCCESSFUL\n    # MEDIA PATH: normalized.mp4\n    # VOLUME: {'mean': -11.0, 'max': 0.0}\n    # ERROR STATUS: False\n    # commandline = [\"ffmpeg-normalize\", \"-o\", outputPath, \"-pr\"]\n    # VOLUME: {'mean': -13.2, 'max': 0.0}"
        },
        {
            "comment": "This code is normalizing the volume of a video file and correcting its container type if necessary. It checks the input and output extensions, sets the video and audio codecs, handles target level, true peak, and overwrite settings, and runs subprocess command to execute FFmpeg for processing. The script prints \"VOLUME NORMALIZATION SUCCESSFUL\" if returncode is 0, indicating successful volume normalization.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/audiotoolbox.py\":97-121",
            "content": "    # the 'mean' is still not correctified.\n    # ERROR STATUS: False\n    # video codec we use 'copy' if the extension name is the same.\n    outputPathExtension = outputPath.lower().split(\".\")[-1]\n    mediaPathExtension = mediaPath.lower().split(\".\")[-1]\n    outputMediaType = determineMediaTypeByExtension(outputPathExtension)\n    # treat this as a common repository.\n    if outputPathExtension == mediaPathExtension and outputMediaType == \"video\":\n        commandline += [\"-c:v\", \"copy\"]\n    # problem is, the container must be video compabible.\n    # list the thing here?\n    if outputPathExtension == \"mp4\":\n        commandline += [\"-c:a\", \"aac\"]\n    if target_level:\n        commandline += [\"-t\", str(target_level)]\n    if true_peak:\n        commandline += [\"-tp\", str(true_peak)]\n    if overwrite_output:\n        commandline += [\"-f\"]\n    commandline += [mediaPath]\n    status = subprocess.run(commandline)  # is it even successful?\n    returncode = status.returncode\n    try:\n        assert returncode == 0\n        print(\"VOLUME NORMALIZATION SUCCESSFUL\")"
        },
        {
            "comment": "This code snippet is responsible for normalizing audio for a given media file. If an error occurs during the process, it prints the error message and stack trace using the traceback module.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/audiotoolbox.py\":122-131",
            "content": "        return outputPath\n    except:\n        import traceback\n        traceback.print_exc()\n        print(\"error when normalizing audio for media: %s\" % mediaPath)\n    # media = ffmpeg.input(videoPath)\n    # audio = media.audio\n    # video = media.video\n    # audio = audio.filter()"
        }
    ]
}