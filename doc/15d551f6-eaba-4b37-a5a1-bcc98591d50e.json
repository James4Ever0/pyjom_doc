{
    "summary": "This code creates a media downloader GUI with library integration, progress updates, customizable appearance, and tabular post topics. It uses decorator function `keywordDecorator` to censor media based on input parameters and handles unknown content types with exceptions.",
    "details": [
        {
            "comment": "This code snippet is for a media downloader function that uses the requests library to download a file from a given URL. It also includes functionality for handling progress updates using the progressbar module, and it creates a folder to store the downloaded files if one does not already exist. The function takes in parameters such as the URL of the file to be downloaded, an optional mblog ID (and index) for creating a unique file name based on this ID, and an optional base directory where the files will be stored. If no base directory is provided, it will create one automatically with the specified name. The function determines the file's suffix by parsing the URL and extracting the last part of the string after any query parameters. Once the download starts, it tracks progress using a widget that displays a bar indicating the percentage completed, along with other information like the current file transfer speed. It also calculates and displays the size of the file in MB as it downloads.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/modules/contentCensoring/core.py\":0-31",
            "content": "from tkinter import *\nfrom pyjom.commons import *\nfrom pyjom.modules.contentCensoring.autoCensor import *\n# import tkinter.font\nimport requests\nimport traceback\nimport os\nimport command_spawner\nfrom progressbar import *\n# add progressbar\ndef mediaDownloader(url, mblogid, basedir=None, index=None):\n    try:\n        with requests.get(url) as r: # what is the media file suffix?\n            suffix = url.split(\"?\")[0].split(\".\")[-1]\n            mid = mblogid if index is None else \"{}[{}]\".format(mblogid, index)\n            fname = \"{}.{}\".format(mid, suffix)\n            if not os.path.exists(basedir):\n                os.mkdir(basedir)\n            fpath = os.path.join(basedir, fname)\n            size = int(r.headers[\"Content-Length\"].strip())\n            mbytes = 0\n            widgets = [\n                fpath,\n                \": \",\n                Bar(marker=\"|\", left=\"[\", right=\" \"),\n                Percentage(),\n                \" \",\n                FileTransferSpeed(),\n                \"] \",\n                \" of {0}MB\".format(str(round(size / 1024 / 1024, 2))[:4]),"
        },
        {
            "comment": "The code downloads media content from a URL and saves it to the specified file path. It also includes error handling using try-except block and traceback. The function censorInterface seems to be an interface for switching between tags, where the user can toggle the visibility of different tags on or off.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/modules/contentCensoring/core.py\":32-64",
            "content": "            ]\n            pbar = ProgressBar(widgets=widgets, maxval=size).start()\n            mfile = []\n            for buf in r.iter_content(1024):\n                if buf:\n                    mfile.append(buf)\n                    mbytes += len(buf)\n                    pbar.update(mbytes)\n            pbar.finish()\n            print(\"saved to {}\".format(fpath))\n            with open(fpath, \"wb\") as f:\n                for byteContent in mfile:\n                    f.write(byteContent)\n            return fpath\n    except:\n        traceback.print_exc()\n        print(\"error in mediaDownloader:\\n\", url)\n    return None\nx_buffer = None\ntag_x_offset =None\ntag_y_counter =None\ndef censorInterface(\n    mtitle, mtopic, mcontent,mtags=[], local=False\n):  # this could be a standard template.\n    global x_buffer,tag_x_offset,tag_y_counter\n    assert type(mtopic) == list\n    assert type(mtags) == list\n    is_on = {key:False for key in mtags}\n    def switch(key, buttons, index, is_on):\n        button = buttons[index]\n        if is_on[key]:"
        },
        {
            "comment": "This code sets up a window with buttons, configures their appearance and state based on the given 'is_on' variable, and provides functions for handling button clicks. It also handles window geometry and theme customization.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/modules/contentCensoring/core.py\":65-97",
            "content": "            button.config(text=key ,bg = \"grey\",fg=\"black\")\n            is_on[key] = False\n        else:\n            button.config(text = key,bg = \"green\",fg=\"white\")\n            is_on[key] = True\n    def getSwitchLambda(text, on_buttons, index, is_on):\n        return lambda:switch(text, on_buttons, index, is_on)\n    on_buttons = []\n    mfunctions = []\n    mdata = {\"labels\": [], \"comment\": None, \"discard\": False}\n    left, top = 1500, 500\n    parent = Tk()\n    parent.geometry(\"+{}+{}\".format(left, top))\n    # parent\n    default_window_size =(460,400)\n    parent.geometry(\"{0}x{1}\".format(*default_window_size))\n    themepath = joinScriptFileBaseDir(__file__, \"Forest-ttk-theme/forest-dark.tcl\")\n    parent.tk.call(\"source\", themepath)\n    parent.attributes(\"-topmost\", True)\n    if not local:\n        title = Label(\n            parent,\n            text=\"Title:\" + \"\\n\" * 4,\n            fg=\"white\",\n        )\n        title.grid(row=0, column=0, sticky=\"e\")\n        text0 = Text(fg=\"aqua\", height=5, width=24)\n        text0.grid(row=0, column=1)"
        },
        {
            "comment": "This code snippet creates a GUI for displaying post topics and content in a tabular format. It includes labels, text boxes, and a red button. The code handles the case where a topic is given or not, and adjusts the positioning accordingly. The variable \"conrow\" keeps track of the row position for the red button. Variables like \"x_buffer\", \"tag_x_offset\", and \"tag_y_counter\" are used for positioning elements on the screen.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/modules/contentCensoring/core.py\":98-133",
            "content": "        text0.insert(END, mtitle)\n        # print(mtopic)\n        mlabel = (  # not designed for sina topic format.\n            \"None\" if mtopic == None else \" \".join([\"[{}]\".format(x) for x in mtopic])\n        )\n        label = Label(\n            parent,\n            text=\"Topics:\" + \"\\n\" * 4,\n            fg=\"aqua\",\n        )\n        label.grid(row=1, column=0, sticky=\"e\")\n        text1 = Text(fg=\"aqua\", height=5, width=24)\n        text1.grid(row=1, column=1)\n        text1.insert(END, mlabel)\n        content = Label(\n            parent,\n            text=\"Content:\" + \"\\n\" * 4,\n            fg=\"white\",\n        )\n        content.grid(row=2, column=0, sticky=\"e\")\n        text2 = Text(fg=\"aqua\", height=5, width=24)\n        text2.grid(row=2, column=1)\n        text2.insert(END, mcontent)\n        conrow = 3\n    else:\n        conrow = 0\n    redbutton = Entry(parent, fg=\"red\")\n    redbutton.grid(row=0 + conrow, column=1, sticky=\"ew\")\n    # button_height = 32 # default height?\n    x_buffer = 10\n    tag_x_offset = 0\n    tag_y_counter = 0"
        },
        {
            "comment": "This code defines a function `placeTagButtons` which creates buttons with specified text and positions them in a window, adjusting the position based on available space. The button color depends on its 'on' parameter, and it stores the button and associated command for later use.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/modules/contentCensoring/core.py\":134-157",
            "content": "    # print(\"TEXT:\", text)\n    def placeTagButtons(index, text,tag_x_offset, tag_y_counter, x_buffer, on=False):\n        # global\n        if not on:\n            mButton = Button(parent, text=text, bd = 0,bg=\"grey\",fg=\"black\")\n        else:\n            mButton = Button(parent, text=text, bd = 0,bg=\"green\",fg=\"white\")\n        button_width = mButton.winfo_reqwidth()\n        # 65\n        button_height = mButton.winfo_reqheight()\n        # print(button_width, button_height)\n        # breakpoint()\n        on_buttons.append(mButton)\n        mfunctions.append(getSwitchLambda(text, on_buttons, index, is_on))\n        on_buttons[index].config(command=mfunctions[index])\n        # on_buttons[index].grid_forget()\n        estimate_x_size = tag_x_offset+x_buffer+button_width\n        estimated_y_size = default_window_size[1]+ button_width*1.3*(tag_y_counter+1)\n        if estimate_x_size > default_window_size[0]:\n            tag_x_offset = 0\n            tag_y_counter+=1\n            # change window geometry\n            parent"
        },
        {
            "comment": "The code is setting the window geometry and placing button elements on the screen based on certain conditions. It calculates the dimensions and positions of buttons to fit within the available window space, while keeping track of the x-offset and y-counter for future button placement. The code also includes a function called \"add_tag\" that takes user input and checks if it's not empty before making further actions.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/modules/contentCensoring/core.py\":157-175",
            "content": ".geometry(\"{0}x{1}\".format(default_window_size[0], int(default_window_size[1]+ button_height*0.1+(tag_y_counter+1)*button_height*1.2)))\n        elif estimated_y_size > default_window_size[1]:\n            parent.geometry(\"{0}x{1}\".format(default_window_size[0], int(default_window_size[1]+ button_height*0.1+(tag_y_counter+1)*button_height*1.2)))\n        on_buttons[index].place(x=tag_x_offset+x_buffer, y=default_window_size[1]+ button_height*0.1+tag_y_counter*button_height*1.2)\n        tag_x_offset+= button_width\n        return tag_x_offset,tag_y_counter\n        # print(dir(mButton))\n    for index, text in enumerate(is_on.keys()):\n        tag_x_offset,tag_y_counter = placeTagButtons(index, text, tag_x_offset,tag_y_counter, x_buffer)\n        # 32\n        # breakpoint()\n    def add_tag():\n        global tag_x_offset, tag_y_counter, x_buffer\n        mtext = redbutton.get()\n        mtext = mtext.strip()\n        if mtext != \"\": # that is the base line\n            redbutton.delete(0, END)\n            # change this shit."
        },
        {
            "comment": "This code creates a GUI window for adding tags and comments to content. It enables any previously unused tag, places tag buttons, adds an \"ADD TAG\" button, sets up a comment input field with a \"SUBMIT\" button, and defines functions for adding tags and comments and closing the window.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/modules/contentCensoring/core.py\":176-205",
            "content": "            # mdata[\"labels\"].append(mtext)\n            if mtext not in is_on.keys():\n                is_on.update({mtext:True}) # enable this tag anyway.\n                # and we do some append task here.\n                tag_x_offset, tag_y_counter=placeTagButtons(len(on_buttons), mtext,tag_x_offset, tag_y_counter, x_buffer, on=True)\n    bluebutton = Button(parent, text=\"ADD TAG\", fg=\"aqua\", command=add_tag)\n    bluebutton.grid(row=0 + conrow, column=0, sticky=\"e\")\n    redbutton3 = Label(parent, text=\"Comment:\", fg=\"red\")\n    redbutton3.grid(row=1 + conrow, column=0, sticky=\"e\")\n    redbutton2 = Entry(parent, fg=\"red\")\n    def add_comment():\n        comment = redbutton2.get()\n        if comment != \"\":\n            mdata[\"comment\"] = comment\n    redbutton2.grid(row=1 + conrow, column=1, sticky=\"ew\")\n    def mdestroy():\n        add_tag()\n        add_comment()\n        parent.destroy()\n    def mdestroy2():\n        mdata[\"discard\"] = True\n        parent.destroy()\n    blackbutton = Button(parent, text=\"SUBMIT\", fg=\"red\", command=mdestroy)"
        },
        {
            "comment": "This code includes functions for playing media, core media censoring functionality, and interacting with a GUI. It spawns a command to play media in the background, binds keyboard events, and updates labels' order when a key is released.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/modules/contentCensoring/core.py\":206-233",
            "content": "    blackbutton.grid(row=1 + conrow, column=2, sticky=\"e\")\n    blackbutton2 = Button(parent, text=\"KILL\", fg=\"yellow\", command=mdestroy2)\n    blackbutton2.grid(row=0 + conrow, column=2, sticky=\"ew\")\n    parent.bind(\"<Return>\", lambda event=None: bluebutton.invoke())\n    parent.bind(\"<Control-Return>\", lambda event=None: mdestroy())\n    # this is for updating the order of tags.\n    parent.bind(\"<KeyRelease>\", lambda event=None: print(\"KEY RELEASED! PLEASE CONSIDER TO BIND THIS EVENT TO UPDATING TAGS ORDER BY INPUT\"))\n    # this is for updating the order of tags.\n    parent.mainloop()\n    mdata[\"labels\"] = [x for x in is_on.keys() if is_on[x]]\n    mdata[\"total_labels\"] = [x for x in is_on.keys()]\n    return mdata\ndef playMedia(mediaPath):\n    cmdline = \"ffplay -alwaysontop -loop 0 -top 0 -left 0 {}\".format(mediaPath)\n    cs = command_spawner.CommandSpawner(command=cmdline, daemon=True)\n    cs.run()\n    return cs\ndef coreMediaCensor(\n    mediaPath,\n    meta,\n    play=True,\n    auto=False,\n    semiauto=True,\n    local=False,"
        },
        {
            "comment": "This code uses a decorator function, `keywordDecorator`, to apply different censoring methods based on the input parameters. If `auto` is False or `semiauto` is True and `play` is True, it calls `playMedia` and applies censoring using the `censor_method`. If `auto` is True, it only generates tags and metadata without approving the content. It also kills any running ffplay instances after playback if necessary.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/modules/contentCensoring/core.py\":234-268",
            "content": "    dummy_auto=True,\n    args={},\n    template_names=[],\n):\n    assert type(local) == bool\n    mtitle, mtopic, mcontent = meta\n    censor_method = (\n        keywordDecorator(autoCensor, args=args, template_names=template_names)\n        if not dummy_auto\n        else dummyAutoCensor\n    )\n    if ((not auto) or semiauto) and play:\n        cs = playMedia(mediaPath)  # siderun.\n        if not auto:\n            mdata = censorInterface(mtitle, mtopic, mcontent, local=local)\n        else:\n            nextData = censor_method(\n                mediaPath, meta, semiauto=semiauto\n            )  # this will not approve the thing. only generate tags and metadata.\n            mdata = censorInterface(mtitle, mtopic, mcontent, local=True)\n            mdata.update(nextData)\n    else:\n        mdata = censor_method(mediaPath, meta, semiauto=semiauto)\n    if ((not auto) or semiauto) and play:\n        cs.kill()\n        os.system(\"killall ffplay\")\n    return mdata\n@decorator\ndef weiboCensor(\n    content,\n    basedir=None,\n    auto=False,\n    semiauto=True,"
        },
        {
            "comment": "This code is creating a dictionary called \"groupArgs\" that holds various parameters. It then checks if the \"auto\" parameter is False or if \"semiauto\" is set, in which case it kills a process named \"ffplay\". Next, it sets the data type to \"text\" and initializes variables for title, topic, and content. If there's a video available, it updates the data type to \"video\", downloads the video, and calls a function \"coreMediaCensor\" with additional parameters. Finally, if there is a picture available but no video, it continues execution.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/modules/contentCensoring/core.py\":269-298",
            "content": "    dummy_auto=True,\n    args={},\n    template_names=[],\n):\n    groupArgs = {\n        \"template_names\": template_names,\n        \"auto\": auto,\n        \"semiauto\": semiauto,\n        \"dummy_auto\": dummy_auto,\n        \"args\": args,\n    }\n    if (not auto) or semiauto:\n        os.system(\"killall ffplay\")\n    # we only need video.\n    data = {\"type\": \"text\", \"review\": None}\n    mtitle = content[\"title\"]\n    mtopic = (\n        None if content[\"topic\"] is None else [x[0] for x in content[\"topic\"]]\n    )  # excerpt the topic name only\n    mcontent = content[\"text\"][\"raw\"]\n    meta = (mtitle, mtopic, mcontent)\n    if content[\"video\"] is not None:\n        data[\"type\"] = \"video\"\n        videoUrl = content[\"video\"][\"download_link\"]\n        mblogid = content[\"meta\"][\"mblogid\"]\n        videoPath = mediaDownloader(videoUrl, mblogid, basedir=basedir)\n        mdata = coreMediaCensor(videoPath, meta, **groupArgs)\n        data[\"review\"] = (videoPath, mdata)\n        # return mdata\n    elif content[\"picture\"] is not None and content[\"picture\"] is not []:"
        },
        {
            "comment": "The code checks if the content is a picture and downloads it using mediaDownloader function. Then, it censors the picture using coreMediaCensor function and adds the path and censoring data to the review list. If the content is not a picture, it directly censors the content without displaying raw content using coreMediaCensor function with appropriate arguments. Finally, it returns the censored content as 'data'.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/modules/contentCensoring/core.py\":299-331",
            "content": "        data[\"type\"] = \"picture\"\n        data[\"review\"] = []\n        for index, pictureUrl in enumerate(content[\"picture\"]):\n            picturePath = mediaDownloader(\n                pictureUrl, mblogid, basedir=basedir, index=index\n            )\n            mdata = coreMediaCensor(picturePath, meta, **groupArgs)\n            data[\"review\"].append((picturePath, mdata))\n    else:\n        # just display the raw content.\n        mdata = coreMediaCensor(\n            None, meta, play=False, **groupArgs\n        )  # how to automate this shit?\n        data[\"review\"] = mdata\n    return data\n@decorator\ndef localCensor(\n    content, auto=False, semiauto=True, dummy_auto=True, args={}, template_names=[]\n):\n    # examine local files.\n    # first determine the content type.\n    groupArgs = {\n        \"auto\": auto,\n        \"semiauto\": semiauto,\n        \"dummy_auto\": dummy_auto,\n        \"template_names\": template_names,\n        \"args\": args,\n    }\n    if (not auto) or semiauto:\n        os.system(\"killall ffplay\")\n    # you may play the media as well."
        },
        {
            "comment": "This code checks the content type, if it's an image or video, then it censor the media using `coreMediaCensor` function and returns the data. If the content type is unknown, it raises an exception.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/modules/contentCensoring/core.py\":332-343",
            "content": "    data = {\"type\": None, \"review\": None}\n    mediaTypes = [\"image\", \"video\"]\n    # mediaTypes = [\"picture\", \"video\"]\n    if content[\"type\"] in mediaTypes:\n        data[\"type\"] = content[\"type\"]\n        mediaPath = content[\"path\"]\n        mdata = coreMediaCensor(mediaPath, (None, None, None), local=True, **groupArgs)\n        # review as video.\n        data[\"review\"] = (mediaPath, mdata)\n    else:\n        raise Exception(\"Unknown Content Type: {}\\n{}\".format(content[\"type\"], content))\n    return data"
        }
    ]
}