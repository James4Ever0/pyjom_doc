{
    "summary": "This code initializes a FastAPI app for translation and recognition with PaddleHub models, handles proxies, and creates API endpoints with error handling and caching. It returns a dictionary containing the result or a 400 status code.",
    "details": [
        {
            "comment": "The code is importing necessary packages, fixing cv2 library path, setting a clash HTTP port, defining a function to use or unset proxies, and initializing FastAPI application along with two PaddleHub models for language translation and recognition.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tests/karaoke_effects/fastapi_translator.py\":0-40",
            "content": "import os\n# before that, we need to fix cv2\nimport pathlib\nimport sys\nfrom isort import stream\nsite_path = pathlib.Path(\"/usr/local/lib/python3.9/site-packages\")\ncv2_libs_dir = (\n    site_path / \"cv2\" / f\"python-{sys.version_info.major}.{sys.version_info.minor}\"\n)\nprint(cv2_libs_dir)\ncv2_libs = sorted(cv2_libs_dir.glob(\"*.so\"))\nif len(cv2_libs) == 1:\n    print(\"INSERTING:\", cv2_libs[0].parent)\n    sys.path.insert(1, str(cv2_libs[0].parent))\nclash_http_port = 8381\n# wtf is wrong with this shit?\ndef useProxy(flag):\n    if flag:\n        os.environ[\"http_proxy\"] = \"http://127.0.0.1:{}\".format(clash_http_port)\n        os.environ[\"https_proxy\"] = \"http://127.0.0.1:{}\".format(clash_http_port)\n    else:\n        os.environ[\"http_proxy\"] = \"\"\n        os.environ[\"https_proxy\"] = \"\"\nfrom fastapi import FastAPI\napp = FastAPI()\n# import time\n# you want to wait? or you want to swap?\nimport paddlehub as hub\nlanguage_translation_model = hub.Module(name=\"baidu_translate\")\nlanguage_recognition_model = hub.Module(name=\"baidu_language_recognition\")"
        },
        {
            "comment": "This code defines two translation functions, `baiduTranslator` and `deeplTranslator`, which use the Baidu and DeepL APIs respectively. The `baiduTranslator` function requires the target language to be in Chinese. It uses a file lock for synchronization, performs language recognition and translation, and handles any exceptions that may occur during translation. The `deeplTranslator` function also performs translation using the DeepL API but with additional options for sleep time, timeout, and modification mode. Both functions return translated text or None if an error occurs.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tests/karaoke_effects/fastapi_translator.py\":43-82",
            "content": "def baiduTranslator(text, sleep=1):  # target language must be chinese.\n    useProxy(False)\n    import filelock\n    lock = filelock.FileLock(\n        \"/root/Desktop/works/pyjom/tests/karaoke_effects/baidu_translator.lock\"\n    )\n    with lock:\n        import time\n        time.sleep(sleep)\n        try:\n            language_code = language_recognition_model.recognize(text)\n            if language_code != \"zh\":\n                text_prompts = language_translation_model.translate(\n                    text, language_code, \"zh\"\n                )\n                translatedText = text_prompts\n            else:\n                translatedText = text\n            return translatedText\n        except:\n            import traceback\n            traceback.print_exc()\n            print(\"ERROR ON BAIDU TRANSLATOR\")\n            return None\nfrom lazero.network.proxy.clash import (\n    getTestedProxyList,\n    setProxyWithSelector,\n    clashProxyStateManager,\n)\nproxyList = []\nrefreshProxyCounter = 0\ndef deeplTranslator(text, sleep=2, timeout=5, mod=40):"
        },
        {
            "comment": "Sets a random proxy from the list or skips proxy usage. Updates the proxy list and counter modulo. Uses a file lock for access control. Makes a POST request to a local DeepL translator service using the selected proxy, if any.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tests/karaoke_effects/fastapi_translator.py\":83-110",
            "content": "    global proxyList, refreshProxyCounter\n    useProxy(False)\n    import random\n    if (\n        refreshProxyCounter % mod == 0\n    ):  # make sure it will be launched at the first request.\n        proxyList = getTestedProxyList()\n        refreshProxyCounter %= mod\n    refreshProxyCounter += 1\n    proxyName = random.choice([proxy[\"name\"] for proxy in proxyList] + [\"DIRECT\"])\n    setProxyWithSelector(proxyName)\n    # better use proxy instead. you need to config it here, and make sure the deepl adaptor uses the proxy.\n    import requests\n    import time\n    import filelock\n    lock = filelock.FileLock(\n        \"/root/Desktop/works/pyjom/tests/karaoke_effects/deepl_translator.lock\"\n    )\n    with clashProxyStateManager(\"Global\", \"Rule\"):\n        with lock:\n            time.sleep(sleep)\n            port = 8281\n            # env ROCKET_PORT=8281 ./executable_deepl\n            url = \"http://127.0.0.1:{}/translate\".format(port)\n            data = {\"text\": text, \"source_lang\": \"auto\", \"target_lang\": \"ZH\"}\n            r = requests.post(url, json=data, timeout=timeout)"
        },
        {
            "comment": "The code snippet is responsible for making requests to a Deepl API and handling the response. If the response has a 200 status code, the translated text is returned; otherwise, it prints an error message and checks the working proxies. The workingProxies set stores valid proxies for making requests, and functions checkWorkingProxies() and changeProxy() manage proxy usage.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tests/karaoke_effects/fastapi_translator.py\":111-147",
            "content": "            response = r.json()\n            code = response[\"code\"]\n            if code == 200:\n                translatedText = response[\"data\"]\n                return translatedText\n            else:\n                print(\"DEEPL RESPONSE ERROR. PLEASE CHECK\")\n                print(response)\n                proxyList = getTestedProxyList()\n                refreshProxyCounter = 1\n                # breakpoint()\n                return None\n# use suggest mechanism\nworkingProxies = set()\ndef checkWorkingProxies():\n    global workingProxies\n    useProxy(False)\n    url = \"http://127.0.0.1:8677/checkProxy\"\n    import requests\n    for proxy in list(workingProxies):\n        # proxy could be None.\n        # print([proxy])\n        # breakpoint()\n        r = requests.get(url, params={\"proxy\": proxy})\n        response = r.json()\n        if not response[\"exists\"]:\n            print(\"REMOVING PROXY %s NOW\" % useProxy)\n            workingProxies.remove(proxy)\ndef changeProxy(useDirect=False, suggestSingleElemProbability=0.1):\n    useProxy(False)"
        },
        {
            "comment": "This code checks if a working proxy is available, then randomly selects one to use or suggests a new one. It makes a request to the server to update the proxy and handles the response. If no proxy name is found in the response, it uses the previously suggested proxy. Finally, it updates the proxy and prints a success message.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tests/karaoke_effects/fastapi_translator.py\":148-180",
            "content": "    global workingProxies\n    checkWorkingProxies()\n    import requests\n    if useDirect:\n        path = \"useDirect\"\n    else:\n        path = \"refreshProxy\"\n    print(\"PATH\", path)\n    if path == \"refreshProxy\":\n        import random\n        prob = random.random() < len(workingProxies) * suggestSingleElemProbability\n        if prob:\n            suggestedProxy = random.choice(list(workingProxies))\n            params = {\"suggest\": suggestedProxy}\n            print(\"SUGGESGING PROXY:\", suggestedProxy)\n        else:\n            params = {}\n            # params = {\"suggest\": None}\n        r = requests.get(\"http://127.0.0.1:8677/{}\".format(path), params=params)\n    else:\n        r = requests.get(\"http://127.0.0.1:8677/{}\".format(path))\n    print(\"RESPONSE:\", r.text)\n    import parse\n    proxyName = parse.parse(\"refresh proxy to {text}\", r.text)\n    if proxyName == None:\n        # using suggested proxy here.\n        print(\"USING SUGGESTED PROXY\")\n    else:\n        proxyName = proxyName[\"text\"]\n    print(\"PROXY REFRESHED\")"
        },
        {
            "comment": "This code is a function that translates text using different backends (Baidu and DeepL) with the option to use a proxy. It uses a max number of tries for translation attempts, randomly selects a backend if previous attempts failed, and handles direct connections or proxies based on backend settings.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tests/karaoke_effects/fastapi_translator.py\":181-212",
            "content": "    return proxyName\ndef metaTranslator(text, backend=\"baidu\", max_tries: int = 3):\n    global workingProxies\n    backendList = [\"baidu\", \"deepl\"]\n    assert backend in backendList\n    # translator = None\n    import random\n    getUseDirect = lambda: False\n    backends = {\n        \"baidu\": (baiduTranslator, lambda: True),\n        # \"deepl\": (deeplTranslator, lambda: False), # use direct? no proxy?\n        \"deepl\": (\n            deeplTranslator,\n            lambda: True,\n        ),  # the proxy is used by deepl client, not here!\n    }\n    translator, getUseDirect = backends[backend]\n    proxyName = None\n    firstTime = True\n    for _ in range(max_tries):\n        try:\n            if not firstTime:  # after first 'failed' trial we will change the strategy.\n                key = random.choice(backendList)\n                translator, getUseDirect = backends[key]\n                proxyName = changeProxy(useDirect=getUseDirect())\n            else:\n                firstTime = False\n            result = translator(text)\n            if result:"
        },
        {
            "comment": "This code checks if a given proxy name is present in the working proxies list and performs actions accordingly. If there's an error during fetching translation, it prints an error message. The \"waitForServerUp\" function tests if a server at a specific port is up by sending requests and checking its response.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tests/karaoke_effects/fastapi_translator.py\":213-244",
            "content": "                if proxyName:\n                    workingProxies.add(proxyName)\n                return result\n            else:\n                if proxyName in workingProxies:\n                    workingProxies.remove(proxyName)\n                print(\"SOME ERROR DURING FETCHING TRANSLATION\")\n        except:\n            import traceback\n            traceback.print_exc()\n            print(\"ERROR FETCHING TRANSLATION\")\n# def waitForServerUp(port, message, timeout=1):\n#     import requests\n#     while True:\n#         try:\n#             url = \"http://localhost:{}\".format(port)\n#             r = requests.get(url, timeout=timeout)\n#             text = r.text.strip('\"').strip(\"'\")\n#             print(\"SERVER AT PORT %d RESPONDS:\" % port, [text])\n#             assert text == message\n#             print(\"SERVER AT PORT %d IS UP\" % port)\n#             break\n#         except:\n#             import traceback\n#             traceback.print_exc()\n#             print(\"SERVER AT PORT %d MIGHT NOT BE UP\")\n#             print(\"EXPECTED MESSAGE:\", [message])"
        },
        {
            "comment": "The code defines two API endpoints: a root endpoint returning \"unified translator hooked on some clash server\" and a \"/translate\" endpoint accepting a \"backend\" parameter (\"deepl\" or \"baidu\") and text to be translated. It caches up to 100 translations in a global dictionary, deleting the least recently used if exceeding cache limit. If the backend is invalid, it returns status code 400 with message \"INVALID BACKEND\". If the input text length is less than 30 and already translated, it returns that translation from cache; otherwise, it uses `metaTranslator` function to translate the text, storing the result in cache if valid.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tests/karaoke_effects/fastapi_translator.py\":245-282",
            "content": "#             import time\n#             time.sleep(1)\n@app.get(\"/\")\ndef read_root():\n    # waitForServerUp(8677, \"clash update controller\")  # probe the clash updator\n    return \"unified translator hooked on some clash server\"\ntranslatedDict = {}\ntranslatedDictCacheLimit = 100\n@app.get(\"/translate\")\ndef read_item(backend: str, text: str):\n    global translatedDict\n    if len(list(translatedDict.keys())) > translatedDictCacheLimit:\n        mkeys = list(translatedDict.keys())\n        import random\n        random.shuffle(mkeys)\n        for key in mkeys[:translatedDictCacheLimit]:\n            del translatedDict[key]\n    code = 200\n    if not backend in [\"deepl\", \"baidu\"]:\n        code = 400\n        result = \"INVALID BACKEND\"\n    else:\n        if len(text) < 30 and text in translatedDict.keys():\n            result = translatedDict[text]\n        else:\n            result = metaTranslator(text, backend=backend)\n            if type(result) == str:\n                if len(result) < 30 and len(text) < 30:\n                    translatedDict.update({text: result})"
        },
        {
            "comment": "This code snippet returns a dictionary containing the \"code\" and \"result\" keys. If the \"result\" is not None, False, True, or an empty string, it will be included in the result dictionary; otherwise, the code will be 400.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tests/karaoke_effects/fastapi_translator.py\":283-286",
            "content": "    return {\n        \"code\": (code if result not in [None, False, True, \"\"] else 400),\n        \"result\": (result if type(result) == str and result != \"\" else None),\n    }"
        }
    ]
}