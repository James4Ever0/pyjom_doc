{
    "summary": "The code imports modules, uses APIs for censoring and translation, applies effects, renders customizable lyrics, formats ASS files, handles errors, and provides previewing and conversion functions using lyrictools and pylrc libraries.",
    "details": [
        {
            "comment": "The code imports various modules, sets proxy environment variables, and defines functions for removing Chinese punctuation, leading/trailing punctuation, and unnecessary punctuation. The \"getMusicDuration\" function uses MediaInfo to get the duration of a music file at a given path.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/lyrictoolbox.py\":0-46",
            "content": "import pylrc\nfrom MediaInfo import MediaInfo\nfrom pyonfx import *\nfrom typing import Literal\n# wildcard not allowed in function\nfrom pyjom.commons import redisLRUCache\n# change the lyric font and font size for hanzi and romaji\nimport os\nos.environ[\"http_proxy\"] = \"\"\nos.environ[\"https_proxy\"] = \"\"\nimport string\nimport zhon.hanzi\nenglishPuncturals = string.punctuation\nchinesePuncturals = zhon.hanzi.punctuation\ndef removeChinesePunctuation(text):\n    for elem in chinesePuncturals:\n        text = text.replace(elem, \"\")\n    return text\ndef removeLeadingAndTrailingPunctuation(text):\n    for elem in englishPuncturals + chinesePuncturals:\n        if text.startswith(elem):\n            text = text[1:]\n        if text.endswith(elem):\n            if elem == \".\":\n                continue\n            text = text[:-1]\n    return text\ndef removeUnnecessaryPunctuation(text):\n    text = removeChinesePunctuation(text)\n    text = removeLeadingAndTrailingPunctuation(text)\n    return text\ndef getMusicDuration(musicPath):\n    info = MediaInfo(filename=musicPath)  # the music path is not right."
        },
        {
            "comment": "This function reads an LRC file and extracts lyrics into a text array. It calculates music duration, parses the LRC string using pylrc library, defines lyric duration thresholds, and creates a sorted list of time-stamped lyrics. If consecutive lyrics are too close together, it combines them into one entry. The function could benefit from calculating the end times of each lyric segment.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/lyrictoolbox.py\":47-87",
            "content": "    info = info.getInfo()\n    # print(info)\n    # breakpoint()\n    length = info[\"duration\"]\n    length = float(length)\n    return length\ndef lrcToTextArray(musicPath, lrcPath):\n    assert lrcPath.endswith(\".lrc\")\n    musicDuration = getMusicDuration(musicPath)\n    with open(lrcPath) as lrc_file:\n        lrc_string = \"\".join(lrc_file.readlines())\n    # lrc_file.close()\n    subs = pylrc.parse(lrc_string)\n    lyricDurationThresholds = (0.3, 4)\n    textArray = []\n    for sub in subs:\n        startTime = sub.time\n        text = sub.text\n        textArray.append((startTime, text))\n    textArray.sort(key=lambda x: x[0])\n    lastStartTime = textArray[0][0]\n    newTextArray = [{\"start\": textArray[0][0], \"text\": textArray[0][1]}]\n    for startTime, text in textArray[1:]:\n        if startTime - lastStartTime < lyricDurationThresholds[0]:\n            continue\n        else:\n            lastStartTime = startTime\n            newTextArray.append({\"text\": text, \"start\": startTime})\n    # now calculate the end time, please?\n    # you may want to translate this if you have to."
        },
        {
            "comment": "This function iterates through an array of lyrics and calculates the duration of each lyric. If a lyric's duration falls within a specified range, its end time is updated accordingly. The function then returns the modified array with each element containing 'text', 'start', and 'end' information.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/lyrictoolbox.py\":88-118",
            "content": "    # when it does not contains anything in chinese.\n    # using deepl?\n    # put that aside please? focus on this shit...\n    import numpy as np\n    lyricDurations = [np.mean(lyricDurationThresholds)]\n    for index, elem in enumerate(newTextArray):\n        text = elem[\"text\"]\n        start = elem[\"start\"]\n        nextIndex = index + 1\n        if nextIndex < len(newTextArray):\n            nextElem = newTextArray[nextIndex]\n            nextStart = nextElem[\"start\"]\n            end = nextStart - start\n            if end > lyricDurationThresholds[0] and end < lyricDurationThresholds[1]:\n                lyricDurations.append(end)\n            end = min(end, lyricDurationThresholds[1], musicDuration - start) + start\n        else:\n            end = np.mean(lyricDurations) + start\n            end = min(musicDuration, end)\n        newTextArray[index].update({\"end\": end})\n    return newTextArray\n    # [{'text':text,'start':start,'end':end}, ...]\ndef lastSpaceSpliter(text):\n    text = text.strip()\n    # index = 0\n    for index in range(len(text) - 1, -1, -1):"
        },
        {
            "comment": "Function getJiebaCuttedText takes a text input and returns a list of words after cutting the text using jieba. The list contains only non-empty words with length greater than 0. This function is used to split the input text into individual words for further analysis.\n\nThe code snippet checks if a space character is found in the input text. If a space is found, it prints the index of the last space and returns a tuple containing the substrings before and after the last space, along with a boolean indicating that the input text is a lyric. If no space is found, it returns the original text and sets the boolean to False.\n\nThe function pyjniusLinguaDetectLanguageLabel sends a GET request to a local server (http://localhost:8978) with the input text as a parameter. It expects the server to return a JSON response containing language detection information. If the code of the response is 200, it implies a successful detection and the function returns the detected language label.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/lyrictoolbox.py\":119-149",
            "content": "        # print(index)\n        elem = text[index]\n        if elem == \" \":\n            print(\"LAST SPACE FOUND AT %d\", index)\n            # do it right now, and return the value here.\n            mTuple = (text[0:index].strip(), text[index:].strip())\n            return mTuple, True\n    return text, False  # not a list.\n# if there is a single shit failed to pass this 'lastSpaceSpliter' test, this is not a bilingual lrc file from netease.\ndef getJiebaCuttedText(text):\n    import jieba\n    textList = jieba.lcut(text)\n    textList = [elem.strip() for elem in textList]\n    textList = [elem for elem in textList if len(elem) > 0]\n    return textList\n# from loadLingua_pyjnius import pyjniusLinguaDetectLanguageLabel\n# from loadLingua_jpype import getLinguaDetectedLanguageLabel as pyjniusLinguaDetectLanguageLabel\ndef pyjniusLinguaDetectLanguageLabel(text):\n    import requests\n    url = \"http://localhost:{}/langid\".format(8978)\n    with requests.get(url, params={\"text\": text}) as r:\n        response = r.json()\n        if response[\"code\"] == 200:"
        },
        {
            "comment": "This code seems to check if a given text is bilingual or not. It does this by iterating through the test data, splitting each element into text and flag. If the sum of flags in the test is less than 80% of the total number of elements, it concludes that the lyrics are not bilingual. Otherwise, it processes the data separately to determine if it is truly bilingual.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/lyrictoolbox.py\":150-181",
            "content": "            return response[\"result\"]\n        else:\n            print(\"ERROR WHEN FETCHING LANGUAGE ID\")\n            print(response)\n            breakpoint()\nnativeLangFlagStandard = \"CHINESE\"\n# need to make this thing totally bilingual if we have to.\n# for test in tests:\ndef getLyricsLanguageType(test):\n    isBilingual = False\n    needToTranslate = True  # not useful for our bilingual shit.\n    print(\"_______________TEST SUBJECT_______________\")\n    for elem in test:\n        print(elem)\n    print(\"_______________TEST SUBJECT_______________\")\n    flags = [int(flag) for _, flag in [lastSpaceSpliter(elem) for elem in test]]\n    print(flags)\n    if sum(flags) < len(flags) * 0.8:\n        print(\"NOT A BILIGUAL LYRICS FILE\")\n    else:\n        # having the potential of being a bilingual shit.\n        # process this shit separately.\n        # double check if this is really bilingual.\n        foreignLangList = []\n        nativeLangList = []\n        for elem in test:\n            text, flag = lastSpaceSpliter(elem)\n            if flag:"
        },
        {
            "comment": "This code snippet is likely trying to determine the language of a given text. It attempts this by using different libraries such as whatlang, cld3, TextBlob and langid. The nativeLangFlagStandard is set to \"Cmn\" or \"zh\" for comparison with the detected languages from these libraries.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/lyrictoolbox.py\":182-206",
            "content": "                # this line might be bilingual.\n                foreignLang, nativeLang = text\n                foreignLangList.append(foreignLang)\n                nativeLangList.append(nativeLang)\n        foreignLangString = \" \".join(foreignLangList)\n        nativeLangString = \" \".join(nativeLangList)\n        # import whatlang\n        # nativeLangFlagStandard = \"Cmn\"\n        # foreignLangFlag = whatlang.detect_language(foreignLangString)\n        # nativeLangFlag = whatlang.detect_language(nativeLangString)\n        # import cld3\n        # nativeLangFlagStandard = \"zh\"\n        # foreignLangFlag = cld3.get_language(foreignLangString)\n        # nativeLangFlag = cld3.get_language(nativeLangString)\n        # from textblob import TextBlob\n        # nativeLangFlagStandard = \"zh\"\n        # foreignLangFlag = TextBlob(foreignLangString).detect_language()\n        # nativeLangFlag = TextBlob(nativeLangString).detect_language()\n        # import langid\n        # nativeLangFlagStandard = \"zh\"\n        # foreignLangFlag = langid.classify(foreignLangString)"
        },
        {
            "comment": "The code uses the pyjniusLinguaDetectLanguageLabel function to classify the foreign and native language strings of a lyric file. If the foreign language does not match the native language standard, it assumes the file is bilingual. It then prints whether it is a bilingual or non-bilingual lyrics file. If non-bilingual, it checks the main language using the same function.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/lyrictoolbox.py\":207-232",
            "content": "        # nativeLangFlag = langid.classify(nativeLangString)\n        foreignLangFlag = (pyjniusLinguaDetectLanguageLabel(foreignLangString), 1)\n        nativeLangFlag = (pyjniusLinguaDetectLanguageLabel(nativeLangString), 1)\n        # there's no probability out there! WTF?\n        print(foreignLangFlag)\n        print(nativeLangFlag)\n        # breakpoint()\n        if (\n            foreignLangFlag[0] != nativeLangFlagStandard\n            and nativeLangFlag[0] == nativeLangFlagStandard\n        ):\n            # this is for sure the bilingual shit.\n            isBilingual = True\n            print(\"BILINGUAL LYRIC FILE IDENTIFIED.\")\n            # then? how shall we judge this?\n            # let the jieba.lcut to handle the cutting. please?\n            # remove all blanks in the list.\n        else:\n            print(\"NOT A BILIGUAL LYRICS FILE\")\n    # what you are going to do with this shit?\n    if not isBilingual:\n        print(\"checking main language\")\n        lyricString = \" \".join(test)\n        mainLanguage = pyjniusLinguaDetectLanguageLabel(lyricString)"
        },
        {
            "comment": "The code defines a function `translate` which takes a text and an optional backend parameter. It checks if the text is empty, returns it as is if so. If not, it sends a GET request to a local server for translation using the specified backend (default is 'baidu'). It also has an option to use a random backend from the available options. The function returns the translated text if the translation is successful (status code 200), or the original text otherwise.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/lyrictoolbox.py\":233-265",
            "content": "        print(\"main language id:\", mainLanguage)\n        if mainLanguage == nativeLangFlagStandard:\n            print(\"no need to translate\")\n            needToTranslate = False\n        else:\n            print(\"need to translate\")\n    return isBilingual, needToTranslate\ndef translate(text: str, backend=\"baidu\"):  # deepl is shit. fucking shit.\n    # import time\n    # time.sleep(delay)\n    import requests\n    url = \"http://localhost:8974/translate\"\n    mTranslate = lambda text, backend, timeout: requests.get(\n        url, params={\"backend\": backend, \"text\": text}, timeout=timeout\n    )\n    backendList = [\"deepl\", \"baidu\"]\n    if backend == \"random\":\n        import random\n        backend = random.choice(backendList)\n    assert backend in backendList\n    translatedText = text\n    if text.strip() == \"\":\n        return text\n    try:\n        with mTranslate(text, backend, timeout=10) as conn:\n            result = conn.json()\n            print(\"TRANSLATOR RESULT:\", result)\n            if result[\"code\"] == 200:\n                translatedText = result[\"result\"]"
        },
        {
            "comment": "This function checks if a server is up and running by continuously sending requests to it on a specified port. If the server responds correctly, it returns success. Otherwise, it prints an error message and continues waiting until the timeout is reached or the server becomes active.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/lyrictoolbox.py\":266-297",
            "content": "            else:\n                print(\"SOME ERROR DURING TRANSLATION, PLEASE CHECK SERVER\")\n            # it just never return.\n    except:\n        import traceback\n        traceback.print_exc()\n    return translatedText\n    # we know the translator cannot respond the same shit to us right?\ndef waitForServerUp(port, message, timeout=1):\n    import requests\n    while True:\n        try:\n            url = \"http://localhost:{}\".format(port)\n            with requests.get(url, timeout=timeout, proxies=None) as r:\n                if type(message) == str:\n                    text = r.text.strip('\"').strip(\"'\")\n                else:\n                    text = r.json()\n                print(\"SERVER AT PORT %d RESPONDS:\" % port, [text])\n                assert text == message\n                print(\"SERVER AT PORT %d IS UP\" % port)\n                break\n        except:\n            import traceback\n            traceback.print_exc()\n            print(\"SERVER AT PORT %d MIGHT NOT BE UP\" % port)\n            print(\"EXPECTED MESSAGE:\", [message])"
        },
        {
            "comment": "The code imports necessary modules, sets up servers, and defines functions for censoring text with a text filter, translating lyrics, and handles bilingual lyrics. It uses a progress bar and calls external APIs for translation and censoring. The code waits for specific server ports to be active before proceeding.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/lyrictoolbox.py\":298-333",
            "content": "            import time\n            time.sleep(1)\nwaitForServerUp(8974, \"unified translator hooked on some clash server\")\nwaitForServerUp(8978, \"say hello to jpype fastapi server\")\nwaitForServerUp(8677, \"clash update controller\", timeout=10)  # probe the clash updator\nwaitForServerUp(\n    8932, {\"response\": \"DFAFilter based Chinese text filter(censor)\"}\n)  # this is text filter.\ndef censorTextWithTextFilter(text):\n    port = 8932\n    import requests\n    url = \"http://localhost:{}/filter\".format(port)\n    with requests.get(url, params={\"text\": text}) as r:\n        data = r.json()\n        return data[\"response\"]\n@redisLRUCache()\ndef getTextListTranslated(test, translate_method=\"baidu\"):\n    newLyricArray = []\n    import progressbar\n    isBilingual, needToTranslate = getLyricsLanguageType(test)\n    if isBilingual:\n        for elem in progressbar.progressbar(test):\n            text, flag = lastSpaceSpliter(elem)\n            if flag:  # splited!\n                foreignText, nativeText = text\n            else:\n                foreignText = text"
        },
        {
            "comment": "The code is a function that takes an array of text and translates it using the specified backend method. If there's a translation difference, it adds the original and translated text to the newLyricArray. If not, it just adds the original text. If no needToTranslate, it creates newLyricArray with elements from test. The function returns the newLyricArray after processing.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/lyrictoolbox.py\":334-361",
            "content": "                nativeText = translate(foreignText, backend=translate_method)\n            if foreignText != nativeText:\n                newLyricArray.append((foreignText, nativeText))\n            else:\n                newLyricArray.append((foreignText,))\n    else:\n        if needToTranslate:\n            for elem in progressbar.progressbar(test):\n                foreignText = elem\n                nativeText = translate(foreignText, backend=translate_method)\n                if not nativeText == foreignText:\n                    newLyricArray.append((foreignText, nativeText))\n                else:\n                    newLyricArray.append((foreignText,))\n        else:\n            newLyricArray = [(elem,) for elem in test.copy()]\n    return newLyricArray\ndef textArrayWithTranslatedListToAss(\n    textArray,\n    translatedList,\n    assPath,\n    shiftAdjust=600,\n    censor=True,\n    puncturalRemoval=True,\n    template_path=\"/root/Desktop/works/pyjom/tests/karaoke_effects/in2.ass.j2\",  # but the style. you know.\n    # aegisub use system fonts. you pass font name into it."
        },
        {
            "comment": "This code is initializing default and style configurations for subtitles, handling both original and translated languages. It uses a copy of the defaultStyleConfig, merges it with assStyleConfig, and assigns the result to styleConfig. The code imports necessary libraries and defines default_template_configs for font names and sizes.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/lyrictoolbox.py\":362-394",
            "content": "    ass_template_configs={},\n    assStyleConfig={},\n    tempdir=\"/dev/shm/medialang/lyrictoolbox\"\n    # editly does not support to put the .ass subtitle directly.\n):\n    defaultStyleConfig = {\n        \"original\": {\n            \"method\": \"romaji\",\n            \"style\": \"Romaji\",\n            \"cutOneByOne\": False,\n            \"charShift\": 35,\n        },  # this is default. you can change this.\n        \"translated\": {\n            \"method\": \"kanji\",\n            \"style\": \"Kanji\",\n            \"cutOneByOne\": True,\n            \"charShift\": 25,  # smaller?\n        },\n    }\n    # newTextArray = [] # dummy shit. must be removed immediately.\n    styleConfig = defaultStyleConfig.copy()\n    for key in styleConfig.keys():\n        styleConfig[key].update(assStyleConfig.get(key, {}))\n    import random\n    import math\n    import jinja2\n    from lazero.filesystem.io import readFile\n    default_template_configs = {\n        \"defaultFontname\": \"Arial\",\n        \"defaultFontsize\": 48,  # integer?\n        \"translationFontname\": \"Migu 1P\",\n        \"translationFontsize\": 48,"
        },
        {
            "comment": "The code sets default template configuration, updates it with additional ass-specific configurations. It then renders the updated template and saves it to a temporary file path. Finally, it reads the rendered template from the temporary file and initializes an Ass object using the path to the saved template. The data (meta, styles, lines) is extracted from this object.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/lyrictoolbox.py\":395-419",
            "content": "        \"kanjiFontname\": \"Migu 1P\",\n        \"kanjiFontsize\": 60,  # 46,  # increase. make 'kanji' one char at a time.\n        \"romajiFontname\": \"Migu 1P\",\n        \"romajiFontsize\": 60,  # 38,  # increase to 60. expand the space!\n    }\n    mTemplateConfigs = default_template_configs.copy()\n    mTemplateConfigs.update(ass_template_configs)\n    template = jinja2.Template(source=readFile(template_path))\n    template_configured = template.render(**mTemplateConfigs)\n    from lazero.filesystem.temp import (\n        tmpfile,\n        getRandomFileNameUnderDirectoryWithExtension,\n    )\n    from lazero.filesystem.io import writeFile\n    template_configured_savedPath = getRandomFileNameUnderDirectoryWithExtension(\n        \"ass\", tempdir, check=False\n    )\n    with tmpfile(template_configured_savedPath):\n        writeFile(template_configured_savedPath, template_configured)\n        io = Ass(template_configured_savedPath, path_output=assPath)\n    meta, styles, lines = io.get_data()\n    # Creating the star and extracting all the color changes from the input file"
        },
        {
            "comment": "This code defines a function `romaji` that takes in a line of lyrics and its associated data, and applies leadin and leadout effects to the syllables within the line. It sets up delay and offset variables for timing and positioning the effect, and iterates through each syllable in the line to apply the effects accordingly.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/lyrictoolbox.py\":420-446",
            "content": "    star = Shape.star(5, 4, 10)\n    CU = ColorUtility(lines)\n    # test this elsewhere. please?\n    def romaji(line, l):\n        # Setting up a delay, we will use it as duration time of the leadin and leadout effects\n        delay = 100\n        # Setting up offset variables, we will use them for the \\move in leadin and leadout effects\n        off_x = 35\n        off_y = 15\n        # Leadin Effect\n        mDelay = 0\n        # lastStartTime = line.start_time\n        for syl in Utils.all_non_empty(line.syls):\n            l.layer = 0\n            # l.start_time = syl.end_time\n            l.start_time = line.start_time\n            # l.start_time = (\n            #     line.start_time + 25 * syl.i - delay - 80\n            # )  # Remove 80 to start_time to let leadin finish a little bit earlier than the main effect of the first syllable\n            # l.end_time = lastStartTime # wtf?\n            # lastStartTime = syl.start_time\n            l.end_time = syl.start_time\n            # l.end_time = line.start_time + syl.start_time # wtf?"
        },
        {
            "comment": "This code is setting up lyrics animation for a specific line in a song. It calculates the duration and position of each syllable, applies animations based on their timing, and writes the effect data to be processed by the renderer. The inline_fx parameter determines the color change if the syllable has the \"m1\" effect applied.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/lyrictoolbox.py\":447-479",
            "content": "            l.dur = l.end_time - l.start_time\n            if l.dur <= 0:\n                continue\n            l.text = (\n                \"{\\\\an5\\\\move(%.3f,%.3f,%.3f,%.3f,0,%d)\\\\blur2\\\\t(0,%d,\\\\blur0)\\\\fad(%d,0)}%s\"\n                % (\n                    syl.center + math.cos(syl.i / 2) * off_x,\n                    syl.middle + math.sin(syl.i / 4) * off_y,\n                    syl.center,\n                    syl.middle,\n                    delay,\n                    delay,\n                    delay,\n                    syl.text,\n                )\n            )\n            io.write_line(l)\n        # Main Effect\n        for syl in Utils.all_non_empty(line.syls):\n            l.layer = 1\n            l.start_time = syl.start_time\n            # l.start_time = line.start_time + syl.start_time\n            l.end_time = syl.end_time + 100\n            l.dur = l.end_time - l.start_time\n            c1 = \"&H81F4FF&\"\n            c3 = \"&H199AAA&\"\n            # Change color if inline_fx is m1\n            if syl.inline_fx == \"m1\":"
        },
        {
            "comment": "This code applies a rotation effect to inline_fx \"m2\", sets the on_inline_effect_2 variable, and constructs a formatted string for text with animation and color properties. It writes this line to an io file while also creating a jumping star shape animation for syllables.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/lyrictoolbox.py\":480-511",
            "content": "                c1 = \"&H8282FF&\"\n                c3 = \"&H191AAA&\"\n            on_inline_effect_2 = \"\"\n            # Apply rotation if inline_fx is m2\n            if syl.inline_fx == \"m2\":\n                on_inline_effect_2 = \"\\\\t(0,%d,\\\\frz%.3f)\\\\t(%d,%d,\\\\frz0)\" % (\n                    l.dur / 4,\n                    random.uniform(-40, 40),\n                    l.dur / 4,\n                    l.dur,\n                )\n            l.text = (\n                \"{\\\\an5\\\\pos(%.3f,%.3f)%s\\\\t(0,80,\\\\fscx105\\\\fscy105\\\\1c%s\\\\3c%s)\\\\t(80,%d,\\\\fscx100\\\\fscy100\\\\1c%s\\\\3c%s)}%s\"\n                % (\n                    syl.center,\n                    syl.middle,\n                    on_inline_effect_2,\n                    c1,\n                    c3,\n                    l.dur - 80,\n                    line.styleref.color1,\n                    line.styleref.color3,\n                    syl.text,\n                )\n            )\n            io.write_line(l)\n            # Animating star shape that jumps over the syllables\n            # Jump-in to the first syl"
        },
        {
            "comment": "This code calculates the positions and alpha values for text overlays on each syllable in a line, using FrameUtility to determine the timing. It applies a sinusoidal function to adjust y-coordinates based on frame percentage, and handles alpha values by adding them over time from FU. It also checks if it's the first syllable of the line to initialize FrameUtility correctly.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/lyrictoolbox.py\":512-537",
            "content": "            jump_height = 18\n            if syl.i == 0:\n                FU = FrameUtility(line.start_time - line.leadin / 2, line.start_time)\n                for s, e, i, n in FU:\n                    l.start_time = s\n                    l.end_time = e\n                    frame_pct = i / n\n                    x = syl.center - syl.width * (1 - frame_pct)\n                    y = syl.top - math.sin(frame_pct * math.pi) * jump_height\n                    alpha = 255\n                    alpha += FU.add(0, syl.duration, -255)\n                    alpha = Convert.alpha_dec_to_ass(int(alpha))\n                    l.text = (\n                        \"{\\\\alpha%s\\\\pos(%.3f,%.3f)\\\\bord1\\\\blur1\\\\1c%s\\\\3c%s\\\\p1}%s\"\n                        % (alpha, x, y, c1, c3, star)\n                    )\n                    io.write_line(l)\n            # Jump to the next syl or to the end of line\n            jump_width = (\n                line.syls[syl.i + 1].center - syl.center\n                if syl.i != len(line.syls) - 1\n                else syl.width"
        },
        {
            "comment": "This code generates lyric information for each syllable in a line, including start and end times, position on screen, and alpha transparency. It also handles the last jump with a fade-out effect. The code uses FrameUtility to calculate frame percentage, adjusts y-coordinate based on frame percentage using sine function, and applies specific colors for text.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/lyrictoolbox.py\":538-566",
            "content": "            )\n            # FU = FrameUtility(\n            #     line.start_time + syl.start_time, line.start_time + syl.end_time\n            # )\n            FU = FrameUtility(syl.start_time, syl.end_time)\n            for s, e, i, n in FU:\n                l.start_time = s\n                l.end_time = e\n                frame_pct = i / n\n                x = syl.center + frame_pct * jump_width\n                y = syl.top - math.sin(frame_pct * math.pi) * jump_height\n                alpha = 0\n                # Last jump should fade-out\n                if syl.i == len(line.syls) - 1:\n                    alpha += FU.add(0, syl.duration, 255)\n                alpha = Convert.alpha_dec_to_ass(int(alpha))\n                l.text = (\n                    \"{\\\\alpha%s\\\\pos(%.3f,%.3f)\\\\bord1\\\\blur1\\\\1c%s\\\\3c%s\\\\p1}%s\"\n                    % (\n                        alpha,\n                        x,\n                        y,\n                        c1,\n                        c3,\n                        star,\n                    )"
        },
        {
            "comment": "This code adjusts the start and end times of each lyric line to create a leadout effect, where subsequent lines fade in after the previous ones have finished. It iterates over each syllable in a line, sets their duration based on the line's start and end times, and applies animation properties for the lyric display.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/lyrictoolbox.py\":567-594",
            "content": "                )\n                io.write_line(l)\n        # Leadout Effect\n        for syl in Utils.all_non_empty(line.syls):\n            l.layer = 0\n            l.start_time = syl.end_time\n            # l.start_time = line.start_time + syl.end_time + 100\n            l.end_time = line.end_time\n            # l.end_time = line.end_time - 25 * (len(line.syls) - syl.i) + delay + 100\n            # l.end_time = line.end_time - 25 * (len(line.syls) - syl.i) + delay + 100\n            l.dur = l.end_time - l.start_time\n            if l.dur <= 0:\n                continue\n            l.text = (\n                \"{\\\\an5\\\\move(%.3f,%.3f,%.3f,%.3f,%d,%d)\\\\t(%d,%d,\\\\blur2)\\\\fad(0,%d)}%s\"\n                % (\n                    syl.center,\n                    syl.middle,\n                    syl.center + math.cos(syl.i / 2) * off_x,\n                    syl.middle + math.sin(syl.i / 4) * off_y,\n                    l.dur - delay,\n                    l.dur,\n                    l.dur - delay,\n                    l.dur,\n                    delay,"
        },
        {
            "comment": "This code calculates the start and end times for a lead-in effect in a lyric animation, with adjustable delay, offsets, and duration. It iterates through syllables, setting the layer, start time, and end time accordingly while applying specific formatting to the text.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/lyrictoolbox.py\":595-623",
            "content": "                    syl.text,\n                )\n            )\n            io.write_line(l)\n    def kanji(line, l):\n        # Setting up a delay, we will use it as duration time of the leadin and leadout effects\n        delay = 300\n        # Setting up offset variables, we will use them for the \\move in leadin and leadout effects\n        off_x = 35\n        off_y = 15\n        # Leadin Effect\n        for syl in Utils.all_non_empty(line.syls):\n            l.layer = 0\n            l.start_time = line.start_time\n            # l.start_time = (\n            #     line.start_time + 25 * syl.i - delay - 80\n            # )  # Remove 80 to start_time to let leadin finish a little bit earlier than the main effect of the first syllable\n            l.end_time = syl.start_time\n            # l.end_time = line.start_time + syl.start_time\n            l.dur = l.end_time - l.start_time\n            if l.dur <= 0:\n                continue\n            l.text = (\n                \"{\\\\an5\\\\move(%.3f,%.3f,%.3f,%.3f,0,%d)\\\\blur2\\\\t(0,%d,\\\\blur0)\\\\fad(%d,0)}%s\""
        },
        {
            "comment": "This code seems to be responsible for generating lines of text with effects based on the input lyrics and effect fields. It calculates the position of each line using sine and cosine functions, sets the start and end times, adjusts colors depending on the effect field, and applies rotation if the effect is set to \"m2\". The code then writes these lines with their respective properties to a file.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/lyrictoolbox.py\":624-657",
            "content": "                % (\n                    syl.center + math.cos(syl.i / 2) * off_x,\n                    syl.middle + math.sin(syl.i / 4) * off_y,\n                    syl.center,\n                    syl.middle,\n                    delay,\n                    delay,\n                    delay,\n                    syl.text,\n                )\n            )\n            io.write_line(l)\n        # Main Effect\n        for syl in Utils.all_non_empty(line.syls):\n            l.layer = 1\n            l.start_time = syl.start_time\n            # l.start_time = line.start_time + syl.start_time\n            l.end_time = syl.end_time + 100\n            l.dur = l.end_time - l.start_time\n            c1 = \"&H81F4FF&\"\n            c3 = \"&H199AAA&\"\n            # Change color if effect field is m1\n            if line.effect == \"m1\":\n                c1 = \"&H8282FF&\"\n                c3 = \"&H191AAA&\"\n            on_inline_effect_2 = \"\"\n            # Apply rotation if effect field is m2\n            if line.effect == \"m2\":\n                on_inline_effect_2 = \"\\\\t(0,%d,\\\\frz%.3f)\\\\t(%d,%d,\\\\frz0)\" % ("
        },
        {
            "comment": "This code appears to handle the rendering of lyrics for a song, applying various effects and positioning them on the screen. It seems to involve manipulating line durations, layer positions, and colors based on different parameters such as syllable positions and timing. The \"Leadout Effect\" suggests that it may also handle transitions or overlays between lines of lyrics.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/lyrictoolbox.py\":658-689",
            "content": "                    l.dur / 4,\n                    random.uniform(-40, 40),\n                    l.dur / 4,\n                    l.dur,\n                )\n            l.text = (\n                \"{\\\\an5\\\\pos(%.3f,%.3f)%s\\\\t(0,80,\\\\fscx105\\\\fscy105\\\\1c%s\\\\3c%s)\\\\t(80,%d,\\\\fscx100\\\\fscy100\\\\1c%s\\\\3c%s)}%s\"\n                % (\n                    syl.center,\n                    syl.middle,\n                    on_inline_effect_2,\n                    c1,\n                    c3,\n                    l.dur - 80,\n                    line.styleref.color1,\n                    line.styleref.color3,\n                    syl.text,\n                )\n            )\n            io.write_line(l)\n        # Leadout Effect\n        for syl in Utils.all_non_empty(line.syls):\n            l.layer = 0\n            l.start_time = syl.end_time + 100\n            # l.start_time = line.start_time + syl.end_time + 100\n            l.end_time = line.end_time\n            # l.end_time = line.end_time - 25 * (len(line.syls) - syl.i) + delay + 100\n            l.dur = l.end_time - l.start_time"
        },
        {
            "comment": "The code calculates the duration and positioning of lyrics on a timeline based on syllable information. It then applies text formatting and color changes to create a visual effect. The function sub sets the layer, start time, end time, and duration for each line of lyrics, taking into account leadin and leadout times. It also retrieves interpolated color changes for the line using a utility function CU.get_color_change().",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/lyrictoolbox.py\":690-723",
            "content": "            if l.dur <= 0:\n                continue\n            l.text = (\n                \"{\\\\an5\\\\move(%.3f,%.3f,%.3f,%.3f,%d,%d)\\\\t(%d,%d,\\\\blur2)\\\\fad(0,%d)}%s\"\n                % (\n                    syl.center,\n                    syl.middle,\n                    syl.center + math.cos(syl.i / 2) * off_x,\n                    syl.middle + math.sin(syl.i / 4) * off_y,\n                    l.dur - delay,\n                    l.dur,\n                    l.dur - delay,\n                    l.dur,\n                    delay,\n                    syl.text,\n                )\n            )\n            io.write_line(l)\n    def sub(line, l):\n        # Translation Effect\n        l.layer = 0\n        l.start_time = line.start_time - line.leadin / 2\n        l.end_time = line.end_time + line.leadout / 2\n        l.dur = l.end_time - l.start_time\n        # Getting interpolated color changes (notice that we do that only after having set up all the times, that's important)\n        colors = CU.get_color_change(l)\n        # Base text\n        l.text = \"{\\\\an5\\\\pos(%.3f,%.3f)\\\\fad(%d,%d)}%s\" % ("
        },
        {
            "comment": "This code applies random clips and colors to each line of text. It generates lines based on a given set of lines, randomly sets x-coordinates for the clipping rectangle, adjusts y-coordinate, and writes the modified text with applied clip and color to an output file.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/lyrictoolbox.py\":724-761",
            "content": "            line.center,\n            line.middle,\n            line.leadin / 2,\n            line.leadout / 2,\n            line.text,\n        )\n        io.write_line(l)\n        # Random clipped text colorated\n        l.layer = 1\n        for i in range(1, int(line.width / 80)):\n            x_clip = line.left + random.uniform(0, line.width)\n            y_clip = line.top - 5\n            clip = (\n                x_clip,\n                y_clip,\n                x_clip + random.uniform(10, 30),\n                y_clip + line.height + 10,\n            )\n            l.text = \"{\\\\an5\\\\pos(%.3f,%.3f)\\\\fad(%d,%d)\\\\clip(%d,%d,%d,%d)%s}%s\" % (\n                line.center,\n                line.middle,\n                line.leadin / 2,\n                line.leadout / 2,\n                clip[0],\n                clip[1],\n                clip[2],\n                clip[3],\n                colors,\n                line.text,\n            )\n            io.write_line(l)\n    for line in lines:\n        # Generating lines\n        if line.styleref.alignment >= 7:"
        },
        {
            "comment": "Code snippet checks if the alignment of a line's style reference is greater than or equal to 4. If so, it creates a copy of the line source and assigns it to 'lineModSource'. It also creates a new copy of the line source specifically for Kanji styling. The code then iterates over a list of translated text elements, extracting source and translated texts. If there is no source text or it's empty, the iteration continues; otherwise, it proceeds with further processing.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/lyrictoolbox.py\":762-789",
            "content": "            lineModSource = line.copy()\n            break\n        elif line.styleref.alignment >= 4:  # what is this shit?\n            lineModSource = line.copy()\n            break\n    lineModSourceKanji = lineModSource.copy()\n    lineModSourceKanji.style = \"Kanji\"\n    # from test_pylrc import *\n    # just a test.\n    # censor these lyrics! fucker!\n    newTextArray = textArray\n    for mIndex, elem in enumerate(newTextArray):\n        # if fail then just continue. fuck.\n        try:\n            translatedTuple = translatedList[mIndex]\n            if len(translatedTuple) == 1:\n                sourceText = translatedTuple[0]\n                translatedText = None\n            elif len(translatedTuple) == 2:\n                sourceText, translatedText = translatedTuple\n            else:\n                print(\"Invalid translatedTuple: %s\" % str(translatedTuple))\n                breakpoint()\n            if sourceText is None or sourceText.strip() == \"\":\n                continue\n            else:\n                hasTranslatedText = ("
        },
        {
            "comment": "Code filters and prepares input text for display by checking if it has been translated, removing unnecessary punctuation, censoring the text if needed, and setting the start and end time of a line. It also removes any double spaces before passing it to the next step.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/lyrictoolbox.py\":790-810",
            "content": "                    (translatedText not in [sourceText, None, \"\"])\n                    and type(translatedText) == str\n                    and translatedText.strip() != \"\"\n                )\n            if puncturalRemoval:\n                sourceText = removeUnnecessaryPunctuation(sourceText)\n                if hasTranslatedText:\n                    translatedText = removeUnnecessaryPunctuation(translatedText)\n            if censor:\n                sourceText = censorTextWithTextFilter(sourceText)\n                if hasTranslatedText:\n                    translatedText = censorTextWithTextFilter(translatedText)\n            elem[\"text\"] = sourceText\n            lineMod = lineModSource.copy()\n            lineMod.start_time = max(0, elem[\"start\"] * 1000 - shiftAdjust)\n            lineMod.end_time = elem[\"end\"] * 1000 - shiftAdjust\n            lineMod.duration = lineMod.end_time - lineMod.start_time\n            lineMod.text = elem[\"text\"].strip()\n            while True:\n                if \"  \" in lineMod.text:"
        },
        {
            "comment": "This function takes a line of text, processes it by replacing consecutive spaces with a single space and splitting the line into words based on the count of spaces. It then initializes variables for cutting words, processing them one at a time or in bulk depending on input parameters, and creates a list of syllables from each word. If there are no words, it sets a default single space.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/lyrictoolbox.py\":811-838",
            "content": "                    lineMod.text = lineMod.text.replace(\"  \", \" \")\n                else:\n                    break\n            # print(lineMod)\n            def addSylToLine(\n                lineMod,\n                translateShift=0,\n                charShift=30,  # increase this!\n                CENTER=1600 / 2,\n                mSylYShift=600,\n                mTop=25,\n                mMiddle=49.0,\n                mBottom=73.0,\n                cutOneByOne=False,\n            ):\n                lineMod.center = CENTER  # wtf?\n                if cutOneByOne:\n                    lineMod.words = list(lineMod.text)\n                elif lineMod.text.count(\" \") >= 1:\n                    lineMod.words = lineMod.text.split(\" \")\n                else:\n                    lineMod.words = getJiebaCuttedText(lineMod.text)\n                sylList = []\n                wordCount = len(lineMod.words)\n                if wordCount == 0:  # clean it no matter what.\n                    lineMod.words = [\" \"]\n                    lineMod.text = \" \""
        },
        {
            "comment": "This code calculates the absolute center shift for each word in a line of text, considering the number of characters and the start-end time difference. It stores these values in two lists: 'wordWidthList' and 'absWordCenterShiftList'. The function also includes a lambda getter method to retrieve a specific value from the 'absWordCenterShiftList'.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/lyrictoolbox.py\":839-862",
            "content": "                    wordCount = 1\n                sylDuration = (lineMod.end_time - lineMod.start_time) / wordCount\n                textLength = len(lineMod.text)\n                absWordCenterShiftList = []\n                prevWordShift = 0\n                wordWidthList = []\n                for word in lineMod.words:\n                    wordWidth = len(word) * charShift\n                    wordWidthList.append(wordWidth)\n                    wordLength = len(word) + 1\n                    wordCenterShift = (charShift * wordLength) / 2\n                    wordShift = charShift * wordLength\n                    absWordCenterShift = (\n                        CENTER\n                        - (textLength * charShift) / 2\n                        + prevWordShift\n                        + wordCenterShift\n                    )\n                    absWordCenterShiftList.append(absWordCenterShift)\n                    prevWordShift += wordShift\n                # CENTER + centerShift*charShift\n                getCenter = lambda index: absWordCenterShiftList[index]"
        },
        {
            "comment": "The code creates a list of syllables for each line of lyrics. It calculates the position, duration, and timing of each syllable based on the line's words, word positions, and durations. The syllables are then added to a list. Finally, it checks the starting and ending lines by finding the first and last syllable in the list, respectively.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/lyrictoolbox.py\":863-882",
            "content": "                getWidth = lambda index: wordWidthList[index]\n                for index, word in enumerate(lineMod.words):\n                    syl = Syllable()\n                    syl.text = word\n                    syl.i = index\n                    syl.center = getCenter(index)\n                    syl.width = getWidth(index)\n                    syl.top = mTop + mSylYShift + translateShift\n                    syl.inline_fx = \"m2\"\n                    syl.middle = mMiddle + mSylYShift + translateShift\n                    syl.bottom = mBottom + mSylYShift + translateShift\n                    syl.start_time = lineMod.start_time + index * sylDuration\n                    syl.end_time = syl.start_time + sylDuration\n                    syl.duration = sylDuration\n                    sylList.append(syl)\n                # double check here! fucker\n                startSyl = sylList[0]\n                startLine = startSyl.center - startSyl.width / 2\n                endSyl = sylList[-1]\n                endLine = endSyl.center + endSyl.width / 2"
        },
        {
            "comment": "Calculates the center point of a lyric by averaging start and end line coordinates, adjusts each syllable's center position based on this calculated value.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/lyrictoolbox.py\":883-901",
            "content": "                currentCenter = (endLine + startLine) / 2\n                # print(startLine, endLine)\n                # print('current center:', currentCenter)\n                centerShift = int(CENTER - currentCenter)\n                # print(\"CENTERSHIFT\", centerShift)\n                for index in range(len(sylList)):\n                    sylList[index].center += centerShift\n                    # import copy\n                    # elem = copy.deepcopy(sylList[index])\n                    # elem.center = sylList[index].center+centerShift\n                    # print(\"CHANGED CENTER\", elem.center, sylList[index].center)\n                    # sylList[index] = copy.deepcopy(elem)\n                # startSyl = sylList[0]\n                # startLine = startSyl.center - startSyl.width/2\n                # endSyl = sylList[-1]\n                # endLine = endSyl.center + endSyl.width/2\n                # currentCenter = (endLine+startLine)/2\n                # print(startLine, endLine)\n                # print('adjusted center:', currentCenter)"
        },
        {
            "comment": "This code snippet is responsible for adding syllables to a line and handling original and translated text. It first assigns the syllable list, applies styles, copies the source and target lines, and then applies the method based on the style configuration. If there's translated text, it creates a new line with the translated text's style.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/lyrictoolbox.py\":903-928",
            "content": "                lineMod.syls = sylList\n            # print(lineMod.syls)\n            # breakpoint()\n            # if translatedText == None:\n            #     addSylToLine(lineMod, charShift = 10)\n            # else:\n            addSylToLine(\n                lineMod,\n                cutOneByOne=styleConfig[\"original\"][\"cutOneByOne\"],\n                charShift=styleConfig[\"original\"][\"charShift\"],\n            )  # this function is to locate this thing.\n            # breakpoint()\n            # pyonfx.ass_core.Syllable\n            lineMod.style = styleConfig[\"original\"][\"style\"]\n            source = lineMod.copy()\n            target = lineMod.copy()\n            methodMapping = {\"kanji\": kanji, \"romaji\": romaji}\n            methodMapping[styleConfig[\"original\"][\"method\"]](\n                source, target\n            )  # writing 'kanji' style to romaji?\n            if hasTranslatedText:\n                # source.style = styleConfig['original']['style']\n                lineMod2 = lineMod.copy()\n                lineMod2.style = styleConfig[\"translated\"][\"style\"]"
        },
        {
            "comment": "This code is translating and formatting lyrics in an ASS (Advanced Substation Alpha) file. It replaces spaces with empty strings, adjusts the translation based on configuration, and applies different formatting methods depending on alignment. If an error occurs, it prints the traceback and continues to the next line. Finally, it saves and returns the generated ASS file path.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/lyrictoolbox.py\":929-954",
            "content": "                translatedText = translatedText.replace(\" \", \"\")  # fuck?\n                lineMod2.text = translatedText\n                translateShift = 100\n                addSylToLine(\n                    lineMod2,\n                    translateShift=translateShift,\n                    cutOneByOne=styleConfig[\"translated\"][\"cutOneByOne\"],\n                    charShift=styleConfig[\"translated\"][\"charShift\"],\n                )\n                source = lineMod2.copy()\n                target = lineMod2.copy()\n                # elif line.styleref.alignment >= 4:\n                methodMapping[styleConfig[\"translated\"][\"method\"]](source, target)\n            # breakpoint()\n            # else:\n            #     romaji(source, target)\n        except:\n            # must be some \"start_ms\" <= 0 or some shit.\n            import traceback\n            traceback.print_exc()\n            print(\"Error when generating lyric subtitle line by line.\")\n            continue\n    io.save()\n    print(\"ASS RENDERED AT %s\" % assPath)\n    return assPath"
        },
        {
            "comment": "This code snippet contains two functions: `previewAssWithVideo()` and `lrcToAnimatedAss()`. The former previews an ASS script with a sample video using the mpv command, while the latter converts LRC to animated ASS format by translating text (if specified) and creating an ASS script file. It also allows for custom ASS styles through configuration.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/lyrictoolbox.py\":957-987",
            "content": "# do the preview later?\n# # io.open_aegisub()\ndef previewAssWithVideo(sample_video, assPath):\n    # from pyonfx import Ass\n    # io = Ass(assPath)\n    # do not load this shit again unless you want to block the whole shit...\n    print(\"PREVIEWING ASS SCRIPT: %s\" % assPath)\n    # io.open_mpv(video_path=sample_video) # ain't see shit...\n    cmd = \"mpv --sub-file='{}' '{}'\".format(assPath, sample_video)\n    os.system(cmd)\ndef lrcToAnimatedAss(\n    musicPath,\n    lrcPath,\n    assPath,\n    translate=True,\n    translate_method: Literal[\n        \"baidu\", \"deepl\", \"random\"\n    ] = \"baidu\",  # so how the fuck you can use deepl?\n    ass_template_configs={},\n    assStyleConfig={},\n):\n    # already moved to lyrictoolbox\n    # TODO: more styles incoming\n    textArray = lrcToTextArray(musicPath, lrcPath)\n    textList = [elem[\"text\"] for elem in textArray]\n    if translate:\n        translatedList = getTextListTranslated(\n            textList, translate_method=translate_method\n        )  # this is taking long time during test. make it redis lru cached!"
        },
        {
            "comment": "The code is a part of the pyjom module, specifically the lyrictoolbox. It defines functions for processing LRC files and extracting lyrics near BPM candidates. The `textArrayWithTranslatedListToAss` function converts an array of text with translated lists to ASS format. The `getLyricNearbyBpmCandidates` function finds nearby BPM (beats per minute) candidates for given lyric timings and beats, and returns them along with any remaining beats. The `read_lrc` function reads an LRC file, parses its content using pylrc module, and returns a list of subtitles.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/lyrictoolbox.py\":988-1026",
            "content": "    else:\n        translatedList = [\n            (sourceText,) for sourceText in textList\n        ]  # notice, we need to examine this damn list.\n    # so we pass both arguments to the ass generator.\n    return textArrayWithTranslatedListToAss(\n        textArray,\n        translatedList,\n        assPath,\n        ass_template_configs=ass_template_configs,\n        assStyleConfig=assStyleConfig,\n    )\n# lyrictoolbox\ndef getLyricNearbyBpmCandidates(lyric_times, beats):\n    nearbys, remains = [], []\n    mbeats = beats.copy()\n    mbeats = list(set(mbeats))\n    mbeats.sort()\n    for ltime in lyric_times:\n        mbeats.sort(key=lambda x: abs(x - ltime))\n        nearby = mbeats[:2].copy()\n        nearbys += nearby\n        for elem in nearby:\n            mbeats.remove(elem)\n    remains = mbeats\n    return nearbys, remains\n# lyrictoolbox\ndef read_lrc(lrc_path):\n    assert lrc_path.endswith(\".lrc\")\n    with open(lrc_path, \"r\") as f:\n        lrc_string = f.read()\n        subs = pylrc.parse(lrc_string)\n        sublist = []\n        for sub in subs:"
        },
        {
            "comment": "This function cleans LRC (Lyric Rich Description) files by parsing each subtitle, removing forbidden characters, and ensuring a minimum number of lines to be considered valid. The minimum_lines_of_lyrics and min_total_lines_of_lyrics parameters allow customization of these thresholds. If removeLinesWithPotentialForbiddenChars is True, any line containing potential_forbidden_chars will be removed. The function utilizes the pylrc module and defines a checkLyricText function to inspect each subtitle's text for forbidden characters.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/lyrictoolbox.py\":1027-1055",
            "content": "            time_in_secs = sub.time\n            content = sub.text\n            sublist.append({\"time\": time_in_secs, \"content\": content})\n            # another square bracket that could kill me.\n        return sublist\n# mainly for netease, this may change.\ndef cleanLrcFromWeb(\n    lyric_string: str,\n    song_duration: float,\n    min_lines_of_lyrics: int = 5,  # whatever. fuck this.\n    min_total_lines_of_lyrics: int = 10,\n    # potential_forbidden_chars=[], # how to deal with these? just remove the line?\n    removeLinesWithPotentialForbiddenChars: bool = True,\n    potential_forbidden_chars=[\"[\", \"]\", \"\u3010\", \"\u3011\", \"\u300c\", \"\u300d\", \"\u300a\", \"\u300b\", \"/\", \"(\", \")\"],\n    core_forbidden_chars=[\":\", \"\uff1a\", \"@\"],\n):\n    import pylrc\n    # you'd better inspect the thing. what is really special about the lyric, which can never appear?\n    def checkLyricText(text):\n        forbidden_chars = core_forbidden_chars\n        return not any([char in text for char in forbidden_chars])\n    # also get the total time covered by lyric.\n    # the time must be long enough, compared to the total time of the song."
        },
        {
            "comment": "This code is parsing a lyric string using pylrc library, then sorting and iterating over the parsed lines. It checks each line to determine if it contains valid lyrics, appends flags, and extracts consecutive spans from the flags. The extracted spans are then printed. This process ensures that only continuous lyrics sequences are considered for further analysis or processing.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/lyrictoolbox.py\":1056-1090",
            "content": "    lrc_parsed = pylrc.parse(lyric_string)  # this is string, not None!\n    lrc_parsed_list = [line for line in lrc_parsed]\n    lrc_parsed_list.sort(key=lambda line: line.time)\n    begin = False\n    # end = False\n    # line_counter = 0\n    # new_lines = []\n    # lrc_parsed: pylrc.classes.Lyrics\n    flags = []\n    for line in lrc_parsed_list:\n        # print(line)\n        text = line.text.strip()\n        # startTime = line.time\n        if not begin:\n            flag = checkLyricText(text)\n            if not flag:\n                begin = True\n        else:\n            flag = checkLyricText(text)\n            if flag:\n                begin = False\n        flags.append(flag)\n        # breakpoint()\n    # select consecutive spans.\n    # from test_commons import *\n    from pyjom.mathlib import extract_span\n    int_flags = [int(flag) for flag in flags]\n    mySpans = extract_span(int_flags, target=1)\n    print(mySpans)  # this will work.\n    # this span is for the range function. no need to add one to the end.\n    total_length = 0"
        },
        {
            "comment": "This code extracts lyrics from a parsed LRC file. It iterates through each line span, checks if the line meets minimum length requirements, and filters out forbidden characters before appending valid lines to new_lyric_list. Line start and end times are also checked and adjusted based on the song duration.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/lyrictoolbox.py\":1092-1112",
            "content": "    new_lyric_list = []\n    for mstart, mend in mySpans:\n        length = mend - mstart\n        total_length += length\n        if length >= min_lines_of_lyrics:\n            # process these lines.\n            for index in range(mstart, mend):\n                line_start_time = lrc_parsed_list[index].time\n                line_text = lrc_parsed_list[index].text\n                if removeLinesWithPotentialForbiddenChars:\n                    if any([char in line_text for char in potential_forbidden_chars]):\n                        line_text = \"\"\n                if line_start_time <= song_duration:\n                    line_end_time = song_duration\n                    if index + 1 < len(lrc_parsed_list):\n                        line_end_time = lrc_parsed_list[index + 1].time\n                        if line_end_time > song_duration:\n                            line_end_time = song_duration\n                    new_lyric_list.append((line_text, line_start_time))\n                    if index == mend - 1:\n                        # append one more thing."
        },
        {
            "comment": "The code is checking the total number of lines in a lyric. If it meets the minimum requirement, it formats the lyric with timestamps and appends each line to an instance of Lyrics class. The resulting LRC string is returned for the accepted lyrics. If the total length is not sufficient, the code continues execution without adding any lines. The `remergeDemandedCutSpans` function seems to handle cut spans by merging valid ones within a specified range.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/lyrictoolbox.py\":1113-1140",
            "content": "                        new_lyric_list.append((\"\", line_end_time))\n                else:\n                    continue\n    # for elem in new_lyric_list:\n    #     print(elem)\n    # exit()\n    if total_length >= min_total_lines_of_lyrics:\n        print(\"LYRIC ACCEPTED.\")\n        new_lrc = pylrc.classes.Lyrics()\n        for text, myTime in new_lyric_list:\n            timecode_min, timecode_sec = divmod(myTime, 60)\n            timecode = \"[{:d}:{:.3f}]\".format(int(timecode_min), timecode_sec)\n            myLine = pylrc.classes.LyricLine(timecode, text)\n            new_lrc.append(myLine)\n        new_lrc_string = new_lrc.toLRC()\n        return new_lrc_string\n        # print(new_lrc_string)\n        # if nothing returned, you know what to do.\n# remerge demanded cut spans.\ndef remergeDemandedCutSpans(demanded_cut_spans:list[tuple[float,float]],min_span=2, max_span=10):\n    new_cut_spans = []  # the last span. could be a problem.\n    checkSpanValid = lambda a, b, c: a <= b and a >= c\n    continue_flag = 0\n    def subdivide_span("
        },
        {
            "comment": "This code calculates cut spans for a given lyric by dividing the original span duration into sub-durations, checking if they are within the specified minimum and maximum duration limits. It appends these valid sub-spans to new_cut_spans until it reaches the desired number of cuts or all original spans have been processed.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/lyrictoolbox.py\":1141-1168",
            "content": "        span_duration, min_span, max_span, span_start, span_end, new_cut_spans,div = 2,\n    ):\n        while True:\n            subduration = span_duration / div\n            # print(f'div {div} subduation {subduration}')\n            # if div>15:\n            #     breakpoint()\n            if checkSpanValid(subduration, max_span, min_span):\n                myspans = [\n                    (span_start + i * subduration, span_start + (i + 1) * subduration)\n                    for i in range(div)\n                ]\n                myspans[-1] = (myspans[-1][0], span_end)\n                for mspan in myspans:\n                    new_cut_spans.append(mspan)\n                break\n            else:\n                div += 1\n    for index, span in enumerate(demanded_cut_spans):\n        if continue_flag>0:\n            continue_flag -=1\n            continue\n        span_start, span_end = span\n        span_duration = span_end - span_start\n        if checkSpanValid(span_duration, max_span, min_span):\n            new_cut_spans.append((span_start, span_end))"
        },
        {
            "comment": "If the span duration is larger than the maximum allowed span, it subdivides the span. If the span duration is smaller than the minimum allowed span, it merges with the previous span or creates a new one if there's no previous span. If the source cut span list is abnormal, it prints an error message and stops execution.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/lyrictoolbox.py\":1169-1190",
            "content": "        elif span_duration > max_span:\n            subdivide_span(\n                span_duration, min_span, max_span, span_start, span_end, new_cut_spans\n            )\n        elif span_duration < min_span:\n            if len(new_cut_spans) > 0:\n                # merge with the previous span.\n                mynewspan = (new_cut_spans[-1][0], span_end)\n                # cut it in the old way.\n                new_cut_spans.pop(-1)\n            else:\n                mynewspan = None\n                for i0 in range(0,len(demanded_cut_spans)-index-1):\n                    continue_flag +=1\n                    mynewspan = span_start, demanded_cut_spans[index + 1+i0][1]\n                    if mynewspan[1]-mynewspan[0]>min_span:\n                        break\n                if mynewspan is None:\n                    print('Error!\\nMaybe the source cut span list is too small or is some abnormal source cut span.\\nPlease check.')\n                    breakpoint()\n            subdivide_span(\n                mynewspan[1]-mynewspan[0],"
        },
        {
            "comment": "The code is returning a list of new_cut_spans after merging, appending to existing spans if present, or merging with later span if previous one is not present.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/lyrictoolbox.py\":1191-1200",
            "content": "                min_span,\n                max_span,\n                mynewspan[0],\n                mynewspan[1],\n                new_cut_spans,\n                div=1\n            )\n                # new_cut_spans.append(mynewspan)\n            # just merge with previous span. if previous span not present, merge with later span.\n    return new_cut_spans"
        }
    ]
}