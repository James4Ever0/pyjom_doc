{
    "summary": "The code is for a video recommendation program that uses text processing, SQLite database, BM25 algorithm, and hybrid search algorithms to retrieve Bilibili user videos, handle pagination, and update databases. It defines functions for video searching and refreshing status, interacts with a database, initializes a scheduler, creates tables, sets up FastAPI application, contains video search endpoints, retrieves video info from generators, schedules tasks, handles forms, registers videos on Bilibili platform, uses Uvicorn server, and runs bilibiliRecommendationServer function.",
    "details": [
        {
            "comment": "This code appears to be a part of a larger program that deals with video recommendations and retrieval on the bilibili platform. It imports various libraries and functions, such as jieba for text processing, opencc for Chinese-to-simplified Chinese conversion, and pydantic for data validation. The getOpenCCConverter function is a memoized function that converts text using OpenCC's \"t2s\" type.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/platforms/bilibili/database.py\":0-42",
            "content": "from lazero.utils.json import jsonify\n# ellipsis = type(...)\n# serve my video, serve my cat video, dog video, set priority, serve others video\n# by means of query? or just directly ask me for it.\n# you'd better mimic the video that you have never recommend, and these audience have never seen before.\nimport time\n# utils.\ndef default(value, default_, isInstance=lambda v: v in [..., None]):\n    if isInstance(value):\n        return default_\n    return value\nimport datetime\nfrom typing import Union, Literal\nfrom functools import lru_cache\nimport random\n# you might want to add this to bilibili platform api, if there's no use of pyjom.commons\nfrom pyjom.platforms.bilibili.credentials import getCredentialByDedeUserId\nfrom pyjom.platforms.bilibili.utils import (\n    linkFixer,\n    videoDurationStringToSeconds,\n    clearHtmlTags,\n)\nfrom lazero.search.preprocessing import getFourVersionsOfProcessedLine\nimport jieba\nimport opencc\nimport jieba.analyse as ana\nimport progressbar\nimport pydantic\n@lru_cache(maxsize=4)\ndef getOpenCCConverter(converter_type: str = \"t2s\"):"
        },
        {
            "comment": "This code snippet performs text preprocessing on a given text. It uses the OpenCC library to convert the text to simplified Chinese if needed, and then applies Jieba's jieba.lcut method for word segmentation. The resulting words are checked for their presence in the Chinese character range (u4e00-u9fff). Flags are created based on whether each word contains a Chinese character or not. The extract_span function is then used to identify spans of consecutive words with similar flags, which are assumed to be either Chinese or non-Chinese text.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/platforms/bilibili/database.py\":43-81",
            "content": "    converter = opencc.OpenCC(converter_type)\n    return converter\ndef isChineseCharacter(char):\n    assert len(char) == 1\n    return char >= \"\\u4e00\" and char <= \"\\u9fff\"\ndef containChineseCharacters(text):\n    for char in text:\n        if isChineseCharacter(char):\n            return True\n    return False\nfrom lazero.utils.mathlib import extract_span\ndef textPreprocessing(text):\n    converter = getOpenCCConverter()\n    text = converter.convert(text)\n    (\n        final_line,\n        final_cutted_line,\n        final_stemmed_line,\n        final_cutted_stemmed_line,\n    ) = getFourVersionsOfProcessedLine(text)\n    # breakpoint()\n    wordlist = jieba.lcut(final_cutted_line)\n    final_wordlist = []\n    for w in wordlist:\n        word = w.strip()\n        if len(word) > 0:\n            final_wordlist.append(word)\n    flags = [int(containChineseCharacters(word)) for word in final_wordlist]\n    chineseSpans = extract_span(flags, target=1)\n    nonChineseSpans = extract_span(flags, target=0)\n    finalSpans = [(span, True) for span in chineseSpans] + ["
        },
        {
            "comment": "This code performs text preprocessing and keyword extraction. It removes stopwords, utilizes a custom function for Chinese word segmentation, and implements TF-IDF or random selection of top keywords from the preprocessed text. It also stores commonly used stopwords in memory using LRU cache.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/platforms/bilibili/database.py\":82-116",
            "content": "        (span, False) for span in nonChineseSpans\n    ]\n    finalSpans.sort(key=lambda span: span[0])\n    finalWordList = []\n    for span, isChineseSpan in finalSpans:\n        subWordList = final_wordlist[span[0] : span[1]]\n        subChars = \"\".join(subWordList)\n        subCharList = [c for c in subChars]  # \u76f4\u63a5\u7ed9\u4f60\u9010\u5b57\u5207\u5272\u4e86 \u8bf4\u4e0d\u5b9a\u5c31\u6709\u7528\u4e86\n        if isChineseSpan:\n            subWordList = jieba.lcut_for_search(subChars)\n        finalWordList.extend(subWordList)\n        finalWordList.extend(subCharList)\n    return \" \".join(finalWordList)\nfrom nltk.corpus import stopwords\n@lru_cache(maxsize=1)\ndef getStopwords(languages: tuple = (\"chinese\", \"english\")):\n    stopword_list = []\n    for lang in languages:\n        stopword_list.extend(stopwords.words(lang))\n    return stopword_list\ndef keywordExtracting(\n    text,\n    method: Literal[\"tfidf\", \"random\"] = \"tfidf\",\n    languages: tuple = (\"chinese\", \"english\"),\n    topK: int = 5,\n):\n    # remove all stopwords.\n    keyword_list = textPreprocessing(text).split(\" \")\n    stopword_list = getStopwords(languages=languages)"
        },
        {
            "comment": "This code performs keyword extraction based on the provided method. It filters out stopwords, shuffles results if using the \"random\" method, and uses TF-IDF for the \"tfidf\" method. The `queryForm` class is a Pydantic model for BiliBili query data models with properties for query, page size, page number, and cached preprocessed search query.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/platforms/bilibili/database.py\":117-150",
            "content": "    results = []\n    for k in keyword_list:\n        if k.lower() not in stopword_list:\n            results.append(k)\n    if method == \"random\":\n        random.shuffle(results)\n        return results[:topK]\n    elif method == \"tfidf\":\n        myText = \" \".join(results)\n        tags = ana.extract_tags(myText, topK=topK)\n        return tags\n    else:\n        raise Exception(\"Unknown keyword extraction method: %s\" % method)\n################################BILIBILI QUERY DATA MODELS######################\n# @reloading\nclass queryForm(pydantic.BaseModel):\n    query: str  # required?\n    page_size: Union[int, None] = None\n    page_num: int = 1\n    query_for_search_cached: Union[str, None] = None\n    # you are going to inherit this.\n    @property\n    def query_for_search(\n        self,\n    ):  # make sure the preprocessing is only called once. really?\n        if self.query_for_search_cached is None:\n            query = self.query\n            self.query_for_search_cached = textPreprocessing(query)\n        return self.query_for_search_cached"
        },
        {
            "comment": "The code defines four classes: `searchVideoForm`, `searchRegisteredVideoForm`, `searchUserVideoForm`, and `registerUserVideoForm`. These classes inherit from `queryForm` and are used for querying video data on Bilibili. The classes have different parameters, such as `tid`, `dedeuserid`, `videoOrder`, `method`, and `use_credential`, to specify the desired search criteria. The code also imports necessary modules and functions from `bilibili_api` for performing operations on videos, users, and searches.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/platforms/bilibili/database.py\":153-194",
            "content": "# @reloading\nclass searchVideoForm(queryForm):\n    iterate: bool = False\n    params: dict = {}  # let's just see what you've got here.\nfrom bilibili_api.user import VideoOrder\n# @reloading\nclass searchRegisteredVideoForm(queryForm):\n    tid: int = 0\n    dedeuserid: Union[list[str], str, None] = None\n    videoOrder: VideoOrder = VideoOrder.PUBDATE\n# @reloading\nclass searchUserVideoForm(searchRegisteredVideoForm):\n    dedeuserid: str = \"397424026\"\n    method: Literal[\"online\", \"bm25\"] = \"online\"\n    use_credential: bool = False\n# @reloading\nclass registerUserVideoForm(pydantic.BaseModel):\n    bvid: str\n    dedeuserid: str\n    is_mine: bool = False\n    visible: bool = False\n################################BILIBILI QUERY DATA MODELS######################\n# from pyjom.platforms.bilibili.searchDataParser import parseSearchVideoResult # but you never use this shit.\n# will it load the overheads of pyjom.commons?\n# updated anyio. does that work? will it break dependencies?\nimport pyjq\nfrom bilibili_api import sync, search, user, video"
        },
        {
            "comment": "This code retrieves major and minor topic mappings from the bilibiliSearchParams database table and stores them in a dictionary called 'majorMinorMappings'. The function is memoized using @lru_cache decorator to avoid redundant queries. The debug parameter, if set to True, will print the major and minor topics during execution.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/platforms/bilibili/database.py\":196-222",
            "content": "from peewee import *\nfrom playhouse.sqlite_ext import SqliteExtDatabase, FTSModel, SearchField, RowIDField\nBSP = search.bilibiliSearchParams\n# you can query for the server status.\n# make it into a dashboard like thing.\n@lru_cache(maxsize=1)\ndef getMajorMinorTopicMappings(debug: bool = False):\n    majorMinorMappings = {}\n    for key, value in BSP.all.tids.__dict__.items():\n        try:\n            major_tid = value.tid\n            if debug:\n                print(\"MAJOR\", key, major_tid)\n            content = {\"major\": {\"tid\": major_tid, \"name\": key}}\n            majorMinorMappings.update(\n                {major_tid: content, key: content, str(major_tid): content}\n            )\n            for subkey, subvalue in value.__dict__.items():\n                if subkey != \"tid\" and type(subvalue) == int:\n                    if debug:\n                        print(\"MINOR\", subkey, subvalue)\n                    content = {\n                        \"major\": {\"tid\": major_tid, \"name\": key},\n                        \"minor\": {\"tid\": subvalue, \"name\": subkey},"
        },
        {
            "comment": "This code defines a function `getTagStringFromTid(tid)` that retrieves topic details from a topic ID (tid) and returns a comma-separated list of major and minor topics. It also uses a decorator to refresh the status, scheduled by calling `schedule()`, and a cached version of `getUserObject()` function with an optional dedeuserid and use_credential parameters.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/platforms/bilibili/database.py\":223-256",
            "content": "                    }\n                    majorMinorMappings.update(\n                        {subvalue: content, subkey: content, str(subvalue): content}\n                    )\n        except:\n            pass\n    return majorMinorMappings\ndef getTagStringFromTid(tid):\n    majorMinorTopicMappings = getMajorMinorTopicMappings()\n    topic = majorMinorTopicMappings.get(tid, None)\n    tags = []\n    if topic:\n        majorTopic = topic.get(\"major\", {}).get(\"name\", None)\n        minorTopic = topic.get(\"minor\", {}).get(\"name\", None)\n        if majorTopic:\n            tags.append(majorTopic)\n            if minorTopic:\n                tags.append(minorTopic)\n    return \",\".join(tags)\n# also make a decorator for refreshing status, add it to every function.\n# thie refresher is scheduled.\n# you may want to run this beforehand...\nimport schedule\n# do we really need credential for checking our video? you can try.\n@lru_cache(maxsize=3)  # could be bigger.\ndef getUserObject(dedeuserid: str = \"397424026\", use_credential: bool = False):"
        },
        {
            "comment": "The code defines a class called BilibiliUser, which inherits from the peewee.Model class. The class has fields for username, user_id (which is unique), is_mine flag, followers count, and avatar URL. A method, userInfoExtracter, is also defined to extract information from the model instance excluding specified keys. Additionally, a function exists to create a new User instance based on the provided dedeuserid and credential.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/platforms/bilibili/database.py\":257-289",
            "content": "    dedeuserid_int = int(dedeuserid)\n    if use_credential:\n        credential = getCredentialByDedeUserId(\n            dedeuserid\n        )  # this will cache the cookies. so it allows multiple accounts.\n    else:\n        credential = None\n    u = user.User(dedeuserid_int, credential=credential)\n    return u\nfrom lazero.filesystem.env import getHomeDirectory\nfrom pathlib import Path\nimport os\nfrom peewee import *\nclass BilibiliUser(Model):\n    username = CharField()  # can be updated later.\n    user_id = IntegerField(unique=True)  # this is integer.\n    is_mine = BooleanField(default=False)\n    followers = IntegerField(\n        null=True\n    )  # how to get that? every time you get some video you do this shit? will get you blocked.\n    # well you can check it later.\n    avatar = CharField(null=True)  # warning! charfield max length is 255\n    def userInfoExtracter(self, blacklist=[\"id\"]):\n        info = {\n            key: value for key, value in self.__data__.items() if key not in blacklist\n        }\n        return info"
        },
        {
            "comment": "This code defines a BilibiliVideo class that inherits from Model and includes various fields such as bvid, typeid, visible, last_check, register_date, poster, play, pic, length, pubdate, review, favorites, title, and tag. The videoInfoExtractor method takes a blacklist parameter and returns information excluding the specified fields.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/platforms/bilibili/database.py\":292-317",
            "content": "class BilibiliVideo(Model):\n    bvid = CharField(unique=True)\n    typeid = IntegerField(null=True)  # string? wtf?\n    visible = BooleanField(null=True)  # are you sure?\n    last_check = DateTimeField(\n        default=datetime.datetime.now\n    )  # well this is not tested. test it!\n    register_date = DateTimeField(default=datetime.datetime.now)\n    poster = ForeignKeyField(\n        BilibiliUser, field=BilibiliUser.user_id\n    )  # is it my account anyway?\n    play = IntegerField(null=True)\n    pic = CharField(null=True)\n    length = IntegerField(null=True)\n    pubdate = IntegerField(default=0, null=True)\n    review = IntegerField(null=True)  # you want to update? according to this?\n    favorites = IntegerField(default=0, null=True)\n    title = CharField(null=True)\n    tag = CharField(null=True)\n    description = CharField(null=True)\n    def videoInfoExtractor(\n        self, blacklist=[\"id\", \"last_check\", \"register_date\", \"poster\"]\n    ):\n        info = {\n            key: value for key, value in self.__data__.items() if key not in blacklist"
        },
        {
            "comment": "This code is initializing a BilibiliVideoIndex model, which extends FTSModel and has three SearchField properties (title, tag, description). It also contains a RowIDField (rowid). The function getBilibiliVideoDatabase() is a cache-friendly function to access the database.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/platforms/bilibili/database.py\":318-353",
            "content": "        }\n        poster = self.poster\n        try:\n            info[\n                \"poster\"\n            ] = (\n                poster.userInfoExtracter()\n            )  # well it will return as always. no live fetching! it is stored in database.\n        except:\n            import traceback\n            traceback.print_exc()\n            print(\"userinfo might be missing from videoinfo.\")\n        try:\n            info[\"typeid\"] = int(info[\"typeid\"])\n        except:\n            pass\n        return info\nclass BilibiliVideoIndex(FTSModel):\n    rowid = RowIDField()\n    # these three must be preprocessed before put into the search engine, or we cannot retrieve the data correctly.\n    title = SearchField()\n    tag = (\n        SearchField()\n    )  # also what the fuck is going on with the tag? why we cannot get the tag/topic name?\n    description = SearchField()\n    class Meta:\n        database = None  # that's good.\n        options = {\"tokenize\": \"porter\"}  # you need manually separate some\n@lru_cache(maxsize=1)\ndef getBilibiliVideoDatabase():"
        },
        {
            "comment": "The code sets up a SQLite database for the Bilibili video platform. It creates a directory if it doesn't exist, defines the database path, and initializes an SqliteExtDatabase object with specified pragmas. The getBilibiliVideoDatabaseAndCreateTables function creates necessary tables using the defined database, and registerUser function retrieves or creates a BilibiliUser based on the provided dedeuserid.\n\nThe code sets up a SQLite database for the Bilibili video platform by initializing an SqliteExtDatabase object with specified pragmas and creating required tables. The getBilibiliVideoDatabaseAndCreateTables function utilizes this setup, while the registerUser function handles user retrieval or creation based on dedeuserid.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/platforms/bilibili/database.py\":354-382",
            "content": "    db_dir = Path(getHomeDirectory()) / \".bilibili_video\"\n    if not os.path.exists(db_dir):\n        os.mkdir(db_dir)\n    db_path = db_dir / \"database.db\"  # sure this works?\n    # db = SqliteDatabase(db_path)\n    db = SqliteExtDatabase(\n        db_path, pragmas={\"journal_mode\": \"wal\", \"cache_size\": -1024 * 64}\n    )\n    # test the full text search function elsewhere. please?\n    return db\ndef getBilibiliVideoDatabaseAndCreateTables():\n    db = getBilibiliVideoDatabase()\n    db.create_tables([BilibiliUser, BilibiliVideo, BilibiliVideoIndex])\n    return db\n# no need to decorate this thing. only put some 'unchecked' video into array.\ndef registerUser(dedeuserid: str, is_mine: Union[bool, None] = None):\n    user_id = int(dedeuserid)\n    u = BilibiliUser.get_or_none(user_id=user_id)\n    if u is None:  # this is to create.\n        if is_mine is None:\n            is_mine = False\n        userObject = user.User(user_id)\n        userInfo = sync(userObject.get_user_info())\n        # print(userInfo)\n        # print(dir(userInfo))"
        },
        {
            "comment": "The code appears to be fetching user and video information from the Bilibili platform, handling updates for user profiles, and searching for videos based on a given query. It utilizes functions like `get_followers()`, `BilibiliUser.get_and_update_or_create()`, and `searchVideos()`. The code also includes a refresh status decorator, and handles user profile updates if the 'is_mine' flag changes.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/platforms/bilibili/database.py\":383-414",
            "content": "        # breakpoint()\n        # dict_keys(['list', 're_version', 'total'])\n        # in the 'list' we've got a few recent followers.\n        followersInfo = sync(userObject.get_followers())\n        username = userInfo[\"name\"]\n        followers = followersInfo[\"total\"]\n        avatar = userInfo[\"face\"]\n        (\n            u,\n            _,\n        ) = BilibiliUser.get_and_update_or_create(  # this is wrong. maybe the username is updated.\n            user_id=user_id,\n            username=username,\n            is_mine=is_mine,\n            followers=followers,\n            avatar=avatar,\n        )\n        # when to update? maybe later.\n    elif is_mine is not None and u.is_mine != is_mine:\n        u.is_mine = is_mine\n        u.save()\n    return u\n# @refresh_status_decorator\ndef searchVideos(\n    query: str,\n    iterate: bool = False,\n    page_start: int = 1,\n    params={\"duration\": BSP.all.duration._10\u5206\u949f\u4ee5\u4e0b},  # is that right? maybe?\n    page_size: int = ...,\n):  # what do you expect? you want the xml object let's get it!"
        },
        {
            "comment": "This code searches for results on Bilibili using the search_type parameter and query. It uses coroutines to get the result, then extracts and returns parsed data from the result. The function gets the result by calling a search API with specified parameters and retrieves the number of pages from the returned result.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/platforms/bilibili/database.py\":415-441",
            "content": "    # search the thing directly? or you distill keywords from it?\n    search_type = search.SearchObjectType.VIDEO\n    # or you use some baidu magic?\n    # anyway, let's begin.\n    # warning: this is coroutine.\n    # you might want some magic. with 'suppressException' and pickledFunction?\n    def getResultParsed(result):\n        mresult = pyjq.all(\n            \".result[] | {mid, author, pic, play, is_pay, duration, bvid, description, title, pubdate, tag, typename, typeid, review, favorites, danmaku, rank_score, like, upic} | select (.title != null and .bvid != null)\",\n            result,\n        )\n        return mresult\n    def getResult(page):\n        result = sync(\n            search.search_by_type(\n                query,\n                search_type,\n                params=params,\n                page=page,\n                **jsonify(dict(page_size=page_size)),\n            )\n        )\n        return result\n    result = getResult(page_start)\n    numPages = result[\"numPages\"]  # usually we select the topmost candidates."
        },
        {
            "comment": "The code is responsible for iterating through a range of pages, fetching data from each page, and processing the results. It also includes checks to see if persistence is required or if any selections need to be made. Additionally, it considers whether to remove keyword highlights from titles. The code may also handle potential errors or breakpoints with a `breakpoint()` statement.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/platforms/bilibili/database.py\":442-473",
            "content": "    # print(result)\n    if numPages < page_start:\n        page_start_current = 1\n    else:\n        page_start_current = page_start\n        mresult = getResultParsed(result)\n        for v in mresult:\n            yield v\n    if not iterate:\n        page_range = range(page_start_current, page_start_current + 1)\n    else:\n        import progressbar\n        print(f\"iterating page range: {page_start_current}-{numPages}\")\n        page_range = progressbar.progressbar(range(page_start_current, numPages + 1))\n    for page in page_range:\n        if page != page_start:\n            result = getResult(page)\n            mresult = getResultParsed(result)\n            for v in mresult:\n                yield v\n    # you can use the upic to render some deceptive ads, but better not?\n    # so you want to persist these results or not?\n    # better persist so we can reuse.\n    # no persistance?\n    # check some interesting result.\n    # no selection?\n    # you should use the parser found elsewhere. or not?\n    # breakpoint()\n    # remove keyword highlight from title. will you?"
        },
        {
            "comment": "This code is defining a function `checkVideoInDatabase` that takes a video bvid as input, initializes a Peewee database, creates tables for BilibiliVideo and BilibiliUser, and checks if the video already exists in the database. It returns True if the video is found, otherwise False.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/platforms/bilibili/database.py\":474-524",
            "content": "    # result['result'][0].keys()\n    # keys = [\n    #     \"type\",\n    #     \"id\",\n    #     \"author\",\n    #     \"mid\",\n    #     \"typeid\",\n    #     \"typename\",\n    #     \"arcurl\",\n    #     \"aid\",\n    #     \"bvid\",\n    #     \"title\",\n    #     \"description\",\n    #     \"arcrank\",\n    #     \"pic\",\n    #     \"play\",\n    #     \"video_review\",\n    #     \"favorites\",\n    #     \"tag\",\n    #     \"review\",\n    #     \"pubdate\",\n    #     \"senddate\",\n    #     \"duration\",\n    #     \"badgepay\",\n    #     \"hit_columns\",\n    #     \"view_type\",\n    #     \"is_pay\",\n    #     \"is_union_video\",\n    #     \"rec_tags\",\n    #     \"new_rec_tags\",\n    #     \"rank_score\",\n    #     \"like\",\n    #     \"upic\",\n    #     \"corner\",\n    #     \"cover\",\n    #     \"desc\",\n    #     \"url\",\n    #     \"rec_reason\",\n    #     \"danmaku\",\n    # ]\n    # rank score is important!\n# you need my credential!\n# better reuse the code.\ndef checkVideoInDatabase(bvid: str):\n    # we use peewee (of course our modified version)\n    db = getBilibiliVideoDatabase()\n    db.create_tables([BilibiliVideo, BilibiliUser])"
        },
        {
            "comment": "This code retrieves a BilibiliVideo object based on the provided bvid and typeid, updates or creates it if necessary, and fills in various attributes from the given video dictionary. The poster attribute is set to bilibiliUser, assuming it belongs to that user's account. The visible attribute is set to True by default, but this may need verification. The last_check timestamp is set to the current datetime, and the code attempts to fix the pic URL with a linkFixer function call.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/platforms/bilibili/database.py\":525-557",
            "content": "    result = BilibiliVideo.get_or_none(BilibiliVideo.bvid == bvid)\n    return result  # check it elsewhere?\n# get my videos first!\nimport math\n# @refresh_status_decorator\nfrom bilibili_api.user import VideoOrder\ndef indexAndGetVideoObject(\n    v, bilibiliUser\n):  # let's wrap this shit. eliminate those 'erroneous' display.\n    try:\n        v[\"typeid\"] = int(v[\"typeid\"])\n    except:\n        pass\n    favdict = {}\n    favorites = v.get(\"favorites\", None)\n    if favorites is not None:\n        favdict[\"favorites\"] = favorites\n    bilibiliVideo, flag = BilibiliVideo.get_and_update_or_create(\n        bvid=v[\"bvid\"],\n        typeid=v[\"typeid\"],\n        visible=True,  # are you sure?\n        last_check=datetime.datetime.now(),  # well this is not tested. test it!\n        poster=bilibiliUser,  # is it my account anyway?\n        play=v[\"play\"],\n        pic=linkFixer(v[\"pic\"]),\n        length=videoDurationStringToSeconds(v.get(\"length\", v.get(\"duration\"))),\n        review=v.get(\"comment\", v.get(\"review\")),\n        pubdate=v.get(\"created\", v.get(\"pubdate\")),"
        },
        {
            "comment": "The code retrieves a user's videos from Bilibili and processes them, updating the database with the video information. It also provides options for filtering and pagination.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/platforms/bilibili/database.py\":558-592",
            "content": "        description=v[\"description\"],\n        title=clearHtmlTags(v[\"title\"]),  # it may contain highlights. be warned\n        tag=v[\"tag\"],\n        **favdict,\n        # _debug=True\n    )\n    # print(\"f\", flag)\n    # print(v)\n    # print(bilibiliUser)\n    # breakpoint()\n    bilibiliVideoIndex, _ = BilibiliVideoIndex.get_and_update_or_create(\n        rowid=bilibiliVideo.id,\n        description=textPreprocessing(bilibiliVideo.description),\n        tag=textPreprocessing(bilibiliVideo.tag),\n        title=textPreprocessing(bilibiliVideo.title),\n    )\n    return bilibiliVideo\ndef getUserVideos(\n    tid=0,\n    keyword=\"\",\n    order=VideoOrder.PUBDATE,\n    dedeuserid: str = \"397424026\",\n    use_credential: bool = False,\n    stop_on_duplicate: bool = True,\n    sleep: int = 2,\n    page_num: int = 1,\n    page_size: int = 30,\n):  # all videos? just at init.\n    pn = page_num\n    # some stop condition for early termination.\n    # if any of the video exists in the database, we stop this shit.\n    bilibiliUser = registerUser(\n        dedeuserid,"
        },
        {
            "comment": "This code is retrieving videos from the Bilibili platform, using a specific user object and various parameters such as pagination and keyword. It fetches data in pages and calculates the number of pages based on the total count of videos. The code handles pagination and possibly retrieves topic information based on different categories (tid).",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/platforms/bilibili/database.py\":593-612",
            "content": "    )\n    u = getUserObject(dedeuserid=dedeuserid, use_credential=use_credential)\n    # tid\tint, optional\t\u5206\u533a ID. Defaults to 0\uff08\u5168\u90e8\uff09\n    # pn\tint, optional\t\u9875\u7801\uff0c\u4ece 1 \u5f00\u59cb. Defaults to 1.\n    # ps\t(int, optional)\t\u6bcf\u4e00\u9875\u7684\u89c6\u9891\u6570. Defaults to 30.\n    # keyword\tstr, optional\t\u641c\u7d22\u5173\u952e\u8bcd. Defaults to \"\".\n    # order\tVideoOrder, optional\t\u6392\u5e8f\u65b9\u5f0f. Defaults to VideoOrder.PUBDATE\n    # this is async. use sync.\n    stopped = False\n    while not stopped:\n        videos = sync(\n            u.get_videos(pn=pn, keyword=keyword, tid=tid, order=order, ps=page_size)\n        )\n        # print(videos)\n        # dict_keys(['list', 'page', 'episodic_button', 'is_risk', 'gaia_res_type', 'gaia_data'])\n        page = videos[\"page\"]  # pagination options\n        numPages = math.ceil(page[\"count\"] / page[\"ps\"])\n        # print('NUM PAGES',numPages)\n        # topicDict = videos[\"list\"][\"tlist\"]\n        # {'1': {'tid': 1, 'count': 13, 'name': '\u52a8\u753b'}, '160': {'tid': 160, 'count': 257, 'name': '\u751f\u6d3b'}, '181': {'tid': 181, 'count': 2, 'name': '\u5f71\u89c6'}, '188': {'t"
        },
        {
            "comment": "The code is iterating through a list of videos and for each video, it updates the tag string using getTagStringFromTid function. Then, it checks if the video already exists in the database using checkVideoInDatabase function. If the video is found and stop_on_duplicate is True, the loop breaks and stopped is set to True.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/platforms/bilibili/database.py\":612-628",
            "content": "id': 188, 'count': 4, 'name': '\u79d1\u6280'}, '217': {'tid': 217, 'count': 4, 'name': '\u52a8\u7269\u5708'}, '234': {'tid': 234, 'count': 1, 'name': '\u8fd0\u52a8'}, '3': {'tid': 3, 'count': 9, 'name': '\u97f3\u4e50'}, '36': {'tid': 36, 'count': 30, 'name': '\u77e5\u8bc6'}, '4': {'tid': 4, 'count': 67, 'name': '\u6e38\u620f'}}\n        # breakpoint()\n        video_list = videos[\"list\"][\"vlist\"]\n        # breakpoint()\n        if video_list == []:\n            break\n        for v in video_list:\n            bvid = v[\"bvid\"]\n            subTypeId = v[\"typeid\"]\n            tagString = getTagStringFromTid(subTypeId)\n            v.update({\"tag\": tagString})\n            result = checkVideoInDatabase(bvid)\n            if result and stop_on_duplicate:\n                stopped = True\n                break\n            # print(v)\n            # dict_keys(['comment', 'typeid', 'play', 'pic', 'subtitle', 'description', 'copyright', 'title', 'review', 'author', 'mid', 'created', 'length', 'video_review', 'aid', 'bvid', 'hide_click', 'is_pay', 'is_union_video', 'is_steins_gate', 'is_live_playback'])"
        },
        {
            "comment": "This code appears to be part of a larger program responsible for interacting with the Bilibili platform's database. It utilizes functions like `indexAndGetVideoObject`, `getMajorMinorTopicMappings`, and `resolveSubTidsFromTid`. The main functionality seems to involve looping through pages of videos, obtaining video objects, and resolving subtopic IDs from a given topic ID. There is also a mechanism for handling duplicate or redundant data and an optional sleep function to control the speed at which the program retrieves information.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/platforms/bilibili/database.py\":629-652",
            "content": "            # breakpoint()\n            # bad idea. you should get the bilibiliUser before you do this.\n            bilibiliVideo = indexAndGetVideoObject(v, bilibiliUser)\n            yield bilibiliVideo\n        # videos['list']['vlist'][0].keys()\n        # dict_keys(['comment', 'typeid', 'play', 'pic', 'subtitle', 'description', 'copyright', 'title', 'review', 'author', 'mid', 'created', 'length', 'video_review', 'aid', 'bvid', 'hide_click', 'is_pay', 'is_union_video', 'is_steins_gate', 'is_live_playback'])\n        if pn >= numPages:\n            break\n        elif not stop_on_duplicate:\n            break  # this is the hint of merely using this as a search tool\n        time.sleep(sleep)\n        pn += 1\n# cannot resolve 217?\ndef resolveSubTidsFromTid(tid: int):\n    if type(tid) != int:\n        tid = int(tid)\n    MMTM = getMajorMinorTopicMappings()\n    allTids = [t for t in MMTM.keys() if type(t) == int]\n    if tid == 0:\n        return allTids\n    elif tid not in allTids:\n        raise Exception(\"Invalid tid: %d\" % tid)"
        },
        {
            "comment": "Code resolves subtopics from a given topic ID and returns a list of associated topic IDs. It checks if the topic is major or minor, then searches for subtopics related to the main topic. Finally, it adds the subtopic's minor topic IDs to the list. This function can be used to find videos related to specific keywords within registered topics and return a result list based on video order preference.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/platforms/bilibili/database.py\":653-685",
            "content": "    else:\n        myTids = set()\n        myTids.add(tid)\n        # print(\"ALL TIDS?\")\n        # import rich\n        # rich.print(allTids)\n        # rich.print(MMTM)\n        myTopic = MMTM[tid]\n        # myTopic = allTids[tid]\n        if myTopic.get(\"minor\", None) == None:\n            # this is a major topic\n            for t in allTids:\n                subTopic = MMTM[t]\n                if subTopic.get(\"major\", {}).get(\"tid\", None) == tid:\n                    subTid = subTopic.get(\"minor\", {}).get(\"tid\", tid)\n                    myTids.add(subTid)\n        return list(myTids)\ndef searchRegisteredVideosAndGetResultList(\n    keyword: str,\n    tid: int = 0,\n    dedeuserid: Union[str, None, list[str]] = \"397424026\",\n    videoOrder=VideoOrder.PUBDATE,  # FAVOURITE, VIEW\n    page_num: int = 1,\n    page_size: int = 10,\n):\n    resultList = []\n    resolvedTids = resolveSubTidsFromTid(tid)\n    condition = (BilibiliVideo.typeid in resolvedTids) & (BilibiliVideo.visible == True)\n    if dedeuserid is not None:\n        if type(dedeuserid) == str:"
        },
        {
            "comment": "This code retrieves bilibili videos based on a given condition. It takes into account dedeuserids, which are either provided as a list or None. If dedeuserids is not None, it applies the condition to filter the videos by specific users. Finally, it sorts and selects the videos based on favorites, pubdate, and view count.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/platforms/bilibili/database.py\":686-715",
            "content": "            dedeuserids = [dedeuserid]\n        else:\n            dedeuserids = dedeuserid\n        dedeuserids = [int(d) for d in dedeuserids]\n    else:\n        dedeuserids = None\n        # print(\"DEDEUSERIDS:\", dedeuserids)\n    # vlist = [v for v in (BilibiliVideo.select().where(condition) or [])]\n    # http://docs.peewee-orm.com/en/latest/peewee/relationships.html#relationships\n    def getVgen(selector, videoOrder):\n        nonlocal condition, dedeuserids\n        vgen = selector\n        # breakpoint()\n        if dedeuserids:\n            from functools import reduce\n            condition &= reduce(\n                lambda a, b: a | b,\n                [BilibiliUser.user_id == int(userid) for userid in dedeuserids],\n            )\n            vgen = vgen.join(BilibiliUser).where(\n                condition\n            )  # this statement does not work.\n        else:\n            vgen = vgen.where(condition)\n        favorites = BilibiliVideo.favorites\n        pubdate = BilibiliVideo.pubdate\n        view = BilibiliVideo.play"
        },
        {
            "comment": "The code retrieves videos based on a specified ordering (favorites, view count, or publication date) and performs a search using the BM25 algorithm. It then paginates the results and retrieves additional information for each video by calling `BilibiliVideo.get()`. The code also includes a comment indicating that reordering might be necessary in the future.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/platforms/bilibili/database.py\":716-741",
            "content": "        if videoOrder == VideoOrder.FAVORITE:  # this is fake ordering.\n            order = favorites.desc()  # desc\n        elif videoOrder == VideoOrder.VIEW:\n            order = view.desc()  # desc\n        elif videoOrder == VideoOrder.PUBDATE:  # also desc.\n            order = pubdate.desc()  # most recent video.\n        else:\n            order = None\n        if order is not None:\n            vgen = vgen.order_by(order)\n        return vgen\n    # user_video_ids = [v.id for v in vgen or []]\n    # print('user of videos',set([v.poster.user_id for v in vgen or []]))\n    # breakpoint()\n    results = getVgen(\n        BilibiliVideoIndex.search_bm25(keyword).join(\n            BilibiliVideo, on=(BilibiliVideoIndex.rowid == BilibiliVideo.id)\n        ),\n        videoOrder,\n    ).paginate(  # again this is wrong.\n        page_num, page_size\n    )\n    for index, video_index in enumerate(results):\n        bilibiliVideo = BilibiliVideo.get(id=video_index.rowid)  # this shall be fast.\n        # what is the count? you need to reorder?"
        },
        {
            "comment": "This code defines functions for searching registered and user videos on Bilibili. The functions take a keyword, video order, tid, dedeuserid, page number, and page size as parameters. It searches for videos based on the provided parameters and returns a list of bilibiliVideoIndex objects along with their orders.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/platforms/bilibili/database.py\":742-777",
            "content": "        # bvid = bilibiliVideo.bvid\n        # cover = bilibiliVideo.pic\n        order = None\n        # you should return the video_index.\n        resultList.append((bilibiliVideo, order))\n    # resultList.sort(key=lambda x: x[1])\n    return resultList\ndef searchRegisteredVideos(\n    keyword: str,\n    tid: int = 0,\n    dedeuserid: Union[list[str], str, None] = \"397424026\",\n    videoOrder=VideoOrder.PUBDATE,  # FAVOURITE, VIEW\n    page_num: int = 1,\n    page_size: int = 30,\n):\n    resultList = searchRegisteredVideosAndGetResultList(\n        tid=tid,\n        dedeuserid=dedeuserid,\n        videoOrder=videoOrder,\n        page_num=page_num,\n        page_size=page_size,\n        keyword=keyword,\n    )\n    for v, _ in resultList:\n        yield v  # this is bilibiliVideoIndex, but you also needs the bvid.\ndef searchUserVideos(\n    keyword: str,\n    tid: int = 0,\n    dedeuserid: str = \"397424026\",\n    method: Literal[\"online\", \"bm25\"] = \"online\",\n    use_credential: bool = False,\n    videoOrder=VideoOrder.PUBDATE,  # FAVOURITE, VIEW"
        },
        {
            "comment": "The code performs a hybrid search for videos, combining metatopic and BM25 search algorithms, to find the most relevant results based on a given keyword. It also retrieves video information and stores it in a list for further processing or display.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/platforms/bilibili/database.py\":778-805",
            "content": "    page_num: int = 1,\n    page_size: int = 30,\n):  # you can support this in database?\n    # you want keyword search or not? it's better than searching in database. i think.\n    # but database search saves bandwidth.\n    # better use semantic search. but now we use hybrid search instead.\n    # hybrid search: metatopic plus bm25\n    # or not?\n    # just dump that shit.\n    # check if keyword overlaps.\n    # how to search my video? and how to measure relevance?\n    if method == \"online\":\n        resultList = []\n        order = None\n        for v in getUserVideos(\n            tid=tid,\n            order=videoOrder,\n            keyword=keyword,\n            dedeuserid=dedeuserid,\n            use_credential=use_credential,\n            stop_on_duplicate=False,\n            page_num=page_num,\n            page_size=page_size,\n        ):\n            # what is the content? plan to update?\n            # print(\"SEARCHED USER VIDEO ID:\", v_id)\n            resultList.append((v, order))\n        # info = u.get_videos(keyword=keyword,order=videoOrder)"
        },
        {
            "comment": "The code is performing a search for registered videos on Bilibili platform, utilizing the BM25 search algorithm. It returns the video results without any limitations and allows for further processing like excerpt generation to attract viewers. The code also includes functions for getting video information and registering user videos with optional visibility settings.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/platforms/bilibili/database.py\":806-836",
            "content": "    elif method == \"bm25\":\n        # export all video? shit?\n        # you should tokenize the thing.\n        # but this search does not have limitations!\n        resultList = searchRegisteredVideosAndGetResultList(\n            tid=tid,\n            dedeuserid=dedeuserid,\n            videoOrder=videoOrder,\n            page_num=page_num,\n            page_size=page_size,\n            keyword=keyword,\n        )\n    for v, _ in resultList:\n        yield v  # this is bilibiliVideoIndex, but you also needs the bvid.\n# you can make excerpt from video to lure people into viewing your video.\ndef getVideoInfo(bvid: str):\n    v = video.Video(bvid=bvid)\n    info = sync(v.get_info())\n    return info\ndef registerUserVideo(\n    bvid: str,\n    dedeuserid: str,\n    is_mine: bool = False,\n    visible: bool = False,  # no checking on video visibility? maybe we need to do this after search.\n):  # this is the video i just post. must be regularly checked then add to candidate list. you can check it when another call for my videos has been issued."
        },
        {
            "comment": "This code is responsible for checking the visibility of a bilibili video. It first checks if the user and video are registered in the database, and then fetches the video information to determine its state. If the state is 0, the video is considered visible; otherwise, it's invisible. In case of an error during the process, the debug parameter can be used to print the exception for further investigation. The code also includes a function to register user and video in the database, and another function for checking if a video has been registered before. The grace period for checking video visibility is set to one day, but it suggests that more experimentation might be needed to optimize this duration.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/platforms/bilibili/database.py\":837-868",
            "content": "    # register user first, then register the video.\n    # you will store it to database.\n    u = registerUser(dedeuserid, is_mine)\n    # check if exists.\n    v = BilibiliVideo.get_or_none(BilibiliVideo.bvid == bvid)\n    new = v is None\n    if new:\n        BilibiliVideo.create(bvid=bvid, visible=visible, poster=u)  # it must be new.\n    return new\n# grace period to be one day. that's long enough. or not?\n# we still need some more experiment.\ndef checkVideoVisibility(bvid: str, debug: bool = False):\n    visible = False  # you might want some 'err' parameter. but that only indicates inavalibility of certain video, not video flagged as permanently invisible.\n    try:\n        info = getVideoInfo(bvid)  # getting shit? we need some normal video for test.\n        state = info[\"state\"]\n        visible = state == 0\n    except:\n        if debug:\n            import traceback\n            traceback.print_exc()\n            print(\"error when checking video status: %s\" % bvid)\n    return visible\n# check api doc for hint.\ndef checkRegisteredVideo("
        },
        {
            "comment": "Checks if a video is published or not by comparing its registration date and last check time with the given grace period and check interval. If needed, it calls `checkVideoVisibility` function to verify visibility.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/platforms/bilibili/database.py\":869-891",
            "content": "    bvid: str,\n    grace_period=datetime.timedelta(days=1),\n    check_interval=datetime.timedelta(hours=1),\n):  # maybe the video is not immediately visible after registration.\n    # check if they are published or not.\n    # ____CI____CI____CI____ (before check video info. decide to check or not.)\n    # __________GP__________ (after check video info. decide to delete or not.)\n    published = False\n    bilibiliVideo = BilibiliVideo.get_or_none(bvid=bvid)\n    now = datetime.datetime.now()\n    needCheck = False\n    if bilibiliVideo:\n        visible = bilibiliVideo.visible\n        needCheck = now - bilibiliVideo.last_check >= check_interval\n        needRemove = now - bilibiliVideo.register_date >= grace_period\n        if (\n            visible and needRemove\n        ):  # do not remove. it just need to be check again, when using checkPublishedVideo. this value is used for double check.\n            published = True\n        else:\n            if needCheck:\n                visible = checkVideoVisibility(bvid)\n                if visible:"
        },
        {
            "comment": "This code is for a database platform, specifically Bilibili. It checks if videos are still visible or taken down and deletes them if not. The code updates 'last_check' and compares it with 'checkin_date', scheduling check every hour. It also mentions that Bilibili automatically categorizes videos, and this function is used during retrieval to find out how it does so.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/platforms/bilibili/database.py\":892-909",
            "content": "                    published = True\n                elif needRemove:\n                    bilibiliVideo.delete_instance()\n    # you update that 'last_check' and compare it with 'checkin_date'\n    # you can schedule check every hour. not all the time.\n    # basically the same thing. but we do not delete these video till the time is too late, after check.\n    return published, not needCheck\n# seems bilibili can automatically categorize video.\n# we just need to find out how?\ndef checkPublishedVideo(bvid: str):  # this is only done during retrieval.\n    # if published, the video is taken down afterwards, we will delete it.\n    # check if video is still visible or taken down.\n    # if video is not visible then we delete this video from database.\n    # v = video.Video(bvid=bvid)\n    # print(info)\n    # dict_keys(['bvid', 'aid', 'videos', 'tid', 'tname', 'copyright', 'pic', 'title', 'pubdate', 'ctime', 'desc', 'desc_v2', 'state', 'duration', 'forward', 'rights', 'owner', 'stat', 'dynamic', 'dimension', 'pre"
        },
        {
            "comment": "Checking if a Bilibili video with the given bvid exists and is available. If it exists, checks if it has been published or needs further checking. If unpublished or visibility issues, deletes the entry in the database.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/platforms/bilibili/database.py\":909-932",
            "content": "miere', 'teenage_mode', 'is_chargeable_season', 'is_story', 'no_cache', 'subtitle', 'is_season_display', 'user_garb', 'honor_reply', 'like_icon'])\n    #  'state': -4,\n    # bad state! what is the meaning of this state?\n    # normal; state -> 0\n    avaliable = False\n    bilibiliVideo = BilibiliVideo.get_or_none(bvid=bvid)\n    if (\n        bilibiliVideo is not None\n    ):  # might be our 'registered' video but not yet been published.\n        published, needCheckAgain = checkRegisteredVideo(bvid)\n        if published:\n            if not needCheckAgain:\n                published = True\n            else:\n                visible = checkVideoVisibility(bvid)\n                avaliable = visible\n                if not visible:\n                    # remove that thing.\n                    bilibiliVideoIndex = BilibiliVideo.get_or_none(\n                        rowid=bilibiliVideo.id\n                    )\n                    bilibiliVideo.delete_instance()\n                    if bilibiliVideoIndex is not None:\n                        # remove that thing."
        },
        {
            "comment": "This code deletes a bilibiliVideoInstance if it's not registered, otherwise updates the last_check and makes it visible. If something goes wrong, it doesn't return state, and suggests using SQLAlchemy for more complex tasks. The function allows searching and registering videos, with optional parameters like query, iterate, page_start, and params. It mentions testing the code with a random video and recommends writing a server (not FastAPI).",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/platforms/bilibili/database.py\":933-962",
            "content": "                        bilibiliVideoIndex.delete_instance()\n                else:\n                    bilibiliVideo.last_check = datetime.datetime.now()\n                    bilibiliVideo.visible = True\n                    bilibiliVideo.save()\n    else:\n        print(\"video %s is not registered.\" % bvid)\n    # info['stat'].keys()\n    # dict_keys(['aid', 'view', 'danmaku', 'reply', 'favorite', 'coin', 'share', 'now_rank', 'his_rank', 'like', 'dislike', 'evaluation', 'argue_msg'])\n    # breakpoint()\n    # if anything goes wrong, do not return the state.\n    # if you want update, better do it here. we are checking and updating the video.\n    # we use some random video for test.\n    return avaliable\n# i suggest you to use sqlalchemy. since this is no ordinary task.\n# you cannot just check every video of your own in the past.\n## following code is for test purpose.\n# shall write some server.\n# not fastapi!\ndef searchAndRegisterVideos(\n    query: str,\n    iterate: bool = False,\n    page_start: int = 1,\n    params={\"duration\": BSP.all.duration._10\u5206\u949f\u4ee5\u4e0b},"
        },
        {
            "comment": "This code searches videos based on a query and iterate parameter, retrieves results, and establishes a database connection elsewhere. It then iterates through the results, gets or creates BilibiliUser objects, indexes and retrieves video objects for each result, and potentially updates or creates BilibiliVideo objects.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/platforms/bilibili/database.py\":963-989",
            "content": "    # 'order': BSP.all.order.\u7efc\u5408\u6392\u5e8f\n    # # you can add this parameter later on.\n    page_size: int = ...,\n):\n    results = searchVideos(\n        query,\n        iterate=iterate,\n        page_start=page_start,\n        params=params,\n        page_size=page_size,\n    )\n    # db = getBilibiliVideoDatabaseAndCreateTables()\n    # this database connection will be established elsewhere.\n    for v in results:  # shall you called them 'tags' instead of 'tag'.\n        # print(v)\n        # breakpoint()\n        mid, author, upic = v[\"mid\"], v[\"author\"], v[\"upic\"]\n        bilibiliUser, _ = BilibiliUser.get_and_update_or_create(\n            username=author, user_id=mid, avatar=linkFixer(upic)\n        )\n        # v.update({'comment':v['review'],'created':v['pubdate']})\n        bilibiliVideo = indexAndGetVideoObject(v, bilibiliUser)\n        # bilibiliVideo, _ = BilibiliVideo.get_and_update_or_create(\n        #     bvid=v[\"bvid\"],\n        #     typeid=v[\"typeid\"],\n        #     visible=True,  # are you sure?\n        #     last_check=datetime.datetime.now(),  # well this is not tested. test it!"
        },
        {
            "comment": "This code is retrieving video information from a generator and creating a list of BilibiliVideo objects. It then returns this list after extracting video information from each object in the generator. The get_and_update_or_create function updates or creates a new BilibiliVideoIndex record based on the description, tag, and title fields. The searchVideosByForm function searches for videos using a provided form and a default page size of 30.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/platforms/bilibili/database.py\":990-1018",
            "content": "        #     poster=bilibiliUser,  # is it my account anyway?\n        #     play=v[\"play\"],\n        #     pic=linkFixer(v[\"pic\"]),\n        #     length=videoDurationStringToSeconds(v[\"duration\"]),\n        #     review=v[\"review\"],\n        #     pubdate=v[\"pubdate\"],\n        #     favorites=v[\"favorites\"],\n        #     description=v[\"description\"],\n        #     title=v[\"title\"],\n        #     tag=v[\"tag\"],\n        # )\n        # bilibiliVideoIndex, _ = BilibiliVideoIndex.get_and_update_or_create(\n        #     rowid=bilibiliVideo.id,\n        #     description=textPreprocessing(bilibiliVideo.description),\n        #     tag=textPreprocessing(bilibiliVideo.tag),\n        #     title=textPreprocessing(bilibiliVideo.title),\n        # )\n        yield bilibiliVideo\n# @reloading\ndef getVideoInfosFromVideoGenerator(vgen):\n    vlist = []\n    for v in vgen:\n        if type(v) == BilibiliVideo:\n            vlist.append(v.videoInfoExtractor())\n    return vlist\ndef searchVideosByForm(form:searchUserVideoForm, default_page_size:int=30):"
        },
        {
            "comment": "This code defines functions for searching videos and refreshing the latest video status of a user. The 'searchVideosByForm' function takes search parameters and returns a list of video information. 'refresh_latest_video_of_user' searches for the latest online video of a specified user. In 'refresh_status', the code loops through a list of target users, refreshes their latest video status, and handles exceptions with sleep and error printing. The code seems to be part of a larger system that requires database interaction to select and update records.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/platforms/bilibili/database.py\":1019-1052",
            "content": "    vgen = searchUserVideos(\n        form.query_for_search,\n        form.tid,\n        form.dedeuserid,\n        form.method,\n        form.use_credential,\n        form.videoOrder,\n        form.page_num,\n        default(form.page_size, default_page_size),\n    )\n    videoInfos = getVideoInfosFromVideoGenerator(vgen)\n    return videoInfos\ndef refresh_latest_video_of_user(uid: int):  # must be online.\n    form = searchUserVideoForm(method=\"online\", tid=0, query=\"\", dedeuserid=str(uid))\n    videoInfos = searchVideosByForm(form)\ndef refresh_status(\n    grace_period=datetime.timedelta(days=1),\n    check_interval=datetime.timedelta(hours=1),\n    sleep: int = 2,\n    target_user_uids: list[int] = [397424026],\n):\n    for uid in target_user_uids:\n        try:\n            refresh_latest_video_of_user(uid)\n            time.sleep(sleep)\n        except:\n            import traceback\n            traceback.print_exc()\n            print(f\"Failed to refresh latest video status of user {uid}\")\n    # what to do? just select and update?\n    # but you need the database object. it is loop dependency!"
        },
        {
            "comment": "This function initializes a database and checks for invisible Bilibili videos, updating their status after a day of invisibility. It uses progressbar to track progress and sleep for a brief period between iterations. The getBilibiliVideoDatabaseCreateTablesAndRefreshStatus function creates tables and calls the refresh_status decorator on another function.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/platforms/bilibili/database.py\":1053-1081",
            "content": "    # well we can split the function.\n    # just for initialization?\n    now_minus_check_interval = datetime.datetime.now() - check_interval\n    selector = BilibiliVideo.select(BilibiliVideo.bvid).where(\n        (BilibiliVideo.last_check < now_minus_check_interval)\n        & (\n            BilibiliVideo.visible == False\n        )  # only check invisible videos. invisible videos will be removed after 1 day of inavaliability.\n    )  # need check or not?\n    print(\"refreshing video status\")\n    for bvid in progressbar.progressbar(selector):\n        checkRegisteredVideo(\n            bvid, grace_period=grace_period, check_interval=check_interval\n        )\n        time.sleep(sleep)\n    return\ndef refresh_status_decorator(func):\n    def wrapper(*args, **kwargs):\n        schedule.run_pending()\n        return func(*args, **kwargs)\n    return wrapper\n@refresh_status_decorator  # this might prevent you adding the decorator everywhere?\ndef getBilibiliVideoDatabaseCreateTablesAndRefreshStatus():\n    db = getBilibiliVideoDatabaseAndCreateTables()"
        },
        {
            "comment": "The code initializes the Bilibili video database, sets up a scheduler to refresh the status periodically, and creates a FastAPI application for serving a recommendation server with a welcome message route (\"/\") and a search route (\"/searchVideos\"). The search route accepts a POST request with parameters.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/platforms/bilibili/database.py\":1082-1122",
            "content": "    return db\n# somewhere here:\n# https://fastapi.tiangolo.com/es/tutorial/debugging/\n@lru_cache(maxsize=1)\ndef bootstrap():\n    db = getBilibiliVideoDatabaseAndCreateTables()\n    refresh_status()  # ensure the database is connected.\n    schedule.every(20).minutes.do(refresh_status)\ndef bilibiliRecommendationServer(\n    welcome_message=\"bilibili recommendation server\", port=7341\n):\n    bootstrap()\n    from fastapi import FastAPI\n    import uvicorn\n    import pydantic\n    app = FastAPI()\n    @app.get(\"/\")\n    # #@reloading\n    def server_hello():\n        schedule.run_pending()\n        return welcome_message\n    # just asking. post or get?\n    @app.post(\"/searchVideos\")  # what do you want to have? all fields?\n    # #@reloading\n    def search_videos(form: searchVideoForm):\n        # print('received params:',params) # it is str.\n        # breakpoint()\n        schedule.run_pending()\n        params = {\n            \"duration\": BSP.all.duration._10\u5206\u949f\u4ee5\u4e0b\n        } | form.params  # this is default parameter.\n        # breakpoint()"
        },
        {
            "comment": "This code appears to contain various endpoints for searching and registering videos on a platform. It utilizes form data to query for specific search results, and then retrieves the video information from the generated video generators. It also schedules tasks and handles different types of video forms.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/platforms/bilibili/database.py\":1123-1156",
            "content": "        vgen = searchAndRegisterVideos(\n            form.query_for_search,\n            iterate=form.iterate,\n            page_start=form.page_num,\n            params=params,\n            page_size=default(form.page_size, ...),\n        )\n        videoInfos = getVideoInfosFromVideoGenerator(vgen)\n        return videoInfos\n    @app.post(\"/searchRegisteredVideos\")\n    # #@reloading\n    def search_registered_videos(form: searchRegisteredVideoForm):\n        schedule.run_pending()\n        vgen = searchRegisteredVideos(\n            form.query_for_search,\n            form.tid,\n            form.dedeuserid,\n            form.videoOrder,\n            form.page_num,\n            default(form.page_size, 30),\n        )\n        videoInfos = getVideoInfosFromVideoGenerator(vgen)\n        return videoInfos\n    @app.post(\"/searchUserVideos\")\n    # #@reloading\n    def search_user_videos(form: searchUserVideoForm):\n        schedule.run_pending()\n        videoInfos = searchVideosByForm(form)\n        return videoInfos\n    @app.post(\"/registerUserVideo\")"
        },
        {
            "comment": "This code registers a user video on Bilibili platform. It utilizes the registerUserVideoForm to store necessary information, schedules pending tasks for execution, and prints details if the registration is successful or not. The code also runs the Uvicorn server for the application, specifying the host and port. If this file is executed directly, it calls bilibiliRecommendationServer() function.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/platforms/bilibili/database.py\":1157-1177",
            "content": "    # #@reloading\n    def register_user_video(form: registerUserVideoForm):\n        schedule.run_pending()\n        new = registerUserVideo(form.bvid, form.dedeuserid, form.is_mine, form.visible)\n        if new:\n            print(\"----\")\n            print(\"registered user video:\", form.bvid)\n            print(\"user:\", form.dedeuserid)\n            print(\"is_mine:\", form.is_mine)\n            print(\"visible:\", form.visible)\n            print(\"----\")\n        else:\n            print(\"video already registered.\")\n        return {\"is_new\": new}\n    uvicorn.run(app, host=\"0.0.0.0\", port=port)\nif __name__ == \"__main__\":\n    bilibiliRecommendationServer()"
        }
    ]
}