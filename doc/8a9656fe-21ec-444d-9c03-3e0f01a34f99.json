{
    "summary": "This Python script utilizes yt-dlp and Bilibili API to retrieve bilibili video metadata, unique identifiers, and related info. Error handling is needed for missing tags.",
    "details": [
        {
            "comment": "This code retrieves video metadata from bilibili, a Chinese video hosting platform. It uses various video link formats and extracts unique identifiers (BVID or AID) to obtain metadata for further filtering unwanted videos. The code also imports relevant libraries and defines two functions to extract BVID and AID from the video links.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tests/anime_highlight_cuts/theme_collector/anime_compilation_video_metadata.py\":0-30",
            "content": "# get video metadata first. we may filter unwanted videos by metadata.\n# let's just view here:\n# https://github.com/SocialSisterYi/bilibili-API-collect\n# i found new format of video shortlink:\n# https://b23.tv/BV1zW4y1p7RT\n# https://b23.tv/<bvid>\nvideoLinks = [\n    \"https://www.bilibili.com/video/BV1e54y1y7qy\",  # \u5973\u653b\u7537\u53d7 emm\n    \"https://www.bilibili.com/video/BV1P441197oV\",  # in which you shall never find anything interesting. no related video.\n    \"https://www.bilibili.com/video/BV1Fs411k7e9\", # multiple chapters, you shall not find this interesting.\n    \"https://www.bilibili.com/video/av5842509\" # aid version of video link.\n]\n# import fake_useragent\n# ua = fake_useragent.UserAgent()\nimport re\nfrom pymaybe import maybe\nimport requests\nfrom urllib.parse import urlencode\ndef extractBVID(chars:str):\n    bvid = maybe(re.findall(r\"/(BV[a-zA-Z0-9]+)\",chars))[0]\n    return bvid\ndef extractAID(chars:str):\n    aid = maybe(re.findall(r\"/av([0-9]+)\",chars))[0]\n    return aid\n## remember the video is always scrapable via av id."
        },
        {
            "comment": "The code is trying to collect metadata for Bilibili videos using APIs and may download the video if needed. It first checks if there is a valid BVID or AID, then retrieves the video's metadata and possibly related tags. However, it encounters issues with determining the source and currently has a workaround using yt-dlp to get metadata but notes that this method isn't working properly.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tests/anime_highlight_cuts/theme_collector/anime_compilation_video_metadata.py\":31-65",
            "content": "## av5842509\n# https://api.bilibili.com/x/web-interface/view?aid=<AID>\n# https://api.bilibili.com/x/web-interface/view?bvid=<BVID>\n# videoDownloadPath = \"\"\n# shit!\n# why i need to download whole damn video? i need to cut it into bite-sized video!\n# for some video there's no possibility to determine the source.\n# let's see the video metadata.\n# import os\n# os.system(f'yt-dlp --dump-metadata --output metadata.json \"{videoLinks[0]}\"') # working?\n# bullshit. we shall get the video metadata first.\nurl = \"https://api.bilibili.com/x/web-interface/view\"\ntags_url = \"https://api.bilibili.com/x/tag/archive/tags\"\nrelated_url = \"https://api.bilibili.com/x/web-interface/archive/related\"\nfor videoLink in videoLinks:\n    bvid = extractBVID(videoLink)\n    if bvid:\n        params = {\"bvid\": bvid}\n    else:\n        aid = extractAID(videoLink)\n        if aid:\n            params = {\"aid\": aid}\n        else:\n            print(\"no valid bilibili video id found.\")\n            print(\"skipping video link:\", videoLink)\n            continue"
        },
        {
            "comment": "This code retrieves video metadata from Bilibili API using Python's `requests` library. It makes three separate requests for the video, tags, and related videos data. The responses are then parsed to extract relevant information such as video title, and the JSON responses are validated to ensure a successful response with status code 0.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tests/anime_highlight_cuts/theme_collector/anime_compilation_video_metadata.py\":67-96",
            "content": "    # print(\"PARAMS?\",params)\n    # shit.\n    r = requests.get(f\"{url}?{urlencode(params)}\") # why? what the fuck?\n    r_tags = requests.get(f\"{tags_url}?{urlencode(params)}\")\n    # r = requests.get(url,data=params,headers={\"User-Agent\":ua.random})\n    r_related = requests.get(f'{related_url}?{urlencode(params)}')\n    # r = requests.get(\"https://api.bilibili.com/x/web-interface/view?bvid=BV1e54y1y7qy\")\n    r.raise_for_status()\n    r_tags.raise_for_status()\n    r_related.raise_for_status()\n    # \"need_jump_bv\":false\n    # bvid only?\n    response_json = r.json()\n    response_tags_json = r_tags.json()\n    response_related_json = r_related.json()\n    # it must be json.\n    import rich\n    # rich.print(response_json)\n    assert response_json['code'] == 0\n    assert response_tags_json['code'] == 0\n    assert response_related_json['code'] == 0\n    data = response_json['data']\n    tags_data = response_tags_json['data']\n    related_data = response_related_json['data']\n    ## parsing video stats.\n    title = data['title']"
        },
        {
            "comment": "This code is fetching data from an API and extracting various information such as video ID, title, thumbnail URLs, description, owner's mid, video statistics (views, replies, danmaku, favorites, coins, shares, likes), and page dimensions. It also skips parsing subtitle info and processes tags data. The code checks if the state is 0 to ensure the video can be downloaded.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tests/anime_highlight_cuts/theme_collector/anime_compilation_video_metadata.py\":97-134",
            "content": "    pic = data['pic']\n    tid,tname = data['tid'],data['tname']\n    # 27, \"\u7efc\u5408\"\n    # 253, \"\u52a8\u6f2b\u6742\u8c08\"\n    dynamic = data['dynamic'] # we can copy that.\n    desc = data['desc']\n    owner_mid = data['owner']['mid']\n    state = data['state']\n    assert state == 0 # make sure this video is downloadable.\n    stat =  data['stat']\n    view  = stat['view']\n    reply = stat['reply']\n    danmaku = stat['danmaku']\n    favorite = stat['favorite']\n    coin  = stat['coin']\n    share = stat['share']\n    like  = stat['like']\n    pages = data['pages']\n    page_count = len(pages) # data['videos']\n    for page in pages:\n        page_index = page['page']\n        page_name = page['part']\n        page_dimension = page['dimension']\n        page_width, page_height, page_rotate = page_dimension['width'], page_dimension['height'], page_dimension['rotate']\n        page_duration = page['duration']\n    # subtitle = data['subtitle']\n    # let's just skip.\n    ## parsing tags info.\n    for tag in tags_data:\n        tag_id = tag['tag_id']\n        tag_name = tag['tag_name']"
        },
        {
            "comment": "This code section is gathering data related to a video, including tag information, count of times the tags were used or caught attention, and details about related videos. It checks if the related state is not 0 before proceeding to gather more information like duration, owner's mid, statistics, etc.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tests/anime_highlight_cuts/theme_collector/anime_compilation_video_metadata.py\":135-159",
            "content": "        tag_used = tag['count']['use']\n        tag_attention = tag['count']['atten']\n        # introduction of tag.\n        tag_content = tag['content']\n        tag_short_content = tag['short_content']\n    ## extract related video info.\n    related_video_counts = len(related_data)\n    for related_video in related_data:\n        related_aid = related_video['aid']\n        related_bvid = related_video['bvid']\n        related_tid = related_video['tid']\n        related_tname = related_video['tname']\n        related_pic = related_video['pic']\n        related_title = related_video['title']\n        related_page_count = related_video['videos'] # make sure this is 1?\n        related_desc = related_video['desc']\n        related_state = related_video['state']\n        if related_state != 0: continue\n        related_duration = related_video['duration']\n        related_owner_mid = related_video['owner']['mid']\n        related_stat = related_video['stat']\n        related_dynamic = related_video['dynamic']\n        # well, we've got non-standard dimensions."
        },
        {
            "comment": "Checking video dimension and no tag found, further processing or error handling might be required.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tests/anime_highlight_cuts/theme_collector/anime_compilation_video_metadata.py\":160-162",
            "content": "        related_dimension = related_video['dimension']\n        # no tag here? you might want more!\n    breakpoint()"
        }
    ]
}