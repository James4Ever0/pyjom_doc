{
    "summary": "The code checks lyrics' adherence to line requirements, processes a list of lyrics, extracts flags, and formats the lyrics into an LRC string.",
    "details": [
        {
            "comment": "Lyric string contains time-stamped song lyrics and metadata, assumed song duration is set to 5 minutes, and pylrc module is imported.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tests/unittest_clean_lrc.py\":0-9",
            "content": "lyric_string = \"\"\"[00:00.000] \u4f5c\u8bcd : \u82cf\u559c\u591a/\u6321\u98ce\u73bb\u7483\\n[00:01.000] \u4f5c\u66f2 : \u82cf\u559c\u591a/\u9648\u6052\u51a0\\n[00:02.000] \u7f16\u66f2 : \u9648\u6052\u51a0/\u9648\u6052\u5bb6\\n[00:31.154]\u4f60\u6234\u4e0a\u5e3d\u5b50\u906e\u4f4f\u773c\u775b \u8f7b\u8f7b\u5730\u7ed5\u7740\u6211 \u603b\u6d0b\u6ea2\u7740\u6696\\n[00:44.404]\u6211\u2026\u6211\u53ea\u80fd\u5531\\n[00:54.902]\u4f60\u50cf\u6c14\u6ce1\u6c34\u76f4\u63a5\u6dd8\u6c14 \u7231\u548c\u661f\u661f\u7728\u773c\u775b \u8f7b\u6613\u6293\u4f4f\u6211\\n[01:07.903]\u6211\u2026\u6211\u53ea\u80fd\u5531\\n[01:16.651]\u6709\u4e00\u4e2a\u5c9b\u5c7f \u5728\u5317\u6781\u51b0\u5ddd\\n[01:23.403]\u90a3\u513f\u6ca1\u6709\u82b1\u6735 \u4e5f\u6ca1\u6709\u5931\u843d\\n[01:30.159]\u5728\u90a3\u4e2a\u5c9b\u5c7f \u6d12\u6ee1\u4e86\u7e41\u661f\\n[01:36.904]\u62e5\u6709\u6211\u548c\u4f60 \u518d\u6ca1\u6709\u5931\u843d\\n[02:15.903]\u4f60\u9080\u8bf7\u6d41\u6d6a\u671f\u5f85\u6b22\u559c \u60f9\u6211\u4e13\u5fc3\u597d\u5947 \u6211\u770b\u89c1\u4e86\u5149\\n[02:29.153]\u6211\u2026\u6211\u53ea\u80fd\u5531\\n[02:39.403]\u96be\u514d\u574f\u5929\u6c14\u95ea\u7535\u66b4\u96e8 \u7ec3\u5c31\u80a9\u8180\u548c\u52c7\u6c14 \u53ea\u4e3a\u4f60\u62e5\u62b1\u6211\\n[02:54.156]\u6211\u2026\u6211\u53ea\u80fd\u5531\\n[03:01.659]\u6709\u4e00\u4e2a\u5c9b\u5c7f \u5728\u5317\u6781\u51b0\u5ddd\\n[03:08.154]\u90a3\u513f\u6ca1\u6709\u82b1\u6735 \u4e5f\u6ca1\u6709\u5931\u843d\\n[03:14.906]\u5728\u90a3\u4e2a\u5c9b\u5c7f \u6d12\u6ee1\u4e86\u7e41\u661f\\n[03:21.651]\u62e5\u6709\u6211\u548c\u4f60 \u518d\u6ca1\u6709\u5931\u843d\\n[03:28.656]\u6709\u4e00\u4e2a\u5c9b\u5c7f \u5728\u5317\u6781\u51b0\u5ddd\\n[03:35.152]\n\u90a3\u513f\u6ca1\u6709\u82b1\u6735 \u4e5f\u6ca1\u6709\u5931\u843d\\n[03:41.904]\u5728\u90a3\u4e2a\u5c9b\u5c7f \u6d12\u6ee1\u4e86\u7e41\u661f\\n[03:48.661]\u62e5\u6709\u6211\u548c\u4f60 \u518d\u6ca1\u6709\u5931\u843d\\n[03:59.159]\u6709\u4e00\u4e2a\u5c9b\u5c7f \u5728\u5317\u6781\u51b0\u5ddd\\n[04:05.654]\u90a3\u513f\u6ca1\u6709\u82b1\u6735 \u4e5f\u6ca1\u6709\u5931\u843d\\n[04:12.659]\u5728\u90a3\u4e2a\u5c9b\u5c7f \u6d12\u6ee1\u4e86\u7e41\u661f\\n[04:19.152]\u62e5\u6709\u6211\u548c\u4f60 \u518d\u6ca1\u6709\u5931\u843d\\n[04:26.405]\u6709\u4e00\u4e2a\u5c9b\u5c7f\n\u5728\u5317\u6781\u51b0\u5ddd\\n[04:33.658]\u90a3\u513f\u6ca1\u6709\u82b1\u6735 \u4e5f\u6ca1\u6709\u5931\u843d\u2026\\n[04:40.401]\u5409\u4ed6\uff1a\u9648\u6052\u5bb6\\n[04:42.654]\u94a2\u7434\uff1a\u9648\u6052\u51a0\\n[04:47.407]\u6df7\u97f3\uff1a\u9648\u6052\u5bb6\\n[04:49.907]\u6bcd\u5e26\uff1a\u9648\u6052\u5bb6\\n[04:53.907]\u76d1\u5236\uff1a1991\u4e0e\u5979\\n\"\"\"\n# assume song duration here!\nsong_duration = 5 * 60\nimport pylrc\n# you'd better inspect the thing. what is really special about the lyric, which can never appear?"
        },
        {
            "comment": "This code checks if a Lyrics object from pylrc meets certain criteria. It defines minimum line requirements for lyrics and forbidden characters. The function checkLyricText() determines whether a line contains any forbidden characters. The code then processes the lrc_parsed list to get the total time covered by lyrics, ensuring it's long enough compared to the song's total time. It creates new_lines with valid lines and flags for each line based on the presence of forbidden characters.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tests/unittest_clean_lrc.py\":11-45",
            "content": "min_lines_of_lyrics = 5\nmin_total_lines_of_lyrics = 10\npotential_forbidden_chars = [\"[\", \"]\", \"\u3010\", \"\u3011\", \"\u300c\", \"\u300d\", \"\u300a\", \"\u300b\", \"/\", \"(\", \")\"]\ncore_forbidden_chars = [\":\", \"\uff1a\", \"@\"]\ndef checkLyricText(text, core_only=False):\n    if core_only:\n        forbidden_chars = core_forbidden_chars\n    else:\n        forbidden_chars = core_forbidden_chars + potential_forbidden_chars\n    return not any([char in text for char in forbidden_chars])\n# also get the total time covered by lyric.\n# the time must be long enough, compared to the total time of the song.\nlrc_parsed = pylrc.parse(lyric_string)\nlrc_parsed_list = [line for line in lrc_parsed]\nlrc_parsed_list.sort(key=lambda line: line.time)\nbegin = False\n# end = False\nline_counter = 0\nnew_lines = []\n# lrc_parsed: pylrc.classes.Lyrics\nflags = []\nfor line in lrc_parsed_list:\n    # print(line)\n    text = line.text.strip()\n    startTime = line.time\n    if not begin:\n        flag = checkLyricText(text, core_only=False)\n        if not flag:\n            begin = True\n    else:\n        flag = checkLyricText(text, core_only=True)"
        },
        {
            "comment": "Checks if a flag is set, appends it to the flags list. Filters and extracts consecutive spans from the flags list. Calculates total length of spans. Iterates over the spans, retrieves line start time and text from lrc_parsed_list, checks if line end time is within song duration.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tests/unittest_clean_lrc.py\":46-77",
            "content": "        if flag:\n            begin = False\n    flags.append(flag)\n    # breakpoint()\n# select consecutive spans.\nfrom test_commons import *\nfrom pyjom.mathlib import extract_span\nint_flags = [int(flag) for flag in flags]\nmySpans = extract_span(int_flags, target=1)\nprint(mySpans)  # this will work.\n# this span is for the range function. no need to add one to the end.\ntotal_length = 0\nnew_lyric_list = []\nfor mstart, mend in mySpans:\n    length = mend - mstart\n    total_length += length\n    if length >= min_lines_of_lyrics:\n        # process these lines.\n        for index in range(mstart, mend):\n            line_start_time = lrc_parsed_list[index].time\n            line_text = lrc_parsed_list[index].text\n            if line_start_time <= song_duration:\n                line_end_time = song_duration\n                if index + 1 < len(lrc_parsed_list):\n                    line_end_time = lrc_parsed_list[index + 1].time\n                    if line_end_time > song_duration:\n                        line_end_time = song_duration"
        },
        {
            "comment": "The code processes a list of lyrics and checks if it meets the minimum requirements for length. If so, it formats the lyrics into an LRC string and prints it.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tests/unittest_clean_lrc.py\":78-97",
            "content": "                new_lyric_list.append((line_text, line_start_time))\n                if index == mend - 1:\n                    # append one more thing.\n                    new_lyric_list.append((\"\", line_end_time))\n            else:\n                continue\n# for elem in new_lyric_list:\n#     print(elem)\n# exit()\nif total_length >= min_total_lines_of_lyrics:\n    print(\"LYRIC ACCEPTED.\")\n    new_lrc = pylrc.classes.Lyrics()\n    for text, myTime in new_lyric_list:\n        timecode_min, timecode_sec = divmod(myTime, 60)\n        timecode = \"[{:d}:{:.3f}]\".format(int(timecode_min), timecode_sec)\n        myLine = pylrc.classes.LyricLine(timecode, text)\n        new_lrc.append(myLine)\n    new_lrc_string = new_lrc.toLRC()\n    print(new_lrc_string)"
        }
    ]
}