{
    "summary": "The code manages functions like ad sending, chat APIs, and sentiment analysis in opqbot. It ensures proper messaging practices by checking for banned words and repetition, schedules periodic message sending, sets up a weighted random reply yielder, monitors group chats, categorizes messages about cats and dogs, updates the database, manages ad counters and penalties, processes media messages, handles Chinese conversion, logs for GPT training, filters message types, writes chat cursor data, and manages red packets asynchronously.",
    "details": [
        {
            "comment": "This code is for the arm64 version of opqbot, disabling the \u590d\u8bfb\u673a plugin, and managing various functions like ad sending, chat APIs, base opq operations, sentiment analysis, censor replies, and more. It handles group messages, repeating them if necessary, while considering sentiment scores and maintaining a log for red packet collection.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tasks/qq/qq_red_packet_collect/botoy_redpacket_collect.py\":0-44",
            "content": "# for arm64 version of opqbot\n# disable that \u590d\u8bfb\u673a plugin.\nimport os\nos.environ['HTTP_PROXY'] = \"\"\nos.environ['HTTPS_PROXY'] = \"\"\n# shall you analyze the logs/redPacketLog_*.log to get topics from groups and individuals.\nfrom chat_local import *\nfrom adtools import sendCatOrDogAdToQQGroup, checkCatOrDog, makeCatOrDogConnections\nfrom chatApis import getChatApiReply\nfrom base_opq import *\nimport schedule\nfrom chat_local import getAbsSentiment\nfrom censorApis import censorReplyAbsSentiment\nfrom commons import (\n    weightedRandomYielder,\n    generatedSentenceFixer,\n    keywordDecorator,\n    removeDuplicateWords,\n    replaceDuplicateChar,\n)\nAD_INIT_COUNTER = 1\ngroupChatCursor = None\ngroupMsgSendStatus = {}\ngroupChatReplyHistory = []\ngroupNoReplyStack = {}  # \u9632\u6b62\u8fde\u7eed\u5bf9\u4e00\u4e2a\u7fa4\u6301\u7eed\u8f93\u51fa\n# qq\u7fa4\u6700\u591a\u53ef\u4ee5\u6dfb\u52a0500\u4e2a\u7fa4 1500\u4e2a\u597d\u53cb \u5176\u4e2d\u7fa4\u53ef\u52a0\u7684\u6570\u91cf = max(0,500 - \u5df2\u52a0\u5165\u7fa4\u6570\u91cf - \u597d\u53cb\u6570\u91cf)\n# \u53ef\u4ee5\u9000\u51fa\u4e00\u4e9b\u5b89\u9759\u7684\u7fa4 \u4e0d\u53d1\u7ea2\u5305\u7684\u7fa4 \u5220\u9664\u597d\u53cb\n# action.getClusterInfo\n# \"\"\"\u83b7\u53d6\u5f53\u524d\u96c6\u7fa4\u4fe1\u606f\"\"\"\n# this is to get the current server running status. i suspect.\ndef groupMsgRepeater(msg: str, sentiment_threshold=0.7):\n    sentiment = getAbsSentiment(msg)"
        },
        {
            "comment": "This function, when called with a replyGetterYielder object and other parameters such as groupBannedErrorBuffer, retry, delay_time_range, context_size_range, maxRepeatRange, noReplyThreshold, and noReplyBuffer, sends a message to a QQ group chat using an async thread. It also manages the groupMsgSendStatus dictionary to keep track of the number of messages sent to each group. The function checks if the group is currently banned or not, retries sending the message a certain number of times if necessary, and adjusts the send status accordingly.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tasks/qq/qq_red_packet_collect/botoy_redpacket_collect.py\":45-79",
            "content": "    if sentiment > sentiment_threshold:\n        return msg\ndef checkGroupMsgSendStatus(group_id, decrease=True):\n    if group_id in groupMsgSendStatus.keys():\n        if decrease:\n            groupMsgSendStatus[group_id] -= 1  # the feedback shall be elsewhere.\n        if groupMsgSendStatus[group_id] <= 0:\n            del groupMsgSendStatus[group_id]\n            return True\n        else:\n            return False\n    return True\n# now async.\n@asyncThread\ndef sendBotGroupTextMsg(\n    replyGetterYielder,\n    groupBannedErrorBuffer=100,  # \u88ab\u7981\u8a00\u4e4b\u540e\u7684buffer\n    retry=3,\n    min_reply_length=3,  # some impirical value.\n    delay_time_range=(5, 15),\n    context_size_range=(1, 3),  # maybe we do not need no context. or not?\n    maxRepeatRange=(2, 5),\n    noReplyThreshold=3,\n    noReplyBuffer=75,\n):  # the context parameter may lead to OOM.\n    global groupChatCursor\n    # will clear cursor after sending\n    if groupChatCursor is not None:\n        # do work here.\n        group_id = groupChatCursor[\"group_id\"]\n        # groupChatCursor = None"
        },
        {
            "comment": "The code checks if the group message sending status is successful, then sets a context size range and uses it to construct a new text message. It joins all messages together with spaces and assigns the new message to the group chat cursor. Finally, it loops through multiple reply getters, trying them in order, with a maximum of three retries if the event is not set.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tasks/qq/qq_red_packet_collect/botoy_redpacket_collect.py\":80-108",
            "content": "        # return\n        result = checkGroupMsgSendStatus(group_id, decrease=False)  # failsafe.\n        if not result:\n            return\n        # modify this textMessage somehow? with context.\n        context = random.randint(*context_size_range)\n        textMessage = groupChatCursor[\"msg\"]\n        groupChatCursorWithContext = groupChatCursor.copy()\n        messageContext = chat_stack[group_id][-context:-1] + [\n            textMessage\n        ]  # include the last message.\n        messageContext = \" \".join(messageContext)  # just use space.\n        groupChatCursorWithContext[\"msg\"] = messageContext\n        for (\n            replyGetter,\n            argumentList,\n            flag,\n            needContext,\n            enableRetryFlag,\n        ) in replyGetterYielder:  # use all methods.\n            if exit_event.is_set():\n                break\n            retried = False\n            for _ in range(retry):  # retry for three times.\n                if exit_event.is_set():\n                    break\n                extraFlags = {}"
        },
        {
            "comment": "This code block retrieves a reply from a replyGetter function, depending on whether context is needed or not. If the reply is not None, it updates retryFlag and generates a new random maxRepeat value for generatedSentenceFixer to fix the reply. The reply is then passed through removeDuplicateWords filter before checking if it's already in groupChatReplyHistory or shorter than min_reply_length.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tasks/qq/qq_red_packet_collect/botoy_redpacket_collect.py\":109-131",
            "content": "                if enableRetryFlag:\n                    extraFlags.update({\"retryFlag\": retried})\n                # stderrPrint(extraFlags,replyGetter)\n                if needContext:\n                    reply = replyGetter(\n                        *[groupChatCursorWithContext[key] for key in argumentList],\n                        **extraFlags\n                    )\n                else:\n                    reply = replyGetter(\n                        *[groupChatCursor[key] for key in argumentList], **extraFlags\n                    )\n                if reply is not None:\n                    retried = True  # only plus one on retryIndex when there is no error during generation.\n                    maxRepeat = random.randint(*maxRepeatRange)\n                    reply = generatedSentenceFixer(\n                        reply, maxRepeat=maxRepeat\n                    )  # fix this reply first.\n                    # add a new filter here.\n                    reply = removeDuplicateWords(reply)\n                    if reply in groupChatReplyHistory or len(reply) < min_reply_length:"
        },
        {
            "comment": "Code checks if the message contains banned words, censors them if necessary, and ensures messages are not too short or repeated. If a suitable reply is found, it sends the message after a random delay to avoid flooding and make it appear more human-like.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tasks/qq/qq_red_packet_collect/botoy_redpacket_collect.py\":132-151",
            "content": "                        continue  # do not send repeated messages or unusually short messages.\n                    else:\n                        update_stack(groupChatReplyHistory, reply)\n                    # \u53e5\u5b50\u91cc\u9762\u4e0d\u80fd\u6709\u8fdd\u7981\u8bcd\u8bed \u4e0d\u7136\u5c31\u4e0d\u80fd\u8f93\u51fa\n                    reply = censorReplyAbsSentiment(reply)\n                    if reply is None:\n                        continue  # skip too vulgar sentences.\n                    if reply.count(\"*\") > 3:  # too much censor will make it unreadable.\n                        continue  # retry to get a better thing.\n                    # do reply.\n                    # stderrPrint(\"PROCESSING GROUP MESSAGE CURSOR:\", groupChatCursor)\n                    stderrPrint(flag, reply)\n                    # must control this shit. \u5982\u679c\u88ab\u7981\u8a00\u4e86\u8be5\u5982\u4f55\u5904\u7406 \u4e00\u822c\u9700\u8981\u7f13\u51b230\u6b21\n                    groupChatCursor = None  # remove it only one reply was to be made.\n                    delay = random.randint(*delay_time_range)\n                    time.sleep(delay)  # to make it more humane.\n                    sendMessageStatus = action.sendGroupText("
        },
        {
            "comment": "Code snippet handles sending messages to a group using the 'sendMessageStatus' response. If an error occurs (non-empty 'ErrMsg' or non-zero 'Ret'), the group is marked as banned. If no errors, the count of unsent messages is incremented for that group. If the count exceeds a threshold, it can be written to the cursor.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tasks/qq/qq_red_packet_collect/botoy_redpacket_collect.py\":152-171",
            "content": "                        group=group_id, content=reply\n                    )\n                    # stderrPrint(\"SENT MESSAGE STATUS:\",sendMessageStatus)\n                    if not (\n                        sendMessageStatus[\"ErrMsg\"] == \"\"\n                        and sendMessageStatus[\"Ret\"] == 0\n                    ):\n                        # some shit had happened. cannot send message without error.\n                        groupMsgSendStatus.update({group_id: groupBannedErrorBuffer})\n                    else:\n                        # no shit happened.\n                        groupNoReplyStack.update(\n                            {group_id: 1 + groupNoReplyStack.get(group_id, 0)}\n                        )\n                        # stderrPrint(\"UPDATE NOREPLYSTACK\", groupNoReplyStack)\n                        noReply = groupNoReplyStack.get(group_id, 0)\n                        if (\n                            noReply >= noReplyThreshold\n                        ):  # only this noReply greater than 0 we can write it to cursor. LOGIC ELSEWHERE"
        },
        {
            "comment": "This code defines four different functions for sending messages to a group chat: `sendAtriGroupChatMessage`, `sendGPT2GroupChatMessage`, `sendXiaoIceGroupChatMessage`, and `sendChatLocalResponse`. Each function takes a \"group_id\" and a \"msg\", and has a specific label indicating the source of the message. The last parameter in each tuple indicates whether to retry sending if an error occurs.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tasks/qq/qq_red_packet_collect/botoy_redpacket_collect.py\":172-208",
            "content": "                            groupNoReplyStack.update({group_id: -noReplyBuffer})\n                    # stderrPrint(\"sendMessageStatus:\", sendMessageStatus)\n                    return True\ndef sendRandomGroupMessage():\n    sendAtriGroupChatMessage = (\n        keywordDecorator(getChatApiReply, chatApiIndex=0),\n        [\"msg\", \"group_id\"],\n        \"SENDING ATRI API REPLY:\",\n        True,\n        True,\n    )  # last is enableRetryFlag\n    sendGPT2GroupChatMessage = (\n        keywordDecorator(getChatApiReply, chatApiIndex=1),\n        [\"msg\", \"group_id\"],\n        \"SENDING GPT2 API REPLY:\",\n        True,\n        True,\n    )  # last is enableRetryFlag\n    sendXiaoIceGroupChatMessage = (\n        keywordDecorator(getChatApiReply, chatApiIndex=2),\n        [\"msg\", \"group_id\"],\n        \"SENDING XIAOICE API REPLY:\",\n        True,\n        True,\n    )\n    sendChatLocalResponse = (\n        getChatLocalResponse,\n        [\"group_id\", \"msg\"],\n        \"SENDING CHATLOCAL REPLY:\",\n        False,\n        False,\n    )\n    sendRepeaterResponse = ("
        },
        {
            "comment": "This code is setting up a weighted random reply yielder for a group chat bot, with multiple reply options and weights. It also schedules a function to send a random group message periodically and prints group text chat messages in JSON format. The schedule functionality seems to have some uncertainty about its effectiveness.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tasks/qq/qq_red_packet_collect/botoy_redpacket_collect.py\":209-239",
            "content": "        groupMsgRepeater,\n        [\"msg\"],\n        \"SENDING REPEATER REPLY:\",\n        False,\n        False,\n    )\n    replyGetterList = [\n        sendAtriGroupChatMessage,\n        sendGPT2GroupChatMessage,\n        sendChatLocalResponse,\n        sendRepeaterResponse,\n        sendXiaoIceGroupChatMessage,\n    ]\n    weightList = [2, 5, 1, 1, 5]\n    # weightList = [1, 3, 2, 2, 5] # said that is girish, because of xiaoice.\n    replyGetterYielder = weightedRandomYielder(replyGetterList, weightList)\n    sendBotGroupTextMsg(replyGetterYielder)\n# schedule.every(1).minute.do(sendApiGroupChatMessage)\n# schedule.every(30).seconds.do(sendChatLocalResponse) # will this shit work?\nschedule.every(1).minute.do(sendRandomGroupMessage)  # will this shit work?\ndef printGroupTextChatJson(group_id, sender_id, content):\n    message = {\"group_id\": group_id, \"sender_id\": sender_id, \"content\": content}\n    message = json.dumps(message, ensure_ascii=False)\n    stderrPrint(\n        \"[GROUP_TEXT_MESSAGE]\", message\n    )  # strange. who the fuck added this shit?"
        },
        {
            "comment": "This code defines a function that checks whether the content sent in a QQ group is an image of a cat or dog. If it is, the function updates a Neo4j database and decides whether to send an ad based on a counter for each group. The code uses OpenCC library for text simplification and imports traceback module for error handling.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tasks/qq/qq_red_packet_collect/botoy_redpacket_collect.py\":242-273",
            "content": "# convert to simplified chinese.\nimport opencc\nchinese_t2s = opencc.OpenCC()\nadBuffer = {}\n# hook up this thing, send cat video only if we receive that topic.\nfrom adtools import checkIsCatOrDogImage\n@asyncThread\ndef catOrDogAsyncThread(group_id:str, sender_id:str,Content:str,is_image:bool=False, is_user:bool=False):\n    if is_image:\n        try:\n            cat_or_dog = checkIsCatOrDogImage(Content)\n        except:\n            import traceback\n            traceback.print_exc()\n            print(\"Exception when detecting image if it is cat or dog\")\n            return\n    else:\n        cat_or_dog = checkCatOrDog(Content)\n    # we need to update neo4j database, using group_id, sender_id, cat_or_dog.\n    if cat_or_dog:\n        makeCatOrDogConnections(\n            str(group_id), str(sender_id), cat_or_dog\n        )\n        # act accordingly. decide to send ad or not.\n        if adBuffer.get(str(group_id), 0) <= 0:\n            penalty = 10\n            # send the ad.\n            success = sendCatOrDogAdToQQGroup(str(group_id), cat_or_dog, action)"
        },
        {
            "comment": "This code fragment monitors a group chat and manages ad counters based on the number of messages sent. For each message, it checks if a penalty should be added and updates an ad counter for the specific group ID. The ad counter is decreased with every standard group message received. It also updates the group name dictionary and handles user input data from messages sent to the group chat.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tasks/qq/qq_red_packet_collect/botoy_redpacket_collect.py\":274-300",
            "content": "            if success:\n                penalty += 40 # every 50 messages we have one ad.\n            adBuffer[str(group_id)] = penalty\n        # decrease that counter by standard group messages.\nfrom botoy.collection import MsgTypes\n@bot.on_group_msg\ndef group(ctx: GroupMsg, groupInitReplyDelayRange=(4, 15)):\n    # too broad for groupInitReplyDelayRange to be (2, 20)\n    # global groupChatCursor\n    #    stderrPrint('\u6536\u5230\u7fa4\u6d88\u606f\uff0c\u7fa4\u53f7\u4e3a', ctx.FromGroupId)\n    # recommed you to check the curret group only.\n    #    stderrPrint(\"checkGroupNoReply:\",groupNoReplyStack.get(ctx.FromGroupId,None))\n    data_dict = ctx.data  # recommend to use this json object. or not?\n    groupName = data_dict.get(\"FromGroupName\", None)\n    group_id = data_dict[\"FromGroupId\"]\n    # decrease that ad counter.\n    adCounter = adBuffer.get(str(group_id), AD_INIT_COUNTER)\n    if adCounter > 0:\n        adCounter -= 1\n    adBuffer[str(group_id)] = adCounter\n    if groupName is not None:\n        updateGroupNameDict(groupName, group_id)\n    sender_id = data_dict[\"FromUserId\"]"
        },
        {
            "comment": "This code is handling media messages (images, videos, voice) in a chat group. It tries to download images and may process videos or voice messages. If the message type is not recognized, it logs an error. The code also initializes random delay for a group's no-reply stack if the group ID isn't present.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tasks/qq/qq_red_packet_collect/botoy_redpacket_collect.py\":301-328",
            "content": "    RedBaginfoDict = data_dict[\"RedBaginfo\"]\n    RedBaginfo = ctx.RedBaginfo\n    MsgType = ctx.MsgType\n    # how to download these shits?\n    try:\n        from botoy.parser.group import Pic\n        if MsgType == MsgTypes.PicMsg:\n            pic_obj = Pic(**json.loads(ctx.Content))\n            pics = pic_obj.GroupPic\n            for pic in pics:\n                pic_url = pic.Url\n                catOrDogAsyncThread(str(group_id), str(sender_id),pic_url,is_image=True)\n        elif MsgType == MsgTypes.VideoMsg:\n            ...\n        elif MsgType == MsgTypes.VoiceMsg:\n            ...\n        elif MsgType == MsgTypes.JsonMsg:\n            ... # hope you can receive that? nope? you can only receive that by go-cqhttp.\n    except:\n        import traceback\n        traceback.print_exc()\n        print(\"ERROR WHEN PROCESSING MEDIA MESSAGES.\")\n        print(\"MSGTYPE:\",MsgType)\n    # first initialize random delay for every group in groupNoReplyStack\n    if group_id not in groupNoReplyStack.keys():\n        groupNoReplyStack.update({group_id: -random.randint(*groupInitReplyDelayRange)})"
        },
        {
            "comment": "Function writes group chat cursor data to a file, with support for Chinese simplified to traditional conversion. The content length is checked against minimum and maximum thresholds before printing or potentially splitting into shorter segments.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tasks/qq/qq_red_packet_collect/botoy_redpacket_collect.py\":330-351",
            "content": "    def writeGroupChatCursor(Content, enable_t2s=True):\n        if enable_t2s:\n            Content = chinese_t2s.convert(Content)\n        # content need to converted into simplified chinese.\n        global groupChatCursor, chat_stack_lock\n        # maybe we should create the mapping table here.\n        content_length = len(Content)\n        content_min_length = 4\n        # maybe we should split sentence into shorter ones, or via summarization/title generation apis.\n        content_max_length = 15\n        recv_content_min_length, recv_content_max_length = 4, 20\n        if not (Content.startswith(\"[\") or Content.endswith(\"]\")):\n            if (\n                content_length <= recv_content_max_length\n                and content_length >= recv_content_min_length\n            ):\n                printGroupTextChatJson(\n                    group_id, sender_id, Content\n                )  # why the fuck you are not printing?\n            if (\n                content_length <= content_max_length\n                and content_length >= content_min_length"
        },
        {
            "comment": "This code block handles QQ group chat messages and logs them for GPT training. It also manages a \"noReply\" counter for groups where the bot should not reply, and updates a chat_stack based on certain conditions. The chat_stack lock is checked to ensure no simultaneous updates are made. If interesting content is detected, it triggers a catOrDogAsyncThread function.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tasks/qq/qq_red_packet_collect/botoy_redpacket_collect.py\":352-372",
            "content": "            ):  # \u65b0\u7248qq\u4e4b\u7c7b\u7684\u4fe1\u606f\n                # we log group chat text for gpt training here. shall we?\n                result = checkGroupMsgSendStatus(group_id)\n                if (\n                    result\n                ):  # will not write banned group to cursor since we will not reply it.\n                    noReply = groupNoReplyStack.get(group_id, 0)\n                    # stderrPrint(\"NOREPLYSTACK:\",groupNoReplyStack)\n                    if noReply >= 0:\n                        groupChatCursor = {\"group_id\": group_id, \"msg\": Content}\n                    else:\n                        groupNoReplyStack.update({group_id: noReply + 1})\n                # chat_stack update logic within the content length filter\n                if chat_stack_lock:\n                    # do not do anything about the chat_stack while locked.\n                    return\n                else:\n                    # check if we are hit by something interesting?\n                    catOrDogAsyncThread(group_id, sender_id, Content)"
        },
        {
            "comment": "This code checks if the message type is an \"AtMsg\" and extracts the content, removes the mentioned user, replaces duplicate characters with a maximum repeat of 1, and updates the chat stack. If the sender is not the bot itself, it performs these actions on the message content.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tasks/qq/qq_red_packet_collect/botoy_redpacket_collect.py\":373-393",
            "content": "                    updateChatStack(group_id, Content)\n                    # or we could simply add the filter on the reply side.\n    if sender_id != my_qq:  # skip text content sent by itself.\n        # how to act like the TextMsg? it could include video/image contents.\n        if MsgType == \"AtMsg\":\n            Content = ctx.Content  # this is string.\n            Content_json = json.loads(Content)\n            content_text = Content_json[\"Content\"].strip()\n            # print(Content_json)\n            # breakpoint()\n            # 'SrcContent', 'UserID'(list)\n            content_at_target = (\"@\" + content_text.split(\"@\")[1]).strip()\n            content_text = content_text.replace(content_at_target, \"\")\n            content_text = replaceDuplicateChar(content_text, \" \", maxRepeat=1)\n            # UserExt = Content_json[\"UserExt\"]\n            # # shit revised. no more 'UserExt'\n            # for elem in UserExt:\n            #     QQNick = elem[\"QQNick\"]\n            #     at_QQNick = \"@{}\".format(QQNick)\n            #     content_text = content_text.replace(at_QQNick + \" \" + at_QQNick, \"\")"
        },
        {
            "comment": "Code chunk handles messages and red packets in a QQ group chat. It filters the message type, prepares content for writing, writes to the group chat cursor, handles received red packets by starting a thread, and runs pending tasks asynchronously.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tasks/qq/qq_red_packet_collect/botoy_redpacket_collect.py\":394-420",
            "content": "            #     content_text = content_text.replace(at_QQNick, \"\")\n            # now the content is ready.\n            writeGroupChatCursor(content_text)\n        if MsgType == \"TextMsg\":\n            # is that group allowing sending messages?\n            content_text = ctx.Content  # must not be empty.\n            writeGroupChatCursor(content_text)\n    if RedBaginfoDict is not None:\n        prefix = \"[MREDBAG_LOG]\"\n        print(prefix, \"RECEIVED RED PACKET\", file=sys.stderr)\n        print(\n            prefix, \"_____________RedPacket Message Dump_____________\", file=sys.stderr\n        )\n        print(prefix, ctx, file=sys.stderr)\n        print(\n            prefix, \"_____________RedPacket Message Dump_____________\", file=sys.stderr\n        )\n        startThread(openRedBag, (RedBaginfoDict, group_id, RedBaginfo))\n    schedule.run_pending()  # this is async.\n    # breakpoint()\nif __name__ == \"__main__\":\n    bot.run()\n# do not send porn shits or you need to relogin."
        }
    ]
}