{
    "summary": "The code offers text filtering through classes like NaiveFilter and BSFilter for keyword removal and regex processing, plus a DFAFilter for performance boost. It checks characters, translates Chinese to Pinyin, and returns moderated text via FastAPI endpoint.",
    "details": [
        {
            "comment": "This code is for creating a filter to remove specific keywords from a given message. It provides three classes: NaiveFilter, BSFilter, and DFAFilter. NaiveFilter is the simplest implementation using set data structure, while BSFilter uses Back Sorted Mapping to improve performance by reducing replacement times. The code also includes parsing functionality to add keywords from a file.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tasks/qq/qq_red_packet_collect/textfilter/filter_py3_fastapi.py\":0-47",
            "content": "#!/usr/bin/env python\n# -*- coding:utf-8 -*-\nfrom collections import defaultdict\nimport re\n__all__ = ['NaiveFilter', 'BSFilter', 'DFAFilter']\n__author__ = 'observer'\n__date__ = '2012.01.05'\nclass NaiveFilter():\n    '''Filter Messages from keywords\n    very simple filter implementation\n    >>> f = NaiveFilter()\n    >>> f.add(\"sexy\")\n    >>> f.filter(\"hello sexy baby\")\n    hello **** baby\n    '''\n    def __init__(self):\n        self.keywords = set([])\n    def parse(self, path):\n        for keyword in open(path):\n            self.keywords.add(keyword.strip().decode('utf-8').lower())\n    def filter(self, message, repl=\"*\"):\n        message = str(message).lower()\n        for kw in self.keywords:\n            message = message.replace(kw, repl)\n        return message\nclass BSFilter:\n    '''Filter Messages from keywords\n    Use Back Sorted Mapping to reduce replacement times\n    >>> f = BSFilter()\n    >>> f.add(\"sexy\")\n    >>> f.filter(\"hello sexy baby\")\n    hello **** baby\n    '''\n    def __init__(self):\n        self.keywords = []"
        },
        {
            "comment": "This code defines a class with methods for adding keywords, parsing from a file, and filtering text. It uses regular expressions to identify English words and stores them in dictionaries based on their characters or full words. The parse method reads a file of keywords and the filter method processes input messages by replacing non-keyword parts with \"*\".",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tasks/qq/qq_red_packet_collect/textfilter/filter_py3_fastapi.py\":48-76",
            "content": "        self.kwsets = set([])\n        self.bsdict = defaultdict(set)\n        self.pat_en = re.compile(r'^[0-9a-zA-Z]+$')  # english phrase or not\n    def add(self, keyword):\n        if not isinstance(keyword, str):\n            keyword = keyword.decode('utf-8')\n        keyword = keyword.lower()\n        if keyword not in self.kwsets:\n            self.keywords.append(keyword)\n            self.kwsets.add(keyword)\n            index = len(self.keywords) - 1\n            for word in keyword.split():\n                if self.pat_en.search(word):\n                    self.bsdict[word].add(index)\n                else:\n                    for char in word:\n                        self.bsdict[char].add(index)\n    def parse(self, path):\n        with open(path, \"r\") as f:\n            for keyword in f:\n                self.add(keyword.strip())\n    def filter(self, message, repl=\"*\"):\n        if not isinstance(message, str):\n            message = message.decode('utf-8')\n        message = message.lower()\n        for word in message.split():"
        },
        {
            "comment": "This code defines a DFAFilter class to filter messages from keywords. It uses DFA (Deterministic Finite Automaton) to improve algorithm performance. The add method adds a keyword and the filter method replaces keywords with asterisks (*). If the keyword is already in the DFA, it updates the level of the DFA accordingly.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tasks/qq/qq_red_packet_collect/textfilter/filter_py3_fastapi.py\":77-112",
            "content": "            if self.pat_en.search(word):\n                for index in self.bsdict[word]:\n                    message = message.replace(self.keywords[index], repl)\n            else:\n                for char in word:\n                    for index in self.bsdict[char]:\n                        message = message.replace(self.keywords[index], repl)\n        return message\nclass DFAFilter():\n    '''Filter Messages from keywords\n    Use DFA to keep algorithm perform constantly\n    >>> f = DFAFilter()\n    >>> f.add(\"sexy\")\n    >>> f.filter(\"hello sexy baby\")\n    hello **** baby\n    '''\n    def __init__(self):\n        self.keyword_chains = {}\n        self.delimit = '\\x00'\n    def add(self, keyword):\n        if not isinstance(keyword, str):\n            keyword = keyword.decode('utf-8')\n        keyword = keyword.lower()\n        chars = keyword.strip()\n        if not chars:\n            return\n        level = self.keyword_chains\n        for i in range(len(chars)):\n            if chars[i] in level:\n                level = level[chars[i]]"
        },
        {
            "comment": "This code is parsing a text file of keywords and their corresponding chains. It then filters a given message by replacing instances of the keyword chains with a placeholder (\"*\"). The \"repl\" argument in filter() function seems to be optional and represents the placeholder character used for replacement. If the input message is not a string, it's decoded from its original format (like bytes) to a string. The code maintains a nested dictionary structure representing keyword chains, and if a delimiter is found missing in a chain, it's set to 0.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tasks/qq/qq_red_packet_collect/textfilter/filter_py3_fastapi.py\":113-142",
            "content": "            else:\n                if not isinstance(level, dict):\n                    break\n                for j in range(i, len(chars)):\n                    level[chars[j]] = {}\n                    last_level, last_char = level, chars[j]\n                    level = level[chars[j]]\n                last_level[last_char] = {self.delimit: 0}\n                break\n        if i == len(chars) - 1:\n            level[self.delimit] = 0\n    def parse(self, path):\n        with open(path) as f:\n            for keyword in f:\n                self.add(keyword.strip())\n    def filter(self, message, repl=\"*\"):  # what is this repl?\n        if not isinstance(message, str):\n            message = message.decode('utf-8')\n        message = message.lower()\n        ret = []\n        start = 0\n        while start < len(message):\n            level = self.keyword_chains\n            step_ins = 0\n            for char in message[start:]:\n                if char in level:\n                    step_ins += 1\n                    if self.delimit not in level[char]:"
        },
        {
            "comment": "This function takes a message and filters it based on a DFA (Deterministic Finite Automaton) filter. It checks each character in the message, appending replacements if necessary or keeping the original character if not. If a keyword is found, it replaces it with '*'. The function returns the filtered text as a string.\n\nThe code also includes a test case for checking if the first character of the filter result matches the expected output for the given input. Additionally, there are import statements and function definitions for other functionalities like getting pinyin and handling Chinese text.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tasks/qq/qq_red_packet_collect/textfilter/filter_py3_fastapi.py\":143-185",
            "content": "                        level = level[char]\n                    else:\n                        # print(\"STEPINS\", step_ins)\n                        # print(\"CHAR\", char)\n                        # print(level[char])\n                        ret.append(repl * step_ins)\n                        start += step_ins - 1\n                        break\n                else:\n                    ret.append(message[start])\n                    break\n            else:\n                ret.append(message[start])\n            start += 1\n        return ''.join(ret)\ndef test_first_character():\n    gfw = DFAFilter()\n    gfw.add(\"1989\u5e74\")\n    assert gfw.filter(\"1989\", \"*\") == \"1989\"\ngfw = DFAFilter()\ngfw.parse(\"keywords\")\nfrom typing import Union\nfrom fastapi import FastAPI\napp = FastAPI()\nfrom snownlp import SnowNLP\nfrom snownlp.normal import pin, re_zh\n# import re\ndef getPinyin(originalText,\n              filteredText,\n              whitelistChars=[\"\u7684\"],\n              whitelistNonChinese=True):  # any repl will do.\n    blocks = [x for x in re_zh.split(originalText) if len(x) > 0]"
        },
        {
            "comment": "This code filters text by translating Chinese characters into their corresponding Pinyin while preserving non-Chinese characters or whitelisted characters. It creates a list of translated characters and applies the filter logic to generate a moderated text output, which is returned as the result. Additionally, there's an API endpoint (\"/\") defined for accessing this functionality through a FastAPI server.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tasks/qq/qq_red_packet_collect/textfilter/filter_py3_fastapi.py\":186-212",
            "content": "    # words = result.words\n    translate_list = []\n    for block in blocks:\n        if re_zh.match(block):\n            block_pinyin = pin.get(block)\n            for index, pinyin in enumerate(block_pinyin):\n                character = block[index]\n                translate_list.append((character, pinyin[0]))\n        else:\n            for index, character in enumerate(block):\n                translate_list.append((character, character))\n    moderatedText = \"\"\n    for index, (originalCharacter, pinyin) in enumerate(translate_list):\n        filteredCharacter = filteredText[index]\n        if filteredCharacter == originalCharacter or originalCharacter in whitelistChars or (\n                whitelistNonChinese and (not re_zh.match(originalCharacter))): # changed the moderator logic.\n            moderatedText += originalCharacter\n        elif pinyin != originalCharacter:\n            moderatedText += pinyin\n        else:\n            moderatedText += filteredCharacter\n    return moderatedText\n@app.get(\"/\")\ndef read_root():"
        },
        {
            "comment": "This code defines a FastAPI route (\"/filter\") that takes in a text input and applies GFW filtering. If the \"moderate\" parameter is True, it generates a moderated text by replacing Chinese characters with their corresponding pinyin. Otherwise, it returns the filtered text.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tasks/qq/qq_red_packet_collect/textfilter/filter_py3_fastapi.py\":213-224",
            "content": "    return {\"response\": \"DFAFilter based Chinese text filter(censor)\"}\n@app.get(\"/filter\")\ndef read_item(text: Union[str, None] = None, moderate: bool = True):\n    originalText = text\n    filteredText = gfw.filter(text, \"*\")\n    if moderate:\n        moderatedText = getPinyin(originalText, filteredText)\n        return {\"response\": moderatedText}\n    else:\n        return {\"response\": filteredText}"
        }
    ]
}