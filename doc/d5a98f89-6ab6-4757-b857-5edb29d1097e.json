{
    "summary": "This code performs image processing, including contrast normalization, hue preservation, and fusion for color images using nonlinear transformation and CLAHE. It can process multiple images in a specified directory via an optional loop.",
    "details": [
        {
            "comment": "The code defines several functions for image processing, including linear stretching, hue preservation, and fusion. These functions are likely used to enhance image quality, contrast, or OCR capabilities.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tests/remove_subtle_watermark_local_contrast_ocr/glche_test.py\":0-39",
            "content": "from PIL import Image\nfrom scipy.optimize import minimize_scalar\nimport numpy as np\nimport cv2\nimport os\ndef linearStretching(x_c, x_max, x_min, l):\n    return (l - 1) * (x_c - x_min) / (x_max - x_min)\ndef mapping(h, l):\n    cum_sum = 0\n    t = np.zeros_like(h, dtype=np.int)\n    for i in range(l):\n        cum_sum += h[i]\n        t[i] = np.ceil((l - 1) * cum_sum + 0.5)\n    return t\ndef f(lam, h_i, h_u, l):\n    h_tilde = 1 / (1 + lam) * h_i + lam / (1 + lam) * h_u\n    t = mapping(h_tilde, l)\n    d = 0\n    for i in range(l):\n        for j in range(i + 1):\n            if h_tilde[i] > 0 and h_tilde[j] > 0 and t[i] == t[j]:\n                d = max(d, i - j)\n    return d\ndef huePreservation(g_i, i, x_hat_c, l):\n    g_i_f = g_i.flatten()\n    i_f = i.flatten()\n    x_hat_c_f = x_hat_c.flatten()\n    g_c = np.zeros(g_i_f.shape)\n    g_c[g_i_f <= i_f] = (g_i_f / i_f * x_hat_c_f)[g_i_f <= i_f]\n    g_c[g_i_f > i_f] = ((l - 1 - g_i_f) / (l - 1 - i_f) * (x_hat_c_f - i_f) + g_i_f)[g_i_f > i_f]\n    return g_c.reshape(i.shape)\ndef fusion(i):"
        },
        {
            "comment": "The code reads an image and applies linear stretching to the red, green, and blue channels separately. It then combines these channels using YCbCr color space conversion and calculates the histogram of the combined image. The resulting histogram is normalized by dividing it by the total number of pixels. Finally, it returns a stretched and scaled image with watermark detection values.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tests/remove_subtle_watermark_local_contrast_ocr/glche_test.py\":40-63",
            "content": "    lap = cv2.Laplacian(i.astype(np.uint8), cv2.CV_16S, ksize=3)\n    c_d = np.array(cv2.convertScaleAbs(lap))\n    #print(np.max(np.max(c_d)), np.min(np.min(c_d)))\n    c_d = c_d / np.max(np.max(c_d)) + 0.00001\n    i_scaled = (i - np.min(np.min(i))) / (np.max(np.max(i)) - np.min(np.min(i)))\n    b_d = np.apply_along_axis(lambda x: np.exp(- (x - 0.5) ** 2 / (2 * 0.2 ** 2)), 0, i_scaled.flatten()).reshape(i.shape)\n    w_d = np.minimum(c_d, b_d)\n    return w_d\ndef main(path, name): # no parameter? fuck.\n    x = np.array(Image.open(path)).astype(np.float64)\n    x_r, x_g, x_b = x[:, :, 0], x[:, :, 1], x[:, :, 2]\n    x_max = np.max(np.max(np.max(x)))\n    x_min = np.min(np.min(np.min(x)))\n    l = 256\n    x_hat_r = linearStretching(x_r, x_max, x_min, l)\n    x_hat_g = linearStretching(x_g, x_max, x_min, l)\n    x_hat_b = linearStretching(x_b, x_max, x_min, l)\n    i = (0.299 * x_hat_r + 0.587 * x_hat_g + 0.114 * x_hat_b).astype(np.uint8)\n    h_i = np.bincount(i.flatten())\n    h_i = np.concatenate((h_i, np.zeros(l - h_i.shape[0]))) / (i.shape[0] * i.shape[1])"
        },
        {
            "comment": "This code performs contrast normalization, hue preservation, and fusion for color image processing. It uses nonlinear transformation to equalize intensity values, applies CLAHE for local contrast enhancement, and fuses the results using a weighted average based on relative brightness.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tests/remove_subtle_watermark_local_contrast_ocr/glche_test.py\":64-90",
            "content": "    h_u = np.ones_like(h_i) * 1 / l\n    result = minimize_scalar(f, method = \"brent\", args = (h_i, h_u, l))\n    h_tilde = 1 / (1 + result.x) * h_i + result.x / (1 + result.x) * h_u\n    t = mapping(h_tilde, l)\n    g_i = np.apply_along_axis(lambda x: t[x], 0, i.flatten()).reshape(i.shape)\n    g_r = huePreservation(g_i, i, x_hat_r, l)\n    g_g = huePreservation(g_i, i, x_hat_g, l)\n    g_b = huePreservation(g_i, i, x_hat_b, l)\n    #glo = np.dstack((g_r, g_g, g_b)).astype(np.int)\n    clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8,8))\n    l_i = clahe.apply(i)\n    l_r = huePreservation(l_i, i, x_hat_r, l)\n    l_g = huePreservation(l_i, i, x_hat_g, l)\n    l_b = huePreservation(l_i, i, x_hat_b, l)\n    #loc = np.dstack((l_r, l_g, l_b)).astype(np.int)\n    w_g = fusion(g_i)\n    w_l = fusion(l_i)\n    w_hat_g = w_g / (w_g + w_l)\n    w_hat_l = w_l / (w_g + w_l)\n    y_r = w_hat_g * g_r + w_hat_l * l_r\n    y_g = w_hat_g * g_g + w_hat_l * l_g\n    y_b = w_hat_g * g_b + w_hat_l * l_b\n    y = np.dstack((y_r, y_g, y_b)).astype(np.uint8)"
        },
        {
            "comment": "This code reads an image file, applies a function to it, and saves the modified image with a new name. It also has an optional loop that processes multiple images in a specified directory.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tests/remove_subtle_watermark_local_contrast_ocr/glche_test.py\":92-108",
            "content": "    img = Image.fromarray(y)\n    img.save(name + '-en.jpg')\nif __name__ == \"__main__\":\n    picPath = \"IWWS.jpeg\"\n    imageName = \"IWWS-glche.jpeg\"\n    main(picPath, imageName)\n#     dirs = '..\\\\'\n#     count = 0\n#     for num in ('9', '14', '43', '45', '99'):\n#         path = dirs + num\n#         pics = os.listdir(path)\n#         path += '\\\\'\n#         for pic in pics:\n#             main(path + pic, pic[: -4])\n#             count += 1\n#             print(count, 'Done!')"
        }
    ]
}