{
    "summary": "The code creates a function to calculate stack depth, iterates through bytecode for debugging, handles various operations, manages stack depth in an interpreter, and generates callables for traceback frames. It resumes execution, patches original with custom _excepthook, tries to execute until exception occurs, logs it, returns error type, and clears.",
    "details": [
        {
            "comment": "The code defines a function _get_value_stack_depth that calculates the value stack depth after executing up to and including a specific instruction. It uses local storage for errors, has limitations on nested functions, coroutines, and jumps within code objects, and imports necessary libraries for debugging and stack management.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tests/skipexception_code_and_continue_resurrection_time_travel_debugging/basic.py\":0-30",
            "content": "import ctypes  # You see a ctypes import, you know this is going to be good\nimport dis\nimport sys\nimport types\nimport threading\nimport traceback\n# Problems which can be solved with more work if you're mad:\n# - No block stack support, so no resuming from within a try / except block, with blocks, or async for block.\n# - Nested functions (__closure__) and coroutines not supported\n# - EXTENDED_ARG not supported, so jumps within code objects must always be fewer than 256 bytes.\nMAGIC = 0xdd\n# The most recent error, retrievable with err(). Use TLS for this because I'm not a monster.\n_last_error = threading.local()\n_last_error.err = None\nABS_JUMPS = set(dis.hasjabs)\nfor _name, _opcode in dis.opmap.items():\n    globals()[_name] = _opcode\nclass DepthNotFound(Exception):\n    pass\ndef _get_value_stack_depth(co_code, target_idx):\n    \" Find the value stack depth after having executed up to (and including) the instruction at target_idx.\"\n    class Found(Exception):\n        def __init__(self, depth):\n            self.depth = depth"
        },
        {
            "comment": "This code iterates through Python bytecode, checking if it has been seen before. If so, it returns without executing further instructions. The set of valid opcodes includes operations like addition, subtraction, power, and others involved in data manipulation or control flow. It seems to be used for debugging purposes, potentially skipping already executed code to avoid infinite loops or other issues.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tests/skipexception_code_and_continue_resurrection_time_travel_debugging/basic.py\":32-53",
            "content": "    seen_pc = set()\n    def _interpret(pc, depth):\n        found = False\n        while not found:\n            found = pc == target_idx\n            instr = co_code[pc]\n            arg = co_code[pc + 1]\n            pc += 2\n            if pc in seen_pc:\n                return\n            seen_pc.add(pc)\n            if instr in {POP_TOP, INPLACE_POWER, INPLACE_MULTIPLY, INPLACE_MATRIX_MULTIPLY, INPLACE_TRUE_DIVIDE,\n                         INPLACE_MODULO, INPLACE_ADD, INPLACE_SUBTRACT, INPLACE_LSHIFT, INPLACE_RSHIFT, INPLACE_AND,\n                         INPLACE_XOR, INPLACE_OR, PRINT_EXPR, SET_ADD, LIST_APPEND, YIELD_VALUE, YIELD_FROM,\n                         IMPORT_STAR, STORE_NAME, DELETE_ATTR, STORE_GLOBAL, LIST_EXTEND, SET_UPDATE, DICT_UPDATE,\n                         DICT_MERGE, COMPARE_OP, IS_OP, CONTAINS_OP, IMPORT_NAME, STORE_FAST, STORE_DEREF,\n                         BINARY_POWER, BINARY_MULTIPLY, BINARY_MATRIX_MULTIPLY, BINARY_FLOOR_DIVIDE,\n                         BINARY_TRUE_DIVIDE, BINARY_MODULO, BINARY_ADD, BINARY_SUBTRACT,"
        },
        {
            "comment": "The code is responsible for managing stack depth based on the current instruction being interpreted. It updates the depth by subtracting different values depending on the type of instruction encountered. For example, if the instruction is a binary operation or CALL_FUNCTION, it reduces the stack depth by 1, but if the instruction is DELETE_SUBSCR, it reduces the stack depth by 2. The code also handles specific instructions like RAISE_VARARGS and CALL_FUNCTION_KW that require different adjustments to the stack depth based on their specific arguments.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tests/skipexception_code_and_continue_resurrection_time_travel_debugging/basic.py\":54-75",
            "content": "                         BINARY_SUBSCR, BINARY_LSHIFT, BINARY_RSHIFT, BINARY_AND, BINARY_XOR, BINARY_OR}:\n                depth -= 1\n            elif instr in {POP_JUMP_IF_TRUE, POP_JUMP_IF_FALSE}:\n                depth -= 1\n                _interpret(arg, depth)\n            elif instr in {JUMP_IF_TRUE_OR_POP, JUMP_IF_FALSE_OR_POP}:\n                _interpret(arg, depth)\n                depth -= 1\n            elif instr in {DELETE_SUBSCR, MAP_ADD, BUILD_SLICE, STORE_ATTR}:\n                depth -= 2\n            elif instr in {JUMP_IF_NOT_EXC_MATCH}:\n                depth -= 2\n                _interpret(pc + arg, depth)\n            elif instr in {STORE_SUBSCR}:\n                depth -= 3\n            elif instr == RAISE_VARARGS:\n                depth -= arg\n            elif instr == CALL_FUNCTION:\n                # pop arg parameters, pop function object, push result.\n                depth -= arg\n            elif instr == CALL_FUNCTION_KW:\n                # pop kw tuple, pop arg kw, pop function object, push result."
        },
        {
            "comment": "The code adjusts the stack depth based on different instructions encountered during execution. It handles function calls, object creation, loading variables and classes, unpacking sequences and maps, and other operations. The stack depth is increased or decreased depending on the specific instruction being processed.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tests/skipexception_code_and_continue_resurrection_time_travel_debugging/basic.py\":76-96",
            "content": "                depth -= (arg + 1)\n            elif instr == CALL_FUNCTION_EX:\n                # pop args, pop function object, maybe pop kw dict, push result.\n                depth -= 1\n                if arg & 1:\n                    depth -= 1\n            elif instr == CALL_METHOD:\n                # pop args, pop object, pop method, push result\n                depth -= (arg + 1)\n            elif instr in (BUILD_TUPLE, BUILD_LIST, BUILD_SET, BUILD_STRING):\n                depth -= (arg - 1)  # a new object is pushed\n            elif instr in {DUP_TOP, GET_ANEXT, BEFORE_ASYNC_WITH, LOAD_BUILD_CLASS, LOAD_CONST, LOAD_NAME, IMPORT_FROM,\n                           LOAD_GLOBAL, LOAD_FAST, LOAD_CLOSURE, LOAD_DEREF, LOAD_CLASSDEREF, LOAD_METHOD}:\n                depth += 1\n            elif instr in {DUP_TOP_TWO, SETUP_WITH}:\n                depth += 2\n            elif instr == UNPACK_SEQUENCE:\n                depth += (arg - 1)  # TOS is popped\n            elif instr == UNPACK_EX:\n                depth += arg\n            elif instr == BUILD_MAP:"
        },
        {
            "comment": "This code appears to be part of an interpreter for a programming language, specifically handling instruction execution and managing the stack depth. It uses nested loops and conditionals to interpret instructions based on opcodes and arguments, adjusting the depth accordingly. If a certain instruction is encountered or a target depth is not found during interpretation, it raises specific exceptions. The code seems to be looking for a target depth index, and returns it if found or throws an exception if not found.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tests/skipexception_code_and_continue_resurrection_time_travel_debugging/basic.py\":97-129",
            "content": "                depth += ((2 * arg) + 1)  # a new object is pushed\n            elif instr == BUILD_CONST_KEY_MAP:\n                depth += (arg + 1 + 1)\n            elif instr == FOR_ITER:\n                _interpret(pc + arg, depth - 1)\n                depth += 1\n            elif instr == MAKE_FUNCTION:\n                depth -= 2  # function code and name\n                while arg:\n                    depth += 1\n                    arg >>= 1\n                depth += 1  # the new function\n            elif instr == FORMAT_VALUE:\n                if arg & 0x4 == 0x4:\n                    depth -= 1\n            elif instr == JUMP_ABSOLUTE:\n                pc = arg\n            elif instr == EXTENDED_ARG:\n                raise NotImplementedError()\n            elif instr == RETURN_VALUE:\n                return\n            #print(f'{pc}\\t{dis.opname[instr]}\\t{arg}\\t{depth}')\n            if found:\n                raise Found(depth)\n    try:\n        _interpret(0, 0)\n    except Found as e:\n        return e.depth\n    raise DepthNotFound(target_idx)"
        },
        {
            "comment": "This code defines a `Frame` class and its fields for Python's frame objects, omitting some members. It also defines an `ObliteratedByException` class that returns '<ObliteratedByException>' when represented. The `_fetch_value_stack` function retrieves 'count' values from the value stack of a frame object in CPython 3.9, handling cases where a value is NULL.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tests/skipexception_code_and_continue_resurrection_time_travel_debugging/basic.py\":131-165",
            "content": "class Frame(ctypes.Structure):\n    pass\n# source: Python3.9/Include/cpython/frameobject.h\n# There are more members after f_valuestack which are omitted here.\nFrame._fields_ = [\n    (\"ob_refcnt\", ctypes.c_ssize_t),\n    (\"ob_type\", ctypes.c_void_p),\n    (\"ob_size\", ctypes.c_ssize_t),\n    (\"f_back\", ctypes.POINTER(Frame)),\n    (\"f_code\", ctypes.py_object),\n    (\"f_builtins\", ctypes.py_object),\n    (\"f_globals\", ctypes.py_object),\n    (\"f_locals\", ctypes.py_object),\n    (\"f_valuestack\", ctypes.POINTER(ctypes.py_object))]\nclass ObliteratedByException:\n    def __repr__(self):\n        return '<ObliteratedByException>'\ndef _fetch_value_stack(c_frame, count):\n    \"\"\"\n    Return 'count' values from the value stack of 'frame'. Implementation- and version-specific (CPython 3.9).\n    \"\"\"\n    if count <= 0:\n        return []\n    frame = Frame.from_address(id(c_frame))\n    values = []\n    for i in range(count):\n        try:\n            values.append(frame.f_valuestack[i])\n        except ValueError:\n            # Very likely \"PyObject is NULL\". This happens because CPython uses a NULL return value to signal"
        },
        {
            "comment": "This code snippet seems to be related to rewriting the absolute jump offsets in a bytecode. It finds the byte offsets matching specific opcodes and then adds an 'offset' to all jumps, which essentially extends the instruction with the given argument. The purpose of this seems to modify or adjust jump offsets within the code.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tests/skipexception_code_and_continue_resurrection_time_travel_debugging/basic.py\":166-187",
            "content": "            # an exception. If an operation triggered by an opcode causes an exception, that operation's \"result\"\n            # of NULL will be written to the stack before the exception machinery is started.\n            values.append(ObliteratedByException())\n    return values\ndef _find_offsets_matching_opcodes(co_code, opcodes):\n    \" Return a list of byte offsets inside co_code matching opcodes in 'opcodes' \"\n    return [idx * 2 for idx, opcode in enumerate(co_code[::2]) if opcode in opcodes]\ndef _find_abs_jump_offset_bytes(co_code):\n    \" Return a list of byte offets for jump offsets in co_code. \"\n    # Broken by EXTENDED ARG (if the argument is a jump offset)\n    # idx + 1 returns the argument, rather than the bytecode.\n    return [idx + 1 for idx in _find_offsets_matching_opcodes(co_code, ABS_JUMPS)]\ndef _rewrite_abs_jump_offsets(code_bytes, amt):\n    \" Add 'offset' to all jumps. \"\n    for offset in _find_abs_jump_offset_bytes(code_bytes):\n        code_bytes[offset] += amt\ndef _extend_instr(opcode, arg):"
        },
        {
            "comment": "This code handles the ON ERROR RESUME NEXT functionality. It generates new callables for each frame in the traceback and returns the root callable. If called from the excepthook, it calls _resume recursively on the next frame. If a patch prefix is present, it fixes the offset by retrieving the original traceback frame and its associated constants.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tests/skipexception_code_and_continue_resurrection_time_travel_debugging/basic.py\":188-218",
            "content": "    \" Prefix opcode with one or more EXTENDED_ARG opcodes if it's > 255. \"\n    arg_bytes = []\n    while True:\n        arg_bytes.append(arg & 0xff)\n        arg >>= 8\n        if not arg:\n            break\n    code = []\n    while len(arg_bytes) > 1:\n        code.extend([EXTENDED_ARG, arg_bytes.pop()])\n    code.extend([opcode, arg_bytes.pop()])\n    return code\nFRAME_CONST_IDX = -2\nCODE_MAGIC_IDX = 3\ndef _resume(tb):\n    \"\"\"\n    Main function for ON ERROR RESUME NEXT. Generate new callables for each frame in 'tb' and return the root callable.\n    \"\"\"\n    if tb.tb_frame.f_code is sys.excepthook.__code__:\n        # We're being called from the excepthook.\n        return _resume(tb.tb_next)\n    if tb.tb_frame.f_code.co_code.startswith(bytes([NOP, MAGIC, NOP])):\n        # We've patched this function before. Restore the original traceback frame which we squirrelled away.\n        tb_frame = tb.tb_frame.f_code.co_consts[FRAME_CONST_IDX]\n        # Fix offets, which will include our patch prefix.\n        old_prefix_length = tb.tb_frame.f_code.co_code[CODE_MAGIC_IDX]"
        },
        {
            "comment": "Checks if the current frame caused an exception, if not then finds the child callable and arguments for resuming execution from next instruction. If the current frame is the one causing the exception, iterates through instructions to find the next line using dis.findlinestarts method.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tests/skipexception_code_and_continue_resurrection_time_travel_debugging/basic.py\":219-237",
            "content": "        faulting_instruction_idx = tb.tb_lasti - old_prefix_length\n    else:\n        tb_frame = tb.tb_frame\n        faulting_instruction_idx = tb.tb_lasti\n    old_code_obj = tb_frame.f_code\n    code_bytes = list(old_code_obj.co_code)\n    if tb.tb_next:\n        # This isn't the frame which caused the exception. This is a parent frame which called something which caused\n        # the exception. We can't just re-try the call, though, because we want to call a rewritten child which skips\n        # the exception-causing behaviour. So instead we skip to the next instruction here.\n        child_callable, child_args = _resume(tb.tb_next)\n        next_instr_idx = faulting_instruction_idx + 2\n    else:\n        # We're on the frame with the faulting instruction. Find the next line. The compiler can reorder lines, so this\n        # isn't guaranteed to do anything sensible, but if you're looking for sensible you're in the wrong place.\n        child_callable, child_args = None, None\n        for offset, lineno in dis.findlinestarts(tb_frame.f_code):"
        },
        {
            "comment": "If the offset is greater than faulting_instruction_idx and line number is higher than tb_frame.f_lineno, set next_instr_idx as offset and break. This indicates running out of lines or last line blew up, so resume from the opcode after RETURN_VALUE safely unless stack isn't corrupted. Create a prefix code with magic sequence, followed by NOP to fix the modified code. If there are distinct locals() (function), supply them as arguments (argcount equals length of tb_frame.f_code.co_varnames).",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tests/skipexception_code_and_continue_resurrection_time_travel_debugging/basic.py\":238-257",
            "content": "            if offset > faulting_instruction_idx and lineno > tb_frame.f_lineno:\n                next_instr_idx = offset\n                break\n        else:\n            # We ran out of lines (e.g. last line of function was 'return <something which blows up>).\n            # Fall back to resuming on the next opcode. The last opcode of every Python function is RETURN_VALUE,\n            # which won't throw (assuming the stack isn't corrupt, which isn't a guarantee here actually :), so\n            # doing this should be relatively safe.\n            next_instr_idx = faulting_instruction_idx + 2\n    # Create a short prefix which will fix up the code, starting with a magic sequence so we can identify\n    # code we've modified\n    prefix_code = [\n        NOP, MAGIC,\n        NOP, 0  # index of first instruction past our patch prefix, to be filled in later.\n    ]\n    if old_code_obj.co_varnames:\n        # It's something which has a distinct locals() (i.e. a function). Supply them as arguments.\n        argcount = len(tb_frame.f_code.co_varnames)"
        },
        {
            "comment": "The code is checking if the faulting instruction index is negative or not. If it's negative, it restores the value stack by finding the depth using abstract interpretation and fetching the stack. If positive, it raises a NotImplementedError. The code also adds magic constants to the co_consts list.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tests/skipexception_code_and_continue_resurrection_time_travel_debugging/basic.py\":258-279",
            "content": "        args = [tb_frame.f_locals.get(name) for name in tb_frame.f_code.co_varnames]\n    else:\n        # It's something else (e.g. a module). Don't supply locals.\n        argcount = 0\n        args = []\n    args.reverse()  # Args are written RTL.\n    if faulting_instruction_idx >= 0:\n        # Restore the value stack. The interpreter doesn't record the value stack depth in a very accessible way (it's a\n        # local variable on the C stack in ceval.c), so figure out the depth of the stack using abstract interpretation.\n        stack_depth = _get_value_stack_depth(code_bytes, faulting_instruction_idx)\n        stack = _fetch_value_stack(tb_frame, stack_depth)  # first entry is bottom of stack.\n    else:\n        # The exception is coming from inside the house^W^W^Wour fixup stub code.\n        print(tb.tb_lasti, faulting_instruction_idx, tb, tb.tb_next)\n        raise NotImplementedError()\n    # Add some magic values as consts.\n    co_consts = list(old_code_obj.co_consts)\n    # First magic const: the patched child function to call."
        },
        {
            "comment": "Stores child callable and arguments in co_consts, appends traceback frame, stack as tuple to co_consts. Extends prefix_code with code to restore stack from const tuple when function starts.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tests/skipexception_code_and_continue_resurrection_time_travel_debugging/basic.py\":280-302",
            "content": "    child_callable_const_idx = None\n    if child_callable:\n        co_consts.append(child_callable)\n        co_consts.append(child_args)\n        child_callable_const_idx = len(co_consts) - 2\n    # Second magic const: the original traceback frame. We use this to get the unpatched version of a function, should\n    # the patched version throw another exception.\n    co_consts.append(tb_frame)\n    # Third magic const: the stack as a tuple.\n    if tb.tb_next and stack and isinstance(stack[-1], ObliteratedByException):\n        # Normally the result of an exception is NULL, but in this case we know the last thing we did in this\n        # frame involved a function call (because tb_next is not None), and we've called the function above\n        # and have a result. We will restore the stack and then call the function.\n        stack = stack[:-1]\n    co_consts.append(tuple(stack))\n    # Add code to restore the stack from our const tuple when the function starts.\n    if stack:\n        prefix_code.extend([\n            LOAD_CONST, len(co_consts) - 1,"
        },
        {
            "comment": "This code creates a patch prefix to restore function state, adds code for child function call (if any), and jumps back to the original position after restoring. It stores the length of the prefix code in an argument slot and rewrites all absolute jumps.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tests/skipexception_code_and_continue_resurrection_time_travel_debugging/basic.py\":303-326",
            "content": "            UNPACK_SEQUENCE, len(stack),\n        ])\n    # Add code to call the patched child function (if any) when the function starts.\n    if child_callable:\n        prefix_code.extend([\n            LOAD_CONST, child_callable_const_idx,  # callable\n            LOAD_CONST, child_callable_const_idx + 1,  # args\n            UNPACK_SEQUENCE, len(child_args),\n            CALL_FUNCTION, len(child_args)])\n    # Add code to jump to where we left off in the function after we've restored its state.\n    prefix_code.extend(_extend_instr(JUMP_ABSOLUTE, next_instr_idx))\n    # We've finished adding code to the patch prefix, so store its length. We store it in the\n    # otherwise-unused argument slot to the NOP opcode (in recent CPython versions, every opcode\n    # has an argument slot).\n    prefix_code[CODE_MAGIC_IDX] = len(prefix_code)\n    # The new code is the previous code plus our prefix.\n    code_bytes = prefix_code + code_bytes\n    # Now that we've put the prefix code at the start, rewrite all absolute jumps.\n    _rewrite_abs_jump_offsets(code_bytes, len(prefix_code))"
        },
        {
            "comment": "This code constructs a new code object and function object by using the original's structure as a template. It sets the necessary parameters like argument count, code bytes, and names for the new code object, and then creates a FunctionType with the new code object and f_globals dictionary. The function returns the new function object and the tuple of arguments.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tests/skipexception_code_and_continue_resurrection_time_travel_debugging/basic.py\":328-347",
            "content": "    # We can now construct a full code object and function object with our new code and consts, using the original as a\n    # template.\n    co_names = old_code_obj.co_names\n    print(\"co_names type:\", type(co_names))\n    new_code_obj = types.CodeType(argcount, 0,\n                                  old_code_obj.co_kwonlyargcount, old_code_obj.co_nlocals,\n                                  old_code_obj.co_stacksize, old_code_obj.co_flags, bytes(code_bytes),\n                                  tuple(co_consts), co_names, old_code_obj.co_varnames,\n                                  old_code_obj.co_filename, old_code_obj.co_name, old_code_obj.co_firstlineno,\n                                  old_code_obj.co_lnotab)\n    # TODO: __closure__ not copied\n    frame_func = types.FunctionType(new_code_obj, tb_frame.f_globals, name=tb_frame.f_code.co_name)\n    #print('resume called for tb ', tb, tb.tb_next, frame_func)\n    #dis.dis(frame_func, depth=0)\n    return (frame_func, tuple(args))\ndef _excepthook(type_, value, tb):"
        },
        {
            "comment": "The code defines a function _excepthook that handles exceptions, and provides additional functions _resume and err. The while loop continuously tries to execute the resumed function until an exception occurs, then logs the exception for further handling. The on_error_resume_next function sets sys.excepthook to _excepthook for error resumption. The err function returns the current error type and clears it.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/tests/skipexception_code_and_continue_resurrection_time_travel_debugging/basic.py\":348-369",
            "content": "    global _last_error\n    while True:\n        _last_error.err = type_\n        func, args = _resume(tb)\n        try:\n            func(*args)\n        except Exception as e:\n            type_, value, tb = sys.exc_info()\n            #print('continuing...')\n            #traceback.print_exc()\n        else:\n            break\ndef on_error_resume_next():\n    sys.excepthook = _excepthook\ndef err():\n    err = _last_error.err\n    _last_error.err = None\n    return err"
        }
    ]
}