{
    "summary": "The code imports functions for keyword removal and topic modeling in English/Chinese, selects words by shuffling topics, fetches random keywords to request gifs/videos from a local server, and retrieves a random picture with related words using keyword and topic modeling.",
    "details": [
        {
            "comment": "This code imports necessary modules and defines two functions: `removeKeywordDuplicates` for removing duplicate keywords in a list or string, and `topicModeling` for topic modeling with specified language (English or Chinese). It also includes an exception handling for unknown keyword types.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/modules/topicGenerator/onlineTopicGenerator.py\":0-32",
            "content": "from pyjom.commons import *\nfrom pyjom.languagetoolbox import englishTopicModeling, chineseTopicModeling\nfrom lazero.utils.tools import flattenUnhashableList  # one of my classic methods\nimport requests\n# import jieba\nfrom typing import Literal\ndef removeKeywordDuplicates(keywords):\n    keywordsType = type(keywords)\n    inputFuncs = {\n        str: lambda x: x.split(\" \"),\n        list: lambda x: x,\n        tuple: lambda x: list(x),\n    }\n    outputFuncs = {\n        str: lambda x: \" \".join(x),\n        list: lambda x: x,\n        tuple: lambda x: tuple(x),\n    }\n    if keywordsType in inputFuncs.keys():\n        keywordsList = inputFuncs[keywordsType](keywords)\n    else:\n        raise Exception(\"Unknown keywords type: %s\" % type(keywords))\n    keywordsSet = set(keywordsList)\n    keywordsSetList = list(keywordsSet)\n    return outputFuncs[keywordsType](keywordsSetList)\ndef topicModeling(sentences: list[str], lang=\"en\"):  # specify language please?\n    # python does not enforce type checking. use third party tool such as linter instead."
        },
        {
            "comment": "The code checks the language input and applies the appropriate topic modeling function. It then performs word selection by removing words already in the list, shuffling the remaining topics, and randomly choosing a new word to append to the selected_topic_list until it reaches a specified threshold.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/modules/topicGenerator/onlineTopicGenerator.py\":33-64",
            "content": "    if lang == \"en\":\n        topics = englishTopicModeling(sentences)\n        return topics\n    elif lang == \"zh\":\n        topics = chineseTopicModeling(sentences)\n        return topics\n    else:\n        raise Exception(\"Unknown language: %s\" % lang)\ndef topicWordSelection(\n    topics,\n    core_topic_set: set,\n    selected_topic_list: list,\n    mode: Literal[\"combined\", \"separate\"] = \"combined\",\n    threshold=10,\n):\n    if len(selected_topic_list) > threshold:\n        for _ in range(len(selected_topic_list) - threshold):\n            selected_topic_list.pop(0)  # right way to remove elem from original list.\n    selected_topic_set = set(list(core_topic_set) + selected_topic_list)\n    import random\n    mTopics = topics.copy()\n    random.shuffle(mTopics)\n    for topic in mTopics:\n        words = topic[mode]\n        words = [x for x in words if x not in selected_topic_set]\n        if len(words) > 0:\n            word = random.choice(words)\n            selected_topic_list.append(word)  # no need to go elsewhere.\n            return word"
        },
        {
            "comment": "The code defines a function called `getMetaTopicString` which takes a metaTopic dictionary as input and returns a string of topic words. It first generates static, optional, and dynamic candidates from the provided metaTopic dictionary. Then, it selects one candidate from each category and combines them into a final string. The code also includes a print statement and a breakpoint for debugging purposes. Finally, the decorator `@decorator` is used to apply some functionality to the `OnlineTopicGenerator` function.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/modules/topicGenerator/onlineTopicGenerator.py\":65-94",
            "content": "    print(\"no topic word this time\")\n    return None\ndef getMetaTopicString(metaTopic):\n    staticCandidates = [random.choice(x) for x in metaTopic.get(\"static\", [])]\n    optionalCandidates = [random.choice(x) for x in metaTopic.get(\"optional\", [])]\n    if len(optionalCandidates) > 0:\n        optionalCandidates = random.choice(optionalCandidates)\n    if type(optionalCandidates) != list:\n        optionalCandidates = [optionalCandidates]\n    dynamicCandidates = [random.choice(x) for x in metaTopic.get(\"dynamic\", [])]\n    samples = random.sample(\n        dynamicCandidates, random.randint(0, len(dynamicCandidates))\n    )\n    # print(staticCandidates)\n    # print(optionalCandidates)\n    # print(samples)\n    # breakpoint()\n    return \" \".join(staticCandidates + optionalCandidates + samples)\n@decorator\ndef OnlineTopicGenerator(\n    source=\"giphy\",\n    metaTopic={\n        \"static\": [[\"dog\", \"cat\"], [\"funny\", \"cute\"]],\n        \"dynamic\": [[\"samoyed\", \"husky\", \"teddy\", \"chiwawa\"]],\n    },  # this is not a matrix.\n    # sample_size = 10 # per search."
        },
        {
            "comment": "Code fetches random keywords from a metaTopic string and sends GET requests to a local server (running on 127.0.0.1:8902) for gifs or videos related to these keywords. If the keyword-related request is successful, it stores the result in mRandomPictureJson variable. This process continues until a timeout occurs or until another condition breaks the loop. The code also has debugging support by allowing the source_type to be hardcoded as 'videos'.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/modules/topicGenerator/onlineTopicGenerator.py\":95-121",
            "content": "    timeout:float=20\n):\n    getKeywords = lambda: getMetaTopicString(metaTopic)\n    core_topic_set = {\n        *flattenUnhashableList([value for key, value in metaTopic.items()])\n    }  # common way to initialize a set.\n    selected_topic_list = []\n    if source == \"giphy\":\n        waitForServerUp(8902, \"nodejs giphy server\")\n        keywords = getKeywords()\n        while True:\n            import time\n            time.sleep(0.5)\n            harvestedData = []\n            try:\n                source_type = random.choice([\"videos\", \"gifs\"])\n                # source_type = 'videos' # for debugging\n                if random.random() > 0.5:\n                    with requests.get(\n                        \"http://127.0.0.1:8902/random\",\n                        params={\"q\": keywords, \"rating\": \"g\", \"type\": source_type},\n                        verify=False,\n                        proxies=None,\n                        timeout=timeout\n                    ) as mRandomPicture:  # may you get stickers?\n                        mRandomPictureJson = mRandomPicture.json()"
        },
        {
            "comment": "This code is making a request to an API, harvesting data based on keywords and type, and selecting a random picture. It also retrieves related words for the selected picture.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/modules/topicGenerator/onlineTopicGenerator.py\":122-142",
            "content": "                        harvestedData += mRandomPictureJson[\"data\"]\n                        randomPictureId = mRandomPictureJson[\"data\"][0][\"id\"]\n                else:\n                    with requests.get(\n                        \"http://127.0.0.1:8902/search\",\n                        params={\"q\": keywords, \"rating\": \"g\", \"type\": source_type},\n                        verify=False,\n                        proxies=None,\n                        timeout=timeout\n                    ) as mSearchPictures:\n                        mSearchPicturesJson = mSearchPictures.json()\n                        harvestedData += mSearchPicturesJson[\"data\"]\n                        randomPictureId = random.choice(mSearchPicturesJson[\"data\"])[\n                            \"id\"\n                        ]\n                selectedWord = None\n                with requests.get(\n                    \"http://127.0.0.1:8902/related\",\n                    params={\n                        \"q\": randomPictureId,\n                        \"type\": source_type,"
        },
        {
            "comment": "This code segment fetches related pictures from a URL, performs topic modeling on the titles of these images, selects a word from the core topic set for further keyword generation, and handles potential exceptions.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/modules/topicGenerator/onlineTopicGenerator.py\":143-164",
            "content": "                    },\n                    verify=False,\n                    proxies=None,  # seems not working? wtf?\n                ) as mRelatedPictures:\n                    mRelatedPicturesJson = mRelatedPictures.json()\n                    harvestedData += mRelatedPicturesJson[\"data\"]\n                    sentences = [x[\"title\"] for x in mRelatedPicturesJson[\"data\"]]\n                    topics = topicModeling(sentences)\n                    selectedWord = topicWordSelection(\n                        topics, core_topic_set, selected_topic_list\n                    )\n                if not selectedWord is None:\n                    keywords = \" \".join(\n                        [getKeywords(), selectedWord]\n                    )  # for next iteration.\n                    print(\"REFRESHING KEYWORDS:\", keywords)\n                else:\n                    keywords = getKeywords()\n                # recheck keywords!\n                keywords = removeKeywordDuplicates(keywords)\n            except:\n                import traceback"
        },
        {
            "comment": "This code block catches exceptions that may occur while fetching GIPHY topics. It prints the error trace and a descriptive message, then proceeds to iterate through the harvested data, yielding each entry's ID and media value after converting it using json_auto_float_int function.",
            "location": "\"/media/root/Toshiba XG3/works/pyjom_doc/src/pyjom/modules/topicGenerator/onlineTopicGenerator.py\":166-169",
            "content": "                traceback.print_exc()\n                print(\"ERROR WHEN FETCHING GIPHY TOPIC\")\n            for elem in harvestedData:\n                yield elem[\"id\"], json_auto_float_int(elem[\"media\"])"
        }
    ]
}