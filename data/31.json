{
    "3100": {
        "file_id": 358,
        "content": "# princlple\nif the image quality is bad, then no matter what model we use we will get poor result.\n# solution\nuse image quality assessment to examine ROI tracked by DasiamRPN and make sure we will use the best sample and get most accurate result.\n# footnote\nDasiamRPN is a good tracker. so before abandon the tracking data re-examine the ROI for several times to see if it really lost its mark. so as the siamMask.\nYou can also examine the image quality by means of motion. if it heavily moves, we refuse to feed it into model.\nIntegrate TA-Lib for less boilerplates. i mean financial analysis can be applied anywhere. they are basically statistics. anything other than that might just be fake.\nwhere is your dog video?\n# further actions\nyou may upscale video using anime4k or other engines.",
        "type": "code",
        "location": "/tests/image_quality_tests/README.md:1-21"
    },
    "3101": {
        "file_id": 358,
        "content": "This code provides a solution to ensure image quality for model accuracy, examines ROI using DasiamRPN and siamMask, re-examines for potential loss of mark, applies motion analysis, suggests integrating TA-Lib for statistics, and recommends upscaling video with anime4k or other engines.",
        "type": "comment"
    },
    "3102": {
        "file_id": 359,
        "content": "/tests/image_quality_tests/pybrisque_init.sh",
        "type": "filepath"
    },
    "3103": {
        "file_id": 359,
        "content": "Installing required dependencies and libraries for pybrisque Python package, including libsvm-dev, pip3 installing pybrisque, alternative options provided for faster installation.",
        "type": "summary"
    },
    "3104": {
        "file_id": 359,
        "content": "apt-get install libsvm-dev\npip3 install pybrisque\n# pip3 install --process-dependency-links pybrisque\npip3 install git+https://github.com/Salinger/libsvm-python.git\n# which is faster?",
        "type": "code",
        "location": "/tests/image_quality_tests/pybrisque_init.sh:1-6"
    },
    "3105": {
        "file_id": 359,
        "content": "Installing required dependencies and libraries for pybrisque Python package, including libsvm-dev, pip3 installing pybrisque, alternative options provided for faster installation.",
        "type": "comment"
    },
    "3106": {
        "file_id": 360,
        "content": "/tests/image_quality_tests/pybrisque_test.py",
        "type": "filepath"
    },
    "3107": {
        "file_id": 360,
        "content": "This code imports the BRISQUE class from the brisque module, integrates svmutil.py and svm.py files, initializes an instance of BRISQUE as brisq, gets a feature from an image path using brisq.get_feature(), assigns an image path to 'image_path' variable, retrieves a quality score for the image using brisq.get_score(image_path), and prints the obtained score which is very fast.",
        "type": "summary"
    },
    "3108": {
        "file_id": 360,
        "content": "from brisque import BRISQUE\n# integrated svmutil.py and svm.py from that git repo.\n# really strange.\nbrisq = BRISQUE()\n# brisq.get_feature('/path')\nimage_path = \"/root/Desktop/works/pyjom/tests/image_quality_tests/sample.bmp\"\nscore = brisq.get_score(image_path)\nprint(\"score:\",score)\n# this is damn fast.",
        "type": "code",
        "location": "/tests/image_quality_tests/pybrisque_test.py:1-12"
    },
    "3109": {
        "file_id": 360,
        "content": "This code imports the BRISQUE class from the brisque module, integrates svmutil.py and svm.py files, initializes an instance of BRISQUE as brisq, gets a feature from an image path using brisq.get_feature(), assigns an image path to 'image_path' variable, retrieves a quality score for the image using brisq.get_score(image_path), and prints the obtained score which is very fast.",
        "type": "comment"
    },
    "3110": {
        "file_id": 361,
        "content": "/tests/image_quality_tests/pyiqa_inference.py",
        "type": "filepath"
    },
    "3111": {
        "file_id": 361,
        "content": "This code uses pyiqa library to evaluate image quality and compare algorithms, averaging scores for multiple inputs and timing the process. It saves or prints results and handles missing files with errors.",
        "type": "summary"
    },
    "3112": {
        "file_id": 361,
        "content": "import argparse\nimport glob\nimport os\nfrom PIL import Image\nfrom pyiqa.models.inference_model import InferenceModel\nmetric_name = None\ndef main():\n    global metric_name\n    \"\"\"Inference demo for pyiqa.\n    \"\"\"\n    parser = argparse.ArgumentParser()\n    parser.add_argument('-i', '--input', type=str, default=None, help='input image/folder path.')\n    parser.add_argument('-r', '--ref', type=str, default=None, help='reference image/folder path if needed.')\n    parser.add_argument(\n        '-m',\n        '--metric_mode',\n        type=str,\n        default='FR',\n        help='metric mode Full Reference or No Reference. options: FR|NR.')\n    parser.add_argument('-n', '--metric_name', type=str, default='PSNR', help='IQA metric name, case sensitive.')\n    parser.add_argument('--model_path', type=str, default=None, help='Weight path for CNN based models.')\n    parser.add_argument('--img_range', type=float, default=1.0, help='Max value of image tensor.')\n    parser.add_argument(\n        '--input_size', type=int, nargs='+', default=None, help='size of input image. (H, W) for tuple input.')",
        "type": "code",
        "location": "/tests/image_quality_tests/pyiqa_inference.py:1-26"
    },
    "3113": {
        "file_id": 361,
        "content": "This code defines a main function for inference demo of the pyiqa library. It takes input, reference image or folder paths as arguments, and allows selection of metric mode (Full Reference or No Reference) and metric name (IQA metric). It also accepts optional parameters like model path, maximum value of image tensor, and input size.",
        "type": "comment"
    },
    "3114": {
        "file_id": 361,
        "content": "    parser.add_argument(\n        '--mean', type=float, nargs='+', default=None, metavar='MEAN', help='Override mean pixel value of dataset')\n    parser.add_argument(\n        '--std', type=float, nargs='+', default=None, metavar='STD', help='Override std deviation of of dataset')\n    parser.add_argument('--save_file', type=str, default=None, help='path to save results.')\n    args = parser.parse_args()\n    metric_name = args.metric_name.lower()\n    # set up IQA model\n    iqa_model = InferenceModel(metric_name, args.metric_mode, args.model_path, args.img_range, args.input_size,\n                               args.mean, args.std)\n    metric_mode = iqa_model.metric_mode\n    if os.path.isfile(args.input):\n        input_paths = [args.input]\n        if args.ref is not None:\n            ref_paths = [args.ref]\n    else:\n        input_paths = sorted(glob.glob(os.path.join(args.input, '*')))\n        if args.ref is not None:\n            ref_paths = sorted(glob.glob(os.path.join(args.ref, '*')))\n    if args.save_file:\n        sf = open(args.save_file, 'w')",
        "type": "code",
        "location": "/tests/image_quality_tests/pyiqa_inference.py:27-53"
    },
    "3115": {
        "file_id": 361,
        "content": "This code sets up an IQA (Image Quality Assessment) model for image quality evaluation. It takes in arguments such as the metric name, input and reference file paths, model path, image range, input size, mean, and std deviation values. If any file is missing, it throws an error. Finally, if a save file is specified, it opens the file for writing.",
        "type": "comment"
    },
    "3116": {
        "file_id": 361,
        "content": "    avg_score = 0\n    test_img_num = len(input_paths)\n    for idx, img_path in enumerate(input_paths):\n        img_name = os.path.basename(img_path)\n        tar_img = Image.open(img_path)\n        if metric_mode == 'FR':\n            ref_img_path = ref_paths[idx]\n            ref_img = Image.open(ref_img_path)\n        else:\n            ref_img = None\n        score = iqa_model.test(tar_img, ref_img)\n        avg_score += score\n        print(f'{metric_name} score of {img_name} is: {score}')\n        if args.save_file:\n            sf.write(f'{img_name}\\t{score}\\n')\n    avg_score /= test_img_num\n    if test_img_num > 1:\n        print(f'Average {metric_name} score of {args.input} with {test_img_num} images is: {avg_score}')\n    if args.save_file:\n        sf.close()\n    if args.save_file:\n        print(f'Done! Results are in {args.save_file}.')\n    else:\n        print(f'Done!')\nimport timeit\nif __name__ == '__main__':\n    main() # to eliminate first time error.\n    repeatTime = 10 # just test\n    taketime = timeit.timeit(main,number=repeatTime)",
        "type": "code",
        "location": "/tests/image_quality_tests/pyiqa_inference.py:55-85"
    },
    "3117": {
        "file_id": 361,
        "content": "This code calculates the image quality score using a pre-trained model. It takes input images and optionally references images, then averages the scores for each image if there are multiple inputs. The results can be saved to a file or simply printed out. It also times how long the process took.",
        "type": "comment"
    },
    "3118": {
        "file_id": 361,
        "content": "    print(\"{} taking time:\".format(metric_name),taketime)\n###########SCOREBOARD##############\n# niqe taking time: 0.24909197200031485\n# brisque taking time: 0.1862209509999957\n# nrqm taking time: 18.15363560300466\n# pi taking time: 18.80046885000047\n# musiq taking time: 2.963457034995372\n# musiq-ava taking time: 2.9661162160045933\n# musiq-koniq taking time: 3.0705577400003676\n# musiq-paq2piq taking time: 2.957391322001058\n# musiq-spaq taking time: 2.948993805999635\n# paq2piq taking time: 1.4981017659956706\n# dbcnn taking time: 16.063134230993455",
        "type": "code",
        "location": "/tests/image_quality_tests/pyiqa_inference.py:86-99"
    },
    "3119": {
        "file_id": 361,
        "content": "This code snippet measures the time taken by various image quality assessment algorithms. The output shows the names and respective times for each algorithm in descending order. It can be used to compare the efficiency of these algorithms when evaluating image quality.",
        "type": "comment"
    },
    "3120": {
        "file_id": 362,
        "content": "/tests/image_quality_tests/pyiqa_test.py",
        "type": "filepath"
    },
    "3121": {
        "file_id": 362,
        "content": "This code is filtering out certain metric modes from the DEFAULT_CONFIGS dictionary, printing only those not in the allow_lists. The author comments that these methods may not be as useful and seems difficult to determine their effectiveness before downloading all models. They express confusion about the size of some model files.",
        "type": "summary"
    },
    "3122": {
        "file_id": 362,
        "content": "from pyiqa.default_model_configs import DEFAULT_CONFIGS\nmlist = []\nfor key in DEFAULT_CONFIGS.keys():\n    config = DEFAULT_CONFIGS[key]\n    mode = config[\"metric_mode\"]\n    if mode == \"NR\":\n        mlist.append(key)\n# print(mlist)\n# forbid_lists = [\"ilniqe\",\"nima\"]\nallow_lists = [\"niqe\", \"brisque\", \"paq2piq\"]\nfor elem in mlist:\n    if elem not in allow_lists:\n        continue\n    print(elem)\n# i need to say these methods are not as useful as it was said.\n# the objective shall be EMA based.\n# ['niqe', 'ilniqe', 'brisque', 'nrqm', 'pi', 'musiq', 'musiq-ava', 'musiq-koniq', 'musiq-paq2piq', 'musiq-spaq', 'nima', 'paq2piq', 'dbcnn']\n# you may try them all?\n# it is really hard to say before we download all these models.\n# seems not really dependent on the model size?\n# we've got freaking huge shits.\n# like this one, for nima.\n# https://download.pytorch.org/models/vgg16-397923af.pth\n# what is this shit for anyway?",
        "type": "code",
        "location": "/tests/image_quality_tests/pyiqa_test.py:1-31"
    },
    "3123": {
        "file_id": 362,
        "content": "This code is filtering out certain metric modes from the DEFAULT_CONFIGS dictionary, printing only those not in the allow_lists. The author comments that these methods may not be as useful and seems difficult to determine their effectiveness before downloading all models. They express confusion about the size of some model files.",
        "type": "comment"
    },
    "3124": {
        "file_id": 363,
        "content": "/tests/image_quality_tests/t_pyiqa2.sh",
        "type": "filepath"
    },
    "3125": {
        "file_id": 363,
        "content": "This code is piping the output of `pyiqa_test.py` into `test_pyiqa.sh`, filtering for lines containing \"taking time\", and returning those results.",
        "type": "summary"
    },
    "3126": {
        "file_id": 363,
        "content": "python3 pyiqa_test.py | xargs -iabc bash test_pyiqa.sh abc 2>&1 | grep \"taking time\"",
        "type": "code",
        "location": "/tests/image_quality_tests/t_pyiqa2.sh:1-1"
    },
    "3127": {
        "file_id": 363,
        "content": "This code is piping the output of `pyiqa_test.py` into `test_pyiqa.sh`, filtering for lines containing \"taking time\", and returning those results.",
        "type": "comment"
    },
    "3128": {
        "file_id": 364,
        "content": "/tests/image_quality_tests/test_image_quality.py",
        "type": "filepath"
    },
    "3129": {
        "file_id": 364,
        "content": "This code reads a video, extracts frames at periodic intervals, calculates the image quality using BRISQUE algorithm and displays it on the frame. The score is displayed in the lower-left corner of each frame, and the user can stop the loop by pressing 'q'.",
        "type": "summary"
    },
    "3130": {
        "file_id": 364,
        "content": "# import imquality.brisque as brisque\nimport cv2\nimport PIL\nvideo = cv2.VideoCapture(\"../../samples/video/dog_with_text.mp4\")\n_,frame = video.read()\n# frame = imutils.resize(frame,width=720) #why?\nindex = 0\nscore = -1\nperiod = 20\nwhile frame is not None:\n    _, frame = video.read()\n    index+=1\n    if frame is None:\n        print(\"VIDEO END.\")\n        break\n    # just get image quality.\n    # the speed is not so damn fast.\n    image = cv2.cvtColor(frame,cv2.COLOR_BGR2GRAY)\n    image = PIL.Image.fromarray(image)\n    if index%period == 0:\n        try:\n            score = brisque.score(image) # the lower the better, it was said.\n        except:\n            score = -1 # unknown.\n    cv2.putText(\n        frame,\n        \"[{}]\".format(str(score)[:5]),\n        (200,200),\n        cv2.FONT_HERSHEY_SIMPLEX,\n        2,\n        (0,255,0),\n        3,\n        cv2.LINE_AA,\n    )\n    cv2.imshow('Output',frame)\n    key  =  cv2.waitKey(1) & 0xff\n    if key == ord('q'):\n        break",
        "type": "code",
        "location": "/tests/image_quality_tests/test_image_quality.py:1-40"
    },
    "3131": {
        "file_id": 364,
        "content": "This code reads a video, extracts frames at periodic intervals, calculates the image quality using BRISQUE algorithm and displays it on the frame. The score is displayed in the lower-left corner of each frame, and the user can stop the loop by pressing 'q'.",
        "type": "comment"
    },
    "3132": {
        "file_id": 365,
        "content": "/tests/image_quality_tests/test_pyiqa.sh",
        "type": "filepath"
    },
    "3133": {
        "file_id": 365,
        "content": "This code is running the pyiqa_inference.py script with the specified image and name argument, which downloads the necessary weights from Torch Hub directory for image quality testing.",
        "type": "summary"
    },
    "3134": {
        "file_id": 365,
        "content": "python3 pyiqa_inference.py -n $1 -i sample.bmp\n# it is downloading weights to torch hub directory.",
        "type": "code",
        "location": "/tests/image_quality_tests/test_pyiqa.sh:1-2"
    },
    "3135": {
        "file_id": 365,
        "content": "This code is running the pyiqa_inference.py script with the specified image and name argument, which downloads the necessary weights from Torch Hub directory for image quality testing.",
        "type": "comment"
    },
    "3136": {
        "file_id": 366,
        "content": "/tests/image_quality_tests/tiq2.py",
        "type": "filepath"
    },
    "3137": {
        "file_id": 366,
        "content": "The code reads video frames, calculates image quality using BRISQUE algorithm, resizes and converts to grayscale. It then displays the resized frame on a GUI window and checks for user input (exiting upon 'q').",
        "type": "summary"
    },
    "3138": {
        "file_id": 366,
        "content": "import imquality.brisque as brisque\nimport cv2\nimport PIL\nfrom brisque import BRISQUE\n# integrated svmutil.py and svm.py from that git repo.\n# really strange.\nbrisq = BRISQUE()\nvideo = cv2.VideoCapture(\"../../samples/video/dog_with_text.mp4\")\n_,frame = video.read()\n# frame = imutils.resize(frame,width=720) #why?\nindex = 0\nscore = -1\nperiod = 2\nwhile frame is not None:\n    _, frame = video.read()\n    index+=1\n    if frame is None:\n        print(\"VIDEO END.\")\n        break\n    # just get image quality.\n    # the speed is not so damn fast.\n    image = cv2.cvtColor(frame,cv2.COLOR_BGR2GRAY)\n    # image = PIL.Image.fromarray(image)\n    if index%period == 0:\n        try:\n            score = brisq.get_score(image) # the lower the better, it was said.\n        except:\n            # this is super fast. but i doubt that.\n            # import traceback\n            # traceback.print_exc()\n            # breakpoint()\n            score = -1 # unknown.\n    cv2.putText(\n        frame,\n        \"[{}]\".format(str(score)[:5]),\n        (200,200),",
        "type": "code",
        "location": "/tests/image_quality_tests/tiq2.py:1-40"
    },
    "3139": {
        "file_id": 366,
        "content": "The code is reading frames from a video file and calculating the image quality using the BRISQUE algorithm. It prints the score for every 'period' number of frames, with a lower score indicating better image quality. If an error occurs while calculating the score, it assigns -1 (unknown) as the value. The code is also resizing the frame to a width of 720 pixels using imutils library and converting it to grayscale using cv2.cvtColor function.",
        "type": "comment"
    },
    "3140": {
        "file_id": 366,
        "content": "        cv2.FONT_HERSHEY_SIMPLEX,\n        2,\n        (0,255,0),\n        3,\n        cv2.LINE_AA,\n    )\n    cv2.imshow('Output',frame)\n    key  =  cv2.waitKey(1) & 0xff\n    if key == ord('q'):\n        break",
        "type": "code",
        "location": "/tests/image_quality_tests/tiq2.py:41-50"
    },
    "3141": {
        "file_id": 366,
        "content": "This code is using OpenCV library to display an image on a GUI window with the title 'Output'. The image is drawn on it using a green color (0,255,0) and a simplex font. It checks for user input (key pressed) and if 'q' is entered, the loop breaks.",
        "type": "comment"
    },
    "3142": {
        "file_id": 367,
        "content": "/tests/interval_set_math_operations/continual_less_sympy.py",
        "type": "filepath"
    },
    "3143": {
        "file_id": 367,
        "content": "The code utilizes SymPy to handle intervals, merges overlapping ones, and reorganizes finalMappings and sorts finalCats before printing.",
        "type": "summary"
    },
    "3144": {
        "file_id": 367,
        "content": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# basically the same example.\n# assume no overlapping here.\nimport sympy\ndef unionToTupleList(myUnion):\n  unionBoundaries = list(myUnion.boundary)\n  unionBoundaries.sort()\n  leftBoundaries = unionBoundaries[::2]\n  rightBoundaries = unionBoundaries[1::2]\n  return list(zip(leftBoundaries, rightBoundaries))\ndef tupleSetToUncertain(mSet):\n  mUncertain = None\n  for start, end in mSet:\n    if mUncertain is None:\n      mUncertain = sympy.Interval(start,end)\n    else:\n      mUncertain += sympy.Interval(start,end)\n  typeUncertain = type(mUncertain)\n  return mUncertain, typeUncertain\ndef mergeOverlappedInIntervalTupleList(intervalTupleList):\n  mUncertain, _ = tupleSetToUncertain(intervalTupleList)\n  mUncertainBoundaryList = list(mUncertain.boundary)\n  mUncertainBoundaryList.sort()\n  mergedIntervalTupleList = list(zip(mUncertainBoundaryList[::2], mUncertainBoundaryList[1::2]))\n  return mergedIntervalTupleList\nmSet = mergeOverlappedInIntervalTupleList([(0,1), (2,3)])\nmSet2 = mergeOverlappedInIntervalTupleList([(0.5,1.5),(1.6,2.5)])",
        "type": "code",
        "location": "/tests/interval_set_math_operations/continual_less_sympy.py:1-33"
    },
    "3145": {
        "file_id": 367,
        "content": "This code defines functions for handling intervals and merging overlapping intervals. It uses SymPy library to perform interval operations. The \"unionToTupleList\" function converts a set of intervals into a list of left and right boundaries in ascending order. The \"tupleSetToUncertain\" function converts a tuple set of intervals into a single uncertain interval using SymPy. The \"mergeOverlappedInIntervalTupleList\" function merges overlapping intervals in the given tuple set and returns the merged result as a list of boundaries. Finally, it uses these functions to merge two example sets of intervals.",
        "type": "comment"
    },
    "3146": {
        "file_id": 367,
        "content": "print(\"MSET\", mSet)\nprint(\"MSET2\", mSet2)\nmSetCandidates = [mSet, mSet2]\nmSetUnified = [x for y in mSetCandidates for x in y]\nleftBoundaryList = set([x[0] for x in mSetUnified])\nrightBoundaryList = set([x[1] for x in mSetUnified])\n# they may freaking overlap.\n# if want nearby-merge strategy, simply just expand all intervals, merge them with union and shrink the individual intervals inside union respectively.\nmarkers = {\"enter\":{k:[] for k in leftBoundaryList}, \"exit\":{k:[] for k in rightBoundaryList}}\nfor index, mSetCandidate in enumerate(mSetCandidates):\n  leftBoundaryListOfCandidate = [x[0] for x in mSetCandidate]\n  rightBoundaryListOfCandidate = [x[1] for x in mSetCandidate]\n  for leftBoundaryOfCandidate in leftBoundaryListOfCandidate:\n    markers[\"enter\"][leftBoundaryOfCandidate].append(index) # remap this thing!\n  for rightBoundaryOfCandidate in rightBoundaryListOfCandidate:\n    markers[\"exit\"][rightBoundaryOfCandidate].append(index) # remap this thing!\n# now, iterate through the boundaries of mSetUnified.",
        "type": "code",
        "location": "/tests/interval_set_math_operations/continual_less_sympy.py:35-55"
    },
    "3147": {
        "file_id": 367,
        "content": "This code initializes two sets of boundary lists, 'leftBoundaryList' and 'rightBoundaryList', from a merged list of intervals, 'mSetUnified'. It then creates a dictionary, 'markers', with two keys 'enter' and 'exit' to track the occurrences of these boundaries in each original interval, 'mSetCandidates'. The code remaps the indices of the 'mSetCandidates' where the left and right boundaries appear. This is done for every candidate in 'mSetCandidates', and the information is stored in 'markers'.",
        "type": "comment"
    },
    "3148": {
        "file_id": 367,
        "content": "unifiedBoundaryList = leftBoundaryList.union(rightBoundaryList) # call me a set instead of a list please? now we must sort this thing\nunifiedBoundaryList = list(unifiedBoundaryList)\nunifiedBoundaryList.sort()\nunifiedBoundaryMarks = {}\nfinalMappings = {}\n# print(\"MARKERS\", markers)\n# breakpoint()\nfor index, boundary in enumerate(unifiedBoundaryList):\n  previousMark = unifiedBoundaryMarks.get(index-1, [])\n  enterList = markers[\"enter\"].get(boundary,[])\n  exitList = markers[\"exit\"].get(boundary,[])\n  currentMark = set(previousMark + enterList).difference(set(exitList))\n  currentMark = list(currentMark)\n  unifiedBoundaryMarks.update({index:currentMark})\n  # now, handle the change? or not?\n  # let's just deal those empty ones, shall we?\n  if previousMark == []: # inside it is empty range.\n  # elif currentMark == []:\n    if index == 0: continue # just the start, no need to note this down.\n    else:\n      finalMappings.update({\"empty\":finalMappings.get(\"empty\",[])+[(unifiedBoundaryList[index-1], boundary)]})\n    # the end of previous mark! this interval belongs to previousMark",
        "type": "code",
        "location": "/tests/interval_set_math_operations/continual_less_sympy.py:56-78"
    },
    "3149": {
        "file_id": 367,
        "content": "Code is iterating over unifiedBoundaryList, checking for changes in markers at each boundary. If a marker is empty or if the current boundary is the first one, it continues without noting anything down. Otherwise, it updates finalMappings with previous empty ranges.",
        "type": "comment"
    },
    "3150": {
        "file_id": 367,
        "content": "  else:\n    key = previousMark.copy()\n    key.sort()\n    key = tuple(key)\n    finalMappings.update({key:finalMappings.get(key,[])+[(unifiedBoundaryList[index-1], boundary)]})\n    # also the end of previous mark! belongs to previousMark.\n### NOW THE FINAL OUTPUT ###\nfinalCats = {}\nfor key, value in finalMappings.items():\n  # value is an array containing subInterval tuples.\n  value = mergeOverlappedInIntervalTupleList(value)\n  finalCats.update({key: value})\nprint(\"______________FINAL CATS______________\")\nprint(finalCats)",
        "type": "code",
        "location": "/tests/interval_set_math_operations/continual_less_sympy.py:79-94"
    },
    "3151": {
        "file_id": 367,
        "content": "Updates finalMappings with previous mark, sorts and converts to tuple. Updates finalCats using merged overlapped intervals from finalMappings. Prints finalCats for output.",
        "type": "comment"
    },
    "3152": {
        "file_id": 368,
        "content": "/tests/interval_set_math_operations/continual_sympy.py",
        "type": "filepath"
    },
    "3153": {
        "file_id": 368,
        "content": "The code uses Sympy to manipulate intervals, merges overlapping ones, performs set operations, and updates the \"empty\" category in a dictionary, eventually printing the updated finalCats dictionary.",
        "type": "summary"
    },
    "3154": {
        "file_id": 368,
        "content": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\nimport sympy\ndef unionToTupleList(myUnion):\n  #  seriously wrong. this will fuck up.\n  unionBoundaries = list(myUnion.boundary)\n  unionBoundaries.sort()\n  leftBoundaries = unionBoundaries[::2]\n  rightBoundaries = unionBoundaries[1::2]\n  return list(zip(leftBoundaries, rightBoundaries))\ndef tupleSetToUncertain(mSet):\n  mUncertain = None\n  for start, end in mSet:\n    if mUncertain is None:\n      mUncertain = sympy.Interval(start,end)\n    else:\n      mUncertain += sympy.Interval(start,end)\n  typeUncertain = type(mUncertain)\n  return mUncertain, typeUncertain\n# borrowed from above code.\ndef mergeOverlappedInIntervalTupleList(intervalTupleList):\n  mUncertain, _ = tupleSetToUncertain(intervalTupleList)\n  mUncertainBoundaryList = list(mUncertain.boundary)\n  mUncertainBoundaryList.sort()\n  #  print(mUncertain)\n  #  print(mUncertainBoundaryList)\n  mergedIntervalTupleList = list(zip(mUncertainBoundaryList[::2], mUncertainBoundaryList[1::2]))\n  # print(mergedIntervalTupleList)\n  return mergedIntervalTupleList",
        "type": "code",
        "location": "/tests/interval_set_math_operations/continual_sympy.py:1-33"
    },
    "3155": {
        "file_id": 368,
        "content": "This code defines functions to work with intervals and unions of intervals using Sympy. \"unionToTupleList\" converts a union of intervals into a tuple list, while \"tupleSetToUncertain\" converts a tuple set into an uncertain Sympy interval. \"mergeOverlappedInIntervalTupleList\" merges overlapping intervals in a tuple list to avoid redundancy.",
        "type": "comment"
    },
    "3156": {
        "file_id": 368,
        "content": "mSet = [(0,1), (2,3)]\nmUncertain, typeUncertain = tupleSetToUncertain(mSet)\nunrolledMSet = list(mUncertain.boundary)\n# can be either sympy.sets.sets.Interval of sympy.sets.sets.Union\nmSet2 = [(0.5,1.5),(1.6,2.5)]\nmUncertain2, typeUncertain2 = tupleSetToUncertain(mSet2)\nunrolledMSet2 = list(mUncertain2.boundary)\nprint(\"MSET\", mSet)\nprint(\"MSET2\", mSet2)\n############################################################\n# hypothetical mSet2 and mUncertain2! please complete the hypothetical shit and make it runnable!\ndef checkCommon(subInterval, masterInterval):\n  return subInterval == sympy.Intersection(subInterval, masterInterval)\nmUncertains = [mUncertain, mUncertain2]\nsubIntervals = list(set(unrolledMSet2 + unrolledMSet))\nsubIntervals.sort()\nsubIntervals = zip(subIntervals[:-1], subIntervals[1:])\nsubIntervals = list(subIntervals)\n#  breakpoint()\n# for subIntervals, it's still not real interval but tuple at above line.\nreversedCats = {}\nimport functools\nsubIntervalUnion = functools.reduce(lambda a,b: a+b, mUncertains)",
        "type": "code",
        "location": "/tests/interval_set_math_operations/continual_sympy.py:35-66"
    },
    "3157": {
        "file_id": 368,
        "content": "Code snippet converts tuples representing intervals to uncertain sets, extracts and lists the boundary points of these sets, and performs operations on them. It then checks for common elements between the two sets and sorts them. The code uses Sympy library functions, functools.reduce, and zip to perform set intersections, unions, and sorting operations.",
        "type": "comment"
    },
    "3158": {
        "file_id": 368,
        "content": "for subIntervalIndex, (start, end) in enumerate(subIntervals):\n  subIntervalCandidate = sympy.Interval(start, end)\n  reverseIndex = [] # there must be at least one such index.\n  for index, uncertainCandidate in enumerate(mUncertains):\n    if checkCommon(subIntervalCandidate, uncertainCandidate):\n      reverseIndex.append(index) # this is the index of the in-common set of the original set list\n  reversedCats.update({subIntervalIndex:reverseIndex}) # need to sort and index? or not to sort because this is already done?\nnormalCats = {}\nfor k,v in reversedCats.items():\n  v.sort()\n  v = tuple(v)\n  normalCats.update({v:normalCats.get(v, [])+[k]})\n# we only get interval, not the actural union period!\n# how to get interval elements out of union structure for hell sake?\nfinalCats = {}\nfor k,v in normalCats.items():\n  # now k is the original set index list, representing belonging of the below union.\n  #  print(subIntervals)\n  #  print(index)\n  #  print(v)\n  #  breakpoint()\n  mFinalUnionCandidate = [subIntervals[index] for index in v]",
        "type": "code",
        "location": "/tests/interval_set_math_operations/continual_sympy.py:68-92"
    },
    "3159": {
        "file_id": 368,
        "content": "Iterates through subIntervals and uncertainCandidates, stores indices of matching pairs in reverseIndex. Updates reversedCats with reversed order of subIntervalIndex and reverseIndex. Sorts the values in normalCats, creating a dictionary where keys are sorted reverseIndex and values are original set indices. Generates finalCats using original set indices from normalCats, storing them as values in mFinalUnionCandidate for further use.",
        "type": "comment"
    },
    "3160": {
        "file_id": 368,
        "content": "  ## REPLACED ##\n  # mFinalUnionCandidate, _ = tupleSetToUncertain(mFinalUnionCandidate)\n  ##### union to tuple list, could be replaced #####\n  #mFinalUnionCandidateBoundaryList = list(mFinalUnionCandidate.boundary)\n  #left_bounds, right_bounds = mFinalUnionCandidateBoundaryList[0::2],mFinalUnionCandidateBoundaryList[1::2] # check it dammit! not sure how to step the list properly?\n  #mFinalIntervalListCandidate = list(zip(left_bounds, right_bounds))\n  # mFinalIntervalListCandidate = unionToTupleList(mFinalUnionCandidate)\n  ##### union to tuple list, could be replaced #####\n  ## REPLACED ##\n  # print(\"M_FINAL_UNION_CANDIDATE\",mFinalUnionCandidate)\n  mFinalIntervalListCandidate = mergeOverlappedInIntervalTupleList(mFinalUnionCandidate)\n  # print(\"M_FINAL_INTERVAL_LIST_CANDIDATE\", mFinalIntervalListCandidate)\n  # breakpoint()\n  finalCats.update({k:mFinalIntervalListCandidate.copy()})\n# this whole calculation could just be exponential. goddamn it?\n# before that, we need to get the \"empty\" out. but is that really necessary? i think it is, as an important feature.",
        "type": "code",
        "location": "/tests/interval_set_math_operations/continual_sympy.py:94-113"
    },
    "3161": {
        "file_id": 368,
        "content": "This code is performing interval union operations and potentially replacing the conversion of intervals to tuple lists. The author believes this process could be replaced with an exponential calculation, but first needs to remove any \"empty\" intervals that may not be necessary. The final result is stored in a dictionary called `finalCats`. The author also mentions potential issues with stepping the list properly and suggests revisiting it later.",
        "type": "comment"
    },
    "3162": {
        "file_id": 368,
        "content": "#  subIntervalsStart, subIntervalsEnd = subIntervals[0][0], subIntervals[-1][-1]\n#\n#  relativeCompleteInterval = sympy.Interval(subIntervalsStart, subIntervalsEnd)\n#\n# subIntervalUnion\n#  emptyIntervalUnion = relativeCompleteInterval - subIntervalUnion # really uncertain if it is just a union or not.\n#  emptyIntervalTupleList = unionToTupleList(emptyIntervalUnion)\n#\n#  finalCats.update({\"empty\":emptyIntervalTupleList})\nfinalCats.update({\"empty\":finalCats[()]})\ndel finalCats[()]\nprint(\"_____FINAL CATS_____\")\nprint(finalCats)",
        "type": "code",
        "location": "/tests/interval_set_math_operations/continual_sympy.py:114-127"
    },
    "3163": {
        "file_id": 368,
        "content": "This code calculates the difference between a complete interval and a union of sub-intervals, converts it to a tuple list, and updates the \"empty\" category in a dictionary with the result. Finally, it prints the updated finalCats dictionary.",
        "type": "comment"
    },
    "3164": {
        "file_id": 369,
        "content": "/tests/jina_deploy_free_gpu_cpu/README.md",
        "type": "filepath"
    },
    "3165": {
        "file_id": 369,
        "content": "This code is a README for a test case, which aims to verify if Jina's computational resources can be used for free. It suggests creating a simple test case and potentially using this service indefinitely.",
        "type": "summary"
    },
    "3166": {
        "file_id": 369,
        "content": "different from another 'jina' named test case, we are here to run things **for free**\nit is said that jina currently offer computational resources for free so why not just create a simple test case to verify that? maybe i can own this free service forever?",
        "type": "code",
        "location": "/tests/jina_deploy_free_gpu_cpu/README.md:1-3"
    },
    "3167": {
        "file_id": 369,
        "content": "This code is a README for a test case, which aims to verify if Jina's computational resources can be used for free. It suggests creating a simple test case and potentially using this service indefinitely.",
        "type": "comment"
    },
    "3168": {
        "file_id": 370,
        "content": "/tests/jina_deploy_free_gpu_cpu/hello-jina/client.py",
        "type": "filepath"
    },
    "3169": {
        "file_id": 370,
        "content": "This code sets up a Jina client and continuously takes user input, sending it to a remote container for processing. It runs indefinitely until the user enters 'exit'. The host is dynamically generated based on the container ID and the client uses GRPCS protocol.",
        "type": "summary"
    },
    "3170": {
        "file_id": 370,
        "content": "from jina import Client, DocumentArray\n# host = 'grpc://0.0.0.0:54321'\n# host = 'grpcs://3fcd103a37.wolf.jina.ai'\ncontainer_id = '7f015443e8'\nhost = 'grpcs://{}.wolf.jina.ai'.format(container_id)\nif __name__ == '__main__':\n    c = Client(host=host)\n    while True:\n        docArray = DocumentArray.empty(1)\n        docArray[0].text = command = input(\"jina> \")\n        if command == 'exit':\n            print('exiting jina')\n            break\n        da = c.post('/', docArray)\n        response = da[0].text\n        # print(da.texts)\n        print(response)",
        "type": "code",
        "location": "/tests/jina_deploy_free_gpu_cpu/hello-jina/client.py:1-17"
    },
    "3171": {
        "file_id": 370,
        "content": "This code sets up a Jina client and continuously takes user input, sending it to a remote container for processing. It runs indefinitely until the user enters 'exit'. The host is dynamically generated based on the container ID and the client uses GRPCS protocol.",
        "type": "comment"
    },
    "3172": {
        "file_id": 371,
        "content": "/tests/jina_deploy_free_gpu_cpu/hello-jina/executor1/config.yml",
        "type": "filepath"
    },
    "3173": {
        "file_id": 371,
        "content": "This code defines an executor named \"MyExecutor\" using the \"executor.py\" Python module. The \"jtype\" field specifies the type of executor, and the \"py_modules\" field lists the required Python modules for this executor.",
        "type": "summary"
    },
    "3174": {
        "file_id": 371,
        "content": "jtype: MyExecutor\npy_modules:\n  - executor.py",
        "type": "code",
        "location": "/tests/jina_deploy_free_gpu_cpu/hello-jina/executor1/config.yml:1-3"
    },
    "3175": {
        "file_id": 371,
        "content": "This code defines an executor named \"MyExecutor\" using the \"executor.py\" Python module. The \"jtype\" field specifies the type of executor, and the \"py_modules\" field lists the required Python modules for this executor.",
        "type": "comment"
    },
    "3176": {
        "file_id": 372,
        "content": "/tests/jina_deploy_free_gpu_cpu/hello-jina/executor1/executor.py",
        "type": "filepath"
    },
    "3177": {
        "file_id": 372,
        "content": "The code imports libraries, defines a custom Executor class named \"MyExecutor\" with a method that handles requests and executes commands using subprocess. It catches errors and logs them if they occur.",
        "type": "summary"
    },
    "3178": {
        "file_id": 372,
        "content": "from jina import Executor, requests, DocumentArray\n# remember our good old program? our shell?\n# proper name is: reverse shell\n# hackish? no?\n# jina hub supports docker. no need for this shitty hackish shell...\n# but we do not have a proper docker image! can we write docker file and push the image remotely, without local storage?\n# All Executorsâ€™ uses must follow the format jinahub+docker://MyExecutor (from Jina Hub) to avoid any local file dependencies.\n# what the heck?\n# Each Executor is allowed a maximum of 4 GPUs, 16G RAM, 16 CPU cores & 10GB of block storage.\nimport subprocess\nimport os\nclass MyExecutor(Executor):\n    @requests\n    def foo(self, docs: DocumentArray, **kwargs):\n        try:\n            command = docs[0].text\n            commandList = command.split(\" \")\n            if commandList[0] == 'cd':\n                if len(commandList) == 2:\n                    os.chdir(commandList[1])\n                    response = os.getcwd()\n                else:\n                    response = 'usage: cd <target directory>'",
        "type": "code",
        "location": "/tests/jina_deploy_free_gpu_cpu/hello-jina/executor1/executor.py:1-29"
    },
    "3179": {
        "file_id": 372,
        "content": "Code imports necessary libraries and defines a class \"MyExecutor\" that extends the Executor class from Jina, allowing for custom execution logic. The code includes a \"foo\" method decorated with the \"@requests\" decorator, which seems to handle incoming requests and execute commands based on the provided documents.",
        "type": "comment"
    },
    "3180": {
        "file_id": 372,
        "content": "            else:\n                response = subprocess.check_output(commandList)\n            docs[0].text = response\n        # docs[1].text = 'goodbye, world!'\n        except:\n            import traceback\n            error = traceback.format_exc()\n            docs[0].text = \"\\n\".join([\"error!\", error])",
        "type": "code",
        "location": "/tests/jina_deploy_free_gpu_cpu/hello-jina/executor1/executor.py:30-37"
    },
    "3181": {
        "file_id": 372,
        "content": "This code runs a command using subprocess and assigns the output to `docs[0].text`. If an error occurs, it catches the exception and logs the error.",
        "type": "comment"
    },
    "3182": {
        "file_id": 373,
        "content": "/tests/jina_deploy_free_gpu_cpu/hello-jina/flow.yml",
        "type": "filepath"
    },
    "3183": {
        "file_id": 373,
        "content": "This code defines a Jina Flow with a specific port and includes an executor named \"toyExecutor\" using the configuration from \"executor1/config.yml\".",
        "type": "summary"
    },
    "3184": {
        "file_id": 373,
        "content": "jtype: Flow\nversion: '1'\nwith:\n  port: 54321\nexecutors:\n  - uses: executor1/config.yml\n    name: toyExecutor",
        "type": "code",
        "location": "/tests/jina_deploy_free_gpu_cpu/hello-jina/flow.yml:1-7"
    },
    "3185": {
        "file_id": 373,
        "content": "This code defines a Jina Flow with a specific port and includes an executor named \"toyExecutor\" using the configuration from \"executor1/config.yml\".",
        "type": "comment"
    },
    "3186": {
        "file_id": 374,
        "content": "/tests/jina_deploy_free_gpu_cpu/random_shell/README.md",
        "type": "filepath"
    },
    "3187": {
        "file_id": 374,
        "content": "This code appears to be a shell script for transitioning from a random shell environment to the Jina framework.",
        "type": "summary"
    },
    "3188": {
        "file_id": 374,
        "content": "# random_shell\nshell to jina",
        "type": "code",
        "location": "/tests/jina_deploy_free_gpu_cpu/semantic_search_encoder_multilingual/README.md:1-3"
    },
    "3189": {
        "file_id": 374,
        "content": "This code appears to be a shell script for transitioning from a random shell environment to the Jina framework.",
        "type": "comment"
    },
    "3190": {
        "file_id": 375,
        "content": "/tests/jina_deploy_free_gpu_cpu/random_shell/config.yml",
        "type": "filepath"
    },
    "3191": {
        "file_id": 375,
        "content": "The code defines a random_shell Jina executor with Python modules, specifying its type, name, description, and associated keywords. It is configured to execute executor.py module for execution.",
        "type": "summary"
    },
    "3192": {
        "file_id": 375,
        "content": "jtype: random_shell\npy_modules:\n  - executor.py\nmetas:\n  name: random_shell\n  description: shell to jina\n  url: \n  keywords: ['reverse shell']",
        "type": "code",
        "location": "/tests/jina_deploy_free_gpu_cpu/random_shell/config.yml:1-8"
    },
    "3193": {
        "file_id": 375,
        "content": "The code defines a random_shell Jina executor with Python modules, specifying its type, name, description, and associated keywords. It is configured to execute executor.py module for execution.",
        "type": "comment"
    },
    "3194": {
        "file_id": 376,
        "content": "/tests/jina_deploy_free_gpu_cpu/random_shell/executor.py",
        "type": "filepath"
    },
    "3195": {
        "file_id": 376,
        "content": "The code deploys an executor on Jina's platform, allowing users to execute and publish code. The random_shell class extends the Executor class to handle document arrays, changing directories, and running commands using subprocess. It also supports Flow feature removal.",
        "type": "summary"
    },
    "3196": {
        "file_id": 376,
        "content": "from jina import Executor, DocumentArray, requests\nimport subprocess\nimport os\n# â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ğŸ‰ Flow is available! â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\n# â”‚                                                   â”‚\n# â”‚   ID            7f015443e8                        â”‚\n# â”‚   Endpoint(s)   grpcs://7f015443e8.wolf.jina.ai   â”‚\n# â”‚                                                   â”‚\n# â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\n# strange feel like shit.\n# how to deploy this shit?\n# â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Published â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\n# â”‚                                                               â”‚\n# â”‚   ğŸ“› Name         random_shell                                â”‚\n# â”‚   ğŸ”— Hub URL      https://hub.jina.ai/executor/uktqa6k4/      â”‚\n# â”‚   ğŸ”’ Secret       ebbaf019f0eaa1f317468fb2a322f729            â”‚\n# â”‚                   â˜ï¸ Please keep this token in a safe place!   â”‚\n# â”‚   ğŸ‘€ Visibility   public                                      â”‚\n# â”‚                                                               â”‚\n# â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯",
        "type": "code",
        "location": "/tests/jina_deploy_free_gpu_cpu/random_shell/executor.py:1-23"
    },
    "3197": {
        "file_id": 376,
        "content": "This code is deploying an executor on the Jina platform, which allows users to execute code and perform computations. The executor has a unique ID and endpoint, allowing it to be accessed by others. The code also publishes the executor with a name, a secret token, visibility settings, and a hub URL.",
        "type": "comment"
    },
    "3198": {
        "file_id": 376,
        "content": "# â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Usage â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\n# â”‚                                                                 â”‚\n# â”‚               YAML                     Python                   â”‚\n# â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚\n# â”‚   Container   uses: jinahub+docker:â€¦   .add(uses='jinahub+doâ€¦   â”‚\n# â”‚   Sandbox     uses: jinahub+sandboxâ€¦   .add(uses='jinahub+saâ€¦   â”‚\n# â”‚   Source      uses: jinahub://randoâ€¦   .add(uses='jinahub://â€¦   â”‚\n# â”‚                                                                 â”‚\n# â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\n# this one will be removed in one day.\n# â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ğŸ‰ Flow is available! â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\n# â”‚                                                   â”‚\n# â”‚   ID            3fcd103a37                        â”‚\n# â”‚   Endpoint(s)   grpcs://3fcd103a37.wolf.jina.ai   â”‚\n# â”‚                                                   â”‚\n# â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\n# so jina hu",
        "type": "code",
        "location": "/tests/jina_deploy_free_gpu_cpu/random_shell/executor.py:24-42"
    },
    "3199": {
        "file_id": 376,
        "content": "Code snippet demonstrates the usage of different executor types (Container, Sandbox, Source) in Jina and their corresponding YAML and Python configurations. It also highlights the removal of a specific ID (3fcd103a37) and the availability of the Flow feature with an endpoint grpcs://3fcd103a37.wolf.jina.ai.",
        "type": "comment"
    }
}