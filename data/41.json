{
    "4100": {
        "file_id": 519,
        "content": "#   --data-raw '{\"sort\":\"-activities.metaMatched\",\"pageIndex\":3,\"pageSize\":16,\"search\":\"\",\"author\":\"\",\"keywords\":[],\"withAnonymous\":true}' \\\n#   --compressed\ncurl 'https://api.hubble.jina.ai/v2/rpc/executor.list' \\\n --data-raw '{\"sort\":\"-activities.metaMatched\",\"pageIndex\":3,\"pageSize\":16,\"search\":\"\",\"author\":\"\",\"keywords\":[],\"withAnonymous\":true}' \\\n  --compressed",
        "type": "code",
        "location": "/tests/jina_multimodal_cross_modal_search_examples_apps/get_jina_hub_list.sh:16-20"
    },
    "4101": {
        "file_id": 519,
        "content": "This code is making a compressed HTTP request to 'https://api.hubble.jina.ai/v2/rpc/executor.list' with specific data parameters and a compressed format.",
        "type": "comment"
    },
    "4102": {
        "file_id": 520,
        "content": "/tests/jina_multimodal_cross_modal_search_examples_apps/get_jina_hub_list.py",
        "type": "filepath"
    },
    "4103": {
        "file_id": 520,
        "content": "This code retrieves a list of Jina Hub executors in chunks and writes them to a JSON file named \"jina_hub.json\". It first makes an API request to the Hubble server, sorts the results by activities.metaMatched, and returns the data as JSON. Then it calculates the number of pages needed based on the total number of executors and loops through each page, appending the data to a list called 'data'. Finally, it writes the list of executors (in multiple chunks) to the file \"jina_hub.json\" with proper indentation and formatting.",
        "type": "summary"
    },
    "4104": {
        "file_id": 520,
        "content": "import requests\nimport time\nimport json\ndef getJson(pageIndex=1, pageSize=16):\n    url = 'https://api.hubble.jina.ai/v2/rpc/executor.list'\n    query = {\"sort\":\"-activities.metaMatched\",\"pageIndex\":pageIndex,\"pageSize\":pageSize,\"search\":\"\",\"author\":\"\",\"keywords\":[],\"withAnonymous\":True}\n    r = requests.post(url,json=query)\n    jsonData = r.json()\n    return jsonData\npageSize = 16\njsonData = getJson(pageSize=pageSize)\ntotal = jsonData[\"meta\"][\"total\"]\nprint('total:', total)\ndata = [jsonData.copy()]\nimport math\npages = math.ceil(total/pageSize)\nimport progressbar\nfor index in progressbar.progressbar(range(2,pages+1)):\n    time.sleep(2)\n    # print('page index:',index)\n    jsonData = getJson(pageIndex=index, pageSize=pageSize)\n    data.append(jsonData.copy())\nprint(\"writing data\")\nwith open(\"jina_hub.json\", \"w\") as f:\n    f.write(json.dumps(data, indent=4, ensure_ascii=False))",
        "type": "code",
        "location": "/tests/jina_multimodal_cross_modal_search_examples_apps/get_jina_hub_list.py:1-29"
    },
    "4105": {
        "file_id": 520,
        "content": "This code retrieves a list of Jina Hub executors in chunks and writes them to a JSON file named \"jina_hub.json\". It first makes an API request to the Hubble server, sorts the results by activities.metaMatched, and returns the data as JSON. Then it calculates the number of pages needed based on the total number of executors and loops through each page, appending the data to a list called 'data'. Finally, it writes the list of executors (in multiple chunks) to the file \"jina_hub.json\" with proper indentation and formatting.",
        "type": "comment"
    },
    "4106": {
        "file_id": 521,
        "content": "/tests/interval_set_math_operations/continual_sympy.py",
        "type": "filepath"
    },
    "4107": {
        "file_id": 521,
        "content": "The code uses Sympy to manipulate intervals, merges overlapping ones, performs set operations, and updates the \"empty\" category in a dictionary, eventually printing the updated finalCats dictionary.",
        "type": "summary"
    },
    "4108": {
        "file_id": 521,
        "content": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\nimport sympy\ndef unionToTupleList(myUnion):\n  #  seriously wrong. this will fuck up.\n  unionBoundaries = list(myUnion.boundary)\n  unionBoundaries.sort()\n  leftBoundaries = unionBoundaries[::2]\n  rightBoundaries = unionBoundaries[1::2]\n  return list(zip(leftBoundaries, rightBoundaries))\ndef tupleSetToUncertain(mSet):\n  mUncertain = None\n  for start, end in mSet:\n    if mUncertain is None:\n      mUncertain = sympy.Interval(start,end)\n    else:\n      mUncertain += sympy.Interval(start,end)\n  typeUncertain = type(mUncertain)\n  return mUncertain, typeUncertain\n# borrowed from above code.\ndef mergeOverlappedInIntervalTupleList(intervalTupleList):\n  mUncertain, _ = tupleSetToUncertain(intervalTupleList)\n  mUncertainBoundaryList = list(mUncertain.boundary)\n  mUncertainBoundaryList.sort()\n  #  print(mUncertain)\n  #  print(mUncertainBoundaryList)\n  mergedIntervalTupleList = list(zip(mUncertainBoundaryList[::2], mUncertainBoundaryList[1::2]))\n  # print(mergedIntervalTupleList)\n  return mergedIntervalTupleList",
        "type": "code",
        "location": "/tests/interval_set_math_operations/continual_sympy.py:1-33"
    },
    "4109": {
        "file_id": 521,
        "content": "This code defines functions to work with intervals and unions of intervals using Sympy. \"unionToTupleList\" converts a union of intervals into a tuple list, while \"tupleSetToUncertain\" converts a tuple set into an uncertain Sympy interval. \"mergeOverlappedInIntervalTupleList\" merges overlapping intervals in a tuple list to avoid redundancy.",
        "type": "comment"
    },
    "4110": {
        "file_id": 521,
        "content": "mSet = [(0,1), (2,3)]\nmUncertain, typeUncertain = tupleSetToUncertain(mSet)\nunrolledMSet = list(mUncertain.boundary)\n# can be either sympy.sets.sets.Interval of sympy.sets.sets.Union\nmSet2 = [(0.5,1.5),(1.6,2.5)]\nmUncertain2, typeUncertain2 = tupleSetToUncertain(mSet2)\nunrolledMSet2 = list(mUncertain2.boundary)\nprint(\"MSET\", mSet)\nprint(\"MSET2\", mSet2)\n############################################################\n# hypothetical mSet2 and mUncertain2! please complete the hypothetical shit and make it runnable!\ndef checkCommon(subInterval, masterInterval):\n  return subInterval == sympy.Intersection(subInterval, masterInterval)\nmUncertains = [mUncertain, mUncertain2]\nsubIntervals = list(set(unrolledMSet2 + unrolledMSet))\nsubIntervals.sort()\nsubIntervals = zip(subIntervals[:-1], subIntervals[1:])\nsubIntervals = list(subIntervals)\n#  breakpoint()\n# for subIntervals, it's still not real interval but tuple at above line.\nreversedCats = {}\nimport functools\nsubIntervalUnion = functools.reduce(lambda a,b: a+b, mUncertains)",
        "type": "code",
        "location": "/tests/interval_set_math_operations/continual_sympy.py:35-66"
    },
    "4111": {
        "file_id": 521,
        "content": "Code snippet converts tuples representing intervals to uncertain sets, extracts and lists the boundary points of these sets, and performs operations on them. It then checks for common elements between the two sets and sorts them. The code uses Sympy library functions, functools.reduce, and zip to perform set intersections, unions, and sorting operations.",
        "type": "comment"
    },
    "4112": {
        "file_id": 521,
        "content": "for subIntervalIndex, (start, end) in enumerate(subIntervals):\n  subIntervalCandidate = sympy.Interval(start, end)\n  reverseIndex = [] # there must be at least one such index.\n  for index, uncertainCandidate in enumerate(mUncertains):\n    if checkCommon(subIntervalCandidate, uncertainCandidate):\n      reverseIndex.append(index) # this is the index of the in-common set of the original set list\n  reversedCats.update({subIntervalIndex:reverseIndex}) # need to sort and index? or not to sort because this is already done?\nnormalCats = {}\nfor k,v in reversedCats.items():\n  v.sort()\n  v = tuple(v)\n  normalCats.update({v:normalCats.get(v, [])+[k]})\n# we only get interval, not the actural union period!\n# how to get interval elements out of union structure for hell sake?\nfinalCats = {}\nfor k,v in normalCats.items():\n  # now k is the original set index list, representing belonging of the below union.\n  #  print(subIntervals)\n  #  print(index)\n  #  print(v)\n  #  breakpoint()\n  mFinalUnionCandidate = [subIntervals[index] for index in v]",
        "type": "code",
        "location": "/tests/interval_set_math_operations/continual_sympy.py:68-92"
    },
    "4113": {
        "file_id": 521,
        "content": "Iterates through subIntervals and uncertainCandidates, stores indices of matching pairs in reverseIndex. Updates reversedCats with reversed order of subIntervalIndex and reverseIndex. Sorts the values in normalCats, creating a dictionary where keys are sorted reverseIndex and values are original set indices. Generates finalCats using original set indices from normalCats, storing them as values in mFinalUnionCandidate for further use.",
        "type": "comment"
    },
    "4114": {
        "file_id": 521,
        "content": "  ## REPLACED ##\n  # mFinalUnionCandidate, _ = tupleSetToUncertain(mFinalUnionCandidate)\n  ##### union to tuple list, could be replaced #####\n  #mFinalUnionCandidateBoundaryList = list(mFinalUnionCandidate.boundary)\n  #left_bounds, right_bounds = mFinalUnionCandidateBoundaryList[0::2],mFinalUnionCandidateBoundaryList[1::2] # check it dammit! not sure how to step the list properly?\n  #mFinalIntervalListCandidate = list(zip(left_bounds, right_bounds))\n  # mFinalIntervalListCandidate = unionToTupleList(mFinalUnionCandidate)\n  ##### union to tuple list, could be replaced #####\n  ## REPLACED ##\n  # print(\"M_FINAL_UNION_CANDIDATE\",mFinalUnionCandidate)\n  mFinalIntervalListCandidate = mergeOverlappedInIntervalTupleList(mFinalUnionCandidate)\n  # print(\"M_FINAL_INTERVAL_LIST_CANDIDATE\", mFinalIntervalListCandidate)\n  # breakpoint()\n  finalCats.update({k:mFinalIntervalListCandidate.copy()})\n# this whole calculation could just be exponential. goddamn it?\n# before that, we need to get the \"empty\" out. but is that really necessary? i think it is, as an important feature.",
        "type": "code",
        "location": "/tests/interval_set_math_operations/continual_sympy.py:94-113"
    },
    "4115": {
        "file_id": 521,
        "content": "This code is performing interval union operations and potentially replacing the conversion of intervals to tuple lists. The author believes this process could be replaced with an exponential calculation, but first needs to remove any \"empty\" intervals that may not be necessary. The final result is stored in a dictionary called `finalCats`. The author also mentions potential issues with stepping the list properly and suggests revisiting it later.",
        "type": "comment"
    },
    "4116": {
        "file_id": 521,
        "content": "#  subIntervalsStart, subIntervalsEnd = subIntervals[0][0], subIntervals[-1][-1]\n#\n#  relativeCompleteInterval = sympy.Interval(subIntervalsStart, subIntervalsEnd)\n#\n# subIntervalUnion\n#  emptyIntervalUnion = relativeCompleteInterval - subIntervalUnion # really uncertain if it is just a union or not.\n#  emptyIntervalTupleList = unionToTupleList(emptyIntervalUnion)\n#\n#  finalCats.update({\"empty\":emptyIntervalTupleList})\nfinalCats.update({\"empty\":finalCats[()]})\ndel finalCats[()]\nprint(\"_____FINAL CATS_____\")\nprint(finalCats)",
        "type": "code",
        "location": "/tests/interval_set_math_operations/continual_sympy.py:114-127"
    },
    "4117": {
        "file_id": 521,
        "content": "This code calculates the difference between a complete interval and a union of sub-intervals, converts it to a tuple list, and updates the \"empty\" category in a dictionary with the result. Finally, it prints the updated finalCats dictionary.",
        "type": "comment"
    },
    "4118": {
        "file_id": 522,
        "content": "/tests/interval_set_math_operations/continual_less_sympy.py",
        "type": "filepath"
    },
    "4119": {
        "file_id": 522,
        "content": "The code utilizes SymPy to handle intervals, merges overlapping ones, and reorganizes finalMappings and sorts finalCats before printing.",
        "type": "summary"
    },
    "4120": {
        "file_id": 522,
        "content": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# basically the same example.\n# assume no overlapping here.\nimport sympy\ndef unionToTupleList(myUnion):\n  unionBoundaries = list(myUnion.boundary)\n  unionBoundaries.sort()\n  leftBoundaries = unionBoundaries[::2]\n  rightBoundaries = unionBoundaries[1::2]\n  return list(zip(leftBoundaries, rightBoundaries))\ndef tupleSetToUncertain(mSet):\n  mUncertain = None\n  for start, end in mSet:\n    if mUncertain is None:\n      mUncertain = sympy.Interval(start,end)\n    else:\n      mUncertain += sympy.Interval(start,end)\n  typeUncertain = type(mUncertain)\n  return mUncertain, typeUncertain\ndef mergeOverlappedInIntervalTupleList(intervalTupleList):\n  mUncertain, _ = tupleSetToUncertain(intervalTupleList)\n  mUncertainBoundaryList = list(mUncertain.boundary)\n  mUncertainBoundaryList.sort()\n  mergedIntervalTupleList = list(zip(mUncertainBoundaryList[::2], mUncertainBoundaryList[1::2]))\n  return mergedIntervalTupleList\nmSet = mergeOverlappedInIntervalTupleList([(0,1), (2,3)])\nmSet2 = mergeOverlappedInIntervalTupleList([(0.5,1.5),(1.6,2.5)])",
        "type": "code",
        "location": "/tests/interval_set_math_operations/continual_less_sympy.py:1-33"
    },
    "4121": {
        "file_id": 522,
        "content": "This code defines functions for handling intervals and merging overlapping intervals. It uses SymPy library to perform interval operations. The \"unionToTupleList\" function converts a set of intervals into a list of left and right boundaries in ascending order. The \"tupleSetToUncertain\" function converts a tuple set of intervals into a single uncertain interval using SymPy. The \"mergeOverlappedInIntervalTupleList\" function merges overlapping intervals in the given tuple set and returns the merged result as a list of boundaries. Finally, it uses these functions to merge two example sets of intervals.",
        "type": "comment"
    },
    "4122": {
        "file_id": 522,
        "content": "print(\"MSET\", mSet)\nprint(\"MSET2\", mSet2)\nmSetCandidates = [mSet, mSet2]\nmSetUnified = [x for y in mSetCandidates for x in y]\nleftBoundaryList = set([x[0] for x in mSetUnified])\nrightBoundaryList = set([x[1] for x in mSetUnified])\n# they may freaking overlap.\n# if want nearby-merge strategy, simply just expand all intervals, merge them with union and shrink the individual intervals inside union respectively.\nmarkers = {\"enter\":{k:[] for k in leftBoundaryList}, \"exit\":{k:[] for k in rightBoundaryList}}\nfor index, mSetCandidate in enumerate(mSetCandidates):\n  leftBoundaryListOfCandidate = [x[0] for x in mSetCandidate]\n  rightBoundaryListOfCandidate = [x[1] for x in mSetCandidate]\n  for leftBoundaryOfCandidate in leftBoundaryListOfCandidate:\n    markers[\"enter\"][leftBoundaryOfCandidate].append(index) # remap this thing!\n  for rightBoundaryOfCandidate in rightBoundaryListOfCandidate:\n    markers[\"exit\"][rightBoundaryOfCandidate].append(index) # remap this thing!\n# now, iterate through the boundaries of mSetUnified.",
        "type": "code",
        "location": "/tests/interval_set_math_operations/continual_less_sympy.py:35-55"
    },
    "4123": {
        "file_id": 522,
        "content": "This code initializes two sets of boundary lists, 'leftBoundaryList' and 'rightBoundaryList', from a merged list of intervals, 'mSetUnified'. It then creates a dictionary, 'markers', with two keys 'enter' and 'exit' to track the occurrences of these boundaries in each original interval, 'mSetCandidates'. The code remaps the indices of the 'mSetCandidates' where the left and right boundaries appear. This is done for every candidate in 'mSetCandidates', and the information is stored in 'markers'.",
        "type": "comment"
    },
    "4124": {
        "file_id": 522,
        "content": "unifiedBoundaryList = leftBoundaryList.union(rightBoundaryList) # call me a set instead of a list please? now we must sort this thing\nunifiedBoundaryList = list(unifiedBoundaryList)\nunifiedBoundaryList.sort()\nunifiedBoundaryMarks = {}\nfinalMappings = {}\n# print(\"MARKERS\", markers)\n# breakpoint()\nfor index, boundary in enumerate(unifiedBoundaryList):\n  previousMark = unifiedBoundaryMarks.get(index-1, [])\n  enterList = markers[\"enter\"].get(boundary,[])\n  exitList = markers[\"exit\"].get(boundary,[])\n  currentMark = set(previousMark + enterList).difference(set(exitList))\n  currentMark = list(currentMark)\n  unifiedBoundaryMarks.update({index:currentMark})\n  # now, handle the change? or not?\n  # let's just deal those empty ones, shall we?\n  if previousMark == []: # inside it is empty range.\n  # elif currentMark == []:\n    if index == 0: continue # just the start, no need to note this down.\n    else:\n      finalMappings.update({\"empty\":finalMappings.get(\"empty\",[])+[(unifiedBoundaryList[index-1], boundary)]})\n    # the end of previous mark! this interval belongs to previousMark",
        "type": "code",
        "location": "/tests/interval_set_math_operations/continual_less_sympy.py:56-78"
    },
    "4125": {
        "file_id": 522,
        "content": "Code is iterating over unifiedBoundaryList, checking for changes in markers at each boundary. If a marker is empty or if the current boundary is the first one, it continues without noting anything down. Otherwise, it updates finalMappings with previous empty ranges.",
        "type": "comment"
    },
    "4126": {
        "file_id": 522,
        "content": "  else:\n    key = previousMark.copy()\n    key.sort()\n    key = tuple(key)\n    finalMappings.update({key:finalMappings.get(key,[])+[(unifiedBoundaryList[index-1], boundary)]})\n    # also the end of previous mark! belongs to previousMark.\n### NOW THE FINAL OUTPUT ###\nfinalCats = {}\nfor key, value in finalMappings.items():\n  # value is an array containing subInterval tuples.\n  value = mergeOverlappedInIntervalTupleList(value)\n  finalCats.update({key: value})\nprint(\"______________FINAL CATS______________\")\nprint(finalCats)",
        "type": "code",
        "location": "/tests/interval_set_math_operations/continual_less_sympy.py:79-94"
    },
    "4127": {
        "file_id": 522,
        "content": "Updates finalMappings with previous mark, sorts and converts to tuple. Updates finalCats using merged overlapped intervals from finalMappings. Prints finalCats for output.",
        "type": "comment"
    },
    "4128": {
        "file_id": 523,
        "content": "/tests/adb_phone_control_termux_network_broadcast_scrcpy_appium_airtest/README.md",
        "type": "filepath"
    },
    "4129": {
        "file_id": 523,
        "content": "This code covers device discovery, Termux daemon, remote unlock with ADB and scrcpy client, focused window titles, downloading a macOS keylogger, and executes input tests on the X server.",
        "type": "summary"
    },
    "4130": {
        "file_id": 523,
        "content": "device discovery, termux daemon, remote unlock\nunlock requires screenshot and input events.\nhttps://technastic.com/unlock-android-phone-pin-pattern-adb/\nclick ok after input password:\nhttps://stackoverflow.com/questions/29072501/how-to-unlock-android-phone-through-adb\nscrcpy client\nhttps://github.com/leng-yue/py-scrcpy-client\nhttps://leng-yue.github.io/py-scrcpy-client/guide.html#bind-events\nyou want to use android emulator on macos m1?\nhttps://github.com/google/android-emulator-m1-preview/releases/tag/0.3\ncheck android screen lock/unlock state\nhttps://android.stackexchange.com/questions/191086/adb-commands-to-get-screen-state-and-locked-state\nBonjour/Avahi/Zeroconf\nlogic: if the kill switch is off, when no physical input events happens, or not focused on scrcpy window with keyboard/mouse input events on pc for some time, allow to interact with the phone.\nget physical events:\nwarning: this command could be offline for a short period of time after using the scrcpy. must automatically reconnect if the device is not offline.",
        "type": "code",
        "location": "/tests/adb_phone_control_termux_network_broadcast_scrcpy_appium_airtest/README.md:1-30"
    },
    "4131": {
        "file_id": 523,
        "content": "This code focuses on device discovery, termux daemon, remote unlock, using scrcpy client and android emulator on MacOS M1. It includes links for unlocking Android phone through ADB, checking screen lock/unlock state, utilizing Bonjour/Avahi/Zeroconf logic, handling physical events and reconnecting if necessary.",
        "type": "comment"
    },
    "4132": {
        "file_id": 523,
        "content": "```bash\nadb -s 192.168.10.3:5555 shell getevent\n```\nto get focused window title:\nhint: for headless ssh sessions, must set apropriate xorg environment variables, eg: `env XAUTHORITY=\"/run/user/0/gdm/Xauthority\" DISPLAY=:1 python3`\ngeneral method:\n```python\nimport pywinctl\npywinctl.getActiveWindowTitle()\n```\nfor linux:\n```bash\nwatch -n 2 xdotool getactivewindow getwindowname\n```\nfor macos: (allow permission first, deprecated since it will not get the window title instead of the program name)\nhttps://alvinalexander.com/mac-os-x/applescript-unix-mac-osx-foreground-application-result/\n(where is the window name?)\n```bash\nsleep 3 && osascript -e 'tell application \"System Events\"' -e 'set frontApp to name of first application process whose frontmost is true' -e 'end tell'\n```\nto get input events on macos:\ndownload keylogger here:\nhttps://hackernoon.com/writing-an-keylogger-for-macos-in-python-24adfa22722\nhttps://github.com/beatsbears/pkl?ref=hackernoon.com\n```bash\npython pkl_nowriting.py\n```\ninput events on linux:\n```bash",
        "type": "code",
        "location": "/tests/adb_phone_control_termux_network_broadcast_scrcpy_appium_airtest/README.md:32-68"
    },
    "4133": {
        "file_id": 523,
        "content": "This code provides methods to obtain the focused window title on different operating systems: Bash commands for Android devices and Windows, Python script for Linux, Applescript for macOS. Additionally, it mentions downloading a keylogger for capturing input events on macOS.",
        "type": "comment"
    },
    "4134": {
        "file_id": 523,
        "content": "xinput test-xi2 --root\n```",
        "type": "code",
        "location": "/tests/adb_phone_control_termux_network_broadcast_scrcpy_appium_airtest/README.md:69-70"
    },
    "4135": {
        "file_id": 523,
        "content": "Executes an input test on the X server, affecting all connected devices.",
        "type": "comment"
    },
    "4136": {
        "file_id": 524,
        "content": "/tests/adb_phone_control_termux_network_broadcast_scrcpy_appium_airtest/unlock_phone_on_given_ip.py",
        "type": "filepath"
    },
    "4137": {
        "file_id": 524,
        "content": "Device address is set to connect to the phone on a specific IP and port for further interactions.",
        "type": "summary"
    },
    "4138": {
        "file_id": 524,
        "content": "# first, check phone status.\ndevice_address = \"192.168.10.3:5555\"",
        "type": "code",
        "location": "/tests/adb_phone_control_termux_network_broadcast_scrcpy_appium_airtest/unlock_phone_on_given_ip.py:1-2"
    },
    "4139": {
        "file_id": 524,
        "content": "Device address is set to connect to the phone on a specific IP and port for further interactions.",
        "type": "comment"
    },
    "4140": {
        "file_id": 525,
        "content": "/tests/adb_phone_control_termux_network_broadcast_scrcpy_appium_airtest/pkl_nowriting.py",
        "type": "filepath"
    },
    "4141": {
        "file_id": 525,
        "content": "This Python script logs keystrokes and mouse events via Cocoa, for educational purposes, requires privilege settings adjustment, and has an event loop with interrupt handling.",
        "type": "summary"
    },
    "4142": {
        "file_id": 525,
        "content": "#!/usr/bin/env python\n\"\"\"\npkl.py\n:author: Andrew Scott\n:date: 9-3-2018\nIf executed successfully this script will log key strokes until the process is killed.\nThis script is for EDUCATIONAL PURPOSES ONLY. \n\"\"\"\n# can be run without root, but must enable the privilege in privacy settings\nimport os, sys\nsys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))\nfrom AppKit import NSApplication, NSApp\nfrom Foundation import NSObject\nfrom Cocoa import (\n    NSEvent,\n    NSKeyDownMask, # keyboard\n    NSLeftMouseUpMask, # mouse\n    NSLeftMouseDownMask,\n    NSLeftMouseDraggedMask,\n    NSRightMouseDownMask,\n    NSRightMouseDraggedMask,\n    NSRightMouseUpMask,\n    NSMouseMovedMask,\n)\nfrom PyObjCTools import AppHelper\n# NSLeftMouseUpMask, NSLeftMouseDownMask, NSLeftMouseDraggedMask, NSRightMouseDownMask, NSRightMouseDraggedMask, NSRightMouseUpMask, NSMouseMovedMask\nclass AppDelegate(NSObject):\n    \"\"\"\n    The App Delegate creates a mask to detect the key being pressed and adds\n    a global monitor for this mask.",
        "type": "code",
        "location": "/tests/adb_phone_control_termux_network_broadcast_scrcpy_appium_airtest/pkl_nowriting.py:1-38"
    },
    "4143": {
        "file_id": 525,
        "content": "This Python script logs key strokes until the process is killed, intended for educational purposes only. It uses AppKit and Foundation modules from Cocoa and PyObjCTools to create an app delegate that detects keyboard and mouse events without root access, but requires enabling privilege in privacy settings.",
        "type": "comment"
    },
    "4144": {
        "file_id": 525,
        "content": "    \"\"\"\n    def applicationDidFinishLaunching_(self, notification):\n        mask_down = NSKeyDownMask\n        mouse_masks = [\n            NSLeftMouseUpMask,\n            NSLeftMouseDownMask,\n            NSLeftMouseDraggedMask,\n            NSRightMouseDownMask,\n            NSRightMouseDraggedMask,\n            NSRightMouseUpMask,\n            NSMouseMovedMask,\n        ]\n        NSEvent.addGlobalMonitorForEventsMatchingMask_handler_(mask_down, key_handler)\n        for mouse_mask in mouse_masks:\n            NSEvent.addGlobalMonitorForEventsMatchingMask_handler_(\n                mouse_mask, mouse_handler\n            )\n# w = Writer()\ndef mouse_handler(event):\n    import time\n    print(\"mouse have actions\", time.time())\ndef key_handler(event):\n    \"\"\"\n    Translates the key press events into readable characters if one exists\n    the key code is also recorded for non-character input.\n    \"\"\"\n    try:\n        capture_char = event.characters()\n        capture_raw = event.keyCode()\n        print(capture_char, capture_raw)\n        # w.write_to_log(capture_char, capture_raw)",
        "type": "code",
        "location": "/tests/adb_phone_control_termux_network_broadcast_scrcpy_appium_airtest/pkl_nowriting.py:39-74"
    },
    "4145": {
        "file_id": 525,
        "content": "The code sets up event handlers for various mouse actions and keyboard events. It adds a global monitor to track these events, and when an event occurs, it logs the characters (if any) and keyCode. The code also includes functions for handling the mouse and key events, but they do not appear to perform any specific actions beyond logging.",
        "type": "comment"
    },
    "4146": {
        "file_id": 525,
        "content": "    except KeyboardInterrupt:\n        AppHelper.stopEventLoop()\nif __name__ == \"__main__\":\n    app = NSApplication.sharedApplication()\n    delegate = AppDelegate.alloc().init()\n    NSApp().setDelegate_(delegate)\n    AppHelper.runEventLoop()",
        "type": "code",
        "location": "/tests/adb_phone_control_termux_network_broadcast_scrcpy_appium_airtest/pkl_nowriting.py:75-83"
    },
    "4147": {
        "file_id": 525,
        "content": "The code sets up an event loop and handles interrupts, ensuring that the application properly terminates when needed.",
        "type": "comment"
    },
    "4148": {
        "file_id": 526,
        "content": "/tests/adb_phone_control_termux_network_broadcast_scrcpy_appium_airtest/get_modifier_with_masscan_scapy.py",
        "type": "filepath"
    },
    "4149": {
        "file_id": 526,
        "content": "This code uses Masscan to scan for open ports, connects to the desired port with AdbWrapper, and stores connected addresses in a list. It is part of a script for controlling devices over the network.",
        "type": "summary"
    },
    "4150": {
        "file_id": 526,
        "content": "# strange.\nfrom __future__ import absolute_import, division, print_function\nimport logging\nimport scapy.config\nimport scapy.layers.l2\nimport scapy.route\nimport socket\nimport math\nimport errno\nimport os\nimport getopt\nimport sys\nmyPort = 5555\nmyInterface = \"wlan0\"\n# list avaliable devices.\nfrom adb_wrapper import AdbWrapper\na = AdbWrapper()\ndevices = a.devices()\nprint(devices)\n# exit()\nconnected_addresses = []\nfor key, value in devices.items():\n    address = key\n    connected_addresses.append(address)\n    deviceType = value\n# not working.\nif os.geteuid() != 0:\n        print('You need to be root to run this script', file=sys.stderr)\n        sys.exit(1)\nscanAddress = None\nfor network, netmask, _, interface, address, _ in scapy.config.conf.route.routes:\n    # print(interface, address)\n    if interface == myInterface:\n        myAddress = address.split(\".\")\n        myAddress[3] = \"0/24\"\n        scanAddress = \".\".join(myAddress)\n        print(scanAddress, interface)\n        break\nif scanAddress is not None:\n    # now scan this interface with masscan.",
        "type": "code",
        "location": "/tests/adb_phone_control_termux_network_broadcast_scrcpy_appium_airtest/get_modifier_with_masscan_scapy.py:1-42"
    },
    "4151": {
        "file_id": 526,
        "content": "The code imports necessary libraries, initializes variables, and connects with available devices using AdbWrapper. It then checks if the user is root before attempting to scan a specific network interface using masscan.",
        "type": "comment"
    },
    "4152": {
        "file_id": 526,
        "content": "    import masscan\n    mas = masscan.PortScanner()\n    mas.scan(scanAddress, ports=str(myPort), arguments='--max-rate 1000')\n    result = mas.scan_result\n    # usually it only show opens.\n    import json\n    scanResultDict = json.loads(result)['scan']\n    for key, value in scanResultDict.items():\n        address = key\n        for port in value:\n            if port['port'] == myPort and port['status'] =='open':\n                # print(address, myPort)\n                # we need to connect to it!\n                connect_address = \"{}:{}\".format(address,myPort)\n                print(connect_address)\n                if not connect_address in connected_addresses:\n                    print(\"connecting device:\", connect_address)\n                    # command1 = \"adb tcpip 5555\"\n                    # no need to restart?\n                    command2 = \"adb connect {}\".format(connect_address)\n                    # os.system(command1)\n                    os.system(command2)",
        "type": "code",
        "location": "/tests/adb_phone_control_termux_network_broadcast_scrcpy_appium_airtest/get_modifier_with_masscan_scapy.py:43-64"
    },
    "4153": {
        "file_id": 526,
        "content": "This code is using the Masscan library to scan for open ports on a specified address. It then checks if the desired port is open, and if so, connects to it by running \"adb connect\" command. The connected addresses are stored in the connected_addresses list. This code is part of a broader script for controlling devices over network.",
        "type": "comment"
    },
    "4154": {
        "file_id": 527,
        "content": "/tests/adb_phone_control_termux_network_broadcast_scrcpy_appium_airtest/get_modifier.sh",
        "type": "filepath"
    },
    "4155": {
        "file_id": 527,
        "content": "This line establishes a TCP/IP connection on port 5555 for ADB, ensuring the device is reachable over the network.",
        "type": "summary"
    },
    "4156": {
        "file_id": 527,
        "content": "adb tcpip 5555 # will not restart if already in tcpip mode\\",
        "type": "code",
        "location": "/tests/adb_phone_control_termux_network_broadcast_scrcpy_appium_airtest/get_modifier.sh:1-1"
    },
    "4157": {
        "file_id": 527,
        "content": "This line establishes a TCP/IP connection on port 5555 for ADB, ensuring the device is reachable over the network.",
        "type": "comment"
    },
    "4158": {
        "file_id": 528,
        "content": "/tests/keepalive_service/test.sh",
        "type": "filepath"
    },
    "4159": {
        "file_id": 528,
        "content": "This line of code is running the \"keepalive\" executable with the argument \"echo abc\". The purpose seems to be testing and logging that the process is still alive.",
        "type": "summary"
    },
    "4160": {
        "file_id": 528,
        "content": "./keepalive echo abc",
        "type": "code",
        "location": "/tests/keepalive_service/test.sh:1-1"
    },
    "4161": {
        "file_id": 528,
        "content": "This line of code is running the \"keepalive\" executable with the argument \"echo abc\". The purpose seems to be testing and logging that the process is still alive.",
        "type": "comment"
    },
    "4162": {
        "file_id": 529,
        "content": "/tests/keepalive_service/install.sh",
        "type": "filepath"
    },
    "4163": {
        "file_id": 529,
        "content": "This line of code copies the 'keepalive' file to '/usr/local/bin/' directory, allowing it to be accessed and executed system-wide.",
        "type": "summary"
    },
    "4164": {
        "file_id": 529,
        "content": "cp keepalive /usr/local/bin/",
        "type": "code",
        "location": "/tests/keepalive_service/install.sh:1-1"
    },
    "4165": {
        "file_id": 529,
        "content": "This line of code copies the 'keepalive' file to '/usr/local/bin/' directory, allowing it to be accessed and executed system-wide.",
        "type": "comment"
    },
    "4166": {
        "file_id": 530,
        "content": "/tests/music_analysis/download_exciting_bgm_with_lyric.py",
        "type": "filepath"
    },
    "4167": {
        "file_id": 530,
        "content": "The code utilizes requests to interact with an API, defines a download path based on file extension, and has functions for login, logout, registration, and downloading BGMs. It searches endpoints for song details, extracts them, downloads and saves the songs as binary files, retrieves lyrics from a local server, writes them to a file, and handles potential issues with duration or service login.",
        "type": "summary"
    },
    "4168": {
        "file_id": 530,
        "content": "get_download_path = lambda extension:\"exciting_bgm.{}\".format(extension) # is the extension right?\nimport requests\nbaseUrl = \"http://localhost:4000\"\n# now what is the port?\n# 4042\nkeywords = \"last friday night\" # american pop music?\nimport time\ndef getJSTimeStamp(): return int(time.time()*1000)\n# {'data': {'code': 200, 'account': {'id': 7935782775, 'userName': '0_fxg_pxw@163.com', 'type': 0, 'status': -10, 'whitelistAuthority': 0, 'createTime': 1657240405751, 'tokenVersion': 0, 'ban': 0, 'baoyueVersion': 0, 'donateVersion': 0, 'vipType': 0, 'anonimousUser': False, 'paidFee': False}, 'profile': None}}\n# breakpoint()\n# phone, password = \"19825089619\",\"dbH361210110\"\n# login_response = requests.get(baseUrl+\"/login/cellphone\",params={\"phone\": phone,\"password\": password})\n# login_response = requests.get(baseUrl+\"/logout\")\n# login_response_json = login_response.json()\n# print(login_response_json)\n# login_response = requests.get(baseUrl+\"/register/anonimous\")\n# login_response_json = login_response.json()\n# # {'code': -460, 'message': '网络太拥挤，请稍候再试！'}",
        "type": "code",
        "location": "/tests/music_analysis/download_exciting_bgm_with_lyric.py:1-23"
    },
    "4169": {
        "file_id": 530,
        "content": "The code defines a download path based on file extension and uses requests to interact with an API at \"http://localhost:4000\". It seems to be related to music analysis and has functions for login, logout, and registration. The API endpoints are used to verify the account and perform operations related to downloading exciting background music (BGMs) with lyrics. The code also uses time.time() function to get the current timestamp in JST format. The purpose of the code is unclear without further context or knowledge of the specific project it's part of.",
        "type": "comment"
    },
    "4170": {
        "file_id": 530,
        "content": "# # what the fuck is this shit?\n# print(login_response_json)\n# login_status = requests.get(baseUrl+\"/login/status\")\n# login_status_json = login_status.json()\n# print(login_status_json)\n# breakpoint()\nsearch_result = requests.get(baseUrl+\"/search\", params={\"keywords\": keywords, \"timestamp\":getJSTimeStamp()})\n# search_result = requests.get(baseUrl+\"/cloudsearch\", params={\"keywords\": keywords, \"timestamp\":getJSTimeStamp()})\nsearch_result_json = search_result.json() # check search_result.json\n# breakpoint()\ncode = search_result_json[\"code\"]\n# print(search_result_json)\n# breakpoint()\n# {'msg': '操作频繁，请稍候再试', 'code': 405, 'message': '操作频繁，请稍候再试'} # too frequent.\nif not code == 200:\n    print(\"ERROR CODE IN SEARCH:\", code)\n    print(search_result_json)\nelse:# no error here.\n    result = search_result_json[\"result\"]\n    songs = result[\"songs\"]\n    mySong = songs[1]\n    mySongName = mySong[\"name\"]\n    mySongId = mySong[\"id\"]\n    if \"ar\" in mySong.keys():\n        mySongArtists = mySong[\"ar\"] # reserved for further use. like find other songs by the artist.",
        "type": "code",
        "location": "/tests/music_analysis/download_exciting_bgm_with_lyric.py:24-55"
    },
    "4171": {
        "file_id": 530,
        "content": "This code makes a GET request to a search endpoint with specified keywords and timestamp. If the response code is not 200, it prints an error message along with the response JSON. Otherwise, it extracts song details from the response and assigns them to variables for further use.",
        "type": "comment"
    },
    "4172": {
        "file_id": 530,
        "content": "    elif \"artists\" in mySong.keys():\n        mySongArtists = mySong[\"artists\"]\n    else: mySongArtists = []\n    # mySong[\"artists\"]\n    print(\"SELECTED SONG:\")\n    print(mySongName, mySongId, mySongArtists)\n    # download that thing.\n    download_result = requests.get(baseUrl + \"/song/url\", params = {\"id\":mySongId}) # 试听歌曲\n    # download_result = requests.get(baseUrl + \"/song/url\", params = {\"id\":mySongId, \"timestamp\":getJSTimeStamp()}) # 试听歌曲\n    download_result_json = download_result.json()\n    print(download_result_json) # no download url!\n    # breakpoint()\n    code = download_result_json[\"code\"]\n    if code == 200: # allow to download now?\n        myDownloads = download_result_json[\"data\"]\n        myDownload = myDownloads[0]\n        myDownloadUrl = myDownload[\"url\"]\n        myDownloadType = myDownload[\"type\"]\n        # now download the thing.\n        result = requests.get(myDownloadUrl) # no need for timestamp?\n        if result.status_code == 200:\n            data = result.content\n            with open(get_download_path(myDownloadType),\"wb\") as f:",
        "type": "code",
        "location": "/tests/music_analysis/download_exciting_bgm_with_lyric.py:56-82"
    },
    "4173": {
        "file_id": 530,
        "content": "This code is checking if the song has associated artists and then prints the selected song's name, ID, and artists. It attempts to download the song's URL based on the provided parameters. If successful, it downloads the song data and saves it as a binary file using the downloaded type and path.",
        "type": "comment"
    },
    "4174": {
        "file_id": 530,
        "content": "                f.write(data)\n            print(\"DOWNLOAD SONG DONE.\") # you should check the duration of this music file.\n            # 2871154\n            lyrics_result = requests.get(\"http://localhost:4000/lyric\",{\"id\":mySongId, \"timestamp\":getJSTimeStamp()})\n            # this is cached.\n            lyrics_result_json = lyrics_result.json()\n            if lyrics_result_json[\"code\"] == 200:\n                lrc = lyrics_result_json[\"lrc\"]\n                if type(lrc) == dict:\n                    version = lrc[\"version\"]\n                    lyric = lrc[\"lyric\"]\n                    if type(lyric) == str:\n                        with open(\n                            \"exciting_bgm.lrc\",\"w\") as f0: f0.write(lyric)\n                        print(\"LYRIC DOWNLOAD DONE.\")\n            # THIS IS FREAKING WRONG... SHALL I LOGIN?\n            # Duration                                 : 30 s 41 ms",
        "type": "code",
        "location": "/tests/music_analysis/download_exciting_bgm_with_lyric.py:83-99"
    },
    "4175": {
        "file_id": 530,
        "content": "This code downloads a music file, then retrieves its lyrics from a local server. It writes the lyrics to a file named \"exciting_bgm.lrc\" and prints messages indicating when the song and lyric downloads are done. The code also includes a comment pointing out an issue, possibly with the duration of the song or logging in to a service.",
        "type": "comment"
    },
    "4176": {
        "file_id": 531,
        "content": "/tests/music_analysis/bpm_tracking/test_audioowl.py",
        "type": "filepath"
    },
    "4177": {
        "file_id": 531,
        "content": "The code uses AudioOwl library to import audio file data, calculates beat times, slices beats, finds closest BPM time and selects startup beat. It then detects the closest beat time to a specified value, appends it to 'selected_beat_times' and prints this list.",
        "type": "summary"
    },
    "4178": {
        "file_id": 531,
        "content": "import matplotlib\nmatplotlib.use(\"TkAgg\")\nimport matplotlib.pyplot as plt # cannot plot shit. must change the thing.\nimport audioowl # do not install with dependencies. check it in setup.py and install latest versions.\nmyMusic = \"tarot_desc_acc_exceprt.wav\"\n# myMusic = \"/root/Desktop/works/bilibili_tarot/tarot_desc_acc.wav\"\nfrom MediaInfo import MediaInfo\ninfo = MediaInfo(filename = myMusic)\ninfo = info.getInfo()\nprint(info)\n# breakpoint()\naudioSampleRate = info[\"audioSamplingRate\"]\naudioSampleRate = int(audioSampleRate)\nwaveform = audioowl.get_waveform(myMusic,sr=audioSampleRate)\ndata = audioowl.analyze_file(myMusic,sr=audioSampleRate) # how fucking long?\n# plt.figure()\n# plt.vlines(data['beat_samples'], -1.0, 1.0)\n# plt.plot(waveform)\n# plt.show()\n# dict_keys(['sample_rate', 'duration', 'beat_samples', 'number_of_beats', 'tempo_float', 'tempo_int', 'zero_crossing', 'noisiness_median', 'noisiness_sum', 'notes', 'dominant_note'])\ndef getClosest(mlist,standard):\n    # mlist is sorted.\n    # assert mlist == list(sorted(mlist))",
        "type": "code",
        "location": "/tests/music_analysis/bpm_tracking/test_audioowl.py:1-30"
    },
    "4179": {
        "file_id": 531,
        "content": "The code imports necessary libraries, reads audio file information and waveform using AudioOwl library, stores the relevant data in a dictionary, and provides a function to find the closest element in a sorted list.",
        "type": "comment"
    },
    "4180": {
        "file_id": 531,
        "content": "    queue_list = []\n    last_elem = None\n    for elem in mlist:\n        mred = abs(elem-standard)\n        queue_list.append(mred)\n        if len(queue_list) > 2:\n            queue_list.pop(0)\n        if len(queue_list) == 2:\n            #compare now.\n            last_mred = queue_list[0]\n            if mred >= last_mred: return last_elem\n        last_elem = elem\n    return last_elem\na,b,c,d = [data[k] for k in [\"beat_samples\",\"duration\",\"sample_rate\",\"tempo_float\"]]\nprint(data)\nbreakpoint()\nsingle_bpm_time = 60/d\nbpm_times = [single_bpm_time*(2**x) for x in range(5)] #usually works.\nmin_beat_time = 2 # minimum beat skip time.\nclosest_beat_time = getClosest(bpm_times,min_beat_time)\n# breakpoint()\nmin_outro_time = 3 # must longer than the song.\n# total_samples = b*c\nbeat_times = [x/c for x in a if x <= c*(b - min_outro_time)] # no final cut.\n# so the beats are evenly sliced.\n# print(beat_times)\n# breakpoint()\nselected_beat_times = [0] # original beat. the startup.\nfor i,x in enumerate(beat_times):\n    lastBeat = selected_beat_times[-1]",
        "type": "code",
        "location": "/tests/music_analysis/bpm_tracking/test_audioowl.py:31-69"
    },
    "4181": {
        "file_id": 531,
        "content": "Calculates beat times for audio, ensures beats are evenly sliced, finds closest bpm time, selects original beat as startup.",
        "type": "comment"
    },
    "4182": {
        "file_id": 531,
        "content": "    if x <= lastBeat:\n        continue\n    ired_beat_times = beat_times[i:] # exactly what we want.\n    selectedBeat = getClosest(ired_beat_times,lastBeat+closest_beat_time)\n    selected_beat_times.append(selectedBeat)\nprint('selected beat times:')\nprint(selected_beat_times)\n# we have to check the thing.",
        "type": "code",
        "location": "/tests/music_analysis/bpm_tracking/test_audioowl.py:70-78"
    },
    "4183": {
        "file_id": 531,
        "content": "This code segment is finding the closest beat time to a specified value from a set of beat times. It continues from the last detected beat and appends the selected beat time to the 'selected_beat_times' list. Finally, it prints out the 'selected_beat_times'.",
        "type": "comment"
    },
    "4184": {
        "file_id": 532,
        "content": "/tests/music_analysis/lyric_change_detector/read_lyrics.py",
        "type": "filepath"
    },
    "4185": {
        "file_id": 532,
        "content": "Reading lyrics from \"some_lyrics.json.lrc\" file using pylrc library, parsing the LRC format and storing time and content for each subtitle in subs variable.",
        "type": "summary"
    },
    "4186": {
        "file_id": 532,
        "content": "import pylrc\nwith open(\"some_lyrics.json.lrc\",\"r\") as f:\n    lrc_string = f.read()\n    subs = pylrc.parse(lrc_string)\n    for sub in subs:\n        time_in_secs = sub.time\n        content = sub.text\n    # skip those which are too short.\n    # print(subs)\n    # breakpoint()",
        "type": "code",
        "location": "/tests/music_analysis/lyric_change_detector/read_lyrics.py:1-11"
    },
    "4187": {
        "file_id": 532,
        "content": "Reading lyrics from \"some_lyrics.json.lrc\" file using pylrc library, parsing the LRC format and storing time and content for each subtitle in subs variable.",
        "type": "comment"
    },
    "4188": {
        "file_id": 533,
        "content": "/tests/music_analysis/lyric_change_detector/launch_lyric_api_server.sh",
        "type": "filepath"
    },
    "4189": {
        "file_id": 533,
        "content": "The code changes the directory to the NeteaseCloudMusicApi project and starts a server on port 4000 with Node.js, launching the music API server.",
        "type": "summary"
    },
    "4190": {
        "file_id": 533,
        "content": "cd ../../../externals/NeteaseCloudMusicApi\nPORT=4000 node app.js",
        "type": "code",
        "location": "/tests/music_analysis/lyric_change_detector/launch_lyric_api_server.sh:1-3"
    },
    "4191": {
        "file_id": 533,
        "content": "The code changes the directory to the NeteaseCloudMusicApi project and starts a server on port 4000 with Node.js, launching the music API server.",
        "type": "comment"
    },
    "4192": {
        "file_id": 534,
        "content": "/tests/music_analysis/lyric_change_detector/extract_lyrics_from_netease_json.py",
        "type": "filepath"
    },
    "4193": {
        "file_id": 534,
        "content": "This code reads a JSON file, checks if it ends with \".json\", and extracts the lyric content. It then writes the extracted lyric to another file with the same name but with an additional \".lrc\" extension.",
        "type": "summary"
    },
    "4194": {
        "file_id": 534,
        "content": "import json\nimport sys\njson_file = sys.argv[1]\nassert json_file.endswith(\".json\")\nwith open(json_file,\"r\", encoding=\"utf-8\") as f:\n    json_data = json.loads(f.read())\n    lrc = json_data[\"lrc\"]\n    version = lrc[\"version\"]\n    lyric = lrc[\"lyric\"]\n    with open(json_file+\".lrc\",\"w\") as f0: f0.write(lyric)",
        "type": "code",
        "location": "/tests/music_analysis/lyric_change_detector/extract_lyrics_from_netease_json.py:1-12"
    },
    "4195": {
        "file_id": 534,
        "content": "This code reads a JSON file, checks if it ends with \".json\", and extracts the lyric content. It then writes the extracted lyric to another file with the same name but with an additional \".lrc\" extension.",
        "type": "comment"
    },
    "4196": {
        "file_id": 535,
        "content": "/tests/music_analysis/lyric_change_detector/download_lyric.sh",
        "type": "filepath"
    },
    "4197": {
        "file_id": 535,
        "content": "The code downloads a JSON file containing lyrics from an API endpoint, then extracts the lyrics using a separate script. The goal is to obtain the \"lrc\" part of the lyrics.",
        "type": "summary"
    },
    "4198": {
        "file_id": 535,
        "content": "curl -L -o some_lyrics.json http://localhost:4000/lyric?id=33894312\npython3 extract_lyrics_from_netease_json.py some_lyrics.json\n# just want the \"lrc\" part.",
        "type": "code",
        "location": "/tests/music_analysis/lyric_change_detector/download_lyric.sh:1-4"
    },
    "4199": {
        "file_id": 535,
        "content": "The code downloads a JSON file containing lyrics from an API endpoint, then extracts the lyrics using a separate script. The goal is to obtain the \"lrc\" part of the lyrics.",
        "type": "comment"
    }
}