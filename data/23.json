{
    "2300": {
        "file_id": 242,
        "content": "from bilibili_api.user import get_self_info\nfrom bilibili_api import Credential\n# how to load credential from our stored things?\nfrom lazero.search.api import getHomeDirectory\nimport os\nimport tinydb\nhome = getHomeDirectory()\ndbPath = os.path.join(home, \".bilibili_api.json\")\nimport tinydb\ndb = tinydb.TinyDB(dbPath)\nUser = tinydb.Query()\ndedeuserid = \"397424026\" # pass it before you do shit!\ndataList = db.search(User.dedeuserid == dedeuserid) # this will never change i suppose?\nif len(dataList) == 1:\n    data = dataList[0].copy()\n    print('try to login credential fetched from db:', data)\n    oldName = data.pop('name')\n    credential = Credential(**{'dedeuserid': dedeuserid,'sessdata':'fakeSessionData'})\n    from bilibili_api import sync\n    name = sync(get_self_info(credential))['name']\n    # 'GetCookieReq.Session' Error:Field validation for 'Session' failed on the 'gte' tag。\n    # don't know how. maybe this works?\n    # if oldName !=name:\n    #     data['name']=name\n    #     db.upsert(data, User.dedeuserid == dedeuserid)",
        "type": "code",
        "location": "/tests/bilibili_login_get_credential_view_data/test_login_fail.py:1-27"
    },
    "2301": {
        "file_id": 242,
        "content": "This code retrieves a user's credential from the database, attempts to log in using the provided session data, and updates the name if it changed. If the name has not changed after logging in, it does not update the database.",
        "type": "comment"
    },
    "2302": {
        "file_id": 242,
        "content": "    # will never succeed.\n    # don't know using some expired sessdata will get what?\n    # maybe will still fail?\n    print('login successful:', name)",
        "type": "code",
        "location": "/tests/bilibili_login_get_credential_view_data/test_login_fail.py:28-31"
    },
    "2303": {
        "file_id": 242,
        "content": "This code block attempts to log in using expired session data, expecting the login to fail. It prints a message indicating whether the login was successful or not.",
        "type": "comment"
    },
    "2304": {
        "file_id": 243,
        "content": "/tests/bilibili_login_get_credential_view_data/test.py",
        "type": "filepath"
    },
    "2305": {
        "file_id": 243,
        "content": "This code allows users to choose between password and SMS login methods, with additional functionality for database storage and geetest validation. It performs a login, retrieves user data, updates the database, and asks about atomic insert in tinydb.",
        "type": "summary"
    },
    "2306": {
        "file_id": 243,
        "content": "from bilibili_api.login import (\n    login_with_password,\n    login_with_sms,\n    send_sms,\n    PhoneNumber,\n    Check,\n)\nfrom bilibili_api.user import get_self_info\nfrom bilibili_api import settings\nfrom bilibili_api import sync, Credential\n# mode = int(input(\"\"\"请选择登录方式：\n# 1. 密码登录\n# 2. 验证码登录\n# 请输入 1/2\n# \"\"\"))\nmode = 2\ncredential = None\n# 关闭自动打开 geetest 验证窗口\nsettings.geetest_auto_open = False\nif mode == 1:\n    # 密码登录\n    username = input(\"请输入手机号/邮箱：\")\n    password = input(\"请输入密码：\")\n    print(\"正在登录。\")\n    c = login_with_password(username, password)\n    if isinstance(c, Check):\n        # 还需验证\n        phone = input(\"需要验证。请输入手机号：\")\n        c.set_phone(PhoneNumber(phone, country=\"+86\"))  # 默认设置地区为中国大陆\n        c.send_code()\n        print(\"已发送验证码。\")\n        code = input(\"请输入验证码：\")\n        credential = c.login(code)\n        print(\"登录成功！\")\n    else:\n        credential = c\nelif mode == 2:\n    # 验证码登录\n    phone = input(\"请输入手机号：\")\n    print(\"正在登录。\")\n    send_sms(PhoneNumber(phone, country=\"+86\"))  # 默认设置地区为中国大陆\n    code = input(\"请输入验证码：\")",
        "type": "code",
        "location": "/tests/bilibili_login_get_credential_view_data/test.py:1-46"
    },
    "2307": {
        "file_id": 243,
        "content": "This code allows the user to choose between two login methods: password or SMS verification. If the user chooses password login, they input their credentials and are logged in immediately if valid. If the user chooses SMS login, they first need to enter their phone number and receive an SMS code. After entering the code, they're logged in. The code also has a setting to disable automatic opening of geetest validation window.",
        "type": "comment"
    },
    "2308": {
        "file_id": 243,
        "content": "    c = login_with_sms(PhoneNumber(phone, country=\"+86\"), code)\n    credential = c\n    print(\"登录成功\")\nelse:\n    print(\"请输入 1/2 ！\")\n    exit()\nfrom lazero.search.api import getHomeDirectory\nimport os\nhome = getHomeDirectory()\ndbPath = os.path.join(home, \".bilibili_api.json\")\nimport tinydb\ndb = tinydb.TinyDB(dbPath)\nif credential != None:\n    name = sync(get_self_info(credential))[\"name\"]\n    print(f\"欢迎，{name}!\")\n    buvid3 = credential.buvid3\n    bili_jct = credential.bili_jct\n    sessdata = credential.sessdata\n    dedeuserid = credential.dedeuserid  # this is userid, better use this instead?\n    User = tinydb.Query()\n    # assume that we are here to fetch valid credentials.\n    db.upsert(\n        {\n            \"name\": name,\n            \"dedeuserid\": dedeuserid,\n            \"bili_jct\": bili_jct,\n            \"buvid3\": buvid3,\n            \"sessdata\": sessdata,\n        },\n        User.dedeuserid == dedeuserid,\n    )\n    # how to perform atomic insert in tinydb?\n    # breakpoint()",
        "type": "code",
        "location": "/tests/bilibili_login_get_credential_view_data/test.py:47-82"
    },
    "2309": {
        "file_id": 243,
        "content": "This code performs a login with SMS and stores the credentials in a database. It first checks if the login was successful, then retrieves the name, buvid3, bili_jct, sessdata, and dedeuserid from the credentials. The code updates the database with this information using an upsert operation, ensuring that the dedeuserid is unique. Finally, it asks how to perform atomic insert in tinydb.",
        "type": "comment"
    },
    "2310": {
        "file_id": 244,
        "content": "/tests/bilibili_login_get_credential_view_data/dump_view_history.py",
        "type": "filepath"
    },
    "2311": {
        "file_id": 244,
        "content": "The code fetches credentials from a local database, updates the user's name if necessary, and processes bilibili video history pages in increments of 100 per page, checking for duplicates and stopping upon completion or no more duplicates found.",
        "type": "summary"
    },
    "2312": {
        "file_id": 244,
        "content": "# how to?\nfrom bilibili_api.user import get_self_info\nfrom bilibili_api import Credential\n# how to load credential from our stored things?\nfrom bilibili_api import user\nfrom lazero.search.api import getHomeDirectory\nimport os\nimport tinydb\nhome = getHomeDirectory()\ndbPath = os.path.join(home, \".bilibili_api.json\")\nimport tinydb\ndb = tinydb.TinyDB(dbPath)\nUser = tinydb.Query()\ndedeuserid = \"397424026\"  # pass it before you do shit!\ndataList = db.search(User.dedeuserid == dedeuserid)  # this will never change i suppose?\nif len(dataList) == 1:\n    data = dataList[0].copy()\n    print(\"try to login credential fetched from db:\", data)\n    oldName = data.pop(\"name\")\n    credential = Credential(**data)\n    from bilibili_api import sync\n    name = sync(get_self_info(credential))[\"name\"]\n    if oldName != name:\n        data[\"name\"] = name\n        db.upsert(data, User.dedeuserid == dedeuserid)\n    print(\"login successful:\", name)\n    # now continue.\n    # how many pages you want? infinite?\n    import time\n    page_num = 0\n    dbHistory = tinydb.TinyDB(\"bilibiliHistory.json\")",
        "type": "code",
        "location": "/tests/bilibili_login_get_credential_view_data/dump_view_history.py:1-36"
    },
    "2313": {
        "file_id": 244,
        "content": "Code fetches credential from local database for a specific bilibili user, checks if the name is up-to-date, and updates it if necessary. Then, it continues with further processing while also keeping track of bilibili history in another database file.",
        "type": "comment"
    },
    "2314": {
        "file_id": 244,
        "content": "    while True:\n        time.sleep(3)\n        page_num += 1  # starts with 1\n        print(\"now processing page:\", page_num)\n        result = sync(\n            user.get_self_history(\n                page_num=page_num, per_page_item=100, credential=credential\n            )\n        )\n        # import pprint\n        # pprint.pprint(result)\n        if type(result) != list or len(result) == 0:\n            break\n        breakFlag=False\n        for elem in result:\n            # it has description.\n            videoData = {key: elem[key] for key in [\"bvid\", \"desc\", \"title\"]}\n            searchResult= dbHistory.search(User.bvid == videoData[\"bvid\"])\n            if len(searchResult) != 0:\n                breakFlag=True\n            dbHistory.upsert(videoData, User.bvid == videoData[\"bvid\"])\n        if breakFlag:\n            break",
        "type": "code",
        "location": "/tests/bilibili_login_get_credential_view_data/dump_view_history.py:37-59"
    },
    "2315": {
        "file_id": 244,
        "content": "This code is processing video history pages from a user's account. It fetches data in increments of 100 per page, checks for duplicates before storing the video details, and stops when there are no more pages or duplicate entries found.",
        "type": "comment"
    },
    "2316": {
        "file_id": 245,
        "content": "/tests/download_sections_video_portion_partial_download_youtube_yt_dlp_bilibili/test_bilibili.sh",
        "type": "filepath"
    },
    "2317": {
        "file_id": 245,
        "content": "This code utilizes yt-dlp to download Bilibili video sections with authentication, handles subtitles and danmaku, supports multiple portions, updates cookies, allows title-only downloads, and retrieves metadata.",
        "type": "summary"
    },
    "2318": {
        "file_id": 245,
        "content": "# 关于视频合集 分p视频的分析逻辑：\n# https://github.com/Satoing/python_bilibili_downloader/blob/master/bilibili_video.py\n# 解析这个接口可以得到分p或者合集的信息 以及字幕信息 AI生成的字幕\n# https://api.bilibili.com/x/web-interface/view?bvid=BV1Fs411k7e9\n# https://api.bilibili.com/x/web-interface/view?bvid=BV1Cg411E7NF\nURL=\"https://www.bilibili.com/video/BV1Fs411k7e9\" #老戴 马克思佩恩 分p视频\n# 也可以直接网页parse\n# executing this you will get \"subtitle\" in \"danmaku\" as language, in xml format.\n# 对于海量弹幕的某些视频 （超电磁炮 12w asoul的某些二创 3w）不建议进行弹幕分析 可以通过API获取弹幕总数 不下载弹幕 \n# yt-dlp --skip-download --list-subs -I 1 \"https://www.bilibili.com/video/BV1Fs411k7e9\"\n# URL=\"https://www.bilibili.com/video/BV1Cg411E7NF\" #苏打baka 魔改机箱 合集\n# 合集视频 用bilibili_api 或者直接网页parse即可\n# it has multiple videos. what to do?\n# --force-keyframes-at-cuts\n# man i just need the first chapter.\n# yt-dlp --download-sections \"*0:05:00-0:06:30\" --playlist-items \"1\" \"$URL\" # only first video.\n# premium?\n# this feature is awesome! how to extract cookies programmatically from browser?\n# Use --cookies-from-browser o",
        "type": "code",
        "location": "/tests/download_sections_video_portion_partial_download_youtube_yt_dlp_bilibili/test_bilibili.sh:1-26"
    },
    "2319": {
        "file_id": 245,
        "content": "This code snippet is for downloading specific sections of Bilibili videos using yt-dlp. It provides URLs for both single video parts and video collections, explains how to handle subtitles and danmaku (comments), and suggests using the --cookies-from-browser option for premium access.",
        "type": "comment"
    },
    "2320": {
        "file_id": 245,
        "content": "r --cookies for the authentication. See  https://github.com/yt-dlp/yt-dlp/wiki/FAQ#how-do-i-pass-cookies-to-yt-dlp \n# not working for chromium on kali? (no bilibili cookie found) maybe it is relocated.\n# cookies = yt_dlp.cookies.extract_cookies_from_browser(BROWSER_NAME) -> YourubeDLCookieJar\n# save as Netscape HTTP Cookie File.\n# cookies.save(OUTPUT_FILE_PATH) \n# since we have issue playing content at tail of video, we do this.\n# yt-dlp --download-sections \"*0:05:00-0:06:30\" --playlist-items \"1\" --cookies-from-browser firefox --force-keyframes-at-cuts \"$URL\" # pass cookies.\n# forcing keyframe is much slower. but it produces better results.\n# yt-dlp --download-sections \"*0:05:00-0:06:30\" --playlist-items \"1\" --cookies-from-browser firefox --force-keyframes-at-cuts \"$URL\" # pass cookies.\n# you may want to add some margin at tail (or head) if not using \"--force-keyframes-at-cuts\", be it 10 seconds. usually jigs happens at 5 secs. but we are careful.\n# yt-dlp --download-sections \"*0:04:50-0:06:40\" --playlist-items \"1\" --cookies-from-browser firefox \"$URL\" # pass cookies.",
        "type": "code",
        "location": "/tests/download_sections_video_portion_partial_download_youtube_yt_dlp_bilibili/test_bilibili.sh:26-42"
    },
    "2321": {
        "file_id": 245,
        "content": "The code is trying to download a specific portion of a Bilibili video, ensuring authentication by passing cookies from the browser (Firefox in this case) to yt-dlp. It forces keyframes at cuts for better results but notes that it's slower. The code provides different options to account for potential issues and suggests adding margin at tail or head if not using --force-keyframes-at-cuts, with a recommended 10 seconds or even 5 seconds depending on the need for caution.",
        "type": "comment"
    },
    "2322": {
        "file_id": 245,
        "content": "# what if we download multiple sections?\n# no combination? shit.\n# if not at the very tail, other tails can be better than the last tail. but it is just my guess. better to keep all these margins!\n# yt-dlp --download-sections \"*0:04:50-0:05:40\" --download-sections \"*0:05:50-0:06:40\" --playlist-items \"1\" --cookies-from-browser firefox -o \"%(uploader_id)s-%(id)s-%(title)s-%(autonumber)s.%(ext)s\" \"$URL\" # pass cookies.\n# since we have cron job now, no need to do the old-school thing.\nyt-dlp --download-sections \"*0:04:50-0:05:40\" --download-sections \"*0:05:50-0:06:40\" --playlist-items \"1\" --cookies /root/.browser_cookies_exported/firefox.cookies -o \"%(uploader_id)s-%(id)s-%(title)s-%(autonumber)s.%(ext)s\" \"$URL\" # pass cookies in different way\n# like this: '2142762-BV1Fs411k7e9_p1-老戴《马克思佩恩 3》全收集流程攻略【共14期完结】 p01 EP-01-00002.mp4'\n# https://github.com/yt-dlp/yt-dlp#readme -> \"OUTPUT TEMPLATE\"\n# https://github.com/yt-dlp/yt-dlp/issues/4579\n# you better use stored cookies instead of retrieving cookies every time.",
        "type": "code",
        "location": "/tests/download_sections_video_portion_partial_download_youtube_yt_dlp_bilibili/test_bilibili.sh:44-59"
    },
    "2323": {
        "file_id": 245,
        "content": "The code tests downloading multiple video portions from Bilibili using yt-dlp with cookies stored, instead of retrieving them every time. It mentions that keeping all margins is better and suggests using a different format for the output file name.",
        "type": "comment"
    },
    "2324": {
        "file_id": 245,
        "content": "# or you can update cookies regularly with cronjob.\n# just want metadata?\n# if you want title for each video in playlist, you just get it from elsewhere or parse the damn output filename (slow, man!)\n# this seems to only have video description. nothing else! not even video length.\n# yt-dlp --write-description --write-playlist-metafiles --skip-download \"$URL\"\n# hey i don't want many download links. i just want title.\n# yt-dlp --write-info-json  --write-playlist-metafiles --skip-download \"$URL\" # this will get metadata main playlist and every video in the playlist in separate json files.\n# this is one of the video in that playlist. \"https://www.bilibili.com/video/BV1Fs411k7e9?p=1\n# you can get comments with this tool.\n## no comments?\n# yt-dlp --write-info-json --skip-download \"$URL\"\n# download-sections can be used multiple times?",
        "type": "code",
        "location": "/tests/download_sections_video_portion_partial_download_youtube_yt_dlp_bilibili/test_bilibili.sh:60-75"
    },
    "2325": {
        "file_id": 245,
        "content": "This code snippet provides various options for downloading or obtaining metadata from a Bilibili playlist using yt-dlp. The user can choose to update cookies regularly, download only the video title, or retrieve metadata for the entire playlist and each individual video in separate JSON files. The user can also use specific URLs to obtain comments without actually downloading the videos. The code suggests multiple usage scenarios for the 'download-sections' functionality.",
        "type": "comment"
    },
    "2326": {
        "file_id": 246,
        "content": "/tests/download_sections_video_portion_partial_download_youtube_yt_dlp_bilibili/cron_update_cookies_stored_under_root_home.py",
        "type": "filepath"
    },
    "2327": {
        "file_id": 246,
        "content": "This script creates a directory for cookie storage if it doesn't already exist, and then extracts and saves cookies from Firefox and Chromium browsers.",
        "type": "summary"
    },
    "2328": {
        "file_id": 246,
        "content": "# 0 * * * * /usr/bin/python3 /root/Desktop/works/pyjom/tests/download_sections_video_portion_partial_download_youtube_yt_dlp_bilibili/cron_update_cookies_stored_under_root_home.py\nimport os\nimport shutil\ncookies_path = \"/root/.browser_cookies_exported\"\nif not (os.path.exists(cookies_path) or os.path.isdir(cookies_path)):\n    if os.path.isfile(cookies_path):\n        os.remove(cookies_path)\n    elif os.path.isdir(cookies_path):\n        shutil.rmtree(cookies_path)\n    elif os.path.islink(cookies_path):\n        os.unlink(cookies_path)\n    os.mkdir(cookies_path)\nimport yt_dlp\nbrowser_names = [\"firefox\",\"chromium\"]\nfor browser_name in browser_names:\n    cookies = yt_dlp.cookies.extract_cookies_from_browser(browser_name)\n    filepath = os.path.join(cookies_path,f\"{browser_name}.cookies\")\n    cookies.save(filepath)",
        "type": "code",
        "location": "/tests/download_sections_video_portion_partial_download_youtube_yt_dlp_bilibili/cron_update_cookies_stored_under_root_home.py:1-24"
    },
    "2329": {
        "file_id": 246,
        "content": "This script creates a directory for cookie storage if it doesn't already exist, and then extracts and saves cookies from Firefox and Chromium browsers.",
        "type": "comment"
    },
    "2330": {
        "file_id": 247,
        "content": "/tests/adb_phone_control_termux_network_broadcast_scrcpy_appium_airtest/README.md",
        "type": "filepath"
    },
    "2331": {
        "file_id": 247,
        "content": "This code covers device discovery, Termux daemon, remote unlock with ADB and scrcpy client, focused window titles, downloading a macOS keylogger, and executes input tests on the X server.",
        "type": "summary"
    },
    "2332": {
        "file_id": 247,
        "content": "device discovery, termux daemon, remote unlock\nunlock requires screenshot and input events.\nhttps://technastic.com/unlock-android-phone-pin-pattern-adb/\nclick ok after input password:\nhttps://stackoverflow.com/questions/29072501/how-to-unlock-android-phone-through-adb\nscrcpy client\nhttps://github.com/leng-yue/py-scrcpy-client\nhttps://leng-yue.github.io/py-scrcpy-client/guide.html#bind-events\nyou want to use android emulator on macos m1?\nhttps://github.com/google/android-emulator-m1-preview/releases/tag/0.3\ncheck android screen lock/unlock state\nhttps://android.stackexchange.com/questions/191086/adb-commands-to-get-screen-state-and-locked-state\nBonjour/Avahi/Zeroconf\nlogic: if the kill switch is off, when no physical input events happens, or not focused on scrcpy window with keyboard/mouse input events on pc for some time, allow to interact with the phone.\nget physical events:\nwarning: this command could be offline for a short period of time after using the scrcpy. must automatically reconnect if the device is not offline.",
        "type": "code",
        "location": "/tests/adb_phone_control_termux_network_broadcast_scrcpy_appium_airtest/README.md:1-30"
    },
    "2333": {
        "file_id": 247,
        "content": "This code focuses on device discovery, termux daemon, remote unlock, using scrcpy client and android emulator on MacOS M1. It includes links for unlocking Android phone through ADB, checking screen lock/unlock state, utilizing Bonjour/Avahi/Zeroconf logic, handling physical events and reconnecting if necessary.",
        "type": "comment"
    },
    "2334": {
        "file_id": 247,
        "content": "```bash\nadb -s 192.168.10.3:5555 shell getevent\n```\nto get focused window title:\nhint: for headless ssh sessions, must set apropriate xorg environment variables, eg: `env XAUTHORITY=\"/run/user/0/gdm/Xauthority\" DISPLAY=:1 python3`\ngeneral method:\n```python\nimport pywinctl\npywinctl.getActiveWindowTitle()\n```\nfor linux:\n```bash\nwatch -n 2 xdotool getactivewindow getwindowname\n```\nfor macos: (allow permission first, deprecated since it will not get the window title instead of the program name)\nhttps://alvinalexander.com/mac-os-x/applescript-unix-mac-osx-foreground-application-result/\n(where is the window name?)\n```bash\nsleep 3 && osascript -e 'tell application \"System Events\"' -e 'set frontApp to name of first application process whose frontmost is true' -e 'end tell'\n```\nto get input events on macos:\ndownload keylogger here:\nhttps://hackernoon.com/writing-an-keylogger-for-macos-in-python-24adfa22722\nhttps://github.com/beatsbears/pkl?ref=hackernoon.com\n```bash\npython pkl_nowriting.py\n```\ninput events on linux:\n```bash",
        "type": "code",
        "location": "/tests/adb_phone_control_termux_network_broadcast_scrcpy_appium_airtest/README.md:32-68"
    },
    "2335": {
        "file_id": 247,
        "content": "This code provides methods to obtain the focused window title on different operating systems: Bash commands for Android devices and Windows, Python script for Linux, Applescript for macOS. Additionally, it mentions downloading a keylogger for capturing input events on macOS.",
        "type": "comment"
    },
    "2336": {
        "file_id": 247,
        "content": "xinput test-xi2 --root\n```",
        "type": "code",
        "location": "/tests/adb_phone_control_termux_network_broadcast_scrcpy_appium_airtest/README.md:69-70"
    },
    "2337": {
        "file_id": 247,
        "content": "Executes an input test on the X server, affecting all connected devices.",
        "type": "comment"
    },
    "2338": {
        "file_id": 248,
        "content": "/tests/adb_phone_control_termux_network_broadcast_scrcpy_appium_airtest/unlock_phone_on_given_ip.py",
        "type": "filepath"
    },
    "2339": {
        "file_id": 248,
        "content": "Device address is set to connect to the phone on a specific IP and port for further interactions.",
        "type": "summary"
    },
    "2340": {
        "file_id": 248,
        "content": "# first, check phone status.\ndevice_address = \"192.168.10.3:5555\"",
        "type": "code",
        "location": "/tests/adb_phone_control_termux_network_broadcast_scrcpy_appium_airtest/unlock_phone_on_given_ip.py:1-2"
    },
    "2341": {
        "file_id": 248,
        "content": "Device address is set to connect to the phone on a specific IP and port for further interactions.",
        "type": "comment"
    },
    "2342": {
        "file_id": 249,
        "content": "/tests/adb_phone_control_termux_network_broadcast_scrcpy_appium_airtest/pkl_nowriting.py",
        "type": "filepath"
    },
    "2343": {
        "file_id": 249,
        "content": "This Python script logs keystrokes and mouse events via Cocoa, for educational purposes, requires privilege settings adjustment, and has an event loop with interrupt handling.",
        "type": "summary"
    },
    "2344": {
        "file_id": 249,
        "content": "#!/usr/bin/env python\n\"\"\"\npkl.py\n:author: Andrew Scott\n:date: 9-3-2018\nIf executed successfully this script will log key strokes until the process is killed.\nThis script is for EDUCATIONAL PURPOSES ONLY. \n\"\"\"\n# can be run without root, but must enable the privilege in privacy settings\nimport os, sys\nsys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))\nfrom AppKit import NSApplication, NSApp\nfrom Foundation import NSObject\nfrom Cocoa import (\n    NSEvent,\n    NSKeyDownMask, # keyboard\n    NSLeftMouseUpMask, # mouse\n    NSLeftMouseDownMask,\n    NSLeftMouseDraggedMask,\n    NSRightMouseDownMask,\n    NSRightMouseDraggedMask,\n    NSRightMouseUpMask,\n    NSMouseMovedMask,\n)\nfrom PyObjCTools import AppHelper\n# NSLeftMouseUpMask, NSLeftMouseDownMask, NSLeftMouseDraggedMask, NSRightMouseDownMask, NSRightMouseDraggedMask, NSRightMouseUpMask, NSMouseMovedMask\nclass AppDelegate(NSObject):\n    \"\"\"\n    The App Delegate creates a mask to detect the key being pressed and adds\n    a global monitor for this mask.",
        "type": "code",
        "location": "/tests/adb_phone_control_termux_network_broadcast_scrcpy_appium_airtest/pkl_nowriting.py:1-38"
    },
    "2345": {
        "file_id": 249,
        "content": "This Python script logs key strokes until the process is killed, intended for educational purposes only. It uses AppKit and Foundation modules from Cocoa and PyObjCTools to create an app delegate that detects keyboard and mouse events without root access, but requires enabling privilege in privacy settings.",
        "type": "comment"
    },
    "2346": {
        "file_id": 249,
        "content": "    \"\"\"\n    def applicationDidFinishLaunching_(self, notification):\n        mask_down = NSKeyDownMask\n        mouse_masks = [\n            NSLeftMouseUpMask,\n            NSLeftMouseDownMask,\n            NSLeftMouseDraggedMask,\n            NSRightMouseDownMask,\n            NSRightMouseDraggedMask,\n            NSRightMouseUpMask,\n            NSMouseMovedMask,\n        ]\n        NSEvent.addGlobalMonitorForEventsMatchingMask_handler_(mask_down, key_handler)\n        for mouse_mask in mouse_masks:\n            NSEvent.addGlobalMonitorForEventsMatchingMask_handler_(\n                mouse_mask, mouse_handler\n            )\n# w = Writer()\ndef mouse_handler(event):\n    import time\n    print(\"mouse have actions\", time.time())\ndef key_handler(event):\n    \"\"\"\n    Translates the key press events into readable characters if one exists\n    the key code is also recorded for non-character input.\n    \"\"\"\n    try:\n        capture_char = event.characters()\n        capture_raw = event.keyCode()\n        print(capture_char, capture_raw)\n        # w.write_to_log(capture_char, capture_raw)",
        "type": "code",
        "location": "/tests/adb_phone_control_termux_network_broadcast_scrcpy_appium_airtest/pkl_nowriting.py:39-74"
    },
    "2347": {
        "file_id": 249,
        "content": "The code sets up event handlers for various mouse actions and keyboard events. It adds a global monitor to track these events, and when an event occurs, it logs the characters (if any) and keyCode. The code also includes functions for handling the mouse and key events, but they do not appear to perform any specific actions beyond logging.",
        "type": "comment"
    },
    "2348": {
        "file_id": 249,
        "content": "    except KeyboardInterrupt:\n        AppHelper.stopEventLoop()\nif __name__ == \"__main__\":\n    app = NSApplication.sharedApplication()\n    delegate = AppDelegate.alloc().init()\n    NSApp().setDelegate_(delegate)\n    AppHelper.runEventLoop()",
        "type": "code",
        "location": "/tests/adb_phone_control_termux_network_broadcast_scrcpy_appium_airtest/pkl_nowriting.py:75-83"
    },
    "2349": {
        "file_id": 249,
        "content": "The code sets up an event loop and handles interrupts, ensuring that the application properly terminates when needed.",
        "type": "comment"
    },
    "2350": {
        "file_id": 250,
        "content": "/tests/adb_phone_control_termux_network_broadcast_scrcpy_appium_airtest/get_modifier_with_masscan_scapy.py",
        "type": "filepath"
    },
    "2351": {
        "file_id": 250,
        "content": "This code uses Masscan to scan for open ports, connects to the desired port with AdbWrapper, and stores connected addresses in a list. It is part of a script for controlling devices over the network.",
        "type": "summary"
    },
    "2352": {
        "file_id": 250,
        "content": "# strange.\nfrom __future__ import absolute_import, division, print_function\nimport logging\nimport scapy.config\nimport scapy.layers.l2\nimport scapy.route\nimport socket\nimport math\nimport errno\nimport os\nimport getopt\nimport sys\nmyPort = 5555\nmyInterface = \"wlan0\"\n# list avaliable devices.\nfrom adb_wrapper import AdbWrapper\na = AdbWrapper()\ndevices = a.devices()\nprint(devices)\n# exit()\nconnected_addresses = []\nfor key, value in devices.items():\n    address = key\n    connected_addresses.append(address)\n    deviceType = value\n# not working.\nif os.geteuid() != 0:\n        print('You need to be root to run this script', file=sys.stderr)\n        sys.exit(1)\nscanAddress = None\nfor network, netmask, _, interface, address, _ in scapy.config.conf.route.routes:\n    # print(interface, address)\n    if interface == myInterface:\n        myAddress = address.split(\".\")\n        myAddress[3] = \"0/24\"\n        scanAddress = \".\".join(myAddress)\n        print(scanAddress, interface)\n        break\nif scanAddress is not None:\n    # now scan this interface with masscan.",
        "type": "code",
        "location": "/tests/adb_phone_control_termux_network_broadcast_scrcpy_appium_airtest/get_modifier_with_masscan_scapy.py:1-42"
    },
    "2353": {
        "file_id": 250,
        "content": "The code imports necessary libraries, initializes variables, and connects with available devices using AdbWrapper. It then checks if the user is root before attempting to scan a specific network interface using masscan.",
        "type": "comment"
    },
    "2354": {
        "file_id": 250,
        "content": "    import masscan\n    mas = masscan.PortScanner()\n    mas.scan(scanAddress, ports=str(myPort), arguments='--max-rate 1000')\n    result = mas.scan_result\n    # usually it only show opens.\n    import json\n    scanResultDict = json.loads(result)['scan']\n    for key, value in scanResultDict.items():\n        address = key\n        for port in value:\n            if port['port'] == myPort and port['status'] =='open':\n                # print(address, myPort)\n                # we need to connect to it!\n                connect_address = \"{}:{}\".format(address,myPort)\n                print(connect_address)\n                if not connect_address in connected_addresses:\n                    print(\"connecting device:\", connect_address)\n                    # command1 = \"adb tcpip 5555\"\n                    # no need to restart?\n                    command2 = \"adb connect {}\".format(connect_address)\n                    # os.system(command1)\n                    os.system(command2)",
        "type": "code",
        "location": "/tests/adb_phone_control_termux_network_broadcast_scrcpy_appium_airtest/get_modifier_with_masscan_scapy.py:43-64"
    },
    "2355": {
        "file_id": 250,
        "content": "This code is using the Masscan library to scan for open ports on a specified address. It then checks if the desired port is open, and if so, connects to it by running \"adb connect\" command. The connected addresses are stored in the connected_addresses list. This code is part of a broader script for controlling devices over network.",
        "type": "comment"
    },
    "2356": {
        "file_id": 251,
        "content": "/tests/adb_phone_control_termux_network_broadcast_scrcpy_appium_airtest/get_modifier.sh",
        "type": "filepath"
    },
    "2357": {
        "file_id": 251,
        "content": "This line establishes a TCP/IP connection on port 5555 for ADB, ensuring the device is reachable over the network.",
        "type": "summary"
    },
    "2358": {
        "file_id": 251,
        "content": "adb tcpip 5555 # will not restart if already in tcpip mode\\",
        "type": "code",
        "location": "/tests/adb_phone_control_termux_network_broadcast_scrcpy_appium_airtest/get_modifier.sh:1-1"
    },
    "2359": {
        "file_id": 251,
        "content": "This line establishes a TCP/IP connection on port 5555 for ADB, ensuring the device is reachable over the network.",
        "type": "comment"
    },
    "2360": {
        "file_id": 252,
        "content": "/tests/bilibili_search_api_modification_section_params_get_related_videos/testApi.py",
        "type": "filepath"
    },
    "2361": {
        "file_id": 252,
        "content": "The code imports functions from the \"bilibili_api\" module and performs actions related to video searching and retrieval on Bilibili platform, using bilibili_search_api module to search for videos and write results to JSON files.",
        "type": "summary"
    },
    "2362": {
        "file_id": 252,
        "content": "from bilibili_api import sync, search\nBSP = search.bilibiliSearchParams()\n# result = sync(\n#     search.search(\n#         keyword=\"汪汪\",\n#         params={\"tids\": BSP.all.tids.动物圈.tid, \"duration\": BSP.all.duration._10分钟以下},\n#         page=1\n#     )\n# )\n# print(result)\n# how to get suggested keyword?\n# suggested_keyword = sync(search.get_suggest_keywords(keyword = \"汪汪\"))\n# print(suggested_keyword)\n# you might want to split this.\n# this is not deterministic.\n# ['汪汪队立大功 第二季 中文配音', '汪汪队立大功', '汪汪队立大功神威狗狗', '汪汪队', '特别任务 汪汪队立大功 冒险湾的一天', '雀魂汪汪录', '汪汪公主biu', '汪汪来透剧', '汪汪在亚美尼亚', '汪汪队立大功 第一季 中文配音']\n# ['汪汪队立大功', '汪汪队', '汪汪队立大功 第一季 中文配音', '汪汪队立大功 第二季 中文配音', '汪汪录', '汪汪队立大功大电影', '汪汪队立大功中文', '汪汪队立大功神威狗狗', '汪汪汪', '汪汪队中文']\nimport json\n# result_str = json.dumps(result, ensure_ascii=False, indent=4)\n# with open(\"search_result_all.json\",'w+') as f:\n#     f.write(result_str)\n# get video info\nfrom bilibili_api import video\nbvid = \"BV1iw411Z7xt\"\nv = video.Video(bvid=bvid)\n# info=sync(v.get_info())\n# # print(info)\n# with open('video_info.json', 'w+') as f:",
        "type": "code",
        "location": "/tests/bilibili_search_api_modification_section_params_get_related_videos/testApi.py:1-38"
    },
    "2363": {
        "file_id": 252,
        "content": "This code imports functions from the \"bilibili_api\" module, initializes a search object, and attempts to perform various actions related to video searching and retrieval on Bilibili platform. It includes searching for videos using specified keywords and tags, getting suggested keywords, obtaining video information, and saving search results and video info as JSON files.",
        "type": "comment"
    },
    "2364": {
        "file_id": 252,
        "content": "#     f.write(json.dumps(info, indent=4, ensure_ascii=False))\n# -> pages to access all parted videos.\n# -> ugc_season to get maker collected seasons.\n# # video tags\n# able to get from search\n# related videos\n# related = sync(v.get_related())\n# with open('video_related.json', 'w+') as f:\n#     f.write(json.dumps(related, indent=4, ensure_ascii=False))\n# search video\nresult = sync(\n    search.search_by_type(\n        keyword=\"汪汪\",\n        params={\"tids\": BSP.all.tids.动物圈.tid, \"duration\": BSP.all.duration._10分钟以下},\n        page=1,\n        search_type=search.SearchObjectType.VIDEO,\n    )\n)\nwith open('search_by_type_result_video.json','w+') as f:\n    f.write(json.dumps(result, indent=4, ensure_ascii=False))\n# with open(\"search_result_all.json\", \"r\") as f:\n#     data = f.read()\n#     data = json.loads(data)",
        "type": "code",
        "location": "/tests/bilibili_search_api_modification_section_params_get_related_videos/testApi.py:39-68"
    },
    "2365": {
        "file_id": 252,
        "content": "This code is using the bilibili_search_api module to search for videos related to a specific keyword and writes the results to json files. The script first calls the get_related() function on each video, then writes the related videos to a 'video_related.json' file. Next, it searches for a specific type of video using the search_by_type() function and writes the result to 'search_by_type_result_video.json'. Additionally, there is commented code that suggests reading data from 'search_result_all.json', but this is not executed in this script.",
        "type": "comment"
    },
    "2366": {
        "file_id": 253,
        "content": "/tests/bilibili_search_api_modification_section_params_get_related_videos/test_search_section_pets.py",
        "type": "filepath"
    },
    "2367": {
        "file_id": 253,
        "content": "The code showcases Bilibili search query URLs with parameters for keyword, source, tid, order type, and duration filter, related to the video search API of Bilibili allowing content searches, modifications, and testing. It defines section categories and provides sorting options for bilibili search results with example URLs and API retrieval of related videos.",
        "type": "summary"
    },
    "2368": {
        "file_id": 253,
        "content": "# https://search.bilibili.com/all?keyword=%E9%A9%AC%E5%85%8B%E6%80%9D%E4%BD%A9%E6%81%A93&from_source=webtop_search&spm_id_from=333.1007&tids=36\n# 综合排序\n# https://search.bilibili.com/all?keyword=%E9%A9%AC%E5%85%8B%E6%80%9D%E4%BD%A9%E6%81%A93&from_source=webtop_search&spm_id_from=333.1007&tids=36&order=click\n# 最多点击\n# https://search.bilibili.com/all?keyword=%E9%A9%AC%E5%85%8B%E6%80%9D%E4%BD%A9%E6%81%A93&from_source=webtop_search&spm_id_from=333.1007&tids=36&order=pubdate\n# 最新发布\n# https://search.bilibili.com/all?keyword=%E9%A9%AC%E5%85%8B%E6%80%9D%E4%BD%A9%E6%81%A93&from_source=webtop_search&spm_id_from=333.1007&tids=36&order=dm\n# 最多弹幕\n# https://search.bilibili.com/all?keyword=%E9%A9%AC%E5%85%8B%E6%80%9D%E4%BD%A9%E6%81%A93&from_source=webtop_search&spm_id_from=333.1007&tids=36&order=stow\n# 最多收藏\n# https://search.bilibili.com/all?keyword=%E9%A9%AC%E5%85%8B%E6%80%9D%E4%BD%A9%E6%81%A93&from_source=webtop_search&spm_id_from=333.1007&tids=36&order=stow&duration=1\n# https://search.bilibili.com/all?keyword=%E",
        "type": "code",
        "location": "/tests/bilibili_search_api_modification_section_params_get_related_videos/test_search_section_pets.py:1-14"
    },
    "2369": {
        "file_id": 253,
        "content": "This code provides example URLs for Bilibili search queries, demonstrating different sorting options such as overall popularity, latest publication date, and number of comments or favorites. The URLs include various parameters like keyword, source, tid, and order type, along with an optional duration filter for favorite videos.",
        "type": "comment"
    },
    "2370": {
        "file_id": 253,
        "content": "9%A9%AC%E5%85%8B%E6%80%9D%E4%BD%A9%E6%81%A93&from_source=webtop_search&spm_id_from=333.1007&tids=36&order=stow&duration=2\n# https://search.bilibili.com/all?keyword=%E9%A9%AC%E5%85%8B%E6%80%9D%E4%BD%A9%E6%81%A93&from_source=webtop_search&spm_id_from=333.1007&tids=36&order=stow&duration=3\n# https://search.bilibili.com/all?keyword=%E9%A9%AC%E5%85%8B%E6%80%9D%E4%BD%A9%E6%81%A93&from_source=webtop_search&spm_id_from=333.1007&tids=36&order=stow&duration=4\n# https://search.bilibili.com/all?keyword=%E9%A9%AC%E5%85%8B%E6%80%9D%E4%BD%A9%E6%81%A93&from_source=webtop_search&spm_id_from=333.1007&order=stow&duration=4&tids=1\n# https://search.bilibili.com/all?keyword=%E9%A9%AC%E5%85%8B%E6%80%9D%E4%BD%A9%E6%81%A93&from_source=webtop_search&spm_id_from=333.1007&order=stow&duration=4&tids=24\n# https://search.bilibili.com/article?keyword=%E9%A9%AC%E5%85%8B%E6%80%9D%E4%BD%A9%E6%81%A93&from_source=webtop_search&spm_id_from=333.1007&duration=4&tids=24&order=attention\n# https://search.bilibili.com/article?keyword=",
        "type": "code",
        "location": "/tests/bilibili_search_api_modification_section_params_get_related_videos/test_search_section_pets.py:14-25"
    },
    "2371": {
        "file_id": 253,
        "content": "This code appears to be a collection of example URLs containing various parameters for searching on Bilibili, likely related to their video search API. The parameters include specific keywords, duration, and article or all searches, as well as other potential options like order and tids. These are most likely used to test and modify the bilibili_search_api function in this codebase.",
        "type": "comment"
    },
    "2372": {
        "file_id": 253,
        "content": "%E9%A9%AC%E5%85%8B%E6%80%9D%E4%BD%A9%E6%81%A93&from_source=webtop_search&spm_id_from=333.1007&duration=4&tids=24&order=scores\n# https://search.bilibili.com/live?keyword=%E9%A9%AC%E5%85%8B%E6%80%9D%E4%BD%A9%E6%81%A93&from_source=webtop_search&spm_id_from=333.1007&duration=4&tids=24\n# https://search.bilibili.com/live?keyword=%E9%A9%AC%E5%85%8B%E6%80%9D%E4%BD%A9%E6%81%A93&from_source=webtop_search&spm_id_from=333.1007&duration=4&tids=24&search_type=live_user\n# https://search.bilibili.com/live?keyword=%E9%A9%AC%E5%85%8B%E6%80%9D%E4%BD%A9%E6%81%A93&from_source=webtop_search&spm_id_from=333.1007&duration=4&tids=24&search_type=live_room\nclass bilibiliSearchParams:\n    class _path:\n        综合 = \"all\"\n        视频 = \"video\" # for now you only search for video, recommend it to qq. remember do not use message post by yourself. or maybe you can make a switch for that?\n        番剧 = \"bangumi\"\n        影视 = \"pgc\"\n        直播 = \"live\"\n        专栏 = \"article\"\n        话题 = \"topic\"\n        用户 = \"upuser\"\n    class all:\n        class order:",
        "type": "code",
        "location": "/tests/bilibili_search_api_modification_section_params_get_related_videos/test_search_section_pets.py:25-45"
    },
    "2373": {
        "file_id": 253,
        "content": "This code is part of the bilibiliSearchParams class, defining search parameters for different types of content on Bilibili. The available content types are \"all\", \"video\", \"bangumi\", \"pgc\", \"live\", \"article\", and \"topic\". The order parameter includes options like \"scores\" and can be used with the specified content type to refine the search results.",
        "type": "comment"
    },
    "2374": {
        "file_id": 253,
        "content": "            综合排序 = None\n            最多点击 = \"click\"\n            最新发布 = \"pubdate\"\n            最多弹幕 = \"dm\"\n            最多收藏 = \"stow\"\n        class duration:\n            全部时长 = None\n            _10分钟以下 = 1\n            _10_30分钟 = 2\n            _30_60分钟 = 3\n            _60分钟以上 = 4\n        class tids:\n            全部分区 = None\n            ########################\n            class 番剧:\n                tid = 13\n                连载动画 = 33\n                完结动画 = 32\n                资讯 = 51\n                官方延伸 = 152\n            class 国创:\n                tid = 167\n                国产动画 = 153\n                国产原创相关 = 168\n                布袋戏 = 169\n                动态漫·广播剧 = 195\n                资讯 = 170\n            class 动画:\n                tid = 1\n                MAD_AMV = 24\n                MMD_3D = 25\n                短片·手书·配音 = 47\n                手办·模玩 = 210\n                特摄 = 86\n                综合 = 27\n            class 游戏:\n                tid = 4\n                单机游戏 = 17\n                电子竞技 = 171\n                手机游戏 = 172\n                网络游戏 = 65",
        "type": "code",
        "location": "/tests/bilibili_search_api_modification_section_params_get_related_videos/test_search_section_pets.py:46-92"
    },
    "2375": {
        "file_id": 253,
        "content": "This code defines different video categories and their corresponding TID values for sorting and filtering purposes in a Bilibili search API modification function. The categories include anime, Chinese animation, games, and more.",
        "type": "comment"
    },
    "2376": {
        "file_id": 253,
        "content": "                桌游棋牌 = 173\n                GMV = 121\n                音游 = 136\n                Mugen = 19\n            class 鬼畜:\n                tid = 119\n                鬼畜调教 = 22\n                音MAD = 26\n                人力VOCALOID = 126\n                鬼畜剧场 = 216\n                教程演示 = 127\n            class 音乐:\n                tid = 3\n                原创音乐 = 28\n                翻唱 = 31\n                演奏 = 59\n                VOCALOID·UTAU = 30\n                音乐现场 = 29\n                MV = 193\n                乐评盘点 = 243\n                音乐教学 = 244\n                音乐综合 = 130\n            class 舞蹈:\n                tid = 129\n                宅舞 = 20\n                街舞 = 198\n                明星舞蹈 = 199\n                中国舞 = 200\n                舞蹈综合 = 154\n                舞蹈教程 = 156\n            class 影视:\n                tid = 181\n                影视杂谈 = 182\n                影视剪辑 = 183\n                小剧场 = 85\n                预告·资讯 = 184\n            class 娱乐:\n                tid = 5\n                综艺 = 71\n                娱乐杂谈 = 241\n                粉丝创作 = 242",
        "type": "code",
        "location": "/tests/bilibili_search_api_modification_section_params_get_related_videos/test_search_section_pets.py:93-138"
    },
    "2377": {
        "file_id": 253,
        "content": "This code defines several classes with different tags (173, 121, 136, 19, 119, 22, 26, 126, 216, 127, 3, 28, 31, 59, 30, 29, 193, 243, 244, 130, 129, 20, 198, 199, 200, 154, 156, 181, 182, 183, 85, 71, 241) for categorizing videos on Bilbili.",
        "type": "comment"
    },
    "2378": {
        "file_id": 253,
        "content": "                明星综合 = 137\n            class 知识:\n                tid = 36\n                科学科普 = 201\n                社科·法律·心理 = 124\n                人文历史 = 228\n                财经商业 = 207\n                校园学习 = 208\n                职业职场 = 209\n                设计·创意 = 229\n                野生技能协会 = 122\n            class 科技:\n                tid = 188\n                数码 = 95\n                软件应用 = 230\n                计算机技术 = 231\n                科工机械 = 232\n            class 资讯:\n                tid = 202\n                热点 = 203\n                环球 = 204\n                社会 = 205\n                综合 = 206\n            class 美食:\n                tid = 211\n                美食制作 = 76\n                美食侦探 = 212\n                美食测评 = 213\n                田园美食 = 214\n                美食记录 = 215\n            class 生活:\n                tid = 160\n                搞笑 = 138\n                出行 = 250\n                三农 = 251\n                家居房产 = 239\n                手工 = 161\n                绘画 = 162\n                日常 = 21\n            class 汽车:\n                tid = 223",
        "type": "code",
        "location": "/tests/bilibili_search_api_modification_section_params_get_related_videos/test_search_section_pets.py:139-185"
    },
    "2379": {
        "file_id": 253,
        "content": "This code defines various classes, each representing a different section category on Bilibili. Each class has a unique 'tid' and a brief description of the content it contains. These sections include knowledge, technology, news, food, life, and cars. The categories are used to retrieve related videos for a search query in the Bilibili API.",
        "type": "comment"
    },
    "2380": {
        "file_id": 253,
        "content": "                赛车 = 245\n                改装玩车 = 246\n                新能源车 = 246\n                房车 = 248\n                摩托车 = 240\n                购车攻略 = 227\n                汽车生活 = 176\n            class 时尚:\n                tid = 155\n                美妆护肤 = 157\n                仿妆cos = 252\n                穿搭 = 158\n                时尚潮流 = 159\n            class 运动:\n                tid = 234\n                篮球 = 235\n                足球 = 249\n                健身 = 164\n                竞技体育 = 236\n                运动文化 = 237\n                运动综合 = 238\n            class 动物圈:\n                tid = 217\n                喵星人 = 218\n                汪星人 = 219\n                大熊猫 = 220\n                野生动物 = 221\n                爬宠 = 222\n                动物综合 = 75\n            ########################\n    video = all\n    class article:\n        class order:\n            综合排序 = None\n            最多点击 = \"click\"\n            最新发布 = \"pubdate\"\n            最多喜欢 = \"attention\"\n            最多评论 = \"scores\"\n    class live:\n        class search_type:\n            全部 = None",
        "type": "code",
        "location": "/tests/bilibili_search_api_modification_section_params_get_related_videos/test_search_section_pets.py:186-233"
    },
    "2381": {
        "file_id": 253,
        "content": "The code contains different sections and their corresponding tags for a search API. It includes categories such as cars, fashion, sports, and animals with specific tag IDs and subcategories. The code also defines order options (like most popular or latest) and live search types (all or specified).",
        "type": "comment"
    },
    "2382": {
        "file_id": 253,
        "content": "            主播 = \"live_user\"\n            直播间 = \"live_room\"\n    class upuser:\n        class order:\n            默认排序 = None\n            粉丝数由高到低 = \"fans\"\n            Lv等级由高到低 = \"level\"\n        class order_sort:\n            正序 = None\n            倒序 = 1\n# https://search.bilibili.com/upuser?keyword=%E9%A9%AC%E5%85%8B%E6%80%9D%E4%BD%A9%E6%81%A93&from_source=webtop_search&spm_id_from=333.1007&duration=4&tids=24&order=fans\n# https://search.bilibili.com/upuser?keyword=%E9%A9%AC%E5%85%8B%E6%80%9D%E4%BD%A9%E6%81%A93&from_source=webtop_search&spm_id_from=333.1007&duration=4&tids=24&order=fans&order_sort=1\n# https://search.bilibili.com/upuser?keyword=%E9%A9%AC%E5%85%8B%E6%80%9D%E4%BD%A9%E6%81%A93&from_source=webtop_search&spm_id_from=333.1007&duration=4&tids=24&order=level\n# bilibiliSearchParams.order.最多弹幕\nprint(bilibiliSearchParams.video.tids)",
        "type": "code",
        "location": "/tests/bilibili_search_api_modification_section_params_get_related_videos/test_search_section_pets.py:234-253"
    },
    "2383": {
        "file_id": 253,
        "content": "This code defines a class \"upuser\" with an inner class \"order\", which contains different sorting options for bilibili search results. The outer class \"order_sort\" provides ascending and descending order options. The code also includes example URLs for different search parameters, and the last line prints the value of \"bilibiliSearchParams.video.tids\".",
        "type": "comment"
    },
    "2384": {
        "file_id": 254,
        "content": "/tests/bilibili_search_api_modification_section_params_get_related_videos/test_get_user_info_followers_dynamic.py",
        "type": "filepath"
    },
    "2385": {
        "file_id": 254,
        "content": "The code imports the \"user\" module from \"bilibil_api\", retrieves user information like followers and followings, but lacks implementation for top_followers. It extracts data using various methods, converts non-JSON serializable results to strings, stores in a dictionary, and dumps it into JSON format.",
        "type": "summary"
    },
    "2386": {
        "file_id": 254,
        "content": "from bilibili_api import user, sync\nu = user.User(660303135)\n# u.get_channel_list\n# data = sync(u.get_relation_info())\n# [\"follower\"]\n# {'mid': 660303135, 'following': 34, 'whisper': 0, 'black': 0, 'follower': 1158}\n# get followers less than 200 but view greater than 3000.\n# also get that damn publish date!\n# print(data)\n# print(data.keys())\n# print(dir(u))\n# you can also get followings to get the 'target video'\npotentialMethods = [\n    # \"credential\",#TypeError: 'Credential' object is not callable\n# error executing u.credential()\n    \"get_all_followings\",\n    \"get_article_list\",\n    \"get_articles\",\n    \"get_audios\",\n    # \"get_channel_list\",\n    # \"get_channel_videos_season\",#TypeError: get_channel_videos_season() missing 1 required positional argument: 'sid'\n# error executing u.get_channel_videos_season()\n# Traceback (most recent call last):\n    # \"get_channel_videos_series\", #TypeError: get_channel_videos_series() missing 1 required positional argument: 'sid'\n# error executing u.get_channel_videos_series()\n    # \"get_channels\",",
        "type": "code",
        "location": "/tests/bilibili_search_api_modification_section_params_get_related_videos/test_get_user_info_followers_dynamic.py:1-27"
    },
    "2387": {
        "file_id": 254,
        "content": "The code is importing the \"user\" module from \"bilibil_api\" and creating an instance of it. It then calls some methods to get user information, specifically focusing on followers and followings. The comments suggest further exploration of available functions and parameters for getting specific types of user data such as articles, audios, and videos. The code also encounters errors when trying to use certain methods without the required arguments.",
        "type": "comment"
    },
    "2388": {
        "file_id": 254,
        "content": "    \"get_cheese\",\n    \"get_dynamics\", # has offset parameter.\n    \"get_followers\", # key feature. we need this some how.\n    \"get_followings\",\n    \"get_live_info\",\n    \"get_overview_stat\",\n    \"get_relation_info\",\n    \"get_subscribed_bangumi\",\n    # \"get_uid\", # probabily not async. #    raise TypeError('An asyncio.Future, a coroutine or an awaitable is '\n# TypeError: An asyncio.Future, a coroutine or an awaitable is required\n# error executing u.get_uid()\n    # \"get_up_stat\", # bilibili_api.exceptions.CredentialNoBiliJctException.CredentialNoBiliJctException: Credential 类未提供 bili_jct。\n# error executing u.get_up_stat()\n    \"get_user_info\",\n    \"get_videos\",\n    # \"modify_relation\", # TypeError: modify_relation() missing 1 required positional argument: 'relation'\n# error executing u.modify_relation()\n##########################################\n# our most wanted feature, top_followers #\n##########################################\n    # \"top_followers\",# bilibili_api.exceptions.ResponseCodeException.ResponseCodeException: 接口返回错误代码：-101，信息：账号未登录。",
        "type": "code",
        "location": "/tests/bilibili_search_api_modification_section_params_get_related_videos/test_get_user_info_followers_dynamic.py:28-48"
    },
    "2389": {
        "file_id": 254,
        "content": "The code contains various functions for interacting with the Bilibili API, including methods to get user information, videos, dynamics, and more. Some functions are incomplete or require additional parameters. The most desired feature, top_followers, is not yet implemented due to an error.",
        "type": "comment"
    },
    "2390": {
        "file_id": 254,
        "content": "# error executing u.top_followers()\n]\n# breakpoint()\n# get_overview_stat()\nimport json\nmdata = {}\nimport progressbar\nfor key in progressbar.progressbar(potentialMethods):\n    command = \"u.{}()\".format(key)\n    try:\n        result = sync(eval(command))\n        # Object of type ChannelSeries is not JSON serializable\n        if type(result) not in [dict, list, tuple, int, float, str]:\n            print(type(result))\n            print('COMMAND:',key)\n            breakpoint()\n            result = str(result)\n        mdata.update({key:result})\n        import time\n        time.sleep(3)\n    except:\n        import traceback\n        traceback.print_exc()\n        print('error executing {}'.format(command))\nmString = json.dumps(mdata, indent=4, ensure_ascii=False)\nwith open('user_data_api.json','w+') as f:\n    f.write(mString)\nprint(\"DUMP COMPLETE\")",
        "type": "code",
        "location": "/tests/bilibili_search_api_modification_section_params_get_related_videos/test_get_user_info_followers_dynamic.py:49-78"
    },
    "2391": {
        "file_id": 254,
        "content": "The code is attempting to extract user data from the Bilibili platform API. It iterates through a list of potential methods, dynamically executes each method on an object 'u', and stores the results in a dictionary. If the result type is not JSON serializable (like ChannelSeries), it converts it to a string before storing. Finally, it dumps the data into a JSON file named \"user_data_api.json\" and prints \"DUMP COMPLETE\".",
        "type": "comment"
    },
    "2392": {
        "file_id": 255,
        "content": "/tests/bilibili_search_api_modification_section_params_get_related_videos/template.j2",
        "type": "filepath"
    },
    "2393": {
        "file_id": 255,
        "content": "This code defines a class with properties named after channel names, where the values are their respective channel TIDs. It also includes subchannels as additional properties, each with its own TID.",
        "type": "summary"
    },
    "2394": {
        "file_id": 255,
        "content": "class {{ channelName }}:\n    tid = {{ channelTid }}{% for subChannelName, subChannelTid in subChannels %}\n    {{ subChannelName }} = {{ subChannelTid }}{% endfor %}",
        "type": "code",
        "location": "/tests/bilibili_search_api_modification_section_params_get_related_videos/template.j2:2-4"
    },
    "2395": {
        "file_id": 255,
        "content": "This code defines a class with properties named after channel names, where the values are their respective channel TIDs. It also includes subchannels as additional properties, each with its own TID.",
        "type": "comment"
    },
    "2396": {
        "file_id": 256,
        "content": "/tests/bilibili_search_api_modification_section_params_get_related_videos/searchDataParser.py",
        "type": "filepath"
    },
    "2397": {
        "file_id": 256,
        "content": "The code processes generators, repairs links, detects errors, and extracts links using regular expressions. It also parses video descriptions for BGM detection and author keyword extraction with Jieba segmentation, and updates video information by processing video-related data.",
        "type": "summary"
    },
    "2398": {
        "file_id": 256,
        "content": "import json\nfrom bs4 import BeautifulSoup\nfrom lazero.utils.logger import sprint\ndef generatorToList(generator):\n    return [x for x in generator]\ndef linkFixer(link, prefix=\"http:\"):\n    if link.startswith(\"//\"):\n        return prefix + link\n    return link\ndef traceError(errorMsg: str = \"error!\", _breakpoint: bool = False):\n    import traceback\n    traceback.print_exc()\n    sprint(errorMsg)\n    if _breakpoint:\n        return breakpoint()\ndef extractLinks(description, extract_bgm=True):\n    \"\"\"Extract and remove links in description\"\"\"\n    import re\n    # notice, we don't need to go wild here. we just want the title and the cover, and the tags.\n    expression = r\"http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\\(\\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+\"\n    # expr = re.compile(expression)\n    links = re.findall(expression, description)\n    # if links == None:\n    #     links = []\n    desc_without_link = re.sub(expression, \"\", description)\n    desc_without_link_per_line = [\n        x.replace(\"\\n\", \"\").strip() for x in desc_without_link.split(\"\\n\")",
        "type": "code",
        "location": "/tests/bilibili_search_api_modification_section_params_get_related_videos/searchDataParser.py:1-37"
    },
    "2399": {
        "file_id": 256,
        "content": "The code contains functions for handling generators, fixing links, error tracing, and extracting links from descriptions. It uses regular expressions to find links in the description and removes them while preserving other relevant information like titles and tags.",
        "type": "comment"
    }
}