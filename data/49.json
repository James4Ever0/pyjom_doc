{
    "4900": {
        "file_id": 624,
        "content": "a = \"select * from user\"\nb = \"create (n:person)\"  # cypher # not working!\nfrom javascript import require, globalThis\nchalk = require(\n    \"./cypher_inline.js\"chr\n)  # that might be some drop-in replacement for jinja? should they work together?\n# print(dir(chalk))\n# what the fuck?\nq = chalk.Query # use static method this time?\n# q = chalk.Query(1,2)\nval = q.myfunc(dict(somearg=1)) # this is similar to the original shit.\n# myfunc args: [ { somearg: 1 } ]\n# good?\n# val = chalk.myfunc()\nprint(\"VALUE\", list(val), type(val))  # it can be converted.\nval = q.otherfunc()\n# val = chalk.otherfunc()\nprint(\"VALUE\", val, type(val))  # it can be converted.",
        "type": "code",
        "location": "/tests/neo4j_cypher_builder_template_why_you_suddenly_want_to_create_exceptions_and_find_solutions_to_hot_fix_reloading_and_edit_and_continue/sql_inline.py:1-22"
    },
    "4901": {
        "file_id": 624,
        "content": "The code is attempting to utilize the chalk library for creating SQL queries. It first defines a string \"a\" as a SELECT query and \"b\" as a CREATE query in Cypher format. Then, it imports the required modules from JavaScript and initializes the chalk library using \"./cypher_inline.js\". The code then creates an instance of chalk's Query class (q) and calls its myfunc method with some arguments. Finally, it prints the VALUE and type of both 'a' and 'b'.",
        "type": "comment"
    },
    "4902": {
        "file_id": 625,
        "content": "/tests/neo4j_cypher_builder_template_why_you_suddenly_want_to_create_exceptions_and_find_solutions_to_hot_fix_reloading_and_edit_and_continue/mtest.py",
        "type": "filepath"
    },
    "4903": {
        "file_id": 625,
        "content": "The code defines an exception named \"my exception\" and lists the available attributes and methods for this exception class. It also defines a function named \"shit\" that raises an Exception with the message 'shit' and returns the string \"value\".",
        "type": "summary"
    },
    "4904": {
        "file_id": 625,
        "content": "e = Exception(\"my exception\")\n# print(dir(e))\n# ['__cause__', '__class__', '__context__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__setstate__', '__sizeof__', '__str__', '__subclasshook__', '__suppress_context__', '__traceback__', 'args', 'with_traceback']\ndef shit():\n    raise Exception('shit')\n    return \"value\"",
        "type": "code",
        "location": "/tests/neo4j_cypher_builder_template_why_you_suddenly_want_to_create_exceptions_and_find_solutions_to_hot_fix_reloading_and_edit_and_continue/mtest.py:1-7"
    },
    "4905": {
        "file_id": 625,
        "content": "The code defines an exception named \"my exception\" and lists the available attributes and methods for this exception class. It also defines a function named \"shit\" that raises an Exception with the message 'shit' and returns the string \"value\".",
        "type": "comment"
    },
    "4906": {
        "file_id": 626,
        "content": "/tests/neo4j_cypher_builder_template_why_you_suddenly_want_to_create_exceptions_and_find_solutions_to_hot_fix_reloading_and_edit_and_continue/hy_repl_normal.py",
        "type": "filepath"
    },
    "4907": {
        "file_id": 626,
        "content": "The code imports the HyREPL module from hy.cmdline and initializes an instance of it called \"repl\". It prints a message before running the REPL, then runs the REPL using the repl.run() method. After that, it prints another message after the REPL. The code aims to demonstrate a normal usage of HyREPL.",
        "type": "summary"
    },
    "4908": {
        "file_id": 626,
        "content": "import hy.cmdline\n# this is different. no access to hidden member.\nprint('message before repl')\nrepl = hy.cmdline.HyREPL() # this is not reliable. exit will exit this shit for good.\nrepl.run()\nprint('message after repl')\n# no message after repl?",
        "type": "code",
        "location": "/tests/neo4j_cypher_builder_template_why_you_suddenly_want_to_create_exceptions_and_find_solutions_to_hot_fix_reloading_and_edit_and_continue/hy_repl_normal.py:1-7"
    },
    "4909": {
        "file_id": 626,
        "content": "The code imports the HyREPL module from hy.cmdline and initializes an instance of it called \"repl\". It prints a message before running the REPL, then runs the REPL using the repl.run() method. After that, it prints another message after the REPL. The code aims to demonstrate a normal usage of HyREPL.",
        "type": "comment"
    },
    "4910": {
        "file_id": 627,
        "content": "/tests/neo4j_cypher_builder_template_why_you_suddenly_want_to_create_exceptions_and_find_solutions_to_hot_fix_reloading_and_edit_and_continue/cypher_inline.js",
        "type": "filepath"
    },
    "4911": {
        "file_id": 627,
        "content": "This code defines two functions for creating SQL statements and a Query class with unclear inline function usage, potentially due to JavaScript's inconsistent behavior. It also logs undefined variables to the console.",
        "type": "summary"
    },
    "4912": {
        "file_id": 627,
        "content": "// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals\n// official javascript driver\n// https://neo4j.com/developer/javascript/\nvar cypher = function(strArray, ...opts) { // this is bad.\n    console.log('input:', strArray, opts) // here we've got the thing.\n    // passed here. good.\n    // this will be good.\n    // suppose we put string, object into this thing.\n    // suppose we quote the thing.\n    return strArray;\n}\nvar sql = function(str) { return str; }\nvar myexpression = {obj:2}; // not supplied to cypher?\n// create (n)-[:married]->(r) [object Object]\n// wtf?\nvar myexpression2 = '3';\nvar b = `create (n)-[:married]->(r) ${myexpression}`\nconsole.log(b) // create (n)-[:married]->(r) 2\n    // this will format the thing.\nvar a = cypher `create (n:person{name:${myexpression}})-[:married]->(r) ${myexpression2}`; // well that's good.\nconsole.log(a);\nconst query = sql `SELECT * FROM users`;\nconsole.log(query);\n// function otherfunc(){\n//     console.log('calling otherfunc')\n//     return 'other func'",
        "type": "code",
        "location": "/tests/neo4j_cypher_builder_template_why_you_suddenly_want_to_create_exceptions_and_find_solutions_to_hot_fix_reloading_and_edit_and_continue/cypher_inline.js:2-28"
    },
    "4913": {
        "file_id": 627,
        "content": "The code defines two functions, `cypher` and `sql`, which create SQL statements using template literals. The `cypher` function takes a string array and optional parameters, while the `sql` function only takes a single string parameter. The code demonstrates how to use these functions by creating a Cypher query with placeholders for dynamic values and executing a SELECT query.",
        "type": "comment"
    },
    "4914": {
        "file_id": 627,
        "content": "// }\n// function myfunc() {\n//     otherfunc()\n//     return query;\n// }\n// // __export__\n// // console.log(module.loaded) // false\n// // export all functions?\n// module.exports = {otherfunc, myfunc} // also some bloated shit.\n// which one you want? damn...\n// you want some object?\n// what if they are interdependent?\n// this is some other strange shit.\n// exports = {\n//         otherfunc: () => {\n//             console.log('calling otherfunc');\n//             return 'otherfunc'\n//         },\n//         myfunc: () => {\n//             exports.otherfunc() // strange shit.\n//             return query;\n//         }\n//     }\n//     // console.log(module)\n// module.exports = exports // must use this to export things.\n// this is self-reference.\nclass Query {\n    constructor(a, b) {\n        this.a = a\n        this.b = b\n    }\n    static otherfunc() {\n        // otherfunc() {\n        console.log('calling otherfunc');\n        return 'otherfunc'\n    }\n    static myfunc(...args) {\n        // static myfunc() {\n            console.log('myfunc args:',args)",
        "type": "code",
        "location": "/tests/neo4j_cypher_builder_template_why_you_suddenly_want_to_create_exceptions_and_find_solutions_to_hot_fix_reloading_and_edit_and_continue/cypher_inline.js:29-71"
    },
    "4915": {
        "file_id": 627,
        "content": "The code defines a class \"Query\" with two static methods: \"otherfunc\" and \"myfunc\". \"otherfunc\" is called within \"myfunc\", creating an interdependence between the two functions. The code exports the entire class, using self-reference for the static methods.",
        "type": "comment"
    },
    "4916": {
        "file_id": 627,
        "content": "        Query.otherfunc() // strange shit.\n            // this.otherfunc() // still working for static functions.\n            // javascript is a beast.\n        return query;\n    }\n}\nmodule.exports = { Query }\n    // console.log(.cypher)\n    // console.log('QUERY?',globalThis.Query, this.sql) // all undefinded.",
        "type": "code",
        "location": "/tests/neo4j_cypher_builder_template_why_you_suddenly_want_to_create_exceptions_and_find_solutions_to_hot_fix_reloading_and_edit_and_continue/cypher_inline.js:72-80"
    },
    "4917": {
        "file_id": 627,
        "content": "This code defines a Query class with a strange inline function call and exports it. The otherfunc() is called inside the Query class, but its purpose is unclear. JavaScript's behavior for static functions versus instance methods seems inconsistent here. The code also logs variables to the console, but they are all undefined.",
        "type": "comment"
    },
    "4918": {
        "file_id": 628,
        "content": "/tests/neo4j_cypher_builder_template_why_you_suddenly_want_to_create_exceptions_and_find_solutions_to_hot_fix_reloading_and_edit_and_continue/babel_decorator.js",
        "type": "filepath"
    },
    "4919": {
        "file_id": 628,
        "content": "This code defines a decorator function using Babel's plugin for JavaScript syntax decorators. It wraps a function, logs the arguments passed to it, and then calls the original function. The decorated function, `myfunc`, is called with 'myval', and its return value is logged to the console.",
        "type": "summary"
    },
    "4920": {
        "file_id": 628,
        "content": "// require(\"@babel/core\").transformSync(\"code\", {\n//     plugins: [\"@babel/plugin-syntax-decorators\"]\n//   });\nfunction dec(func){\n    function innerfunc(...args){\n        console.log('calling func with args:', args)\n        func(...args)\n    }\n    return innerfunc\n}\n@dec\nfunction myfunc(val){\n    return val\n}\nval = myfunc('myval')\nconsole.log('val:', val)",
        "type": "code",
        "location": "/tests/neo4j_cypher_builder_template_why_you_suddenly_want_to_create_exceptions_and_find_solutions_to_hot_fix_reloading_and_edit_and_continue/babel_decorator.js:2-19"
    },
    "4921": {
        "file_id": 628,
        "content": "This code defines a decorator function using Babel's plugin for JavaScript syntax decorators. It wraps a function, logs the arguments passed to it, and then calls the original function. The decorated function, `myfunc`, is called with 'myval', and its return value is logged to the console.",
        "type": "comment"
    },
    "4922": {
        "file_id": 629,
        "content": "/tests/neo4j_cypher_builder_template_why_you_suddenly_want_to_create_exceptions_and_find_solutions_to_hot_fix_reloading_and_edit_and_continue/my_module/some_module.py",
        "type": "filepath"
    },
    "4923": {
        "file_id": 629,
        "content": "The code defines a function 'program' within the module 'some_module' that raises an exception. If the file is run directly, it enters a loop that attempts to execute the 'program' function repeatedly, reloading the module after each failure in order to hot fix issues and apply edits while continuing execution.",
        "type": "summary"
    },
    "4924": {
        "file_id": 629,
        "content": "# inside some_module.py\ndef program():\n    raise Exception(\"Exception in program\")\n    # return \"VALUE\"\nif __name__ == \"__main__\":\n    while True:\n        try:\n            import some_module # will it even succeed? doubt this.\n            val = some_module.program()\n            print(\"returned value:\", val)\n            break\n        except:\n            import traceback\n            traceback.print_exc()\n            input('are you done yet?')\n            import importlib\n            importlib.reload(some_module)",
        "type": "code",
        "location": "/tests/neo4j_cypher_builder_template_why_you_suddenly_want_to_create_exceptions_and_find_solutions_to_hot_fix_reloading_and_edit_and_continue/my_module/some_module.py:1-19"
    },
    "4925": {
        "file_id": 629,
        "content": "The code defines a function 'program' within the module 'some_module' that raises an exception. If the file is run directly, it enters a loop that attempts to execute the 'program' function repeatedly, reloading the module after each failure in order to hot fix issues and apply edits while continuing execution.",
        "type": "comment"
    },
    "4926": {
        "file_id": 630,
        "content": "/tests/qq_go_cqhttp/launch.sh",
        "type": "filepath"
    },
    "4927": {
        "file_id": 630,
        "content": "The code changes the directory to \"go-cqhttp\" and executes the \"go-cqhttp\" script, which likely starts the CQHTTP bot.",
        "type": "summary"
    },
    "4928": {
        "file_id": 630,
        "content": "cd go-cqhttp\n./go-cqhttp",
        "type": "code",
        "location": "/tests/qq_go_cqhttp/launch.sh:1-2"
    },
    "4929": {
        "file_id": 630,
        "content": "The code changes the directory to \"go-cqhttp\" and executes the \"go-cqhttp\" script, which likely starts the CQHTTP bot.",
        "type": "comment"
    },
    "4930": {
        "file_id": 631,
        "content": "/tests/qq_go_cqhttp/build.sh",
        "type": "filepath"
    },
    "4931": {
        "file_id": 631,
        "content": "This code navigates to the \"go-cqhttp\" directory and compiles it using the Go language's 'build' command.",
        "type": "summary"
    },
    "4932": {
        "file_id": 631,
        "content": "cd go-cqhttp\ngo build",
        "type": "code",
        "location": "/tests/qq_go_cqhttp/build.sh:1-2"
    },
    "4933": {
        "file_id": 631,
        "content": "This code navigates to the \"go-cqhttp\" directory and compiles it using the Go language's 'build' command.",
        "type": "comment"
    },
    "4934": {
        "file_id": 632,
        "content": "/tests/qq_go_cqhttp/tests/download_group_files.py",
        "type": "filepath"
    },
    "4935": {
        "file_id": 632,
        "content": "The code connects to a local server, retrieves status, and handles errors. It provides functions for downloading QQ group files and directories using different APIs, handling subfolders recursively, and checking for existing files. The `group_file_wholesale_downloader` function is used to download group files to a specific path, running in a loop for each group ID with optional retry and sleep mechanisms.",
        "type": "summary"
    },
    "4936": {
        "file_id": 632,
        "content": "import pathlib\nimport os\nimport requests\n# again 0.0.0.0 not avaliable. must be localhost.\nbaseurl = \"http://localhost:5700/\"\n# go-cqhttp client does not support adding friends, searching groups or something! test if we can login opqbot and this shit at the same time!\n# it is working but unable to know if it is going to kill me.\nimport time\ndef check_connection():\n    while True:\n        try:\n            response = requests.get(baseurl+\"get_status\", timeout=5)\n            response_json = response.json()\n            print(\"GO_CQHTTP STATUS:\", response_json)\n            data_json = response_json[\"data\"]\n            assert data_json[\"online\"] == True\n            print(\"connection ok\")\n            break\n        except:\n            import traceback\n            traceback.print_exc()\n            print(\"Connection error.\")\n            time.sleep(3)\ndef get_url(api):\n    assert not api.startswith(\"/\")\n    return baseurl+api\ndef ensure_dir(download_path):\n    if not os.path.exists(download_path):\n        os.mkdir(download_path)",
        "type": "code",
        "location": "/tests/qq_go_cqhttp/tests/download_group_files.py:1-34"
    },
    "4937": {
        "file_id": 632,
        "content": "This code checks the connection to a local server, retrieves and prints the status, handles errors by retrying, and provides a function for generating full URLs. It seems related to testing or managing a program that interacts with CQHTTP, a third-party service.",
        "type": "comment"
    },
    "4938": {
        "file_id": 632,
        "content": "# api = \"get_group_file_system_info\"\ndef get_group_file(group_id, file_id, busid):\n    api = \"get_group_file_url\"\n    url = get_url(api)\n    params = {\"group_id\": group_id, \"file_id\": file_id, \"busid\": busid}\n    r = requests.get(url, params=params)\n    # print(r.content)\n    content = r.json()\n    data = content[\"data\"]\n    if data!=None:\n        download_url = data[\"url\"]\n        print(\"DOWNLOAD URL:\", download_url)\n        return download_url\ndef try_pass(function):\n    try:\n        function()\n    except:\n        pass\ndef downloader(url, filepath, skip_exist=True):\n    lock = filepath+\".lock\"\n    # check lock related operations.\n    if os.path.exists(lock):\n        try_pass(lambda: os.remove(lock))\n        try_pass(lambda: os.remove(filepath))\n    # do skip if flag \"skip_exists\" is set.\n    if skip_exist:\n        if os.path.exists(filepath):\n            return  # no overwritting existing files.\n    # download command\n    cmd = 'curl -L -o \"{}\" \"{}\"'.format(filepath, url)\n    # download main logic\n    # touch lock first.",
        "type": "code",
        "location": "/tests/qq_go_cqhttp/tests/download_group_files.py:36-77"
    },
    "4939": {
        "file_id": 632,
        "content": "This code defines a function for getting group file URLs, downloading files using curl, and includes optional checks for existing files and locking mechanisms.",
        "type": "comment"
    },
    "4940": {
        "file_id": 632,
        "content": "    pathlib.Path(lock).touch()\n    os.system(cmd)\n    try_pass(lambda: os.remove(lock))\ndef recursive_get_qq_group_files(api, group_id, basepath=None, folder_id=None, download_path=\"qq_group_file_download\"):\n    ensure_dir(download_path)\n    if basepath is None:\n        basepath = os.path.join(download_path, str(group_id))\n    ensure_dir(basepath)\n    if api == \"get_group_root_files\":\n        params = {\"group_id\": group_id}  # integer for group id\n    elif api == \"get_group_files_by_folder\":\n        # integer for group id\n        params = {\"group_id\": group_id, \"folder_id\": folder_id}\n    else:\n        raise Exception(\"Unknown recursive_get_qq_group_files api\", api)\n    url = get_url(api)\n    r = requests.get(url, params=params)\n# r = requests.get(url)\n    content = r.json()\n    # print(content)\n    # breakpoint()\n    data = content[\"data\"]\n    base_files = data[\"files\"]\n    base_folders = data[\"folders\"]  # may walk recursively.\n    base_files = [] if base_files == None else base_files\n    base_folders = [] if base_folders == None else base_folders",
        "type": "code",
        "location": "/tests/qq_go_cqhttp/tests/download_group_files.py:78-109"
    },
    "4941": {
        "file_id": 632,
        "content": "Creates a directory for group files based on the group ID, downloads QQ group files recursively and handles different APIs.",
        "type": "comment"
    },
    "4942": {
        "file_id": 632,
        "content": "    # print(base_files)\n    for bfile in base_files:\n        file_id = bfile[\"file_id\"]  # prefixed with /, no need to check?\n        # any expired files present? may cause download errors?\n        file_name = bfile[\"file_name\"]\n        busid = bfile[\"busid\"]\n        download_url = get_group_file(group_id, file_id, busid)\n        if download_url == None: continue\n        filepath = os.path.join(basepath, file_name)\n        print(\"FILEPATH:\", filepath)\n        yield download_url, filepath\n        # download those base files!\n    for bfolder in base_folders:\n        # we have group_id though.\n        folder_id = bfolder[\"folder_id\"]\n        folder_name = bfolder[\"folder_name\"]\n        new_basepath = os.path.join(basepath, folder_name)\n        for download_url, filepath in recursive_get_qq_group_files(\"get_group_files_by_folder\", group_id, basepath=new_basepath, folder_id=folder_id):\n            yield download_url, filepath\n        # all the same logic.\n        # now do recursive folder search.\n    # how to download these shits? curl?",
        "type": "code",
        "location": "/tests/qq_go_cqhttp/tests/download_group_files.py:111-134"
    },
    "4943": {
        "file_id": 632,
        "content": "This code downloads group files and folders from QQ group. It first retrieves base files by iterating through the base_files list, using get_group_file to obtain the download URL for each file and storing it in the filepath. Then, it recursively downloads files within specified folders using recursive_get_qq_group_files function. This code uses os.path.join to construct file paths and continues if a download URL is None.",
        "type": "comment"
    },
    "4944": {
        "file_id": 632,
        "content": "def group_file_wholesale_downloader(group_id, download_path=\"qq_group_file_download\", skip_exist=True):\n    for download_url, filepath in recursive_get_qq_group_files(\"get_group_root_files\", group_id, download_path=download_path):\n        downloader(download_url, filepath, skip_exist=skip_exist)\n# group_id = 927825838 # more files but no base_files.\n# group_id = 537384511 # less files but have base_files\n# make it dynamic!\ndownload_path = \"/root/Desktop/works/pyjom/tests/wechat_bots/msimg32.dll_wechat_hook_webapi/official_qq_group_files\"\ngroup_ids = [927825838, 537384511] # i know i am in these groups.\n#  import time\ncheck_connection() # failsafe or not?\nfor group_id in group_ids:\n    #  while True:\n        #  try:\n    group_file_wholesale_downloader(group_id, download_path=download_path, skip_exist=True)\n    #  break\n        #  except: time.sleep(10) # auto retry.\n        # there is no need for any failsafes. maybe we are outside the groups.\n# already downloaded. waiting for updates?",
        "type": "code",
        "location": "/tests/qq_go_cqhttp/tests/download_group_files.py:137-159"
    },
    "4945": {
        "file_id": 632,
        "content": "The code defines a function `group_file_wholesale_downloader` that downloads QQ group files for specified group IDs to a specific path. It uses recursive calls to `recursive_get_qq_group_files` and `downloader` functions. The provided example group IDs (927825838, 537384511) are used with the download path \"/root/Desktop/works/pyjom/tests/wechat_bots/msimg32.dll_wechat_hook_webapi/official_qq_group_files\". The code runs this function in a loop for each group ID, potentially with retry and sleep mechanisms if needed.",
        "type": "comment"
    },
    "4946": {
        "file_id": 633,
        "content": "/tests/random_giphy_gifs/test_sdk.js",
        "type": "filepath"
    },
    "4947": {
        "file_id": 633,
        "content": "The code imports libraries, initializes the GiphyFetch API, defines a function to write JSON data, and tests various API functions such as trending gifs, searching for dog-related gifs, retrieving related gifs, listing categories, and searching with keywords. The results are saved in separate JSON files.",
        "type": "summary"
    },
    "4948": {
        "file_id": 633,
        "content": "// Require with custom API key\n// const myBetaApiKey = 'IoJVsWoxDPKBr6gOcCgOPWAB25773hqP';\nconst myBetaApiKey = \"Gc7131jiJuvI7IdN0HZ1D7nh0ow5BU6g\"; // some common web browser based things.\n// maybe they just don't distinguish api and sdk keys. fuck.\n// sXpGFDGZs0Dv1mmNFvYaGUvYwKX0PWIh\n// is this key limited? or is it production ready?\nconst fetch = require('node-fetch');\nconst fs = require(\"fs\");\nconst JsonFormat = require(\"json-format\")\nconst { GiphyFetch } = require('@giphy/js-fetch-api')\nconst gf = new GiphyFetch(myBetaApiKey)\n// fetch 10 gifs\nfunction writeJsonToFile(json, filename) {\n    // let data = JSON.stringify(json);\n    let data = JsonFormat(json)\n    fs.writeFile(filename, data, function(err) {\n        if (err) {\n            console.error(err);\n        } else {\n            console.log(filename + \" has been saved with the json data\");\n        }\n    });\n}\n// console.log(data)\n// https://bobbyhadz.com/blog/javascript-error-err-require-esm-of-es-module-node-fetch\n// fucking hell?\n// data.then((result) =>{console.log('TRENDING OUTPUT');",
        "type": "code",
        "location": "/tests/random_giphy_gifs/test_sdk.js:1-35"
    },
    "4949": {
        "file_id": 633,
        "content": "Code imports necessary libraries and initializes the GiphyFetch API with a custom key. It defines a function to write JSON data to a file, and then fetches 10 trending gifs using the API.",
        "type": "comment"
    },
    "4950": {
        "file_id": 633,
        "content": "// writeJsonToFile(result, 'trending.json')\n// })\nasync function test(){\n// var data = await gf.trending({ limit: 10 }) // a promise\n// search for related things dog related things.\n// await writeJsonToFile(data,'trending.json')\n// var data = await gf.search('dog cute', { sort: 'relevant', rating: 'g'});\n// await writeJsonToFile(data,'cute_dog.json')\n// var relatedId = \"QvBoMEcQ7DQXK\"\n// var data = await gf.related(relatedId, { limit: 50 })\n// await writeJsonToFile(data,'related.json')\n// const data = await gf.categories() // category are actually keywords here.\n// // data.forEach((category) => {\n// //     console.log(category) // ICategory\n// // })\n// await writeJsonToFile(data,'categories.json')\n// var data = await gf.gifs('animals','bulldog') // not freaking found!\nvar data = await gf.gifs('animals','samoyed') // freaking works! guess it is just keyword based search\nawait writeJsonToFile(data, 'samoyed_subcategory2.json')\n}\ntest()",
        "type": "code",
        "location": "/tests/random_giphy_gifs/test_sdk.js:36-61"
    },
    "4951": {
        "file_id": 633,
        "content": "This code tests various Giphy API functions. It fetches trending gifs, searches for dog-related gifs, retrieves related gifs, lists available categories, and searches for gifs using different keywords. The test results are saved in separate JSON files.",
        "type": "comment"
    },
    "4952": {
        "file_id": 634,
        "content": "/tests/random_giphy_gifs/test_api.js",
        "type": "filepath"
    },
    "4953": {
        "file_id": 634,
        "content": "This code uses 'giphy-api', 'json-format', and 'fs' modules to search for \"pokemon\" and \"dog funny\" GIFs, checking duration and saving results as JSON files. Error logging and 'writeJsonToFile' function are included.",
        "type": "summary"
    },
    "4954": {
        "file_id": 634,
        "content": "// Require with custom API key\n// const myBetaApiKey = 'IoJVsWoxDPKBr6gOcCgOPWAB25773hqP';\nconst myBetaApiKey = \"Gc7131jiJuvI7IdN0HZ1D7nh0ow5BU6g\"; // some common web browser based things.\n// can we prepare some key server? i don't know. wtf is this shit?\nvar giphy = require('giphy-api')(myBetaApiKey);\nconst JsonFormat = require(\"json-format\")\nconst fs = require(\"fs\");\nfunction writeJsonToFile(json, filename) {\n    // let data = JSON.stringify(json);\n    let data = JsonFormat(json)\n    fs.writeFile(filename, data, function(err) {\n        if (err) {\n            console.error(err);\n        } else {\n            console.log(filename + \" has been saved with the json data\");\n        }\n    });\n}\n// // Require with the public beta key\n// var giphy = require('giphy-api')(); // banned. cannot use this public api.\n// it may timeout!\n// giphy.search({\n//     q: 'pokemon',\n//     rating: 'g'\n// }, function(err, res) {\n//     // Res contains gif data!\n//     console.log('ERROR?', err); //null if normal.\n//     // save it to json?",
        "type": "code",
        "location": "/tests/random_giphy_gifs/test_api.js:1-31"
    },
    "4955": {
        "file_id": 634,
        "content": "Code snippet requires the 'giphy-api', 'json-format', and 'fs' modules. It defines a function 'writeJsonToFile' to write JSON data to file. The API key is set for a custom Giphy API, and it mentions a public API key that is currently banned. The code then searches for GIFs related to \"pokemon\" with a \"g\" rating, and plans to save the results as JSON to a file.",
        "type": "comment"
    },
    "4956": {
        "file_id": 634,
        "content": "//     writeJsonToFile(res, 'pokemon_test.json');\n// });   \n//     // save it to json?\n//     writeJsonToFile(res, 'pokemon_test.json');\n// });\n// giphy.search({\n//     q: 'pokemon',\n//     rating: 'y'\n// }, function(err, res) {\n//     // Res contains gif data!\n//     console.log('ERROR?', err); //null if normal.\n//     // save it to json?\n//     writeJsonToFile(res, 'pokemon_test_youth.json');\n// });\n// question: is that still image?\n// check the duration bro. filter out those ridiculusly short ones.\n// Input £0, gif, from 'still_gif_image.gif':\n// Duration: 00:00:00.84, start: 0.000000, bitrate: 635 kb/s\n// Stream £0:0: Video: gif, bgra, 300x200, 19.42 fps, 25 tbr, 100 tbn\n// giphy.random({\n//     tag: 'dog funny',\n//     rating: 'g',\n//     fmt: 'json',\n// }, function (err, res) {\n//     console.log('ERROR?', err); //null if normal.\n//     // save it to json?\n//     writeJsonToFile(res, 'funny_dog_test.json');\n// });\ngiphy.id('feqkVgjJpYtjy', function (err, res) { // only one reply. there are no other fancy shits.",
        "type": "code",
        "location": "/tests/random_giphy_gifs/test_api.js:32-64"
    },
    "4957": {
        "file_id": 634,
        "content": "This code is making API requests to Giphy, retrieving gifs based on different search criteria (pokemon and dog funny), and then saving the returned data as JSON files. It also checks the duration of the gif to filter out extremely short ones. The 'writeJsonToFile' function is used to save the gif data as JSON.",
        "type": "comment"
    },
    "4958": {
        "file_id": 634,
        "content": "    console.log('ERROR?', err); //null if normal.\n    // save it to json?\n    writeJsonToFile(res, 'id_search2.json');\n});",
        "type": "code",
        "location": "/tests/random_giphy_gifs/test_api.js:65-68"
    },
    "4959": {
        "file_id": 634,
        "content": "This code logs an error message if there is an error, and then saves the response to a JSON file named 'id_search2.json' using the writeJsonToFile function.",
        "type": "comment"
    },
    "4960": {
        "file_id": 635,
        "content": "/tests/random_giphy_gifs/README.md",
        "type": "filepath"
    },
    "4961": {
        "file_id": 635,
        "content": "The code provides Giphy API keys and usage information, defining global variables for authentication and access to GIPHY's APIs, including public and sdk keys. Links to GitHub repositories guide users on implementation.",
        "type": "summary"
    },
    "4962": {
        "file_id": 635,
        "content": "# random giphy gifs\ngiphy has many extensible apis. i guess most media platforms are all the same (complex enough), but we have to start somewhere though...\ngiphy has 'clips' now. clips are gifs with sound, just like short videos.\nbeta key limitations:\n1000 requests per day, 42 requests per hour\nor just use the public beta key? does that subject to the rate limit?\n```javascript\nvar PUBLIC_BETA_API_KEY = 'dc6zaTOxFJmzC';\n```\napi keys:\nIoJVsWoxDPKBr6gOcCgOPWAB25773hqP\nlTRWAEGHjB1AkfO0sk2XTdujaPB5aH7X\nsdk keys:\n6esYBEm9OG3wAifbBFZ2mA0Ml6Ic0rvy\nto use api:\nhttps://github.com/austinkelleher/giphy-api\nto use sdk:\nhttps://github.com/Giphy/giphy-js/blob/master/packages/fetch-api/README.md\nfind public api keys inside html:\n```javascript\n          window.GIPHY_FE_MOBILE_API_KEY = \"L8eXbxrbPETZxlvgXN9kIEzQ55Df04v0\"\n          window.GIPHY_FE_WEB_API_KEY = \"Gc7131jiJuvI7IdN0HZ1D7nh0ow5BU6g\"\n          window.GIPHY_FE_FOUR_O_FOUR_API_KEY = \"MRwXFtxAnaHo3EUMrSefHWmI0eYz5aGe\"\n          window.GIPHY_FE_STORIES_AND_GIPHY_TV_API_KEY = \"3eFQvabDx69SMoOemSPiYfh9FY0nzO9x\"",
        "type": "code",
        "location": "/tests/random_giphy_gifs/README.md:1-34"
    },
    "4963": {
        "file_id": 635,
        "content": "This code snippet provides information about Giphy APIs, their usage, and API keys. The PUBLIC_BETA_API_KEY is defined in JavaScript, and there are various public and sdk keys listed for using the Giphy APIs. Links to GitHub repositories are provided for guidance on how to use them, and four public API keys found inside HTML elements are also mentioned.",
        "type": "comment"
    },
    "4964": {
        "file_id": 635,
        "content": "          window.GIPHY_FE_DEFAULT_API_SERVICE_KEY = \"5nt3fDeGakBKzV6lHtRM1zmEBAs6dsIc\"\n          window.GIPHY_FE_GET_POST_HEADERS_KEY = \"e0771ed7b244ec9c942bea646ad08e6bf514f51a\"\n          window.GIPHY_FE_MEDIUM_BLOG_API_KEY = \"i3dev0tcpgvcuaocfmdslony2q9er7tvfndxcszm\"\n          window.GIPHY_FE_EMBED_KEY = \"eDs1NYmCVgdHvI1x0nitWd5ClhDWMpRE\"\n```\nsearch for 'ear flops' to locate the tags in 'samoyed.html'",
        "type": "code",
        "location": "/tests/random_giphy_gifs/README.md:35-41"
    },
    "4965": {
        "file_id": 635,
        "content": "This code sets the GIPHY API service key, get headers key, medium blog API key, and embed key as global variables in the window object. These keys are used to authenticate and access GIPHY's APIs for fetching gifs and related content.",
        "type": "comment"
    },
    "4966": {
        "file_id": 636,
        "content": "/tests/random_giphy_gifs/nodejs_server.js",
        "type": "filepath"
    },
    "4967": {
        "file_id": 636,
        "content": "This Node.js server code handles Giphy API requests, provides error-handling functions for processing elements and retrieving GIFs, and serves responses while listening on port 8902.",
        "type": "summary"
    },
    "4968": {
        "file_id": 636,
        "content": "const http = require('http');\n// const url = require('url');\nconst { GiphyFetch } = require('@giphy/js-fetch-api');\nconst GiphyApi = require('giphy-api');\nfunction randomAPIKey() {\n    webApiKeys = [\"L8eXbxrbPETZxlvgXN9kIEzQ55Df04v0\", \"Gc7131jiJuvI7IdN0HZ1D7nh0ow5BU6g\", \"MRwXFtxAnaHo3EUMrSefHWmI0eYz5aGe\", \"3eFQvabDx69SMoOemSPiYfh9FY0nzO9x\", \"5nt3fDeGakBKzV6lHtRM1zmEBAs6dsIc\", \"eDs1NYmCVgdHvI1x0nitWd5ClhDWMpRE\"]\n    publicSdkKeys = [\"Gc7131jiJuvI7IdN0HZ1D7nh0ow5BU6g\"]\n    apiKeys = ['IoJVsWoxDPKBr6gOcCgOPWAB25773hqP', 'lTRWAEGHjB1AkfO0sk2XTdujaPB5aH7X']\n    sdkKeys = ['6esYBEm9OG3wAifbBFZ2mA0Ml6Ic0rvy', 'sXpGFDGZs0Dv1mmNFvYaGUvYwKX0PWIh']\n    items = webApiKeys.concat(publicSdkKeys).concat(apiKeys).concat(sdkKeys)\n        // deleted some unqualified api keys because they look different in length\n    item = items[Math.floor(Math.random() * items.length)];\n    console.log(\"using api key: \" + item)\n    return item\n}\nfunction randInt(start, end) {\n    if (start > end) {\n        medium = end\n        end = start",
        "type": "code",
        "location": "/tests/random_giphy_gifs/nodejs_server.js:1-22"
    },
    "4969": {
        "file_id": 636,
        "content": "Code snippet defines two functions:\n1. `randomAPIKey()` - generates a random API key from provided arrays of keys, logs the chosen key, and returns it.\n2. `randInt(start, end)` - takes a start and an end number, if start is greater than end, swaps them internally and returns a random integer between the two numbers.",
        "type": "comment"
    },
    "4970": {
        "file_id": 636,
        "content": "        start = medium\n    } else if (start == end) {\n        return Math.floor(start)\n    }\n    return Math.floor(Math.random() * (end - start) + start)\n}\nfunction processElemUncatched(elem, typeFilter) {\n    if ('type' in elem) {\n        dataType = elem['type']\n        if (typeFilter.indexOf(dataType) == -1) {\n            dataId = elem['id']\n            dataUrl = elem['url']\n            title = elem['title']\n            original = elem['images']['original']\n            height = original['height']\n            width = original['width']\n            url = original['url']\n            newElem = {\n                id: dataId,\n                url: dataUrl,\n                title: title,\n                media: { height: height, width: width, url: url }\n            }\n            return newElem\n        }\n    } else {\n        console.log(\"some weird data/element encountered. please check.\")\n        console.log(elem)\n    }\n    return null\n}\nfunction processElem(elem, typeFilter) {\n    try {\n        result = processElemUncatched(elem, typeFilter)",
        "type": "code",
        "location": "/tests/random_giphy_gifs/nodejs_server.js:23-59"
    },
    "4971": {
        "file_id": 636,
        "content": "The code contains a function `processElemUncatched` that processes elements with specific data types and filters, and returns an object containing id, url, title, and media (height, width, url). If the element does not have the required attributes or type does not match the filter, it logs a warning message and returns null. The main function `processElem` calls `processElemUncatched` and handles any potential errors with a try-catch block.",
        "type": "comment"
    },
    "4972": {
        "file_id": 636,
        "content": "        return result\n    } catch (e) {\n        console.log(e)\n        console.log(\"______________________ELEMENT______________________\")\n        console.log(elem)\n        console.log(\"______________________ELEMENT______________________\")\n        console.log(\"error while processing element\")\n        return null;\n    }\n}\nfunction getResultParsed(result, typeFilter) {\n    filteredResult = []\n    if ('data' in result) {\n        data = result['data']\n        if (Array.isArray(data)) {\n            for (elem of data) {\n                newElem = processElem(elem, typeFilter)\n                if (newElem != null) {\n                    filteredResult.push(newElem)\n                }\n            }\n        } else {\n            newElem = processElem(data, typeFilter)\n            if (newElem != null) {\n                filteredResult.push(newElem)\n            }\n        }\n    }\n    finalResult = {data:filteredResult}\n    if ('pagination' in result){\n        finalResult.pagination = result.pagination\n    }\n    return JSON.stringify(finalResult)",
        "type": "code",
        "location": "/tests/random_giphy_gifs/nodejs_server.js:60-93"
    },
    "4973": {
        "file_id": 636,
        "content": "This function returns the result after processing it. If an error occurs, it logs the error and returns null. The getResultParsed function filters data based on typeFilter, creating a new array called filteredResult. If the result has pagination information, it adds that to the finalResult object before returning it as a JSON string.",
        "type": "comment"
    },
    "4974": {
        "file_id": 636,
        "content": "}\nfunction getGF() {\n    return new GiphyFetch(randomAPIKey())\n}\nfunction getApi() {\n    return GiphyApi(randomAPIKey())\n}\nasync function getRandomGif(keywords, type, callback) {\n    try {\n        result = await getGF().random({ tag: keywords, type: type })\n        callback(result)\n    } catch (e) {\n        console.log(e)\n        console.log(\"error when calling getRandomGif\")\n        callback([])\n    }\n}\nfunction getRandomGifs(keywords, rating, callback) {\n    getApi().random({ tag: keywords, rating: rating, fmt: 'json' }, function(err, result) {\n        console.log('ERROR?', err); //null if normal.\n        if (err != null) {\n            callback([]);\n        } else {\n            callback(result)\n        }\n    })\n}\nasync function getSearchGifs(keywords, sort, limit, offset, type, rating, lang, callback) {\n    // sort in 'recent', 'relevant'\n    try {\n        result = await getGF().search(keywords, { sort: sort, limit: limit, offset: offset, type: type, rating: rating, lang: lang })\n        callback(result)\n    } catch (e) {",
        "type": "code",
        "location": "/tests/random_giphy_gifs/nodejs_server.js:94-130"
    },
    "4975": {
        "file_id": 636,
        "content": "This code provides functions to fetch random and search gifs from Giphy API using Node.js server. It handles potential errors and returns results to the callback function. The getGF, getApi, getRandomGif, getRandomGifs, and getSearchGifs are functions for interacting with Giphy API to retrieve various types of gifs.",
        "type": "comment"
    },
    "4976": {
        "file_id": 636,
        "content": "        console.log(e)\n        console.log(\"error when calling getSearchGifs\")\n        callback([])\n    }\n}\nasync function getRelatedGifs(keywords, limit, offset, type, callback) {\n    // sort in 'recent', 'relevant'\n    try {\n        result = await getGF().related(keywords, { limit: limit, offset: offset, type: type })\n        callback(result)\n    } catch (e) {\n        console.log(e)\n        console.log(\"error when calling getRelatedGifs\")\n        callback([])\n    }\n}\nasync function getTrendingGifs(limit, offset, type, rating, callback) {\n    // sort in 'recent', 'relevant'\n    try {\n        result = await getGF().trending({ limit: limit, offset: offset, type: type, rating: rating })\n        callback(result)\n    } catch (e) {\n        console.log(e)\n        console.log(\"error when calling getTrendingGifs\")\n        callback([])\n    }\n}\nfunction getQueryParams(reqUrl) {\n    current_url = new URL('http://localhost' + reqUrl)\n    params = current_url.searchParams\n    console.log('query parameters:', params)\n    return params",
        "type": "code",
        "location": "/tests/random_giphy_gifs/nodejs_server.js:131-164"
    },
    "4977": {
        "file_id": 636,
        "content": "This code defines three functions: `getSearchGifs`, `getRelatedGifs`, and `getTrendingGifs`. These functions use the GIPHY API to retrieve gifs based on different criteria. In case of errors, the functions log an error message and return an empty array. The `getQueryParams` function retrieves the query parameters from a URL.",
        "type": "comment"
    },
    "4978": {
        "file_id": 636,
        "content": "}\nconst typeArray = ['gifs', 'text', 'videos', 'stickers']\nconst ratingArray = ['y', 'g', 'pg', 'pg-13', 'r']\nconst sortArray = ['recent', 'relevant']\nconst langArray = [\"en\", \"es\", \"pt\", \"id\", \"fr\", \"ar\", \"tr\", \"th\", \"vi\", \"de\", \"it\", \"ja\", \"zh-CN\", \"zh-TW\", \"ru\", \"ko\", \"pl\", \"nl\", \"ro\", \"hu\", \"sv\", \"cs\", \"hi\", \"bn\", \"da\", \"fa\", \"tl\", \"fi\", \"he\", \"ms\", \"no\", \"uk\"]\nconst limitArray = [...Array(101).keys()].slice(20)\nconst offsetArray = [...Array(20000).keys()]\nfunction fallbackDefault(params, tag, valid, defaultParam) {\n    param = params.get(tag)\n    if (typeof(defaultParam) == 'number') {\n        param = parseFloat(param)\n    }\n    if (valid.indexOf(param) == -1) {\n        // type = 'gifs'\n        console.log(tag + \" undefined. falling back to default: \" + defaultParam)\n        return defaultParam\n    }\n    return param\n}\nconst validEntries = ['/random', '/related', '/trending', '/search']\nconst requestListener = function(req, res) {\n    // use 'less' to scan this beast?\n    console.log(\"________________________________________________\")",
        "type": "code",
        "location": "/tests/random_giphy_gifs/nodejs_server.js:165-192"
    },
    "4979": {
        "file_id": 636,
        "content": "The code defines arrays for different media types, ratings, sorting options, languages, and limit and offset values. It also includes a function to handle fallback defaults for parameters and specifies valid entry points. The function uses the request listener to log a marker and handle incoming requests based on the specified endpoints.",
        "type": "comment"
    },
    "4980": {
        "file_id": 636,
        "content": "    console.log(\"REQUEST AT:\", req.url, req.method)\n    if (req.url == \"/\") {\n        res.writeHead(200);\n        res.end('nodejs giphy server');\n    } else if (validEntries.indexOf(req.url.split(\"?\")[0]) != -1) {\n        callback = (result) => {\n            res.writeHead(200);\n            res.end(getResultParsed(result, ['text', 'sticker']))\n        }\n        params = getQueryParams(req.url)\n        q = params.get('q')\n        type = fallbackDefault(params, 'type', typeArray, typeArray[0])\n        rating = fallbackDefault(params, 'rating', ratingArray, ratingArray[1])\n        limit = fallbackDefault(params, 'limit', limitArray, 100)\n        offset = fallbackDefault(params, 'offset', offsetArray, randInt(0, 100))\n        sort = fallbackDefault(params, 'sort', sortArray, sortArray[1])\n        lang = fallbackDefault(params, 'lang', langArray, 'en')\n        console.log('search keywords:', q)\n        if (q != null) {\n            if (req.url.startsWith('/random')) {\n                // getRandomGif(q, type, callback) // this only returns a single random gif. deprecated.",
        "type": "code",
        "location": "/tests/random_giphy_gifs/nodejs_server.js:193-213"
    },
    "4981": {
        "file_id": 636,
        "content": "This code is handling HTTP requests and serving appropriate responses based on the URL. If the request URL is \"/\", it sends a 200 response with the message \"nodejs giphy server\". If the request URL contains valid entries (presumably GIF-related), it extracts query parameters, sets default values if necessary, and calls getRandomGif() function to retrieve a random GIF. The code also includes console logging of search keywords for debugging purposes.",
        "type": "comment"
    },
    "4982": {
        "file_id": 636,
        "content": "                getRandomGifs(q, rating, callback)\n            } else if (req.url.startsWith('/search')) {\n                getSearchGifs(q, sort, limit, offset, type, rating, lang, callback)\n            } else if (req.url.startsWith('/related')) {\n                getRelatedGifs(q, limit, offset, type, callback)\n            } else {\n                res.end(\"don't know how you get here\")\n            }\n        } else {\n            if (req.url.startsWith('/trending')) {\n                getTrendingGifs(limit, offset, type, rating, callback)\n            } else { res.end('no search keywords.') }\n        }\n        // def = params.get('def')\n        // console.log(def, def == null)\n        // console.log(req.params)\n    } else {\n        res.end('not being right')\n    }\n}\nconst server = http.createServer(requestListener);\nport = 8902\nserver.listen(port);\nconsole.log('server running on http://localhost:' + port);",
        "type": "code",
        "location": "/tests/random_giphy_gifs/nodejs_server.js:214-239"
    },
    "4983": {
        "file_id": 636,
        "content": "Code handles different API routes and dispatches corresponding function calls. It checks the URL, retrieves search keywords, and filters/sorts gifs accordingly. If no keywords or incorrect route is provided, it returns appropriate error messages. The server listens on port 8902 and logs a confirmation message.",
        "type": "comment"
    },
    "4984": {
        "file_id": 637,
        "content": "/tests/random_giphy_gifs/download_webp.sh",
        "type": "filepath"
    },
    "4985": {
        "file_id": 637,
        "content": "The script uses curl to download a GIF from the specified URL and save it as \"pikachu.gif\". It does not mention using a proxy for faster downloading, but implies that without one it might be slow.",
        "type": "summary"
    },
    "4986": {
        "file_id": 637,
        "content": "# curl -o pikachu.webp \"https://media0.giphy.com/media/fSvqyvXn1M3btN8sDh/giphy.webp?cid=c32f918edh7reod7g89e9oyy0717c9jstsdms9wqs8sm6a5b&rid=giphy.webp&ct=g\"\n# not supported. ffmpeg does not buy it.\n# very fucking slow if not using proxy.\ncurl -o pikachu.gif \"https://media0.giphy.com/media/fSvqyvXn1M3btN8sDh/giphy.gif?cid=c32f918edh7reod7g89e9oyy0717c9jstsdms9wqs8sm6a5b&rid=giphy.gif&ct=g\"",
        "type": "code",
        "location": "/tests/random_giphy_gifs/download_webp.sh:1-6"
    },
    "4987": {
        "file_id": 637,
        "content": "The script uses curl to download a GIF from the specified URL and save it as \"pikachu.gif\". It does not mention using a proxy for faster downloading, but implies that without one it might be slow.",
        "type": "comment"
    },
    "4988": {
        "file_id": 638,
        "content": "/tests/random_giphy_gifs/can_we_get_tag_info_about_this.sh",
        "type": "filepath"
    },
    "4989": {
        "file_id": 638,
        "content": "The code is using the curl command to download a specific Giphy GIF (samoyed.html) from the given URL, which contains information about the samoyed dog breed. The tag in the comment might be used by an internal recommendation engine for similar content.",
        "type": "summary"
    },
    "4990": {
        "file_id": 638,
        "content": "curl -o samoyed.html \"https://giphy.com/gifs/roverdotcom-rover-samoyed-gifofdogs-AgO9VR2a9KW1MSP73I\"\n# tag is probably used by internal recommendation engine.",
        "type": "code",
        "location": "/tests/random_giphy_gifs/can_we_get_tag_info_about_this.sh:1-3"
    },
    "4991": {
        "file_id": 638,
        "content": "The code is using the curl command to download a specific Giphy GIF (samoyed.html) from the given URL, which contains information about the samoyed dog breed. The tag in the comment might be used by an internal recommendation engine for similar content.",
        "type": "comment"
    },
    "4992": {
        "file_id": 639,
        "content": "/tests/qq_share_autojs/unlock_and_run_autox.sh",
        "type": "filepath"
    },
    "4993": {
        "file_id": 639,
        "content": "The script checks if the device is locked, runs Auto.js script, monitors the flag file for changes and loops until it completes or encounters an error.",
        "type": "summary"
    },
    "4994": {
        "file_id": 639,
        "content": "bash adb_check_lock.sh \nfunction autox_run {\n  adb -s 192.168.10.3:5555 shell touch /storage/emulated/0/flag\n  bash adb_autox_launch.sh\n  while true\n  do\n    adb -s 192.168.10.3:5555 shell cat /storage/emulated/0/flag\n    if [[ $? -eq 1 ]]\n    then\n      echo \"script complete\"\n      exit\n    else\n      echo \"script running\"\n      sleep 1\n    fi\n  done\n}\nwhile true\ndo\n  autox_run\n  # you need to ensure the script run as expected.\ndone",
        "type": "code",
        "location": "/tests/qq_share_autojs/unlock_and_run_autox.sh:1-24"
    },
    "4995": {
        "file_id": 639,
        "content": "The script checks if the device is locked, runs Auto.js script, monitors the flag file for changes and loops until it completes or encounters an error.",
        "type": "comment"
    },
    "4996": {
        "file_id": 640,
        "content": "/tests/qq_share_autojs/test_qq_share.sh",
        "type": "filepath"
    },
    "4997": {
        "file_id": 640,
        "content": "This code launches the JumpActivity in the Tencent MobileQQ app, passing a complex URI with various data such as file type, file data, title, description, and URL to share. The shared content is related to Bilibili video recommendation server. It specifies the app name and package name (tv.danmaku.bili).",
        "type": "summary"
    },
    "4998": {
        "file_id": 640,
        "content": "am start -n com.tencent.mobileqq/com.tencent.mobileqq.activity.JumpActivity -a android.intent.action.VIEW -d 'mqqapi://share/to_fri?src_type=app&version=1&file_type=news&file_data=L3N0b3JhZ2UvZW11bGF0ZWQvMC9QaWN0dXJlcy9zaGFyZS8xMjcyMDY0MzU0&file_uri=Y29udGVudDovL3R2LmRhbm1ha3UuYmlsaS5maWxlcHJvdmlkZXIvb3BlbnNka19leHRlcm5hbC9zaGFyZTJxcV90ZW1wNDIwOTU0OTNhYjhlZGRhZmYzMWQ1Y2ZjYWYzZjE3MDQuanBn&title=5ZOU5ZOp5ZOU5ZOp&description=5aSn5Z6L5pS/6K6654mH772c5paw5pe25Luj562U5Y23&share_id=100951776&url=aHR0cHM6Ly9iMjMudHYvdGRKZGd6WT9zaGFyZV9tZWRpdW09YW5kcm9pZCZzaGFyZV9zb3VyY2U9cXEmYmJpZD1YWTFCQjcyMUIxRjk3MzQ4REJERTQyOTdGRTFCNEFCRTI2QkFBJnRzPTE2NjcyNzU0ODI4MTY=&app_name=5ZOU5ZOp5ZOU5ZOp&req_type=Nw==&mini_program_appid=MTEwOTkzNzU1Nw==&mini_program_path=cGFnZXMvdmlkZW8vdmlkZW8/YnZpZD1CVjFuZTQxMUw3aHkmc2hhcmVfc291cmNlPXFxX3VnYyZ1bmlxdWVfaz10ZEpkZ3pZ&mini_program_type=Mw==&cflag=MA==&third_sd=dHJ1ZQ==' -e pkg_name tv.danmaku.bili",
        "type": "code",
        "location": "/tests/bilibili_video_recommendation_server/xml_and_json_qq_send/test_launch_share.sh:1-1"
    },
    "4999": {
        "file_id": 640,
        "content": "This code launches the JumpActivity in the Tencent MobileQQ app, passing a complex URI with various data such as file type, file data, title, description, and URL to share. The shared content is related to Bilibili video recommendation server. It specifies the app name and package name (tv.danmaku.bili).",
        "type": "comment"
    }
}