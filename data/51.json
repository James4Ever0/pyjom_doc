{
    "5100": {
        "file_id": 661,
        "content": "/tests/remove_subtle_watermark_local_contrast_ocr/init_mclahe_numpy_only.sh",
        "type": "filepath"
    },
    "5101": {
        "file_id": 661,
        "content": "This command installs the latest version of mclahe library from a zip file, specifically optimized for numpy.",
        "type": "summary"
    },
    "5102": {
        "file_id": 661,
        "content": "pip3 install --upgrade https://github.com/VincentStimper/mclahe/archive/numpy.zip",
        "type": "code",
        "location": "/tests/remove_subtle_watermark_local_contrast_ocr/init_mclahe_numpy_only.sh:1-1"
    },
    "5103": {
        "file_id": 661,
        "content": "This command installs the latest version of mclahe library from a zip file, specifically optimized for numpy.",
        "type": "comment"
    },
    "5104": {
        "file_id": 662,
        "content": "/tests/remove_subtle_watermark_local_contrast_ocr/imagej2_pyimagej_test_clahe.py",
        "type": "filepath"
    },
    "5105": {
        "file_id": 662,
        "content": "The code integrates Python and Java using jpype, sets up JVM classpath, applies CLAHE in ImageJ2/PyImageJ for image contrast enhancement, and explores available methods and properties.",
        "type": "summary"
    },
    "5106": {
        "file_id": 662,
        "content": "# source:\n# https://github.com/seung-lab/Alembic/blob/575c8ed2a5f8789e65de652c9349993c530de718/src/archive/import/convert_dir_to_CLAHE.py\n# https://github.com/search?q=mpicbg.ij.clahe&type=code\n# for jpython you need to append all jar absolute paths to sys.path. grammar shall be identical.\nimport jpype\nimport jpype.imports\nfrom jpype.types import *\n# jpype.addClassPath(\"/root/Desktop/works/pyjom/tests/remove_subtle_watermark_local_contrast_ocr/imagej_fiji_linux/Fiji.app/jars/*\")\n# jpype.addClassPath(\"/root/Desktop/works/pyjom/tests/remove_subtle_watermark_local_contrast_ocr/imagej_fiji_linux/Fiji.app/jars/*/*\")\n# jpype.addClassPath(\"/root/Desktop/works/pyjom/tests/remove_subtle_watermark_local_contrast_ocr/imagej_fiji_linux/Fiji.app/plugins/*\")\n# jpype.addClassPath(\"/root/Desktop/works/pyjom/tests/remove_subtle_watermark_local_contrast_ocr/imagej_fiji_linux/Fiji.app/plugins/*/*\")\njpype.startJVM(\n    classpath=[\n        \"/root/Desktop/works/pyjom/tests/remove_subtle_watermark_local_contrast_ocr/imagej_fiji_linux/Fiji.app/jars/*\",",
        "type": "code",
        "location": "/tests/remove_subtle_watermark_local_contrast_ocr/imagej2_pyimagej_test_clahe.py:1-18"
    },
    "5107": {
        "file_id": 662,
        "content": "This code is setting up the JVM classpath for jpype, a tool to integrate Python and Java, by appending various jar absolute paths. These paths may include jars within Fiji's directories. This allows the program to use specific Java classes or libraries that are located in these jar files.",
        "type": "comment"
    },
    "5108": {
        "file_id": 662,
        "content": "        \"/root/Desktop/works/pyjom/tests/remove_subtle_watermark_local_contrast_ocr/imagej_fiji_linux/Fiji.app/plugins/*\",\n    ]\n)\nfrom ij import IJ\nimport os\nfrom mpicbg.ij.clahe import Flat\nfrom ij.process import ImageConverter\n# http://fiji.sc/wiki/index.php/Enhance_Local_Contrast_(CLAHE)\n# http://fiji.sc/cgi-bin/gitweb.cgi?p=mpicbg.git;a=blob;f=mpicbg/ij/clahe/PlugIn.java;h=663153764493547de560c08ee11f2e6b1e7e1a32;hb=HEAD\n# dir = \"/usr/people/tmacrina/seungmount/research/Julimaps/datasets/AIBS_pilot_v1/0_raw/\"\nblocksize = 40\nhistogram_bins = 255\nmaximum_slope = 5\nmask = \"*None*\"\ncomposite = False\nmask = None\n# files = os.listdir(dir)\n# files.sort()\n# for file in files:\n#      if file.endswith(\".tif\")\n# fn = os.path.join(dir, 'original.tif')\nfn = \"IWWS.jpeg\"\nimp = IJ.openImage(fn)\noutput_fn = \"imagej_output.jpg\"\nimp = IJ.openImage(fn)\nFlat.getFastInstance().run(\n    imp, blocksize, histogram_bins, maximum_slope, mask, composite\n)\nIJ.save(imp, output_fn)\nFlat.getFastInstance().run(\n    imp, blocksize, histogram_bins, maximum_slope, mask, composite",
        "type": "code",
        "location": "/tests/remove_subtle_watermark_local_contrast_ocr/imagej2_pyimagej_test_clahe.py:19-58"
    },
    "5109": {
        "file_id": 662,
        "content": "Applies CLAHE (Contrast Limited Adaptive Histogram Equalization) on an input image to enhance local contrast. It takes the input image, adjusts blocksize, histogram bins, maximum slope, mask, and composite parameters to improve image quality. Saves the output image with modified contrast.",
        "type": "comment"
    },
    "5110": {
        "file_id": 662,
        "content": ")\n# ImageConverter(imp).convertToGray8()\nIJ.save(imp, \"imagej_double.jpg\")\n# # Create an ImageJ2 gateway with the newest available version of ImageJ2.\n# # fiji_path = \"/root/Desktop/works/pyjom/tests/remove_subtle_watermark_local_contrast_ocr/imagej_fiji_linux/Fiji.app\"\n# # ij = imagej.init(fiji_path)\n# import scyjava\n# # plugins_dir = '/Applications/Fiji.app/plugins'\n# # plugins_dir = \"/root/Desktop/works/pyjom/tests/remove_subtle_watermark_local_contrast_ocr/imagej_fiji_linux/Fiji.app/plugins\"\n# # scyjava.config.add_option(f'-Dplugins.dir={plugins_dir}')\n# # scyjava.config.add_repositories({'scijava.public': 'https://maven.scijava.org/content/groups/public'})\n# import imagej\n# ij = imagej.init()\n# # Load an image.\n# image_url = \"IWWS.jpeg\"\n# jimage = ij.io().open(image_url)\n# # Convert the image from ImageJ2 to xarray, a package that adds\n# # labeled datasets to numpy (http://xarray.pydata.org/en/stable/).\n# image = ij.py.from_java(jimage)\n# # Display the image (backed by matplotlib).\n# # ij.py.show(image, cmap='gray')",
        "type": "code",
        "location": "/tests/remove_subtle_watermark_local_contrast_ocr/imagej2_pyimagej_test_clahe.py:59-85"
    },
    "5111": {
        "file_id": 662,
        "content": "This code initializes ImageJ2, opens an image, converts it to xarray for labeled datasets in numpy, and displays the image using matplotlib.",
        "type": "comment"
    },
    "5112": {
        "file_id": 662,
        "content": "# # print('IMAGE',image)\n# # d = dir(ij)\n# # print(d)\n# # ['IJ', 'ResultsTable', 'RoiManager', 'WindowManager', '__class__', '__del__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_access_legacy_class', '_check_legacy_active', 'animation', 'app', 'appEvent', 'command', 'compareTo', 'console', 'context', 'convert', 'dataset', 'display', 'dispose', 'equals', 'event', 'eventHistory', 'get', 'getApp', 'getClass', 'getContext', 'getIdentifier', 'getInfo', 'getLocation', 'getPriority', 'getShortName', 'getTitle', 'getVersion', 'hashCode', 'icon', 'imageDisplay', 'input', 'io', 'launch', 'legacy', 'log', 'lut', 'main', 'menu', 'module', 'notebook', 'notify', 'notifyAll', 'object', 'op', 'options', 'overlay', 'pla",
        "type": "code",
        "location": "/tests/remove_subtle_watermark_local_contrast_ocr/imagej2_pyimagej_test_clahe.py:86-89"
    },
    "5113": {
        "file_id": 662,
        "content": "The code is exploring the available methods and properties of the ImageJ2/PyImageJ object (ij) by printing a list of all accessible attributes. However, this specific snippet seems to have been commented out, indicating that the developer may have considered it but eventually decided against including it in the final code.",
        "type": "comment"
    },
    "5114": {
        "file_id": 662,
        "content": "tform', 'plugin', 'prefs', 'py', 'recentFile', 'rendering', 'sampler', 'scifio', 'screenCapture', 'script', 'setContext', 'setInfo', 'setPriority', 'startup', 'status', 'text', 'thread', 'toString', 'tool', 'ui', 'update', 'uploader', 'wait', 'widget', 'window']\n# # p = ij.plugin\n# # print(dir(p))\n# clahe = scyjava.jimport('mpicbg')",
        "type": "code",
        "location": "/tests/remove_subtle_watermark_local_contrast_ocr/imagej2_pyimagej_test_clahe.py:89-92"
    },
    "5115": {
        "file_id": 662,
        "content": "Code imports 'clahe' from 'mpicbg' for ImageJ2 usage.",
        "type": "comment"
    },
    "5116": {
        "file_id": 663,
        "content": "/tests/remove_subtle_watermark_local_contrast_ocr/glche_test.py",
        "type": "filepath"
    },
    "5117": {
        "file_id": 663,
        "content": "This code performs image processing, including contrast normalization, hue preservation, and fusion for color images using nonlinear transformation and CLAHE. It can process multiple images in a specified directory via an optional loop.",
        "type": "summary"
    },
    "5118": {
        "file_id": 663,
        "content": "from PIL import Image\nfrom scipy.optimize import minimize_scalar\nimport numpy as np\nimport cv2\nimport os\ndef linearStretching(x_c, x_max, x_min, l):\n    return (l - 1) * (x_c - x_min) / (x_max - x_min)\ndef mapping(h, l):\n    cum_sum = 0\n    t = np.zeros_like(h, dtype=np.int)\n    for i in range(l):\n        cum_sum += h[i]\n        t[i] = np.ceil((l - 1) * cum_sum + 0.5)\n    return t\ndef f(lam, h_i, h_u, l):\n    h_tilde = 1 / (1 + lam) * h_i + lam / (1 + lam) * h_u\n    t = mapping(h_tilde, l)\n    d = 0\n    for i in range(l):\n        for j in range(i + 1):\n            if h_tilde[i] > 0 and h_tilde[j] > 0 and t[i] == t[j]:\n                d = max(d, i - j)\n    return d\ndef huePreservation(g_i, i, x_hat_c, l):\n    g_i_f = g_i.flatten()\n    i_f = i.flatten()\n    x_hat_c_f = x_hat_c.flatten()\n    g_c = np.zeros(g_i_f.shape)\n    g_c[g_i_f <= i_f] = (g_i_f / i_f * x_hat_c_f)[g_i_f <= i_f]\n    g_c[g_i_f > i_f] = ((l - 1 - g_i_f) / (l - 1 - i_f) * (x_hat_c_f - i_f) + g_i_f)[g_i_f > i_f]\n    return g_c.reshape(i.shape)\ndef fusion(i):",
        "type": "code",
        "location": "/tests/remove_subtle_watermark_local_contrast_ocr/glche_test.py:1-40"
    },
    "5119": {
        "file_id": 663,
        "content": "The code defines several functions for image processing, including linear stretching, hue preservation, and fusion. These functions are likely used to enhance image quality, contrast, or OCR capabilities.",
        "type": "comment"
    },
    "5120": {
        "file_id": 663,
        "content": "    lap = cv2.Laplacian(i.astype(np.uint8), cv2.CV_16S, ksize=3)\n    c_d = np.array(cv2.convertScaleAbs(lap))\n    #print(np.max(np.max(c_d)), np.min(np.min(c_d)))\n    c_d = c_d / np.max(np.max(c_d)) + 0.00001\n    i_scaled = (i - np.min(np.min(i))) / (np.max(np.max(i)) - np.min(np.min(i)))\n    b_d = np.apply_along_axis(lambda x: np.exp(- (x - 0.5) ** 2 / (2 * 0.2 ** 2)), 0, i_scaled.flatten()).reshape(i.shape)\n    w_d = np.minimum(c_d, b_d)\n    return w_d\ndef main(path, name): # no parameter? fuck.\n    x = np.array(Image.open(path)).astype(np.float64)\n    x_r, x_g, x_b = x[:, :, 0], x[:, :, 1], x[:, :, 2]\n    x_max = np.max(np.max(np.max(x)))\n    x_min = np.min(np.min(np.min(x)))\n    l = 256\n    x_hat_r = linearStretching(x_r, x_max, x_min, l)\n    x_hat_g = linearStretching(x_g, x_max, x_min, l)\n    x_hat_b = linearStretching(x_b, x_max, x_min, l)\n    i = (0.299 * x_hat_r + 0.587 * x_hat_g + 0.114 * x_hat_b).astype(np.uint8)\n    h_i = np.bincount(i.flatten())\n    h_i = np.concatenate((h_i, np.zeros(l - h_i.shape[0]))) / (i.shape[0] * i.shape[1])",
        "type": "code",
        "location": "/tests/remove_subtle_watermark_local_contrast_ocr/glche_test.py:41-64"
    },
    "5121": {
        "file_id": 663,
        "content": "The code reads an image and applies linear stretching to the red, green, and blue channels separately. It then combines these channels using YCbCr color space conversion and calculates the histogram of the combined image. The resulting histogram is normalized by dividing it by the total number of pixels. Finally, it returns a stretched and scaled image with watermark detection values.",
        "type": "comment"
    },
    "5122": {
        "file_id": 663,
        "content": "    h_u = np.ones_like(h_i) * 1 / l\n    result = minimize_scalar(f, method = \"brent\", args = (h_i, h_u, l))\n    h_tilde = 1 / (1 + result.x) * h_i + result.x / (1 + result.x) * h_u\n    t = mapping(h_tilde, l)\n    g_i = np.apply_along_axis(lambda x: t[x], 0, i.flatten()).reshape(i.shape)\n    g_r = huePreservation(g_i, i, x_hat_r, l)\n    g_g = huePreservation(g_i, i, x_hat_g, l)\n    g_b = huePreservation(g_i, i, x_hat_b, l)\n    #glo = np.dstack((g_r, g_g, g_b)).astype(np.int)\n    clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8,8))\n    l_i = clahe.apply(i)\n    l_r = huePreservation(l_i, i, x_hat_r, l)\n    l_g = huePreservation(l_i, i, x_hat_g, l)\n    l_b = huePreservation(l_i, i, x_hat_b, l)\n    #loc = np.dstack((l_r, l_g, l_b)).astype(np.int)\n    w_g = fusion(g_i)\n    w_l = fusion(l_i)\n    w_hat_g = w_g / (w_g + w_l)\n    w_hat_l = w_l / (w_g + w_l)\n    y_r = w_hat_g * g_r + w_hat_l * l_r\n    y_g = w_hat_g * g_g + w_hat_l * l_g\n    y_b = w_hat_g * g_b + w_hat_l * l_b\n    y = np.dstack((y_r, y_g, y_b)).astype(np.uint8)",
        "type": "code",
        "location": "/tests/remove_subtle_watermark_local_contrast_ocr/glche_test.py:65-91"
    },
    "5123": {
        "file_id": 663,
        "content": "This code performs contrast normalization, hue preservation, and fusion for color image processing. It uses nonlinear transformation to equalize intensity values, applies CLAHE for local contrast enhancement, and fuses the results using a weighted average based on relative brightness.",
        "type": "comment"
    },
    "5124": {
        "file_id": 663,
        "content": "    img = Image.fromarray(y)\n    img.save(name + '-en.jpg')\nif __name__ == \"__main__\":\n    picPath = \"IWWS.jpeg\"\n    imageName = \"IWWS-glche.jpeg\"\n    main(picPath, imageName)\n#     dirs = '..\\\\'\n#     count = 0\n#     for num in ('9', '14', '43', '45', '99'):\n#         path = dirs + num\n#         pics = os.listdir(path)\n#         path += '\\\\'\n#         for pic in pics:\n#             main(path + pic, pic[: -4])\n#             count += 1\n#             print(count, 'Done!')",
        "type": "code",
        "location": "/tests/remove_subtle_watermark_local_contrast_ocr/glche_test.py:93-109"
    },
    "5125": {
        "file_id": 663,
        "content": "This code reads an image file, applies a function to it, and saves the modified image with a new name. It also has an optional loop that processes multiple images in a specified directory.",
        "type": "comment"
    },
    "5126": {
        "file_id": 664,
        "content": "/tests/setu_server_mail_collector_ad_poster_personalization_java/README.md",
        "type": "filepath"
    },
    "5127": {
        "file_id": 664,
        "content": "This Java code sets up a server for Bilibli UIDs and collects personal interests by analyzing images. It requests an email address after some time if not initially provided, then shares tracker links in sent emails as ads.",
        "type": "summary"
    },
    "5128": {
        "file_id": 664,
        "content": "a simple setu server written in java.\nwill ask for bilibili uid\nwill ask for email address after a while (if not provided)\nwill collect personal interest on pictures (planned)\nwill post tracker links on ads in email",
        "type": "code",
        "location": "/tests/setu_server_mail_collector_ad_poster_personalization_java/README.md:1-9"
    },
    "5129": {
        "file_id": 664,
        "content": "This Java code sets up a server for Bilibli UIDs and collects personal interests by analyzing images. It requests an email address after some time if not initially provided, then shares tracker links in sent emails as ads.",
        "type": "comment"
    },
    "5130": {
        "file_id": 665,
        "content": "/tests/skin_clean/process_image.py",
        "type": "filepath"
    },
    "5131": {
        "file_id": 665,
        "content": "The code includes two image processing functions, beauty_face and beauty_face2, which enhance facial features using Gaussian blur, bilateral filtering, and custom processing. The results are saved as 'result1.png' and 'result2.png'. The source image file is set to \"IMG_20220515_2220565.jpg\" and the init function is called with this source parameter for potential further manipulations or analysis.",
        "type": "summary"
    },
    "5132": {
        "file_id": 665,
        "content": "import numpy as np\nimport cv2\ndef beauty_face(img):\n    '''\n    Dest =(Src * (100 - Opacity) + (Src + 2 * GuassBlur(EPFFilter(Src) - Src + 128) - 256) * Opacity) /100 ;\n    https://my.oschina.net/wujux/blog/1563461\n    '''\n    dst = np.zeros_like(img)\n    #int value1 = 3, value2 = 1; 磨皮程度与细节程度的确定\n    v1 = 3\n    v2 = 1\n    dx = v1 * 5 # 双边滤波参数之一 \n    fc = v1 * 12.5 # 双边滤波参数之一 \n    p = 0.1\n    temp4 = np.zeros_like(img)\n    temp1 = cv2.bilateralFilter(img,dx,fc,fc)\n    temp2 = cv2.subtract(temp1,img)\n    temp2 = cv2.add(temp2,(10,10,10,128))\n    temp3 = cv2.GaussianBlur(temp2,(2*v2 - 1,2*v2-1),0)\n    temp4 = cv2.add(img,temp3)\n    dst = cv2.addWeighted(img,p,temp4,1-p,0.0)\n    dst = cv2.add(dst,(10, 10, 10,255))\n    return dst\ndef beauty_face2(src):\n    '''\n    Dest =(Src * (100 - Opacity) + (Src + 2 * GuassBlur(EPFFilter(Src) - Src + 128) - 256) * Opacity) /100 ;\n    '''\n    dst = np.zeros_like(src)\n    #int value1 = 3, value2 = 1; 磨皮程度与细节程度的确定\n    v1 = 3\n    v2 = 1\n    dx = v1 * 5 # 双边滤波参数之一 \n    fc = v1 * 12.5 # 双边滤波参数之一 ",
        "type": "code",
        "location": "/tests/skin_clean/process_image.py:3-41"
    },
    "5133": {
        "file_id": 665,
        "content": "The code defines two functions, beauty_face and beauty_face2. The beauty_face function applies a series of image processing operations to create a smoothed and enhanced version of the input image. This includes bilateral filtering, subtraction, Gaussian blurring, addition, and weighted addition. The beauty_face2 function is similar but processes a different source image.",
        "type": "comment"
    },
    "5134": {
        "file_id": 665,
        "content": "    p = 0.1\n    temp4 = np.zeros_like(src)\n    temp1 = cv2.bilateralFilter(src,dx,fc,fc)\n    temp2 = cv2.subtract(temp1,src)\n    temp2 = cv2.add(temp2, (10,10,10,128))\n    temp3 = cv2.GaussianBlur(temp2,(2*v2 - 1,2*v2-1),0)\n    temp4 = cv2.subtract(cv2.add(cv2.add(temp3, temp3), src), (10, 10, 10, 255))\n    dst = cv2.addWeighted(src,p,temp4,1-p,0.0)\n    dst = cv2.add(dst, (10, 10, 10,255))\n    return dst\ndef init(source):\n    img = cv2.imread(source)\n    # blur1 = cv2.GaussianBlur(img, (5,5),0)\n    # blur2 = cv2.bilateralFilter(img, 9 , 75, 75)\n    blur3 = beauty_face(img)\n    blur4 = beauty_face2(img)\n    # cv2.imshow('image0', img)\n    # # cv2.imshow('image1', blur1)\n    # # cv2.imshow('image2', blur2)\n    # cv2.imshow('image3', blur3)\n    # cv2.imshow('image4', blur4)\n    # cv2.namedWindow('image', cv2.WINDOW_NORMAL)\n    # cv2.resizeWindow('image', 1000, 1000) #定义frame的大小\n    # cv2.waitKey(0)\n    cv2.imwrite('result1.png', blur3)\n    cv2.imwrite('result2.png', blur4)\n    # cv2.destroyAllWindows()\nif __name__ == \"__main__\":",
        "type": "code",
        "location": "/tests/skin_clean/process_image.py:42-79"
    },
    "5135": {
        "file_id": 665,
        "content": "Code applies image processing techniques to enhance facial features. It uses Gaussian blur, bilateral filtering, and custom beauty_face/beauty_face2 functions. The processed images are displayed in separate windows and saved as 'result1.png' and 'result2.png'.",
        "type": "comment"
    },
    "5136": {
        "file_id": 665,
        "content": "    source = \"IMG_20220515_2220565.jpg\"\n    init(source)",
        "type": "code",
        "location": "/tests/skin_clean/process_image.py:80-81"
    },
    "5137": {
        "file_id": 665,
        "content": "This code snippet sets the source image file name as \"IMG_20220515_2220565.jpg\" and calls the init function with this source parameter. The purpose of this step might be to initialize the image processing or loading process for further manipulations or analysis.",
        "type": "comment"
    },
    "5138": {
        "file_id": 666,
        "content": "/tests/still_watermark_auto_removal/test_auto_video_watermark_detection.sh",
        "type": "filepath"
    },
    "5139": {
        "file_id": 666,
        "content": "cd into the automatic-watermark-detection directory and execute the video_watermark_detection.py script for watermark detection in videos.",
        "type": "summary"
    },
    "5140": {
        "file_id": 666,
        "content": "cd automatic-watermark-detection\npython3 video_watermark_detection.py",
        "type": "code",
        "location": "/tests/still_watermark_auto_removal/test_auto_video_watermark_detection.sh:1-3"
    },
    "5141": {
        "file_id": 666,
        "content": "cd into the automatic-watermark-detection directory and execute the video_watermark_detection.py script for watermark detection in videos.",
        "type": "comment"
    },
    "5142": {
        "file_id": 667,
        "content": "/tests/still_watermark_auto_removal/maxRectangleSolver.py",
        "type": "filepath"
    },
    "5143": {
        "file_id": 667,
        "content": "The code defines checkOverlap for point validation and solves the maximum rectangle problem, iterating through candidate rectangles, detecting overlaps, and displaying the best candidate in red. It also sorts and prints top 5 areas.",
        "type": "summary"
    },
    "5144": {
        "file_id": 667,
        "content": "import sympy\nimport json\ndata = json.loads(open(\"test_special.json\", \"r\").read())\ncanvas = data[\"canvas\"]\nrectangles = data[\"rectangles\"]\ncanvasWidth, canvasHeight = canvas\nxValid = [0, canvasWidth]\nyValid = [0, canvasHeight]\nmRects = []\ndef checkContains(rect, point):\n    xPoints = [p[0] for p in rect]\n    yPoints = [p[1] for p in rect]\n    maxX, minX = max(xPoints), min(xPoints)\n    maxY, minY = max(yPoints), min(yPoints)\n    x, y = point\n    return x > minX and x < maxX and y > minY and y < maxY\n# def checkOverlapAsymmetric(rect0, rect1):\n#     for point in rect0:\n#         if checkContains(rect1, point):\n#             return True\n#         # also check for intersections?\n#     return False\n# Python program to check if rectangles overlap\nclass D2Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\ndef getRectDiagonalPoints(rect):\n    xPoints = [p[0] for p in rect]\n    yPoints = [p[1] for p in rect]\n    maxX, minX = max(xPoints), min(xPoints)\n    maxY, minY = max(yPoints), min(yPoints)\n    p0, p1 = D2Point(minX, minY), D2Point(maxX, maxY)",
        "type": "code",
        "location": "/tests/still_watermark_auto_removal/maxRectangleSolver.py:1-43"
    },
    "5145": {
        "file_id": 667,
        "content": "Code reads JSON data containing a canvas and rectangles. It validates points, creates a function to check if two rectangles overlap, and defines D2Point class for storing 2D point coordinates.",
        "type": "comment"
    },
    "5146": {
        "file_id": 667,
        "content": "    return p0, p1\ndef do_overlap(l1, r1, l2, r2):\n    # if rectangle has area 0, no overlap\n    if l1.x == r1.x or l1.y == r1.y or r2.x == l2.x or l2.y == r2.y:\n        return False\n    # If one rectangle is on left side of other\n    if l1.x >= r2.x or l2.x >= r1.x:\n        return False\n    if l1.y >= r2.y or l2.y >= r1.y:\n        return False\n    return True\ndef checkOverlap(rect0, rect1):\n    return do_overlap(*getRectDiagonalPoints(rect0),*getRectDiagonalPoints(rect1))\nfor x, y, mWidth, mHeight in rectangles:\n    xValid.append(x)\n    xValid.append(x + mWidth)\n    yValid.append(y)\n    yValid.append(y + mHeight)\n    p0, p1, p2, p3 = (\n        (x, y),\n        (x + mWidth, y),\n        (x + mWidth, y + mHeight),\n        (x, y + mHeight),\n    )\n    # mRectangle = sympy.Polygon(p0,p1,p2,p3)\n    mRectangle = [p0, p1, p2, p3]\n    mRects.append(mRectangle)\ndef purify(xValid):\n    xValid = list(set(xValid))\n    xValid.sort()\n    return xValid\ndef checkOverlapAgainstRectList(rect, rectList):\n    for testRect in rectList:\n        if checkOverlap(rect, testRect):",
        "type": "code",
        "location": "/tests/still_watermark_auto_removal/maxRectangleSolver.py:44-85"
    },
    "5147": {
        "file_id": 667,
        "content": "This code defines a function checkOverlap which takes two rectangles and checks if they overlap. The function do_overlap is used to determine if the rectangles have any area of overlap. It also includes utility functions like getRectDiagonalPoints, purify, and checkOverlapAgainstRectList for manipulating and comparing rectangles. The code creates a list of rectangles and checks for overlaps between each rectangle and others in a separate list.",
        "type": "comment"
    },
    "5148": {
        "file_id": 667,
        "content": "            return True\n    return False\nxValid = purify(xValid)\nyValid = purify(yValid)\ntotalCandidates = []\ndef getRectArea(rect):\n    xPoints = [p[0] for p in rect]\n    yPoints = [p[1] for p in rect]\n    maxX, minX = max(xPoints), min(xPoints)\n    maxY, minY = max(yPoints), min(yPoints)\n    return (maxX - minX) * (maxY - minY)\nbestCandidate = None\nbestArea = 0\nfor ix0 in range(0, len(xValid)-1):\n    for ix1 in range(ix0+1, len(xValid)):\n        for iy0 in range(0, len(yValid)-1):\n            for iy1 in range(iy0+1, len(yValid)):\n                x0, x1, y0, y1 = xValid[ix0], xValid[ix1], yValid[iy0], yValid[iy1]\n                x, y = x0, y0\n                mWidth, mHeight = x1 - x, y1 - y\n                p0, p1, p2, p3 = (\n                    (x, y),\n                    (x + mWidth, y),\n                    (x + mWidth, y + mHeight),\n                    (x, y + mHeight),\n                )\n                rectCandidate = [p0, p1, p2, p3]\n                area = getRectArea(rectCandidate)\n                if area <= bestArea:",
        "type": "code",
        "location": "/tests/still_watermark_auto_removal/maxRectangleSolver.py:86-120"
    },
    "5149": {
        "file_id": 667,
        "content": "The code is implementing a maximum rectangle solver algorithm. It iterates over the x and y validated points to generate all possible rectangles, calculating their areas using the getRectArea function. The best candidate with the highest area is stored.",
        "type": "comment"
    },
    "5150": {
        "file_id": 667,
        "content": "                    continue\n                if checkOverlapAgainstRectList(rectCandidate, mRects):\n                    break\n                bestCandidate = rectCandidate.copy()\n                bestArea = area\n                # print(\"UPDATING:\",bestCandidate)\n                # print('AREA:', bestArea)\n                # totalCandidates.append(rectCandidate.copy())\nprint(\"final candidate:\", bestCandidate)\n# plot this?\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Rectangle\nfig, ax = plt.subplots()\nax.plot([canvasWidth, canvasHeight])\n# add rectangle to plot\ndef plotRect(ax, x, y, width, height, facecolor):\n    ax.add_patch(Rectangle((x, y), width, height, facecolor=facecolor, fill=True))\ndef rectToXYWH(rect):\n    xPoints = [p[0] for p in rect]\n    yPoints = [p[1] for p in rect]\n    maxX, minX = max(xPoints), min(xPoints)\n    maxY, minY = max(yPoints), min(yPoints)\n    x, y = minX, minY\n    width, height = (maxX - minX), (maxY - minY)\n    return x, y, width, height\nplotRect(ax,0,0,canvasWidth, canvasHeight,'black')",
        "type": "code",
        "location": "/tests/still_watermark_auto_removal/maxRectangleSolver.py:121-151"
    },
    "5151": {
        "file_id": 667,
        "content": "This code finds the maximum rectangle by iterating through candidate rectangles and checking for overlaps. It updates the best candidate and area if a better one is found, then plots the final candidate rectangle on a plot.",
        "type": "comment"
    },
    "5152": {
        "file_id": 667,
        "content": "for rect in mRects:\n    x,y, width, height = rectToXYWH(rect)\n    plotRect(ax,x,y,width,height,'white')\nplotRect(ax,*rectToXYWH(bestCandidate),'red')\n# display plot\nplt.show()\n# totalCandidates.sort(key = lambda rect: -getRectArea(rect))\n# for rect in totalCandidates[:5]:\n#     print(rect)",
        "type": "code",
        "location": "/tests/still_watermark_auto_removal/maxRectangleSolver.py:153-161"
    },
    "5153": {
        "file_id": 667,
        "content": "The code generates and plots rectangles using given coordinates and dimensions, with the best candidate rectangle displayed in red. It also sorts the total list of candidate rectangles by area and prints the top 5 areas.",
        "type": "comment"
    },
    "5154": {
        "file_id": 668,
        "content": "/tests/still_watermark_auto_removal/EAST-Detector-for-text-detection-using-OpenCV-master/README.md",
        "type": "filepath"
    },
    "5155": {
        "file_id": 668,
        "content": "EAST Detector code in OpenCV enables real-time, accurate text detection in natural scenes, addressing challenges like angles, lighting, and non-ideal surfaces. The project welcomes improvements via pull requests and is licensed under MIT.",
        "type": "summary"
    },
    "5156": {
        "file_id": 668,
        "content": "# EAST Detector for Text Detection\nOpenCV’s EAST(Efficient and Accurate Scene Text Detection ) text detector is a deep learning model, based on a novel architecture and training pattern. It is capable of \n- running at near real-time at 13 FPS on 720p images and \n- obtains state-of-the-art text detection accuracy.\n[Link to paper](https://arxiv.org/pdf/1704.03155.pdf)\nOpenCV’s text detector implementation of EAST is quite robust, capable of localizing text even when it’s blurred, reflective, or partially obscured.\nThere are many natural scene text detection challenges that have been described by Celine Mancas-Thillou and Bernard Gosselin in their excellent 2017 paper, [Natural Scene Text Understanding](https://www.tcts.fpms.ac.be/publications/regpapers/2007/VS_cmtbg2007.pdf) below:\n- **Image/sensor noise**: Sensor noise from a handheld camera is typically higher than that of a traditional scanner. Additionally, low-priced cameras will typically interpolate the pixels of raw sensors to produce real colors.",
        "type": "code",
        "location": "/tests/still_watermark_auto_removal/EAST-Detector-for-text-detection-using-OpenCV-master/README.md:1-13"
    },
    "5157": {
        "file_id": 668,
        "content": "Code for OpenCV's EAST Detector implementation for text detection, capable of real-time performance and high accuracy. Based on a novel architecture and training pattern, it can detect text even when blurred, reflective or partially obscured. The code addresses challenges like sensor noise from handheld cameras.",
        "type": "comment"
    },
    "5158": {
        "file_id": 668,
        "content": "- **Viewing angles**: Natural scene text can naturally have viewing angles that are not parallel to the text, making the text harder to recognize.\nBlurring: Uncontrolled environments tend to have blur, especially if the end user is utilizing a smartphone that does not have some form of stabilization.\n- **Lighting conditions**: We cannot make any assumptions regarding our lighting conditions in natural scene images. It may be near dark, the flash on the camera may be on, or the sun may be shining brightly, saturating the entire image.\n- **Resolution**: Not all cameras are created equal — we may be dealing with cameras with sub-par resolution.\n- **Non-paper objects**: Most, but not all, paper is not reflective (at least in context of paper you are trying to scan). Text in natural scenes may be reflective, including logos, signs, etc.\n- **Non-planar objects**: Consider what happens when you wrap text around a bottle — the text on the surface becomes distorted and deformed. While humans may sti",
        "type": "code",
        "location": "/tests/still_watermark_auto_removal/EAST-Detector-for-text-detection-using-OpenCV-master/README.md:15-24"
    },
    "5159": {
        "file_id": 668,
        "content": "The code discusses various challenges in natural scene text detection, such as viewing angles, lighting conditions, resolution, non-paper objects (like reflective surfaces), and non-planar objects (such as distorted text on curved surfaces). These factors make it difficult to recognize and extract text from natural scenes.",
        "type": "comment"
    },
    "5160": {
        "file_id": 668,
        "content": "ll be able to easily “detect” and read the text, our algorithms will struggle. We need to be able to handle such use cases.\n- **Unknown layout**: We cannot use any a priori information to give our algorithms “clues” as to where the text resides.\n## Contributing\nPull requests are welcome. For major changes, please open an issue first to discuss what you would like to change.\n### Thanks to [Adrian's Blog](https://www.pyimagesearch.com/2018/08/20/opencv-text-detection-east-text-detector/) for a comprehensive blog on EAST Detector.\n## License\n[MIT](https://choosealicense.com/licenses/mit/)",
        "type": "code",
        "location": "/tests/still_watermark_auto_removal/EAST-Detector-for-text-detection-using-OpenCV-master/README.md:24-35"
    },
    "5161": {
        "file_id": 668,
        "content": "This code is from the README file of a project that utilizes EAST Detector, an OpenCV-based text detection algorithm. The project aims to improve its algorithms' ability to handle complex text layouts and use cases. It welcomes pull requests for major changes and is licensed under MIT.",
        "type": "comment"
    },
    "5162": {
        "file_id": 669,
        "content": "/tests/still_watermark_auto_removal/EAST-Detector-for-text-detection-using-OpenCV-master/opencv_text_detection_image.py",
        "type": "filepath"
    },
    "5163": {
        "file_id": 669,
        "content": "The code loads an input image, preprocesses it, resizes using argparse, detects text with OpenCV and EAST Detector, calculates prediction time, filters low-confidence detections, extracts scores & geometrical data, applies non-maxima suppression, scales coordinates, draws bounding boxes on the original image, and displays it.",
        "type": "summary"
    },
    "5164": {
        "file_id": 669,
        "content": "# USAGE\n# python3 opencv_text_detection_image.py --image images/lebron_james.jpg --east frozen_east_text_detection.pb\n# import the necessary packages\nfrom imutils.object_detection import non_max_suppression\nimport numpy as np\nimport argparse\nimport time\nimport cv2\n# construct the argument parser and parse the arguments\nap = argparse.ArgumentParser()\nap.add_argument(\"-i\", \"--image\", type=str,\n                help=\"path to input image\")\nap.add_argument(\"-east\", \"--east\", type=str,\n                help=\"path to input EAST text detector\")\nap.add_argument(\"-c\", \"--min-confidence\", type=float, default=0.5,\n                help=\"minimum probability required to inspect a region\")\nap.add_argument(\"-w\", \"--width\", type=int, default=320,\n                help=\"resized image width (should be multiple of 32)\")\nap.add_argument(\"-e\", \"--height\", type=int, default=320,\n                help=\"resized image height (should be multiple of 32)\")\nargs = vars(ap.parse_args())\n# load the input image and grab the image dimensions\nimage = cv2.imread(args[\"image\"])",
        "type": "code",
        "location": "/tests/still_watermark_auto_removal/EAST-Detector-for-text-detection-using-OpenCV-master/opencv_text_detection_image.py:1-26"
    },
    "5165": {
        "file_id": 669,
        "content": "This code loads an input image and applies preprocessing steps. It utilizes the argparse module to accept command-line arguments, allowing users to specify the input image path and the East text detector model file. It also sets default values for confidence threshold and resized image dimensions, which can be overridden by command-line options.",
        "type": "comment"
    },
    "5166": {
        "file_id": 669,
        "content": "orig = image.copy()\n(H, W) = image.shape[:2]\n# set the new width and height and then determine the ratio in change\n# for both the width and height\n(newW, newH) = (args[\"width\"], args[\"height\"])\nrW = W / float(newW)\nrH = H / float(newH)\n# resize the image and grab the new image dimensions\nimage = cv2.resize(image, (newW, newH))\n(H, W) = image.shape[:2]\n# define the two output layer names for the EAST detector model that\n# we are interested -- the first is the output probabilities and the\n# second can be used to derive the bounding box coordinates of text\nlayerNames = [\n    \"feature_fusion/Conv_7/Sigmoid\",\n    \"feature_fusion/concat_3\"]\n# load the pre-trained EAST text detector\nprint(\"[INFO] loading EAST text detector...\")\nnet = cv2.dnn.readNet(args[\"east\"])\n# construct a blob from the image and then perform a forward pass of\n# the model to obtain the two output layer sets\nblob = cv2.dnn.blobFromImage(image, 1.0, (W, H),\n                             (123.68, 116.78, 103.94), swapRB=True, crop=False)\nstart = time.time()",
        "type": "code",
        "location": "/tests/still_watermark_auto_removal/EAST-Detector-for-text-detection-using-OpenCV-master/opencv_text_detection_image.py:27-55"
    },
    "5167": {
        "file_id": 669,
        "content": "This code performs image preprocessing, resizing and loads the EAST text detector model for text detection. It sets the original image copy, calculates new width and height based on arguments, resizes the image, gets updated dimensions, defines output layer names for the model, loads the pre-trained EAST text detector model, constructs a blob from the image, performs a forward pass of the model to obtain two output layers.",
        "type": "comment"
    },
    "5168": {
        "file_id": 669,
        "content": "net.setInput(blob)\n(scores, geometry) = net.forward(layerNames)\nend = time.time()\n# show timing information on text prediction\nprint(\"[INFO] text detection took {:.6f} seconds\".format(end - start))\n# grab the number of rows and columns from the scores volume, then\n# initialize our set of bounding box rectangles and corresponding\n# confidence scores\n(numRows, numCols) = scores.shape[2:4]\nrects = []\nconfidences = []\n# loop over the number of rows\nfor y in range(0, numRows):\n    # extract the scores (probabilities), followed by the geometrical\n    # data used to derive potential bounding box coordinates that\n    # surround text\n    scoresData = scores[0, 0, y]\n    xData0 = geometry[0, 0, y]\n    xData1 = geometry[0, 1, y]\n    xData2 = geometry[0, 2, y]\n    xData3 = geometry[0, 3, y]\n    anglesData = geometry[0, 4, y]\n    # loop over the number of columns\n    for x in range(0, numCols):\n        # if our score does not have sufficient probability, ignore it\n        if scoresData[x] < args[\"min_confidence\"]:\n            continue",
        "type": "code",
        "location": "/tests/still_watermark_auto_removal/EAST-Detector-for-text-detection-using-OpenCV-master/opencv_text_detection_image.py:56-86"
    },
    "5169": {
        "file_id": 669,
        "content": "Code performs text detection using OpenCV and EAST Detector. It calculates the time taken for text prediction, extracts scores and geometrical data, filters out low-confidence detections, and stores bounding box rectangles and corresponding confidence scores in lists.",
        "type": "comment"
    },
    "5170": {
        "file_id": 669,
        "content": "        # compute the offset factor as our resulting feature maps will\n        # be 4x smaller than the input image\n        (offsetX, offsetY) = (x * 4.0, y * 4.0)\n        # extract the rotation angle for the prediction and then\n        # compute the sin and cosine\n        angle = anglesData[x]\n        cos = np.cos(angle)\n        sin = np.sin(angle)\n        # use the geometry volume to derive the width and height of\n        # the bounding box\n        h = xData0[x] + xData2[x]\n        w = xData1[x] + xData3[x]\n        # compute both the starting and ending (x, y)-coordinates for\n        # the text prediction bounding box\n        endX = int(offsetX + (cos * xData1[x]) + (sin * xData2[x]))\n        endY = int(offsetY - (sin * xData1[x]) + (cos * xData2[x]))\n        startX = int(endX - w)\n        startY = int(endY - h)\n        # add the bounding box coordinates and probability score to\n        # our respective lists\n        rects.append((startX, startY, endX, endY))\n        confidences.append(scoresData[x])\n# apply non-maxima suppression to suppress weak, overlapping bounding",
        "type": "code",
        "location": "/tests/still_watermark_auto_removal/EAST-Detector-for-text-detection-using-OpenCV-master/opencv_text_detection_image.py:88-115"
    },
    "5171": {
        "file_id": 669,
        "content": "This code computes the bounding box coordinates and confidence scores for text predictions, using input data such as angles, offsets, xData values. It then applies non-maxima suppression to suppress weak overlapping bounding boxes, likely for further processing or object detection purposes.",
        "type": "comment"
    },
    "5172": {
        "file_id": 669,
        "content": "# boxes\nboxes = non_max_suppression(np.array(rects), probs=confidences)\n# loop over the bounding boxes\nfor (startX, startY, endX, endY) in boxes:\n    # scale the bounding box coordinates based on the respective\n    # ratios\n    startX = int(startX * rW)\n    startY = int(startY * rH)\n    endX = int(endX * rW)\n    endY = int(endY * rH)\n    # draw the bounding box on the image\n    cv2.rectangle(orig, (startX, startY), (endX, endY), (0, 255, 0), 2)\n# show the output image\ncv2.imshow(\"Text Detection\", orig)\ncv2.waitKey(0)",
        "type": "code",
        "location": "/tests/still_watermark_auto_removal/EAST-Detector-for-text-detection-using-OpenCV-master/opencv_text_detection_image.py:116-133"
    },
    "5173": {
        "file_id": 669,
        "content": "This code performs non-maximum suppression on bounding box coordinates, scales the coordinates based on image ratios, draws bounding boxes on the original image using OpenCV, and displays the resulting image.",
        "type": "comment"
    },
    "5174": {
        "file_id": 670,
        "content": "/tests/still_watermark_auto_removal/automatic-watermark-detection/video_watermark_detection.py",
        "type": "filepath"
    },
    "5175": {
        "file_id": 670,
        "content": "The code employs OpenCV and Deep Learning for watermark detection, estimation, and removal. It detects video watermarks using adaptive thresholding, applies Gaussian blur, scales, and draws boxes before saving the information to a JSON file.",
        "type": "summary"
    },
    "5176": {
        "file_id": 670,
        "content": "# sample few images from a video.\nimport random\n## we import our version of cv2 here? or uninstall and reinstall opencv-python with custom things?\nimport pathlib\nimport sys\nsite_path = pathlib.Path(\"/usr/local/lib/python3.9/site-packages\")\ncv2_libs_dir = site_path / 'cv2' / f'python-{sys.version_info.major}.{sys.version_info.minor}'\nprint(cv2_libs_dir)\ncv2_libs = sorted(cv2_libs_dir.glob(\"*.so\"))\nif len(cv2_libs) == 1:\n    print(\"INSERTING:\",cv2_libs[0].parent)\n    sys.path.insert(1, str(cv2_libs[0].parent))\nimport cv2\nimport progressbar as pb\nvideoPaths = [\n    \"/root/Desktop/works/pyjom/tests/still_watermark_auto_removal/kunfu_cat.mp4\", # bilibili animal video compilation\n    \"/root/Desktop/works/pyjom/tests/bilibili_practices/bilibili_video_translate/japan_day.webm\", # youtube animation with watermark\n    \"/root/Desktop/works/pyjom/samples/video/LiGHT3ZCi.mp4\", # animal video compilation with pip and large area of watermark\n]  # his watermark. scorpa.\nvideo_path = videoPaths[2]\n# will change this shit.\n# shall we downscale this thing?",
        "type": "code",
        "location": "/tests/still_watermark_auto_removal/automatic-watermark-detection/video_watermark_detection.py:1-25"
    },
    "5177": {
        "file_id": 670,
        "content": "The code imports necessary libraries, checks and inserts custom OpenCV library paths, defines a list of video paths, and selects the third video for processing.",
        "type": "comment"
    },
    "5178": {
        "file_id": 670,
        "content": "# video = cv2.\n# video_path = \"\"\n# long loading time since we are backing up.\nsample_count = 60\nvideo_cap = cv2.VideoCapture(video_path)\nfps = video_cap.get(cv2.CAP_PROP_FPS)  # 60.\nframe_count = int(video_cap.get(cv2.CAP_PROP_FRAME_COUNT))\nprint(frame_count)\nsample_indexs = [x for x in range(frame_count)]\nsample_indexs = random.sample(sample_indexs, sample_count)\n# import copy\nimageSet = []\nfor frame_index_counter in pb.progressbar(range(frame_count)):  # are you sure?\n    success, frame = video_cap.read()\n    if not success:\n        break\n    if frame_index_counter in sample_indexs:\n        imageSet.append(frame.copy())\nfrom src import *\ngx, gy, gxlist, gylist = estimate_watermark_imgSet(imageSet)\n# print(len(imageSet))\ncropped_gx, cropped_gy, watermark_location = crop_watermark(gx, gy, location=True)\nW_m = poisson_reconstruct(cropped_gx, cropped_gy)\nW_full = poisson_reconstruct(gx, gy)\nprint(cropped_gx.shape, cropped_gy.shape, W_m.shape)  # (50, 137, 3) may vary.\nprint(watermark_location)  # ((1022, 21), (1072, 158)) inverted x,y! hell.",
        "type": "code",
        "location": "/tests/still_watermark_auto_removal/automatic-watermark-detection/video_watermark_detection.py:27-62"
    },
    "5179": {
        "file_id": 670,
        "content": "This code reads frames from a video, randomly selects some frames to analyze for watermark detection, and then estimates the watermark using poisson reconstruction. The code also outputs the shape of the detected watermark and its location on the frames. It may not use progress bar properly and has an issue with inverted x and y coordinates for watermark location.",
        "type": "comment"
    },
    "5180": {
        "file_id": 670,
        "content": "# cv2.imshow(\"WATERMARK\",W_m)\n# cv2.imshow(\"WATERMARK_FULL\",W_full)\n# # remove the freaking watermark please?\n# cv2.waitKey(0)\n# east_net = \"/media/root/help/pyjom/tests/still_watermark_auto_removal/EAST-Detector-for-text-detection-using-OpenCV-master/frozen_east_text_detection.pb\"\n# net = cv2.dnn.readNet(east_net)\n# H,W = W_full.shape[:2]\n# newH = (H//32)*32\n# newW = (W//32)*32\n# rH, rW = H/float(newH), W/float(newW)\n# W_full = cv2.resize(W_full,(newW,newH))\nmaxval, minval = np.max(W_full), np.min(W_full)\nW_full = (W_full - minval) * (255 / (maxval - minval))  # is that necessary?\n# # print(,W_full.shape,W_full.dtype)\nW_full = W_full.astype(np.uint8)\n# # breakpoint()\n# newH,newW = W_full.shape[:2]\n# # 14.122540090957173 -17.575702620638673 (1080, 1920, 3) float64\n# # you even have negative values. what the fuck?\n# blob = cv2.dnn.blobFromImage(W_full, 1.0, (newW, newH), (123.68, 116.78, 103.94), swapRB=True, crop=False)\n# # start = time.time()\n# net.setInput(blob)\n# layerNames = [\n# \t\"feature_fusion/Conv_7/Sigmoid\",",
        "type": "code",
        "location": "/tests/still_watermark_auto_removal/automatic-watermark-detection/video_watermark_detection.py:64-91"
    },
    "5181": {
        "file_id": 670,
        "content": "The code is using OpenCV and TensorFlow to detect and remove a watermark from an input image. It resizes the input image, normalizes pixel values, preprocesses the image with a DNN (Deep Neural Network), and then sets the input for the network's feature extraction layer.",
        "type": "comment"
    },
    "5182": {
        "file_id": 670,
        "content": "# \t\"feature_fusion/concat_3\"]\n# (scores, geometry) = net.forward(layerNames)\n# def decode_predictions(scores, geometry,min_confidence=0.5):\n# \t# grab the number of rows and columns from the scores volume, then\n# \t# initialize our set of bounding box rectangles and corresponding\n# \t# confidence scores\n# \t(numRows, numCols) = scores.shape[2:4]\n# \trects = []\n# \tconfidences = []\n# \t# loop over the number of rows\n# \tfor y in range(0, numRows):\n# \t\t# extract the scores (probabilities), followed by the\n# \t\t# geometrical data used to derive potential bounding box\n# \t\t# coordinates that surround text\n# \t\tscoresData = scores[0, 0, y]\n# \t\txData0 = geometry[0, 0, y]\n# \t\txData1 = geometry[0, 1, y]\n# \t\txData2 = geometry[0, 2, y]\n# \t\txData3 = geometry[0, 3, y]\n# \t\tanglesData = geometry[0, 4, y]\n# \t\t# loop over the number of columns\n# \t\tfor x in range(0, numCols):\n# \t\t\t# if our score does not have sufficient probability,\n# \t\t\t# ignore it\n# \t\t\tif scoresData[x] < min_confidence:\n# \t\t\t\tcontinue\n# \t\t\t# compute the offset factor as our resulting feature",
        "type": "code",
        "location": "/tests/still_watermark_auto_removal/automatic-watermark-detection/video_watermark_detection.py:92-119"
    },
    "5183": {
        "file_id": 670,
        "content": "The code is decoding the predictions of a deep learning model for watermark detection. It iterates through the scores and geometrical data to extract bounding box coordinates and angles, discarding low-confidence predictions.",
        "type": "comment"
    },
    "5184": {
        "file_id": 670,
        "content": "# \t\t\t# maps will be 4x smaller than the input image\n# \t\t\t(offsetX, offsetY) = (x * 4.0, y * 4.0)\n# \t\t\t# extract the rotation angle for the prediction and\n# \t\t\t# then compute the sin and cosine\n# \t\t\tangle = anglesData[x]\n# \t\t\tcos = np.cos(angle)\n# \t\t\tsin = np.sin(angle)\n# \t\t\t# use the geometry volume to derive the width and height\n# \t\t\t# of the bounding box\n# \t\t\th = xData0[x] + xData2[x]\n# \t\t\tw = xData1[x] + xData3[x]\n# \t\t\t# compute both the starting and ending (x, y)-coordinates\n# \t\t\t# for the text prediction bounding box\n# \t\t\tendX = int(offsetX + (cos * xData1[x]) + (sin * xData2[x]))\n# \t\t\tendY = int(offsetY - (sin * xData1[x]) + (cos * xData2[x]))\n# \t\t\tstartX = int(endX - w)\n# \t\t\tstartY = int(endY - h)\n# \t\t\t# add the bounding box coordinates and probability score\n# \t\t\t# to our respective lists\n# \t\t\trects.append((startX, startY, endX, endY))\n# \t\t\tconfidences.append(scoresData[x])\n# \t# return a tuple of the bounding boxes and associated confidences\n# \treturn (rects, confidences)\n# (rects, confidences) = decode_predictions(scores, geometry)",
        "type": "code",
        "location": "/tests/still_watermark_auto_removal/automatic-watermark-detection/video_watermark_detection.py:120-144"
    },
    "5185": {
        "file_id": 670,
        "content": "This code block extracts the rotation angle, computes sin and cosine values, derives bounding box width and height from geometry volume, calculates starting and ending coordinates of text prediction bounding boxes, appends these coordinates to rects list, and probability scores to confidences list. Finally, it returns a tuple containing the bounding boxes and associated confidences.",
        "type": "comment"
    },
    "5186": {
        "file_id": 670,
        "content": "# from imutils.object_detection import non_max_suppression\n# boxes = non_max_suppression(np.array(rects), probs=confidences)\n# rW=rH=1\n# no box painting.\n# for (startX, startY, endX, endY) in boxes:\n#     # scale the bounding box coordinates based on the respective\n#     # ratios\n#     startX = int(startX * rW)\n#     startY = int(startY * rH)\n#     endX = int(endX * rW)\n#     endY = int(endY * rH)\n#     # draw the bounding box on the frame\n#     cv2.rectangle(W_full, (startX, startY), (endX, endY), (0, 255, 0), 2)\n# # you could implement your own watermark detector network so far. it is easy.\n# # maybe directly using optical flow and gradients will be prettier?\n# W_full\nsrc = W_full\nscale_percent = 50\n# calculate the 50 percent of original dimensions\nwidth = int(src.shape[1] * scale_percent / 100)\nheight = int(src.shape[0] * scale_percent / 100)\n# dsize\ndsize = (width, height)\n# resize image\noutput = cv2.resize(src, dsize)\ngray_output = cv2.cvtColor(output, cv2.COLOR_BGR2GRAY)\ngray_output = cv2.GaussianBlur(gray_output, (11, 3), 0)",
        "type": "code",
        "location": "/tests/still_watermark_auto_removal/automatic-watermark-detection/video_watermark_detection.py:146-181"
    },
    "5187": {
        "file_id": 670,
        "content": "The code performs non-maximum suppression on rectangles, scales bounding box coordinates based on aspect ratios, draws bounding boxes on frames, and resizes the image with 50% scale while converting it to grayscale and applying Gaussian blur.",
        "type": "comment"
    },
    "5188": {
        "file_id": 670,
        "content": "thresh_output = cv2.adaptiveThreshold(\n    gray_output, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 11, 2\n)\nthresh_output = 255 - thresh_output\n# cnts, hierachy = cv2.findContours(thresh_output,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE) # really freaking bad. we should invert this.\ncnts, hierachy = cv2.findContours(\n    thresh_output, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE\n)  # really freaking bad. we should invert this.\n# cv2.RETR_EXTERNAL\n[a, b] = output.shape[:2]\nmyMask = np.zeros(shape=[a, b], dtype=np.uint8)\n# this is for video watermarks. how about pictures? do we need to cut corners? how to find the freaking watermark again?\nfor cnt in cnts:\n    x, y, w, h = cv2.boundingRect(cnt)  # Draw the bounding box image=\n    # cv2.rectangle(output, (x,y), (x+w,y+h), (0,0,255),2)\n    cv2.rectangle(myMask, (x, y), (x + w, y + h), 255, -1)\ndilated_mask = cv2.GaussianBlur(myMask, (11, 11), 0)\ncv2.threshold(dilated_mask, 256 / 2, 255, cv2.THRESH_BINARY, dilated_mask)\ncnts2, hierachy2 = cv2.findContours(",
        "type": "code",
        "location": "/tests/still_watermark_auto_removal/automatic-watermark-detection/video_watermark_detection.py:183-206"
    },
    "5189": {
        "file_id": 670,
        "content": "This code applies adaptive thresholding to detect watermarks in a video. It then identifies contours and creates a mask using bounding boxes, applies Gaussian blur, and finally finds the contours again for further processing.",
        "type": "comment"
    },
    "5190": {
        "file_id": 670,
        "content": "    dilated_mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE\n)\nmyMask2 = np.zeros(shape=[a, b], dtype=np.uint8)\n# this is for video watermarks. how about pictures? do we need to cut corners? how to find the freaking watermark again?\nheight, width = myMask2.shape[:2]\nrectangles = []\nfor cnt in cnts2:\n    x, y, w, h = cv2.boundingRect(cnt)  # Draw the bounding box image=\n    # cv2.rectangle(output, (x,y), (x+w,y+h), (0,0,255),2)\n    rectangles.append((x,y,w,h))\n    cv2.rectangle(myMask2, (x, y), (x + w, y + h), 255, -1)\nimport json\ndata = {\"canvas\":(width, height), 'rectangles':rectangles}\ndataString = json.dumps(data)\nwith open(\"test.json\", 'w+') as f: f.write(dataString)\nprint(\"TOTAL {} CONTOURS.\".format(len(cnts2)))  # paint those contours.\n# cv2.imshow(\"IMAGE\",thresh_output)\ncv2.imshow(\"MPICTURE\", myMask2)\ncv2.waitKey(0)\n# fill those areas and you will get it.\n# how do we remove this shit?\n# also how do we remove other weird things? like floating watermarks?\n# print(imageSet[0].shape)\n# breakpoint()",
        "type": "code",
        "location": "/tests/still_watermark_auto_removal/automatic-watermark-detection/video_watermark_detection.py:207-239"
    },
    "5191": {
        "file_id": 670,
        "content": "Code creates a mask for video watermarks by detecting contours and drawing bounding boxes. It saves the mask information to a JSON file. The code also displays the mask as an image. The code is not specifically designed for images; modifications are needed to handle other formats like images with floating watermarks.",
        "type": "comment"
    },
    "5192": {
        "file_id": 671,
        "content": "/tests/taobao_guangguang_download_哇哦视频_淘宝逛逛_tiktok_douyin/wtf_is_this_shit.sh",
        "type": "filepath"
    },
    "5193": {
        "file_id": 671,
        "content": "Downloading and unzipping main.json from a URL, saving it as wtf_is_this2.",
        "type": "summary"
    },
    "5194": {
        "file_id": 671,
        "content": "# curl -o - https://g.alicdn.com/tnode/fullpageshortvideo/2.1.0/main.json.json | gunzip -c > wtf_is_this2\n# file wtf_is_this # data\n# gzipped.",
        "type": "code",
        "location": "/tests/taobao_guangguang_download_哇哦视频_淘宝逛逛_tiktok_douyin/wtf_is_this_shit.sh:1-3"
    },
    "5195": {
        "file_id": 671,
        "content": "Downloading and unzipping main.json from a URL, saving it as wtf_is_this2.",
        "type": "comment"
    },
    "5196": {
        "file_id": 672,
        "content": "/tests/taobao_guangguang_download_哇哦视频_淘宝逛逛_tiktok_douyin/view_weishi_capture_data.sh",
        "type": "filepath"
    },
    "5197": {
        "file_id": 672,
        "content": "This code runs MITM proxy with logs from \"logs.log\" and hits the URL for getting Weishi play page in a H5 environment.",
        "type": "summary"
    },
    "5198": {
        "file_id": 672,
        "content": "mitmproxy -r logs.log\n# http://h5.weishi.qq.com/webapp/json/weishi/WSH5GetPlayPage",
        "type": "code",
        "location": "/tests/taobao_guangguang_download_哇哦视频_淘宝逛逛_tiktok_douyin/view_weishi_capture_data.sh:1-2"
    },
    "5199": {
        "file_id": 672,
        "content": "This code runs MITM proxy with logs from \"logs.log\" and hits the URL for getting Weishi play page in a H5 environment.",
        "type": "comment"
    }
}