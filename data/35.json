{
    "3500": {
        "file_id": 429,
        "content": "    )\n    args = parser.parse_args()\n    if not args.replace:\n        assert args.output != \"\"\n    main(\n        args.input,\n        args.target,\n        f_out=args.output,\n        in_place=args.replace,\n        # audio=args.audio\n    )",
        "type": "code",
        "location": "/tests/moviepy_loop_video_till_target/loop_till_target.py:117-128"
    },
    "3501": {
        "file_id": 429,
        "content": "The code initializes a parser, parses command line arguments, asserts the absence of replace flag or an output path specified, and then calls the main function with the input, target, output (if applicable), and replace (if applicable) arguments.",
        "type": "comment"
    },
    "3502": {
        "file_id": 430,
        "content": "/tests/ffmpeg_python_test/test.py",
        "type": "filepath"
    },
    "3503": {
        "file_id": 430,
        "content": "The code utilizes FFmpeg library to crop, resize, and pad videos before concatenating modified video streams with original audio using ffmpeg, addressing API complexity.",
        "type": "summary"
    },
    "3504": {
        "file_id": 430,
        "content": "import ffmpeg\ndef basicTrimVideoProcess():\n    input_source = \"/root/Desktop/works/pyjom/samples/video/karaoke_effects_source.mp4\"\n    stream = ffmpeg.input(input_source,ss=4, to=10) # from 4 to 10 seconds?\n    # stream = ffmpeg.hflip(stream)\n    # we just need to crop this.\n    stream = ffmpeg.output(stream, 'output.mp4')\n    ffmpeg.run(stream, overwrite_output=True)\ndef getRandomCrop(width, height):\n    import random\n    randomGenerator = lambda: random.uniform(0.3, 0.8)\n    newWidth, newHeight = int(randomGenerator()*width), int(randomGenerator()*height)\n    newX, newY = random.randint(0, width-newWidth-1), random.randint(0, height-newHeight-1) # maybe we need to reserve that.\n    return newX, newY, newWidth, newHeight\n# pipCrop in some span?\ndef cropVideoRegion():\n    # this lasts for 6 seconds.\n    # what is the shape of your thing?\n    # just use simple concat. right?\n    # 334x188\n    from MediaInfo import MediaInfo\n    info = MediaInfo(filename = 'output.mp4')\n    infoData = info.getInfo()\n    # print(infoData)",
        "type": "code",
        "location": "/tests/ffmpeg_python_test/test.py:1-30"
    },
    "3505": {
        "file_id": 430,
        "content": "The code imports the ffmpeg library and defines three functions. The first function, `basicTrimVideoProcess()`, trims a video file from 4 to 10 seconds and outputs it as 'output.mp4'. The second function, `getRandomCrop(width, height)`, generates random crop values for a given image width and height using the random module. The third function, `cropVideoRegion()`, uses MediaInfo to get information about the video file, potentially for cropping.",
        "type": "comment"
    },
    "3506": {
        "file_id": 430,
        "content": "    # breakpoint()\n    defaultWidth = infoData[\"videoWidth\"]\n    defaultHeight = infoData[\"videoHeight\"]\n    # not only crop, but ZOOM!\n    import math\n    x, y, width, height = getRandomCrop(defaultWidth, defaultHeight)\n    minRatio = min(defaultWidth/width, defaultHeight/height)\n    newWidth = math.floor(minRatio*width)\n    newHeight = math.floor(minRatio*height)\n    stream_0 = ffmpeg.input(\"output.mp4\",ss=0, to=2)\n    stream_0_audio = stream_0.audio\n    stream_0_video = stream_0.video.crop(x,y,width, height).filter(\"scale\", newWidth, newHeight).filter(\"pad\",x=math.floor((defaultWidth-newWidth)/2), y=math.floor((defaultHeight-newHeight)/2), width=defaultWidth, height=defaultHeight,color=\"black\")\n    x, y, width, height = getRandomCrop(defaultWidth, defaultHeight)\n    minRatio = min(defaultWidth/width, defaultHeight/height)\n    newWidth = math.floor(minRatio*width)\n    newHeight = math.floor(minRatio*height)\n    stream_1 = ffmpeg.input(\"output.mp4\",ss=2, to=4)\n    stream_1_audio = stream_1.audio\n    st",
        "type": "code",
        "location": "/tests/ffmpeg_python_test/test.py:31-53"
    },
    "3507": {
        "file_id": 430,
        "content": "This code is performing a double crop and zoom operation on an input video file named \"output.mp4\". It reads the default width and height from infoData, then applies random cropping and scaling to create two separate video streams (stream_0 and stream_1) using ffmpeg library. Finally, it pads the scaled and cropped videos with a black border before proceeding.",
        "type": "comment"
    },
    "3508": {
        "file_id": 430,
        "content": "ream_1_video = stream_1.video.crop(x, y, width, height).filter(\"scale\", newWidth, newHeight).filter(\"pad\",x=math.floor((defaultWidth-newWidth)/2), y=math.floor((defaultHeight-newHeight)/2), width=defaultWidth, height=defaultHeight,color=\"black\")\n    x, y, width, height = getRandomCrop(defaultWidth, defaultHeight)\n    minRatio = min(defaultWidth/width, defaultHeight/height)\n    newWidth = math.floor(minRatio*width)\n    newHeight = math.floor(minRatio*height)\n    stream_2 = ffmpeg.input(\"output.mp4\",ss=4, to=6)\n    stream_2_audio = stream_2.audio\n    stream_2_video = stream_2.video.crop(x,y,width, height).filter(\"scale\", newWidth, newHeight).filter(\"pad\",x=math.floor((defaultWidth-newWidth)/2), y=math.floor((defaultHeight-newHeight)/2), width=defaultWidth, height=defaultHeight,color=\"black\")\n    # stream_0 = stream_0.output(\"pipCrop.mp4\")\n    video_stream = ffmpeg.concat(stream_0_video, stream_1_video, stream_2_video)\n    audio_stream = ffmpeg.concat(stream_0_audio,stream_1_audio, stream_2_audio,v=0, a=1)",
        "type": "code",
        "location": "/tests/ffmpeg_python_test/test.py:53-66"
    },
    "3509": {
        "file_id": 430,
        "content": "This code is cropping and resizing video streams from different input sources, applying padding if necessary. It then concatenates the modified video streams and the original audio streams into a single output file. The process involves getting random crop parameters, scaling and padding videos to maintain aspect ratio, and finally concatenating the streams.",
        "type": "comment"
    },
    "3510": {
        "file_id": 430,
        "content": "    # stream = ffmpeg.concat(stream_0, stream_1, stream_2)\n    stream = ffmpeg.output(video_stream, audio_stream,\"pipCrop.mp4\")\n    stream.run(overwrite_output=True)\n    # stream = ffmpeg.concat(stream_0.video, stream_0.audio, stream_1.video, stream_1.audio, stream_2.video, stream_2.audio, v=1, a=1)\n    # # there is no audio down here! fuck.\n    # stream = ffmpeg.output(stream,\"pipCrop.mp4\")\n    # stream.run(overwrite_output=True)\ndef concatVideoWithAudio():\n    stream_0 = ffmpeg.input(\"output.mp4\",ss=0, t=3)\n    stream_1 = ffmpeg.input(\"output.mp4\",ss=3, t=6)\n    stream = ffmpeg.concat(stream_0.video, stream_0.audio, stream_1.video, stream_1.audio, v=1, a=1)\n    # print(stream)\n    # breakpoint()\n    stream = ffmpeg.output(stream, \"concatVideo.mp4\")\n    # print(stream.get_args())\n    stream.run(overwrite_output=True)\ndef delogoTest():\n    from MediaInfo import MediaInfo\n    info = MediaInfo(filename = 'output.mp4')\n    infoData = info.getInfo()\n    # print(infoData)\n    # breakpoint()\n    defaultWidth = infoData[\"videoWidth\"]",
        "type": "code",
        "location": "/tests/ffmpeg_python_test/test.py:68-96"
    },
    "3511": {
        "file_id": 430,
        "content": "This code concatenates videos and audio streams using the FFmpeg library. It merges video and audio from separate inputs, then outputs the resulting stream to a file. The code also includes functions for MediaInfo to retrieve information about a media file.",
        "type": "comment"
    },
    "3512": {
        "file_id": 430,
        "content": "    defaultHeight = infoData[\"videoHeight\"]\n    import math\n    stream_0 = ffmpeg.input(\"output.mp4\", ss=0, to=3)\n    x,y,width, height = getRandomCrop(defaultWidth,defaultHeight) # get our delogo area.\n    stream_0_video = stream_0.video.filter(\"delogo\", x=x, y=y, w=width, h=height, show=1)\n    stream_0_audio = stream_0.audio\n    stream_1 = ffmpeg.input(\"output.mp4\", ss=3, to=6)\n    x,y,width, height = getRandomCrop(defaultWidth,defaultHeight) # get our delogo area.\n    stream_1_video = stream_1.video.filter(\"delogo\", x=x, y=y, w=width, h=height, show=1)\n    x,y,width, height = getRandomCrop(defaultWidth,defaultHeight) # get our delogo area.\n    stream_1_video = stream_1_video.filter(\"delogo\", x=x, y=y, w=width, h=height, show=1)\n    stream_1_audio = stream_1.audio\n    # we must specify the time first.\n    # it is like a compiler! ffmpeg commandline (also its library, mind-blowingly crazy and complex) really sucks. thanks, ffmpeg-python wrapper.\n    video_stream = ffmpeg.concat(stream_0_video, stream_1_video)",
        "type": "code",
        "location": "/tests/ffmpeg_python_test/test.py:97-114"
    },
    "3513": {
        "file_id": 430,
        "content": "Code snippet takes input video \"output.mp4\", crops and overlays delogo in different positions, concatenates the two resulting videos with a 3-second overlap, and assigns audio streams. The comment about ffmpeg commandline complexity reflects frustration with its API.",
        "type": "comment"
    },
    "3514": {
        "file_id": 430,
        "content": "    audio_stream = ffmpeg.concat(stream_0_audio, stream_1_audio, v=0,a=1)\n    stream = ffmpeg.output(video_stream, audio_stream,\"delogoTest.mp4\")\n    stream.run(overwrite_output=True)\nif __name__ == \"__main__\":\n    # cropVideoRegion()\n    # concatVideoWithAudio() # damn quiet out there.\n    delogoTest()",
        "type": "code",
        "location": "/tests/ffmpeg_python_test/test.py:115-122"
    },
    "3515": {
        "file_id": 430,
        "content": "The code is using the ffmpeg library to concatenate two audio streams (stream_0_audio and stream_1_audio) and then output the resulting video stream with the audio stream to a file named \"delogoTest.mp4\". The overwrite_output parameter ensures that if the file already exists, it will be overwritten. This code is part of the delogoTest() function, which is being executed if the script is run as the main program.",
        "type": "comment"
    },
    "3516": {
        "file_id": 431,
        "content": "/tests/elastic_search_engine/README.md",
        "type": "filepath"
    },
    "3517": {
        "file_id": 431,
        "content": "The code suggests that there is a need for a memory-efficient search engine, possibly due to limited resources. It also mentions Meilisearch as a potential option but expresses concerns about its memory intensity or the team's mastery of it.",
        "type": "summary"
    },
    "3518": {
        "file_id": 431,
        "content": "we need a memory efficient search engine, under limited memory.\nmeilisearch is memory intensive maybe? or just because we have not properly mastered it",
        "type": "code",
        "location": "/tests/elastic_search_engine/README.md:1-3"
    },
    "3519": {
        "file_id": 431,
        "content": "The code suggests that there is a need for a memory-efficient search engine, possibly due to limited resources. It also mentions Meilisearch as a potential option but expresses concerns about its memory intensity or the team's mastery of it.",
        "type": "comment"
    },
    "3520": {
        "file_id": 432,
        "content": "/tests/editly_test_video_render_with_bgm/test.sh",
        "type": "filepath"
    },
    "3521": {
        "file_id": 432,
        "content": "This code sets up a headless Linux machine to run test cases for the Editly application using xvfb-run and specifying test parameters in a json5 file. It also discusses potential alternative methods and options for audio handling, resolution, and file playback.",
        "type": "summary"
    },
    "3522": {
        "file_id": 432,
        "content": "# run in headless linux machine! test both xvfp specs?\nxvfb-run -s \"-ac -screen 0 1280x1024x24\" editly test.json5  # this will suffice. json5 will specify all specs? or use our GUI service run specifications (envs)?\n# sometimes we have weird issues with the ffplay. use 'open' instead? does quicktime automatically repair the file by itself?\n# xvfb-run -s \"-ac -screen 0 1920x1080x24\" editly test.json5 --fast # this will suffice. json5 will specify all specs? this 'fast' setting definitely reduced the output resolution to 334x188 15fps, which just saves my time in final production or remote preview from n2n/frp\n# without --keep-source-audio, will we not hear anything from the source video?\n# json5: json for humans\n# this much likely to bring python dict and json objects into a single readable format.",
        "type": "code",
        "location": "/tests/editly_test_video_render_with_bgm/test.sh:1-11"
    },
    "3523": {
        "file_id": 432,
        "content": "This code sets up a headless Linux machine to run test cases for the Editly application using xvfb-run and specifying test parameters in a json5 file. It also discusses potential alternative methods and options for audio handling, resolution, and file playback.",
        "type": "comment"
    },
    "3524": {
        "file_id": 433,
        "content": "/tests/random_giphy_gifs/test_sdk.js",
        "type": "filepath"
    },
    "3525": {
        "file_id": 433,
        "content": "The code imports libraries, initializes the GiphyFetch API, defines a function to write JSON data, and tests various API functions such as trending gifs, searching for dog-related gifs, retrieving related gifs, listing categories, and searching with keywords. The results are saved in separate JSON files.",
        "type": "summary"
    },
    "3526": {
        "file_id": 433,
        "content": "// Require with custom API key\n// const myBetaApiKey = 'IoJVsWoxDPKBr6gOcCgOPWAB25773hqP';\nconst myBetaApiKey = \"Gc7131jiJuvI7IdN0HZ1D7nh0ow5BU6g\"; // some common web browser based things.\n// maybe they just don't distinguish api and sdk keys. fuck.\n// sXpGFDGZs0Dv1mmNFvYaGUvYwKX0PWIh\n// is this key limited? or is it production ready?\nconst fetch = require('node-fetch');\nconst fs = require(\"fs\");\nconst JsonFormat = require(\"json-format\")\nconst { GiphyFetch } = require('@giphy/js-fetch-api')\nconst gf = new GiphyFetch(myBetaApiKey)\n// fetch 10 gifs\nfunction writeJsonToFile(json, filename) {\n    // let data = JSON.stringify(json);\n    let data = JsonFormat(json)\n    fs.writeFile(filename, data, function(err) {\n        if (err) {\n            console.error(err);\n        } else {\n            console.log(filename + \" has been saved with the json data\");\n        }\n    });\n}\n// console.log(data)\n// https://bobbyhadz.com/blog/javascript-error-err-require-esm-of-es-module-node-fetch\n// fucking hell?\n// data.then((result) =>{console.log('TRENDING OUTPUT');",
        "type": "code",
        "location": "/tests/random_giphy_gifs/test_sdk.js:1-35"
    },
    "3527": {
        "file_id": 433,
        "content": "Code imports necessary libraries and initializes the GiphyFetch API with a custom key. It defines a function to write JSON data to a file, and then fetches 10 trending gifs using the API.",
        "type": "comment"
    },
    "3528": {
        "file_id": 433,
        "content": "// writeJsonToFile(result, 'trending.json')\n// })\nasync function test(){\n// var data = await gf.trending({ limit: 10 }) // a promise\n// search for related things dog related things.\n// await writeJsonToFile(data,'trending.json')\n// var data = await gf.search('dog cute', { sort: 'relevant', rating: 'g'});\n// await writeJsonToFile(data,'cute_dog.json')\n// var relatedId = \"QvBoMEcQ7DQXK\"\n// var data = await gf.related(relatedId, { limit: 50 })\n// await writeJsonToFile(data,'related.json')\n// const data = await gf.categories() // category are actually keywords here.\n// // data.forEach((category) => {\n// //     console.log(category) // ICategory\n// // })\n// await writeJsonToFile(data,'categories.json')\n// var data = await gf.gifs('animals','bulldog') // not freaking found!\nvar data = await gf.gifs('animals','samoyed') // freaking works! guess it is just keyword based search\nawait writeJsonToFile(data, 'samoyed_subcategory2.json')\n}\ntest()",
        "type": "code",
        "location": "/tests/random_giphy_gifs/test_sdk.js:36-61"
    },
    "3529": {
        "file_id": 433,
        "content": "This code tests various Giphy API functions. It fetches trending gifs, searches for dog-related gifs, retrieves related gifs, lists available categories, and searches for gifs using different keywords. The test results are saved in separate JSON files.",
        "type": "comment"
    },
    "3530": {
        "file_id": 434,
        "content": "/tests/random_giphy_gifs/test_api.js",
        "type": "filepath"
    },
    "3531": {
        "file_id": 434,
        "content": "This code uses 'giphy-api', 'json-format', and 'fs' modules to search for \"pokemon\" and \"dog funny\" GIFs, checking duration and saving results as JSON files. Error logging and 'writeJsonToFile' function are included.",
        "type": "summary"
    },
    "3532": {
        "file_id": 434,
        "content": "// Require with custom API key\n// const myBetaApiKey = 'IoJVsWoxDPKBr6gOcCgOPWAB25773hqP';\nconst myBetaApiKey = \"Gc7131jiJuvI7IdN0HZ1D7nh0ow5BU6g\"; // some common web browser based things.\n// can we prepare some key server? i don't know. wtf is this shit?\nvar giphy = require('giphy-api')(myBetaApiKey);\nconst JsonFormat = require(\"json-format\")\nconst fs = require(\"fs\");\nfunction writeJsonToFile(json, filename) {\n    // let data = JSON.stringify(json);\n    let data = JsonFormat(json)\n    fs.writeFile(filename, data, function(err) {\n        if (err) {\n            console.error(err);\n        } else {\n            console.log(filename + \" has been saved with the json data\");\n        }\n    });\n}\n// // Require with the public beta key\n// var giphy = require('giphy-api')(); // banned. cannot use this public api.\n// it may timeout!\n// giphy.search({\n//     q: 'pokemon',\n//     rating: 'g'\n// }, function(err, res) {\n//     // Res contains gif data!\n//     console.log('ERROR?', err); //null if normal.\n//     // save it to json?",
        "type": "code",
        "location": "/tests/random_giphy_gifs/test_api.js:1-31"
    },
    "3533": {
        "file_id": 434,
        "content": "Code snippet requires the 'giphy-api', 'json-format', and 'fs' modules. It defines a function 'writeJsonToFile' to write JSON data to file. The API key is set for a custom Giphy API, and it mentions a public API key that is currently banned. The code then searches for GIFs related to \"pokemon\" with a \"g\" rating, and plans to save the results as JSON to a file.",
        "type": "comment"
    },
    "3534": {
        "file_id": 434,
        "content": "//     writeJsonToFile(res, 'pokemon_test.json');\n// });   \n//     // save it to json?\n//     writeJsonToFile(res, 'pokemon_test.json');\n// });\n// giphy.search({\n//     q: 'pokemon',\n//     rating: 'y'\n// }, function(err, res) {\n//     // Res contains gif data!\n//     console.log('ERROR?', err); //null if normal.\n//     // save it to json?\n//     writeJsonToFile(res, 'pokemon_test_youth.json');\n// });\n// question: is that still image?\n// check the duration bro. filter out those ridiculusly short ones.\n// Input £0, gif, from 'still_gif_image.gif':\n// Duration: 00:00:00.84, start: 0.000000, bitrate: 635 kb/s\n// Stream £0:0: Video: gif, bgra, 300x200, 19.42 fps, 25 tbr, 100 tbn\n// giphy.random({\n//     tag: 'dog funny',\n//     rating: 'g',\n//     fmt: 'json',\n// }, function (err, res) {\n//     console.log('ERROR?', err); //null if normal.\n//     // save it to json?\n//     writeJsonToFile(res, 'funny_dog_test.json');\n// });\ngiphy.id('feqkVgjJpYtjy', function (err, res) { // only one reply. there are no other fancy shits.",
        "type": "code",
        "location": "/tests/random_giphy_gifs/test_api.js:32-64"
    },
    "3535": {
        "file_id": 434,
        "content": "This code is making API requests to Giphy, retrieving gifs based on different search criteria (pokemon and dog funny), and then saving the returned data as JSON files. It also checks the duration of the gif to filter out extremely short ones. The 'writeJsonToFile' function is used to save the gif data as JSON.",
        "type": "comment"
    },
    "3536": {
        "file_id": 434,
        "content": "    console.log('ERROR?', err); //null if normal.\n    // save it to json?\n    writeJsonToFile(res, 'id_search2.json');\n});",
        "type": "code",
        "location": "/tests/random_giphy_gifs/test_api.js:65-68"
    },
    "3537": {
        "file_id": 434,
        "content": "This code logs an error message if there is an error, and then saves the response to a JSON file named 'id_search2.json' using the writeJsonToFile function.",
        "type": "comment"
    },
    "3538": {
        "file_id": 435,
        "content": "/tests/random_giphy_gifs/README.md",
        "type": "filepath"
    },
    "3539": {
        "file_id": 435,
        "content": "The code provides Giphy API keys and usage information, defining global variables for authentication and access to GIPHY's APIs, including public and sdk keys. Links to GitHub repositories guide users on implementation.",
        "type": "summary"
    },
    "3540": {
        "file_id": 435,
        "content": "# random giphy gifs\ngiphy has many extensible apis. i guess most media platforms are all the same (complex enough), but we have to start somewhere though...\ngiphy has 'clips' now. clips are gifs with sound, just like short videos.\nbeta key limitations:\n1000 requests per day, 42 requests per hour\nor just use the public beta key? does that subject to the rate limit?\n```javascript\nvar PUBLIC_BETA_API_KEY = 'dc6zaTOxFJmzC';\n```\napi keys:\nIoJVsWoxDPKBr6gOcCgOPWAB25773hqP\nlTRWAEGHjB1AkfO0sk2XTdujaPB5aH7X\nsdk keys:\n6esYBEm9OG3wAifbBFZ2mA0Ml6Ic0rvy\nto use api:\nhttps://github.com/austinkelleher/giphy-api\nto use sdk:\nhttps://github.com/Giphy/giphy-js/blob/master/packages/fetch-api/README.md\nfind public api keys inside html:\n```javascript\n          window.GIPHY_FE_MOBILE_API_KEY = \"L8eXbxrbPETZxlvgXN9kIEzQ55Df04v0\"\n          window.GIPHY_FE_WEB_API_KEY = \"Gc7131jiJuvI7IdN0HZ1D7nh0ow5BU6g\"\n          window.GIPHY_FE_FOUR_O_FOUR_API_KEY = \"MRwXFtxAnaHo3EUMrSefHWmI0eYz5aGe\"\n          window.GIPHY_FE_STORIES_AND_GIPHY_TV_API_KEY = \"3eFQvabDx69SMoOemSPiYfh9FY0nzO9x\"",
        "type": "code",
        "location": "/tests/random_giphy_gifs/README.md:1-34"
    },
    "3541": {
        "file_id": 435,
        "content": "This code snippet provides information about Giphy APIs, their usage, and API keys. The PUBLIC_BETA_API_KEY is defined in JavaScript, and there are various public and sdk keys listed for using the Giphy APIs. Links to GitHub repositories are provided for guidance on how to use them, and four public API keys found inside HTML elements are also mentioned.",
        "type": "comment"
    },
    "3542": {
        "file_id": 435,
        "content": "          window.GIPHY_FE_DEFAULT_API_SERVICE_KEY = \"5nt3fDeGakBKzV6lHtRM1zmEBAs6dsIc\"\n          window.GIPHY_FE_GET_POST_HEADERS_KEY = \"e0771ed7b244ec9c942bea646ad08e6bf514f51a\"\n          window.GIPHY_FE_MEDIUM_BLOG_API_KEY = \"i3dev0tcpgvcuaocfmdslony2q9er7tvfndxcszm\"\n          window.GIPHY_FE_EMBED_KEY = \"eDs1NYmCVgdHvI1x0nitWd5ClhDWMpRE\"\n```\nsearch for 'ear flops' to locate the tags in 'samoyed.html'",
        "type": "code",
        "location": "/tests/random_giphy_gifs/README.md:35-41"
    },
    "3543": {
        "file_id": 435,
        "content": "This code sets the GIPHY API service key, get headers key, medium blog API key, and embed key as global variables in the window object. These keys are used to authenticate and access GIPHY's APIs for fetching gifs and related content.",
        "type": "comment"
    },
    "3544": {
        "file_id": 436,
        "content": "/tests/random_giphy_gifs/nodejs_server.js",
        "type": "filepath"
    },
    "3545": {
        "file_id": 436,
        "content": "This Node.js server code handles Giphy API requests, provides error-handling functions for processing elements and retrieving GIFs, and serves responses while listening on port 8902.",
        "type": "summary"
    },
    "3546": {
        "file_id": 436,
        "content": "const http = require('http');\n// const url = require('url');\nconst { GiphyFetch } = require('@giphy/js-fetch-api');\nconst GiphyApi = require('giphy-api');\nfunction randomAPIKey() {\n    webApiKeys = [\"L8eXbxrbPETZxlvgXN9kIEzQ55Df04v0\", \"Gc7131jiJuvI7IdN0HZ1D7nh0ow5BU6g\", \"MRwXFtxAnaHo3EUMrSefHWmI0eYz5aGe\", \"3eFQvabDx69SMoOemSPiYfh9FY0nzO9x\", \"5nt3fDeGakBKzV6lHtRM1zmEBAs6dsIc\", \"eDs1NYmCVgdHvI1x0nitWd5ClhDWMpRE\"]\n    publicSdkKeys = [\"Gc7131jiJuvI7IdN0HZ1D7nh0ow5BU6g\"]\n    apiKeys = ['IoJVsWoxDPKBr6gOcCgOPWAB25773hqP', 'lTRWAEGHjB1AkfO0sk2XTdujaPB5aH7X']\n    sdkKeys = ['6esYBEm9OG3wAifbBFZ2mA0Ml6Ic0rvy', 'sXpGFDGZs0Dv1mmNFvYaGUvYwKX0PWIh']\n    items = webApiKeys.concat(publicSdkKeys).concat(apiKeys).concat(sdkKeys)\n        // deleted some unqualified api keys because they look different in length\n    item = items[Math.floor(Math.random() * items.length)];\n    console.log(\"using api key: \" + item)\n    return item\n}\nfunction randInt(start, end) {\n    if (start > end) {\n        medium = end\n        end = start",
        "type": "code",
        "location": "/tests/random_giphy_gifs/nodejs_server.js:1-22"
    },
    "3547": {
        "file_id": 436,
        "content": "Code snippet defines two functions:\n1. `randomAPIKey()` - generates a random API key from provided arrays of keys, logs the chosen key, and returns it.\n2. `randInt(start, end)` - takes a start and an end number, if start is greater than end, swaps them internally and returns a random integer between the two numbers.",
        "type": "comment"
    },
    "3548": {
        "file_id": 436,
        "content": "        start = medium\n    } else if (start == end) {\n        return Math.floor(start)\n    }\n    return Math.floor(Math.random() * (end - start) + start)\n}\nfunction processElemUncatched(elem, typeFilter) {\n    if ('type' in elem) {\n        dataType = elem['type']\n        if (typeFilter.indexOf(dataType) == -1) {\n            dataId = elem['id']\n            dataUrl = elem['url']\n            title = elem['title']\n            original = elem['images']['original']\n            height = original['height']\n            width = original['width']\n            url = original['url']\n            newElem = {\n                id: dataId,\n                url: dataUrl,\n                title: title,\n                media: { height: height, width: width, url: url }\n            }\n            return newElem\n        }\n    } else {\n        console.log(\"some weird data/element encountered. please check.\")\n        console.log(elem)\n    }\n    return null\n}\nfunction processElem(elem, typeFilter) {\n    try {\n        result = processElemUncatched(elem, typeFilter)",
        "type": "code",
        "location": "/tests/random_giphy_gifs/nodejs_server.js:23-59"
    },
    "3549": {
        "file_id": 436,
        "content": "The code contains a function `processElemUncatched` that processes elements with specific data types and filters, and returns an object containing id, url, title, and media (height, width, url). If the element does not have the required attributes or type does not match the filter, it logs a warning message and returns null. The main function `processElem` calls `processElemUncatched` and handles any potential errors with a try-catch block.",
        "type": "comment"
    },
    "3550": {
        "file_id": 436,
        "content": "        return result\n    } catch (e) {\n        console.log(e)\n        console.log(\"______________________ELEMENT______________________\")\n        console.log(elem)\n        console.log(\"______________________ELEMENT______________________\")\n        console.log(\"error while processing element\")\n        return null;\n    }\n}\nfunction getResultParsed(result, typeFilter) {\n    filteredResult = []\n    if ('data' in result) {\n        data = result['data']\n        if (Array.isArray(data)) {\n            for (elem of data) {\n                newElem = processElem(elem, typeFilter)\n                if (newElem != null) {\n                    filteredResult.push(newElem)\n                }\n            }\n        } else {\n            newElem = processElem(data, typeFilter)\n            if (newElem != null) {\n                filteredResult.push(newElem)\n            }\n        }\n    }\n    finalResult = {data:filteredResult}\n    if ('pagination' in result){\n        finalResult.pagination = result.pagination\n    }\n    return JSON.stringify(finalResult)",
        "type": "code",
        "location": "/tests/random_giphy_gifs/nodejs_server.js:60-93"
    },
    "3551": {
        "file_id": 436,
        "content": "This function returns the result after processing it. If an error occurs, it logs the error and returns null. The getResultParsed function filters data based on typeFilter, creating a new array called filteredResult. If the result has pagination information, it adds that to the finalResult object before returning it as a JSON string.",
        "type": "comment"
    },
    "3552": {
        "file_id": 436,
        "content": "}\nfunction getGF() {\n    return new GiphyFetch(randomAPIKey())\n}\nfunction getApi() {\n    return GiphyApi(randomAPIKey())\n}\nasync function getRandomGif(keywords, type, callback) {\n    try {\n        result = await getGF().random({ tag: keywords, type: type })\n        callback(result)\n    } catch (e) {\n        console.log(e)\n        console.log(\"error when calling getRandomGif\")\n        callback([])\n    }\n}\nfunction getRandomGifs(keywords, rating, callback) {\n    getApi().random({ tag: keywords, rating: rating, fmt: 'json' }, function(err, result) {\n        console.log('ERROR?', err); //null if normal.\n        if (err != null) {\n            callback([]);\n        } else {\n            callback(result)\n        }\n    })\n}\nasync function getSearchGifs(keywords, sort, limit, offset, type, rating, lang, callback) {\n    // sort in 'recent', 'relevant'\n    try {\n        result = await getGF().search(keywords, { sort: sort, limit: limit, offset: offset, type: type, rating: rating, lang: lang })\n        callback(result)\n    } catch (e) {",
        "type": "code",
        "location": "/tests/random_giphy_gifs/nodejs_server.js:94-130"
    },
    "3553": {
        "file_id": 436,
        "content": "This code provides functions to fetch random and search gifs from Giphy API using Node.js server. It handles potential errors and returns results to the callback function. The getGF, getApi, getRandomGif, getRandomGifs, and getSearchGifs are functions for interacting with Giphy API to retrieve various types of gifs.",
        "type": "comment"
    },
    "3554": {
        "file_id": 436,
        "content": "        console.log(e)\n        console.log(\"error when calling getSearchGifs\")\n        callback([])\n    }\n}\nasync function getRelatedGifs(keywords, limit, offset, type, callback) {\n    // sort in 'recent', 'relevant'\n    try {\n        result = await getGF().related(keywords, { limit: limit, offset: offset, type: type })\n        callback(result)\n    } catch (e) {\n        console.log(e)\n        console.log(\"error when calling getRelatedGifs\")\n        callback([])\n    }\n}\nasync function getTrendingGifs(limit, offset, type, rating, callback) {\n    // sort in 'recent', 'relevant'\n    try {\n        result = await getGF().trending({ limit: limit, offset: offset, type: type, rating: rating })\n        callback(result)\n    } catch (e) {\n        console.log(e)\n        console.log(\"error when calling getTrendingGifs\")\n        callback([])\n    }\n}\nfunction getQueryParams(reqUrl) {\n    current_url = new URL('http://localhost' + reqUrl)\n    params = current_url.searchParams\n    console.log('query parameters:', params)\n    return params",
        "type": "code",
        "location": "/tests/random_giphy_gifs/nodejs_server.js:131-164"
    },
    "3555": {
        "file_id": 436,
        "content": "This code defines three functions: `getSearchGifs`, `getRelatedGifs`, and `getTrendingGifs`. These functions use the GIPHY API to retrieve gifs based on different criteria. In case of errors, the functions log an error message and return an empty array. The `getQueryParams` function retrieves the query parameters from a URL.",
        "type": "comment"
    },
    "3556": {
        "file_id": 436,
        "content": "}\nconst typeArray = ['gifs', 'text', 'videos', 'stickers']\nconst ratingArray = ['y', 'g', 'pg', 'pg-13', 'r']\nconst sortArray = ['recent', 'relevant']\nconst langArray = [\"en\", \"es\", \"pt\", \"id\", \"fr\", \"ar\", \"tr\", \"th\", \"vi\", \"de\", \"it\", \"ja\", \"zh-CN\", \"zh-TW\", \"ru\", \"ko\", \"pl\", \"nl\", \"ro\", \"hu\", \"sv\", \"cs\", \"hi\", \"bn\", \"da\", \"fa\", \"tl\", \"fi\", \"he\", \"ms\", \"no\", \"uk\"]\nconst limitArray = [...Array(101).keys()].slice(20)\nconst offsetArray = [...Array(20000).keys()]\nfunction fallbackDefault(params, tag, valid, defaultParam) {\n    param = params.get(tag)\n    if (typeof(defaultParam) == 'number') {\n        param = parseFloat(param)\n    }\n    if (valid.indexOf(param) == -1) {\n        // type = 'gifs'\n        console.log(tag + \" undefined. falling back to default: \" + defaultParam)\n        return defaultParam\n    }\n    return param\n}\nconst validEntries = ['/random', '/related', '/trending', '/search']\nconst requestListener = function(req, res) {\n    // use 'less' to scan this beast?\n    console.log(\"________________________________________________\")",
        "type": "code",
        "location": "/tests/random_giphy_gifs/nodejs_server.js:165-192"
    },
    "3557": {
        "file_id": 436,
        "content": "The code defines arrays for different media types, ratings, sorting options, languages, and limit and offset values. It also includes a function to handle fallback defaults for parameters and specifies valid entry points. The function uses the request listener to log a marker and handle incoming requests based on the specified endpoints.",
        "type": "comment"
    },
    "3558": {
        "file_id": 436,
        "content": "    console.log(\"REQUEST AT:\", req.url, req.method)\n    if (req.url == \"/\") {\n        res.writeHead(200);\n        res.end('nodejs giphy server');\n    } else if (validEntries.indexOf(req.url.split(\"?\")[0]) != -1) {\n        callback = (result) => {\n            res.writeHead(200);\n            res.end(getResultParsed(result, ['text', 'sticker']))\n        }\n        params = getQueryParams(req.url)\n        q = params.get('q')\n        type = fallbackDefault(params, 'type', typeArray, typeArray[0])\n        rating = fallbackDefault(params, 'rating', ratingArray, ratingArray[1])\n        limit = fallbackDefault(params, 'limit', limitArray, 100)\n        offset = fallbackDefault(params, 'offset', offsetArray, randInt(0, 100))\n        sort = fallbackDefault(params, 'sort', sortArray, sortArray[1])\n        lang = fallbackDefault(params, 'lang', langArray, 'en')\n        console.log('search keywords:', q)\n        if (q != null) {\n            if (req.url.startsWith('/random')) {\n                // getRandomGif(q, type, callback) // this only returns a single random gif. deprecated.",
        "type": "code",
        "location": "/tests/random_giphy_gifs/nodejs_server.js:193-213"
    },
    "3559": {
        "file_id": 436,
        "content": "This code is handling HTTP requests and serving appropriate responses based on the URL. If the request URL is \"/\", it sends a 200 response with the message \"nodejs giphy server\". If the request URL contains valid entries (presumably GIF-related), it extracts query parameters, sets default values if necessary, and calls getRandomGif() function to retrieve a random GIF. The code also includes console logging of search keywords for debugging purposes.",
        "type": "comment"
    },
    "3560": {
        "file_id": 436,
        "content": "                getRandomGifs(q, rating, callback)\n            } else if (req.url.startsWith('/search')) {\n                getSearchGifs(q, sort, limit, offset, type, rating, lang, callback)\n            } else if (req.url.startsWith('/related')) {\n                getRelatedGifs(q, limit, offset, type, callback)\n            } else {\n                res.end(\"don't know how you get here\")\n            }\n        } else {\n            if (req.url.startsWith('/trending')) {\n                getTrendingGifs(limit, offset, type, rating, callback)\n            } else { res.end('no search keywords.') }\n        }\n        // def = params.get('def')\n        // console.log(def, def == null)\n        // console.log(req.params)\n    } else {\n        res.end('not being right')\n    }\n}\nconst server = http.createServer(requestListener);\nport = 8902\nserver.listen(port);\nconsole.log('server running on http://localhost:' + port);",
        "type": "code",
        "location": "/tests/random_giphy_gifs/nodejs_server.js:214-239"
    },
    "3561": {
        "file_id": 436,
        "content": "Code handles different API routes and dispatches corresponding function calls. It checks the URL, retrieves search keywords, and filters/sorts gifs accordingly. If no keywords or incorrect route is provided, it returns appropriate error messages. The server listens on port 8902 and logs a confirmation message.",
        "type": "comment"
    },
    "3562": {
        "file_id": 437,
        "content": "/tests/random_giphy_gifs/download_webp.sh",
        "type": "filepath"
    },
    "3563": {
        "file_id": 437,
        "content": "The script uses curl to download a GIF from the specified URL and save it as \"pikachu.gif\". It does not mention using a proxy for faster downloading, but implies that without one it might be slow.",
        "type": "summary"
    },
    "3564": {
        "file_id": 437,
        "content": "# curl -o pikachu.webp \"https://media0.giphy.com/media/fSvqyvXn1M3btN8sDh/giphy.webp?cid=c32f918edh7reod7g89e9oyy0717c9jstsdms9wqs8sm6a5b&rid=giphy.webp&ct=g\"\n# not supported. ffmpeg does not buy it.\n# very fucking slow if not using proxy.\ncurl -o pikachu.gif \"https://media0.giphy.com/media/fSvqyvXn1M3btN8sDh/giphy.gif?cid=c32f918edh7reod7g89e9oyy0717c9jstsdms9wqs8sm6a5b&rid=giphy.gif&ct=g\"",
        "type": "code",
        "location": "/tests/random_giphy_gifs/download_webp.sh:1-6"
    },
    "3565": {
        "file_id": 437,
        "content": "The script uses curl to download a GIF from the specified URL and save it as \"pikachu.gif\". It does not mention using a proxy for faster downloading, but implies that without one it might be slow.",
        "type": "comment"
    },
    "3566": {
        "file_id": 438,
        "content": "/tests/random_giphy_gifs/can_we_get_tag_info_about_this.sh",
        "type": "filepath"
    },
    "3567": {
        "file_id": 438,
        "content": "The code is using the curl command to download a specific Giphy GIF (samoyed.html) from the given URL, which contains information about the samoyed dog breed. The tag in the comment might be used by an internal recommendation engine for similar content.",
        "type": "summary"
    },
    "3568": {
        "file_id": 438,
        "content": "curl -o samoyed.html \"https://giphy.com/gifs/roverdotcom-rover-samoyed-gifofdogs-AgO9VR2a9KW1MSP73I\"\n# tag is probably used by internal recommendation engine.",
        "type": "code",
        "location": "/tests/random_giphy_gifs/can_we_get_tag_info_about_this.sh:1-3"
    },
    "3569": {
        "file_id": 438,
        "content": "The code is using the curl command to download a specific Giphy GIF (samoyed.html) from the given URL, which contains information about the samoyed dog breed. The tag in the comment might be used by an internal recommendation engine for similar content.",
        "type": "comment"
    },
    "3570": {
        "file_id": 439,
        "content": "/tests/dump_python_dependencies/dump.py",
        "type": "filepath"
    },
    "3571": {
        "file_id": 439,
        "content": "This code generates a timestamp, creates a directory for storing logs, and uses os.system() to execute the \"pip3 list\" command, saving the output to a log file in the specified directory with the current timestamp as part of the filename.",
        "type": "summary"
    },
    "3572": {
        "file_id": 439,
        "content": "import datetime\nlog_dir = \"logs\"\nnow = datetime.datetime.now().isoformat().replace(\".\",\"_\").replace(\" \",\"_\")\nprint('DUMP TIME:',now)\ncmd = \"pip3 list > {}/py3_deps_{}.log\".format(log_dir,now)\nimport os\nif not os.path.exists(log_dir):\n    os.mkdir(log_dir)\nos.system(cmd)",
        "type": "code",
        "location": "/tests/dump_python_dependencies/dump.py:1-13"
    },
    "3573": {
        "file_id": 439,
        "content": "This code generates a timestamp, creates a directory for storing logs, and uses os.system() to execute the \"pip3 list\" command, saving the output to a log file in the specified directory with the current timestamp as part of the filename.",
        "type": "comment"
    },
    "3574": {
        "file_id": 440,
        "content": "/tests/qq_share_autojs/unlock_and_run_autox.sh",
        "type": "filepath"
    },
    "3575": {
        "file_id": 440,
        "content": "The script checks if the device is locked, runs Auto.js script, monitors the flag file for changes and loops until it completes or encounters an error.",
        "type": "summary"
    },
    "3576": {
        "file_id": 440,
        "content": "bash adb_check_lock.sh \nfunction autox_run {\n  adb -s 192.168.10.3:5555 shell touch /storage/emulated/0/flag\n  bash adb_autox_launch.sh\n  while true\n  do\n    adb -s 192.168.10.3:5555 shell cat /storage/emulated/0/flag\n    if [[ $? -eq 1 ]]\n    then\n      echo \"script complete\"\n      exit\n    else\n      echo \"script running\"\n      sleep 1\n    fi\n  done\n}\nwhile true\ndo\n  autox_run\n  # you need to ensure the script run as expected.\ndone",
        "type": "code",
        "location": "/tests/qq_share_autojs/unlock_and_run_autox.sh:1-24"
    },
    "3577": {
        "file_id": 440,
        "content": "The script checks if the device is locked, runs Auto.js script, monitors the flag file for changes and loops until it completes or encounters an error.",
        "type": "comment"
    },
    "3578": {
        "file_id": 441,
        "content": "/tests/qq_share_autojs/test_qq_share.sh",
        "type": "filepath"
    },
    "3579": {
        "file_id": 441,
        "content": "This code launches the JumpActivity in the Tencent MobileQQ app, passing a complex URI with various data such as file type, file data, title, description, and URL to share. The shared content is related to Bilibili video recommendation server. It specifies the app name and package name (tv.danmaku.bili).",
        "type": "summary"
    },
    "3580": {
        "file_id": 441,
        "content": "am start -n com.tencent.mobileqq/com.tencent.mobileqq.activity.JumpActivity -a android.intent.action.VIEW -d 'mqqapi://share/to_fri?src_type=app&version=1&file_type=news&file_data=L3N0b3JhZ2UvZW11bGF0ZWQvMC9QaWN0dXJlcy9zaGFyZS8xMjcyMDY0MzU0&file_uri=Y29udGVudDovL3R2LmRhbm1ha3UuYmlsaS5maWxlcHJvdmlkZXIvb3BlbnNka19leHRlcm5hbC9zaGFyZTJxcV90ZW1wNDIwOTU0OTNhYjhlZGRhZmYzMWQ1Y2ZjYWYzZjE3MDQuanBn&title=5ZOU5ZOp5ZOU5ZOp&description=5aSn5Z6L5pS/6K6654mH772c5paw5pe25Luj562U5Y23&share_id=100951776&url=aHR0cHM6Ly9iMjMudHYvdGRKZGd6WT9zaGFyZV9tZWRpdW09YW5kcm9pZCZzaGFyZV9zb3VyY2U9cXEmYmJpZD1YWTFCQjcyMUIxRjk3MzQ4REJERTQyOTdGRTFCNEFCRTI2QkFBJnRzPTE2NjcyNzU0ODI4MTY=&app_name=5ZOU5ZOp5ZOU5ZOp&req_type=Nw==&mini_program_appid=MTEwOTkzNzU1Nw==&mini_program_path=cGFnZXMvdmlkZW8vdmlkZW8/YnZpZD1CVjFuZTQxMUw3aHkmc2hhcmVfc291cmNlPXFxX3VnYyZ1bmlxdWVfaz10ZEpkZ3pZ&mini_program_type=Mw==&cflag=MA==&third_sd=dHJ1ZQ==' -e pkg_name tv.danmaku.bili",
        "type": "code",
        "location": "/tests/bilibili_video_recommendation_server/xml_and_json_qq_send/test_launch_share.sh:1-1"
    },
    "3581": {
        "file_id": 441,
        "content": "This code launches the JumpActivity in the Tencent MobileQQ app, passing a complex URI with various data such as file type, file data, title, description, and URL to share. The shared content is related to Bilibili video recommendation server. It specifies the app name and package name (tv.danmaku.bili).",
        "type": "comment"
    },
    "3582": {
        "file_id": 442,
        "content": "/tests/qq_share_autojs/parse_qq_url.py",
        "type": "filepath"
    },
    "3583": {
        "file_id": 442,
        "content": "The code parses a QQ share URL, handles base64 encoding and decoding, stores values in a new dictionary for sharing, encodes URL parameters, prints them, opens the link using os.system().",
        "type": "summary"
    },
    "3584": {
        "file_id": 442,
        "content": "url = \"mqqapi://share/to_fri?src_type=app&version=1&file_type=news&file_data=L3N0b3JhZ2UvZW11bGF0ZWQvMC9QaWN0dXJlcy9zaGFyZS8xMjcyMDY0MzU0&file_uri=Y29udGVudDovL3R2LmRhbm1ha3UuYmlsaS5maWxlcHJvdmlkZXIvb3BlbnNka19leHRlcm5hbC9zaGFyZTJxcV90ZW1wNDIwOTU0OTNhYjhlZGRhZmYzMWQ1Y2ZjYWYzZjE3MDQuanBn&title=5ZOU5ZOp5ZOU5ZOp&description=5aSn5Z6L5pS/6K6654mH772c5paw5pe25Luj562U5Y23&share_id=100951776&url=aHR0cHM6Ly9iMjMudHYvdGRKZGd6WT9zaGFyZV9tZWRpdW09YW5kcm9pZCZzaGFyZV9zb3VyY2U9cXEmYmJpZD1YWTFCQjcyMUIxRjk3MzQ4REJERTQyOTdGRTFCNEFCRTI2QkFBJnRzPTE2NjcyNzU0ODI4MTY=&app_name=5ZOU5ZOp5ZOU5ZOp&req_type=Nw==&mini_program_appid=MTEwOTkzNzU1Nw==&mini_program_path=cGFnZXMvdmlkZW8vdmlkZW8/YnZpZD1CVjFuZTQxMUw3aHkmc2hhcmVfc291cmNlPXFxX3VnYyZ1bmlxdWVfaz10ZEpkZ3pZ&mini_program_type=Mw==&cflag=MA==&third_sd=dHJ1ZQ==\"\nfrom urllib.parse import urlparse, parse_qs\nparse_result=urlparse(url)\n#print(parse_result)\n#breakpoint()\n#\n#params=['count', 'encode', 'fragment', 'geturl', 'hostname', 'index', 'netloc', 'params', 'password', 'path', 'port', 'query', 'scheme', 'username']",
        "type": "code",
        "location": "/tests/qq_share_autojs/parse_qq_url.py:1-9"
    },
    "3585": {
        "file_id": 442,
        "content": "This code is parsing a URL using urllib.parse, extracting its components and possibly preparing for further processing. The URL appears to be related to QQ share and contains various parameters including app name, file data, description, etc.",
        "type": "comment"
    },
    "3586": {
        "file_id": 442,
        "content": "#for k in params:\n#    print(\"key:\",k,\"value:\",eval(\"parse_result.{}\".format(k)))\n#[scheme]://[netloc/hostname]/[path]?[query]\ndict_result=parse_qs(parse_result.query)\nnon_b64vals=[\"share_id\",\"src_type\",\"version\",\"file_type\"]\nimport base64\ndef dec_b64(v):\n    if type(v) == str:\n        v = v.encode()\n    v=base64.b64decode(v)\n    v=v.decode()\n    return v\ndef enc_b64(v):\n    if type(v) == str:\n        v = v.encode()\n    v=base64.b64encode(v)\n    v=v.decode()\n    return v\nnew_q={}\nmypic=\"/storage/emulated/0/Pictures/share/cat.gif\"\nmyuri='file://{}'.format(mypic)\nshortlink=\"uHML5mi\"\nbvid=\"BV1zd4y117WF\"\nfor k,v in dict_result.items():\n    v=v[0]\n    if k == \"file_data\":\n        v=enc_b64(mypic)\n    elif k == \"file_uri\":\n        v=enc_b64(myuri)\n    elif k == \"share_id\":\n        v=100951776\n    elif k == \"url\":\n        v=\"https://b23.tv/\"+shortlink\n        v=enc_b64(v)\n    elif k == \"mini_program_path\":\n        v=enc_b64(\"pages/video/video?bvid=\"+bvid)\n    elif k == \"description\":\n        v=enc_b64(\"喵喵喵\")\n    new_q.update({k:v})",
        "type": "code",
        "location": "/tests/qq_share_autojs/parse_qq_url.py:10-55"
    },
    "3587": {
        "file_id": 442,
        "content": "The code is parsing a QQ share URL, decoding and encoding specific values using base64, and storing them in a new dictionary. It also includes hardcoded values such as file path, shortlink, and bvid. The purpose seems to be related to sharing files or links within the QQ platform.",
        "type": "comment"
    },
    "3588": {
        "file_id": 442,
        "content": "    #for printing purpose\n    if k not in non_b64vals:\n        v=dec_b64(v)\n    print(k,\":\",v)\nfrom urllib.parse import urlencode\nnew_qs=urlencode(new_q)\nprint()\ntemplate=\"am start -n com.tencent.mobileqq/com.tencent.mobileqq.activity.JumpActivity -a android.intent.action.VIEW -d 'mqqapi://share/to_fri?{}' -e pkg_name tv.danmaku.bili\"\ncmd=template.format(new_qs)\nprint(cmd)\nimport os\nos.system(cmd)",
        "type": "code",
        "location": "/tests/qq_share_autojs/parse_qq_url.py:56-67"
    },
    "3589": {
        "file_id": 442,
        "content": "The code encodes URL parameters, prints them, and then executes a command to open a QQ share link in the mobile app. It converts base64 values if needed for printing, formats the command with URL parameters, and uses os.system() to execute the command.",
        "type": "comment"
    },
    "3590": {
        "file_id": 443,
        "content": "/tests/qq_share_autojs/launch_autojs.sh",
        "type": "filepath"
    },
    "3591": {
        "file_id": 443,
        "content": "This code uses the am start command to launch the ShortcutActivity in AutoJS, passing the path of a JavaScript file (\"/storage/emulated/0/脚本/show_toast.js\") as an argument. This could be used for executing a specific AutoJS script on the device.",
        "type": "summary"
    },
    "3592": {
        "file_id": 443,
        "content": "am start -n org.autojs.autoxjs.v6/org.autojs.autojs.external.shortcut.ShortcutActivity -a android.intent.action.MAIN -e path \"/storage/emulated/0/脚本/show_toast.js\"\n#am start -n org.autojs.autoxjs.v6/org.autojs.autojs.external.shortcut.ShortcutActivity -a android.intent.action.MAIN -e path \"/storage/emulated/0/脚本/qq_share_auto.js\"",
        "type": "code",
        "location": "/tests/qq_share_autojs/launch_autojs.sh:1-2"
    },
    "3593": {
        "file_id": 443,
        "content": "This code uses the am start command to launch the ShortcutActivity in AutoJS, passing the path of a JavaScript file (\"/storage/emulated/0/脚本/show_toast.js\") as an argument. This could be used for executing a specific AutoJS script on the device.",
        "type": "comment"
    },
    "3594": {
        "file_id": 444,
        "content": "/tests/qq_share_autojs/appium_unlock_phone.py",
        "type": "filepath"
    },
    "3595": {
        "file_id": 444,
        "content": "The code sets up an Appium test for unlocking an Android phone without requiring the device password. It initializes capabilities, connects to the appium server, checks if the screen is locked, and uses a bash script to unlock it.",
        "type": "summary"
    },
    "3596": {
        "file_id": 444,
        "content": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\nfrom appium import webdriver\nfrom appium.webdriver.common.appiumby import AppiumBy\ncapabilities = dict(\n    platformName='Android',\n    automationName='uiautomator2',\n    deviceName='Android',\n    appPackage='com.android.settings',\n    appActivity='.Settings',\n    language='en',\n    locale='US',\n    noSign=True,\n    skipUnlock=True\n    # it tries to clear my password.\n)\nappium_server_url = 'http://localhost:4723'\ndriver = webdriver.Remote(appium_server_url, capabilities)\nprint('is screen ready?')\nwhile True:\n    try:\n        locked = driver.is_locked()\n        print('locked?', locked)\n        if not locked:\n            break\n        import os\n        if locked:\n            os.system(\"bash adb_unlock.sh\")\n            print(\"UNLOCKED\")\n    except:\n        pass\n# unlocking the phone will disconnect adb sessions\nif driver:\n    driver.quit()",
        "type": "code",
        "location": "/tests/qq_share_autojs/appium_unlock_phone.py:1-42"
    },
    "3597": {
        "file_id": 444,
        "content": "The code sets up an Appium test for unlocking an Android phone without requiring the device password. It initializes capabilities, connects to the appium server, checks if the screen is locked, and uses a bash script to unlock it.",
        "type": "comment"
    },
    "3598": {
        "file_id": 445,
        "content": "/tests/qq_share_autojs/appium_test.py",
        "type": "filepath"
    },
    "3599": {
        "file_id": 445,
        "content": "Code sets up Appium test for Android device using the uiautomator2 automation, launches com.android.settings app, searches for \"Battery\" and clicks it, then quits the driver if open.",
        "type": "summary"
    }
}