{
    "4200": {
        "file_id": 536,
        "content": "/tests/bezier_paddlehub_dogcat_detector_serving/server.py",
        "type": "filepath"
    },
    "4201": {
        "file_id": 536,
        "content": "This code changes the directory, appends current path to sys.path, and imports specific configurations and classes for a Bezier PaddleHub ResNet50 Image DogCatDetectorServer in pyjom project.",
        "type": "summary"
    },
    "4202": {
        "file_id": 536,
        "content": "import sys\nimport os\ndef changeDirForImport():\n    os.chdir(\"/root/Desktop/works/pyjom\")\n    sys.path.append(\".\")\nif __name__ == '__main__':\n    changeDirForImport()\n    from pyjom.config.shared import pyjom_config\n    pyjom_config['BEZIER_PADDLE_RESNET50_IMAGE_DOG_CAT_DETECTOR_SERVER_INSTANCE']=True\n    from pyjom.imagetoolbox import bezierPaddleHubResnet50ImageDogCatDetectorServer\n    bezierPaddleHubResnet50ImageDogCatDetectorServer()",
        "type": "code",
        "location": "/tests/bezier_paddlehub_dogcat_detector_serving/server.py:1-13"
    },
    "4203": {
        "file_id": 536,
        "content": "This code changes the directory, appends current path to sys.path, and imports specific configurations and classes for a Bezier PaddleHub ResNet50 Image DogCatDetectorServer in pyjom project.",
        "type": "comment"
    },
    "4204": {
        "file_id": 537,
        "content": "/tests/bezier_paddlehub_dogcat_detector_serving/client.py",
        "type": "filepath"
    },
    "4205": {
        "file_id": 537,
        "content": "The code reads an image file from a specific location, changes the working directory for importing necessary libraries, initializes a client and server object for detecting dog/cat images using PaddleHub's ResNet50 model, reads the test image using OpenCV, performs detection on the image with the client object, and finally prints the result.",
        "type": "summary"
    },
    "4206": {
        "file_id": 537,
        "content": "test_image = \"/root/Desktop/works/pyjom/samples/image/dog_with_text.jpg\"\nfrom server import changeDirForImport\nchangeDirForImport()\nfrom pyjom.imagetoolbox import bezierPaddleHubResnet50ImageDogCatDetectorClient,bezierPaddleHubResnet50ImageDogCatDetectorServerChecker\nimport cv2\ntest_image = cv2.imread(test_image)\nbezierPaddleHubResnet50ImageDogCatDetectorServerChecker()\nresult = bezierPaddleHubResnet50ImageDogCatDetectorClient(test_image)\nprint(\"RESULT?\",result)",
        "type": "code",
        "location": "/tests/bezier_paddlehub_dogcat_detector_serving/client.py:1-10"
    },
    "4207": {
        "file_id": 537,
        "content": "The code reads an image file from a specific location, changes the working directory for importing necessary libraries, initializes a client and server object for detecting dog/cat images using PaddleHub's ResNet50 model, reads the test image using OpenCV, performs detection on the image with the client object, and finally prints the result.",
        "type": "comment"
    },
    "4208": {
        "file_id": 538,
        "content": "/tests/bilibili_login_get_credential_view_data/test.py",
        "type": "filepath"
    },
    "4209": {
        "file_id": 538,
        "content": "This code allows users to choose between password and SMS login methods, with additional functionality for database storage and geetest validation. It performs a login, retrieves user data, updates the database, and asks about atomic insert in tinydb.",
        "type": "summary"
    },
    "4210": {
        "file_id": 538,
        "content": "from bilibili_api.login import (\n    login_with_password,\n    login_with_sms,\n    send_sms,\n    PhoneNumber,\n    Check,\n)\nfrom bilibili_api.user import get_self_info\nfrom bilibili_api import settings\nfrom bilibili_api import sync, Credential\n# mode = int(input(\"\"\"请选择登录方式：\n# 1. 密码登录\n# 2. 验证码登录\n# 请输入 1/2\n# \"\"\"))\nmode = 2\ncredential = None\n# 关闭自动打开 geetest 验证窗口\nsettings.geetest_auto_open = False\nif mode == 1:\n    # 密码登录\n    username = input(\"请输入手机号/邮箱：\")\n    password = input(\"请输入密码：\")\n    print(\"正在登录。\")\n    c = login_with_password(username, password)\n    if isinstance(c, Check):\n        # 还需验证\n        phone = input(\"需要验证。请输入手机号：\")\n        c.set_phone(PhoneNumber(phone, country=\"+86\"))  # 默认设置地区为中国大陆\n        c.send_code()\n        print(\"已发送验证码。\")\n        code = input(\"请输入验证码：\")\n        credential = c.login(code)\n        print(\"登录成功！\")\n    else:\n        credential = c\nelif mode == 2:\n    # 验证码登录\n    phone = input(\"请输入手机号：\")\n    print(\"正在登录。\")\n    send_sms(PhoneNumber(phone, country=\"+86\"))  # 默认设置地区为中国大陆\n    code = input(\"请输入验证码：\")",
        "type": "code",
        "location": "/tests/bilibili_login_get_credential_view_data/test.py:1-46"
    },
    "4211": {
        "file_id": 538,
        "content": "This code allows the user to choose between two login methods: password or SMS verification. If the user chooses password login, they input their credentials and are logged in immediately if valid. If the user chooses SMS login, they first need to enter their phone number and receive an SMS code. After entering the code, they're logged in. The code also has a setting to disable automatic opening of geetest validation window.",
        "type": "comment"
    },
    "4212": {
        "file_id": 538,
        "content": "    c = login_with_sms(PhoneNumber(phone, country=\"+86\"), code)\n    credential = c\n    print(\"登录成功\")\nelse:\n    print(\"请输入 1/2 ！\")\n    exit()\nfrom lazero.search.api import getHomeDirectory\nimport os\nhome = getHomeDirectory()\ndbPath = os.path.join(home, \".bilibili_api.json\")\nimport tinydb\ndb = tinydb.TinyDB(dbPath)\nif credential != None:\n    name = sync(get_self_info(credential))[\"name\"]\n    print(f\"欢迎，{name}!\")\n    buvid3 = credential.buvid3\n    bili_jct = credential.bili_jct\n    sessdata = credential.sessdata\n    dedeuserid = credential.dedeuserid  # this is userid, better use this instead?\n    User = tinydb.Query()\n    # assume that we are here to fetch valid credentials.\n    db.upsert(\n        {\n            \"name\": name,\n            \"dedeuserid\": dedeuserid,\n            \"bili_jct\": bili_jct,\n            \"buvid3\": buvid3,\n            \"sessdata\": sessdata,\n        },\n        User.dedeuserid == dedeuserid,\n    )\n    # how to perform atomic insert in tinydb?\n    # breakpoint()",
        "type": "code",
        "location": "/tests/bilibili_login_get_credential_view_data/test.py:47-82"
    },
    "4213": {
        "file_id": 538,
        "content": "This code performs a login with SMS and stores the credentials in a database. It first checks if the login was successful, then retrieves the name, buvid3, bili_jct, sessdata, and dedeuserid from the credentials. The code updates the database with this information using an upsert operation, ensuring that the dedeuserid is unique. Finally, it asks how to perform atomic insert in tinydb.",
        "type": "comment"
    },
    "4214": {
        "file_id": 539,
        "content": "/tests/bilibili_login_get_credential_view_data/dump_view_history.py",
        "type": "filepath"
    },
    "4215": {
        "file_id": 539,
        "content": "The code fetches credentials from a local database, updates the user's name if necessary, and processes bilibili video history pages in increments of 100 per page, checking for duplicates and stopping upon completion or no more duplicates found.",
        "type": "summary"
    },
    "4216": {
        "file_id": 539,
        "content": "# how to?\nfrom bilibili_api.user import get_self_info\nfrom bilibili_api import Credential\n# how to load credential from our stored things?\nfrom bilibili_api import user\nfrom lazero.search.api import getHomeDirectory\nimport os\nimport tinydb\nhome = getHomeDirectory()\ndbPath = os.path.join(home, \".bilibili_api.json\")\nimport tinydb\ndb = tinydb.TinyDB(dbPath)\nUser = tinydb.Query()\ndedeuserid = \"397424026\"  # pass it before you do shit!\ndataList = db.search(User.dedeuserid == dedeuserid)  # this will never change i suppose?\nif len(dataList) == 1:\n    data = dataList[0].copy()\n    print(\"try to login credential fetched from db:\", data)\n    oldName = data.pop(\"name\")\n    credential = Credential(**data)\n    from bilibili_api import sync\n    name = sync(get_self_info(credential))[\"name\"]\n    if oldName != name:\n        data[\"name\"] = name\n        db.upsert(data, User.dedeuserid == dedeuserid)\n    print(\"login successful:\", name)\n    # now continue.\n    # how many pages you want? infinite?\n    import time\n    page_num = 0\n    dbHistory = tinydb.TinyDB(\"bilibiliHistory.json\")",
        "type": "code",
        "location": "/tests/bilibili_login_get_credential_view_data/dump_view_history.py:1-36"
    },
    "4217": {
        "file_id": 539,
        "content": "Code fetches credential from local database for a specific bilibili user, checks if the name is up-to-date, and updates it if necessary. Then, it continues with further processing while also keeping track of bilibili history in another database file.",
        "type": "comment"
    },
    "4218": {
        "file_id": 539,
        "content": "    while True:\n        time.sleep(3)\n        page_num += 1  # starts with 1\n        print(\"now processing page:\", page_num)\n        result = sync(\n            user.get_self_history(\n                page_num=page_num, per_page_item=100, credential=credential\n            )\n        )\n        # import pprint\n        # pprint.pprint(result)\n        if type(result) != list or len(result) == 0:\n            break\n        breakFlag=False\n        for elem in result:\n            # it has description.\n            videoData = {key: elem[key] for key in [\"bvid\", \"desc\", \"title\"]}\n            searchResult= dbHistory.search(User.bvid == videoData[\"bvid\"])\n            if len(searchResult) != 0:\n                breakFlag=True\n            dbHistory.upsert(videoData, User.bvid == videoData[\"bvid\"])\n        if breakFlag:\n            break",
        "type": "code",
        "location": "/tests/bilibili_login_get_credential_view_data/dump_view_history.py:37-59"
    },
    "4219": {
        "file_id": 539,
        "content": "This code is processing video history pages from a user's account. It fetches data in increments of 100 per page, checks for duplicates before storing the video details, and stops when there are no more pages or duplicate entries found.",
        "type": "comment"
    },
    "4220": {
        "file_id": 540,
        "content": "/tests/bilibili_login_get_credential_view_data/dump_favourite_list.py",
        "type": "filepath"
    },
    "4221": {
        "file_id": 540,
        "content": "This code loads Bilibili API credentials, fetches user information and favorite lists, processes media data, utilizes TinyDB, and interacts with bilibili_api module. It iterates through elements, extracts bvid, title, updates desc as intro, searches for existing records, and upserts data if not present or loop breaks due to no more elements.",
        "type": "summary"
    },
    "4222": {
        "file_id": 540,
        "content": "from bilibili_api import favorite_list\n# that favourite list is public. i just want that.\n# dedeuserid = \"397424026\"\n# how to?\nfrom bilibili_api.user import get_self_info\nfrom bilibili_api import sync, Credential\n# how to load credential from our stored things?\n# from bilibili_api import user\nfrom lazero.search.api import getHomeDirectory\nimport os\nimport tinydb\nhome = getHomeDirectory()\ndbPath = os.path.join(home, \".bilibili_api.json\")\nimport tinydb\ndb = tinydb.TinyDB(dbPath)\ndbFavList = tinydb.TinyDB(\"bilibiliFavouriteList.json\")\nUser = tinydb.Query()\ndedeuserid = \"397424026\"  # pass it before you do shit!\ndataList = db.search(User.dedeuserid == dedeuserid)  # this will never change i suppose?\nif len(dataList) == 1:\n    data = dataList[0].copy()\n    print(\"try to login credential fetched from db:\", data)\n    oldName = data.pop(\"name\")\n    credential = Credential(**data)\n    from bilibili_api import sync\n    name = sync(get_self_info(credential))[\"name\"]\n    if oldName != name:\n        data[\"name\"] = name\n        db.upsert(data, User.dedeuserid == dedeuserid)",
        "type": "code",
        "location": "/tests/bilibili_login_get_credential_view_data/dump_favourite_list.py:1-34"
    },
    "4223": {
        "file_id": 540,
        "content": "This code aims to load the Bilibili API credentials from stored data and retrieve the user's information using a provided dedeuserid. It utilizes TinyDB for database operations, fetches the home directory, and interacts with the bilibili_api module. If a credential is found in the database, it will update the \"name\" field if necessary and print the retrieved credential information.",
        "type": "comment"
    },
    "4224": {
        "file_id": 540,
        "content": "    print(\"login successful:\", name)\n    # now you have it.\n    result = sync(\n        favorite_list.get_video_favorite_list(int(dedeuserid), None, credential)\n    )\n    print(result)  # None? wtf?\n    favLists = result[\"list\"]\n    for favList in favLists:\n        listId = favList[\"id\"]  # integer.\n        listName = favList[\"title\"]\n        print(\"processing favList:\", listName)\n        page = 0\n        while True:\n            import time\n            time.sleep(3)\n            page += 1\n            print(\"processing page:\", page)\n            result = sync(\n                favorite_list.get_video_favorite_list_content(\n                    listId, page=page, credential=credential\n                )\n            )\n            # import pprint\n            # pprint.pprint(result)\n            has_more = result[\"has_more\"]\n            # print(\"__________result__________\")\n            medias = result[\"medias\"]\n            if type(medias) != list or len(medias) == 0:\n                break\n            breakFlag = False\n            for elem in medias:",
        "type": "code",
        "location": "/tests/bilibili_login_get_credential_view_data/dump_favourite_list.py:35-66"
    },
    "4225": {
        "file_id": 540,
        "content": "Code is fetching user's favorite lists from Bilibili and processing each list's contents page by page. It checks for more content using \"has_more\" flag, fetches media data from the server, and breaks the loop when no more content is available or if the media data type is incorrect.",
        "type": "comment"
    },
    "4226": {
        "file_id": 540,
        "content": "                # print('ELEM:',elem)\n                # breakpoint()\n                # it has description.\n                videoData = {key: elem[key] for key in [\"bvid\", \"title\"]}\n                # here we call 'desc' as 'intro.\n                videoData.update({\"desc\": elem[\"intro\"]})\n                searchResult= dbFavList.search(User.bvid == videoData[\"bvid\"])\n                if len(searchResult) != 0:\n                    breakFlag=True\n                dbFavList.upsert(videoData, User.bvid == videoData[\"bvid\"])\n            if not has_more or breakFlag:\n                break",
        "type": "code",
        "location": "/tests/bilibili_login_get_credential_view_data/dump_favourite_list.py:67-78"
    },
    "4227": {
        "file_id": 540,
        "content": "This code iterates through elements, extracts bvid and title, updates with intro as desc, searches for existing records, upserts data if not already present or if the loop breaks due to no more elements.",
        "type": "comment"
    },
    "4228": {
        "file_id": 541,
        "content": "/tests/bilibili_login_get_credential_view_data/test_login_successful.py",
        "type": "filepath"
    },
    "4229": {
        "file_id": 541,
        "content": "The code retrieves user credentials from a local database and uses them to log in to Bilibili API. It checks if the user exists, updates the name if necessary, and prints the login status.",
        "type": "summary"
    },
    "4230": {
        "file_id": 541,
        "content": "from bilibili_api.user import get_self_info\nfrom bilibili_api import Credential\n# how to load credential from our stored things?\nfrom lazero.search.api import getHomeDirectory\nimport os\nimport tinydb\nhome = getHomeDirectory()\ndbPath = os.path.join(home, \".bilibili_api.json\")\nimport tinydb\ndb = tinydb.TinyDB(dbPath)\nUser = tinydb.Query()\ndedeuserid = \"397424026\"  # pass it before you do shit!\ndataList = db.search(User.dedeuserid == dedeuserid)  # this will never change i suppose?\nif len(dataList) == 1:\n    data = dataList[0].copy()\n    print(\"try to login credential fetched from db:\", data)\n    oldName = data.pop(\"name\")\n    credential = Credential(**data)\n    from bilibili_api import sync\n    name = sync(get_self_info(credential))[\"name\"]\n    if oldName != name:\n        data[\"name\"] = name\n        db.upsert(data, User.dedeuserid == dedeuserid)\n    print(\"login successful:\", name)",
        "type": "code",
        "location": "/tests/bilibili_login_get_credential_view_data/test_login_successful.py:1-29"
    },
    "4231": {
        "file_id": 541,
        "content": "The code retrieves user credentials from a local database and uses them to log in to Bilibili API. It checks if the user exists, updates the name if necessary, and prints the login status.",
        "type": "comment"
    },
    "4232": {
        "file_id": 542,
        "content": "/tests/bilibili_login_get_credential_view_data/test_login_fail.py",
        "type": "filepath"
    },
    "4233": {
        "file_id": 542,
        "content": "This code retrieves user credentials, logs in using session data, and updates the name if it changed; attempts logging in with expired data to check for failure.",
        "type": "summary"
    },
    "4234": {
        "file_id": 542,
        "content": "from bilibili_api.user import get_self_info\nfrom bilibili_api import Credential\n# how to load credential from our stored things?\nfrom lazero.search.api import getHomeDirectory\nimport os\nimport tinydb\nhome = getHomeDirectory()\ndbPath = os.path.join(home, \".bilibili_api.json\")\nimport tinydb\ndb = tinydb.TinyDB(dbPath)\nUser = tinydb.Query()\ndedeuserid = \"397424026\" # pass it before you do shit!\ndataList = db.search(User.dedeuserid == dedeuserid) # this will never change i suppose?\nif len(dataList) == 1:\n    data = dataList[0].copy()\n    print('try to login credential fetched from db:', data)\n    oldName = data.pop('name')\n    credential = Credential(**{'dedeuserid': dedeuserid,'sessdata':'fakeSessionData'})\n    from bilibili_api import sync\n    name = sync(get_self_info(credential))['name']\n    # 'GetCookieReq.Session' Error:Field validation for 'Session' failed on the 'gte' tag。\n    # don't know how. maybe this works?\n    # if oldName !=name:\n    #     data['name']=name\n    #     db.upsert(data, User.dedeuserid == dedeuserid)",
        "type": "code",
        "location": "/tests/bilibili_login_get_credential_view_data/test_login_fail.py:1-27"
    },
    "4235": {
        "file_id": 542,
        "content": "This code retrieves a user's credential from the database, attempts to log in using the provided session data, and updates the name if it changed. If the name has not changed after logging in, it does not update the database.",
        "type": "comment"
    },
    "4236": {
        "file_id": 542,
        "content": "    # will never succeed.\n    # don't know using some expired sessdata will get what?\n    # maybe will still fail?\n    print('login successful:', name)",
        "type": "code",
        "location": "/tests/bilibili_login_get_credential_view_data/test_login_fail.py:28-31"
    },
    "4237": {
        "file_id": 542,
        "content": "This code block attempts to log in using expired session data, expecting the login to fail. It prints a message indicating whether the login was successful or not.",
        "type": "comment"
    },
    "4238": {
        "file_id": 543,
        "content": "/tests/bilibili_login_get_credential_view_data/tinydb_test.py",
        "type": "filepath"
    },
    "4239": {
        "file_id": 543,
        "content": "This code imports the tinydb library and sets a database location. It creates a TinyDB object at that location, which serves as a lightweight NoSQL document database. The code defines a User query using the tinydb.Query() function and performs an upsert operation on the database, where it either updates or inserts a document based on the provided condition (User.ghi == 123). Note that there is also a commented-out section for updating the database without an insertion operation.",
        "type": "summary"
    },
    "4240": {
        "file_id": 543,
        "content": "import tinydb\ndbLocation = \"test_credential.json\"\ndb = tinydb.TinyDB(dbLocation)\n# table = db.table('mytable')\nUser = tinydb.Query()\ndb.upsert({\"abc\": \"def\", \"ghi\": 123}, User.ghi == 123)  # please specify a condition!\n# db.update({'abc': 'def', 'ghi': 123}) # no insert here!",
        "type": "code",
        "location": "/tests/bilibili_login_get_credential_view_data/tinydb_test.py:1-8"
    },
    "4241": {
        "file_id": 543,
        "content": "This code imports the tinydb library and sets a database location. It creates a TinyDB object at that location, which serves as a lightweight NoSQL document database. The code defines a User query using the tinydb.Query() function and performs an upsert operation on the database, where it either updates or inserts a document based on the provided condition (User.ghi == 123). Note that there is also a commented-out section for updating the database without an insertion operation.",
        "type": "comment"
    },
    "4242": {
        "file_id": 544,
        "content": "/tests/bilibili_tag_recommend_activities/README.md",
        "type": "filepath"
    },
    "4243": {
        "file_id": 544,
        "content": "Code snippet provides a link to another file, \"bilibili_up.py\", which contains information on how to get the 'upload_id' in bilibili API.",
        "type": "summary"
    },
    "4244": {
        "file_id": 544,
        "content": "[how to get upload_id](https://github.com/xunsword/bilibil/blob/2abf66a9771daebc12c181f88d8af82613975548/bilibili_up.py)",
        "type": "code",
        "location": "/tests/bilibili_tag_recommend_activities/README.md:1-1"
    },
    "4245": {
        "file_id": 544,
        "content": "Code snippet provides a link to another file, \"bilibili_up.py\", which contains information on how to get the 'upload_id' in bilibili API.",
        "type": "comment"
    },
    "4246": {
        "file_id": 545,
        "content": "/tests/medialang_reference/videolang.mdl",
        "type": "filepath"
    },
    "4247": {
        "file_id": 545,
        "content": "The code defines two media streams: the first one is a video with a .mp4 extension and a speed of 1.5, while the second one is an audio file also with a .mp4 extension located at \"/root/Desktop/works/pyjom/src/samples/video/dog_with_text.mp4\", set to play at 1.5 speed but without video output.",
        "type": "summary"
    },
    "4248": {
        "file_id": 545,
        "content": "(\".mp4\", speed=1.5\n)\n(\"/root/Desktop/works/pyjom/src/samples/video/dog_with_text.mp4\",\n    speed=1.5, video=false\n)",
        "type": "code",
        "location": "/tests/medialang_reference/videolang.mdl:1-6"
    },
    "4249": {
        "file_id": 545,
        "content": "The code defines two media streams: the first one is a video with a .mp4 extension and a speed of 1.5, while the second one is an audio file also with a .mp4 extension located at \"/root/Desktop/works/pyjom/src/samples/video/dog_with_text.mp4\", set to play at 1.5 speed but without video output.",
        "type": "comment"
    },
    "4250": {
        "file_id": 546,
        "content": "/tests/medialang_reference/recursive_audiolang.mdl",
        "type": "filepath"
    },
    "4251": {
        "file_id": 546,
        "content": "This code sets the audio language model and specifies its configuration. It uses a subtitle detector with an input file located at \"/root/Desktop/works/pyjom/src/samples/video/dog_with_text.mp4\". The speed of processing is set to 1.5x, and the output file is generated from the template at \"/root/Desktop/works/pyjom/src/test/audiolang.mdl.j2\" with format arguments \"some_number\": 2 and \"some_text\": \"shit\".",
        "type": "summary"
    },
    "4252": {
        "file_id": 546,
        "content": "(\".mp3\", processor=\"subtitle_detector\"\n)\n(\"/root/Desktop/works/pyjom/src/samples/video/dog_with_text.mp4\",\n    speed=1.5\n)\n(\"/root/Desktop/works/pyjom/src/test/audiolang.mdl.j2\",\n    format_args={\"some_number\": 2, \"some_text\": \"shit\"}\n)",
        "type": "code",
        "location": "/tests/medialang_reference/recursive_audiolang.mdl:1-10"
    },
    "4253": {
        "file_id": 546,
        "content": "This code sets the audio language model and specifies its configuration. It uses a subtitle detector with an input file located at \"/root/Desktop/works/pyjom/src/samples/video/dog_with_text.mp4\". The speed of processing is set to 1.5x, and the output file is generated from the template at \"/root/Desktop/works/pyjom/src/test/audiolang.mdl.j2\" with format arguments \"some_number\": 2 and \"some_text\": \"shit\".",
        "type": "comment"
    },
    "4254": {
        "file_id": 547,
        "content": "/tests/medialang_reference/processor_multi.mdl",
        "type": "filepath"
    },
    "4255": {
        "file_id": 547,
        "content": "The code is creating a pipeline to process a video file and associated .json files. It uses a video file \"dog_with_text.mp4\" at 1.5x speed, followed by subtitle detection and active region detection on the .json files.",
        "type": "summary"
    },
    "4256": {
        "file_id": 547,
        "content": "(\"/root/Desktop/works/pyjom/src/samples/video/dog_with_text.mp4\",\n    speed=1.5\n)\n(\".json\", processor=\"subtitle_detector\"\n)\n(\".json\",\n    processor=\"active_region_detector\"\n)",
        "type": "code",
        "location": "/tests/medialang_reference/processor_multi.mdl:1-10"
    },
    "4257": {
        "file_id": 547,
        "content": "The code is creating a pipeline to process a video file and associated .json files. It uses a video file \"dog_with_text.mp4\" at 1.5x speed, followed by subtitle detection and active region detection on the .json files.",
        "type": "comment"
    },
    "4258": {
        "file_id": 548,
        "content": "/tests/medialang_reference/processor_demo.mdl",
        "type": "filepath"
    },
    "4259": {
        "file_id": 548,
        "content": "The code specifies a video file path and sets the playback speed. The \"subtitle_detector\" processor is applied to a JSON file.",
        "type": "summary"
    },
    "4260": {
        "file_id": 548,
        "content": "(\".json\", processor=\"subtitle_detector\"\n)\n(\"/root/Desktop/works/pyjom/samples/video/dog_with_text.mp4\",\n    speed=1.5\n)",
        "type": "code",
        "location": "/tests/medialang_reference/processor_demo.mdl:1-6"
    },
    "4261": {
        "file_id": 548,
        "content": "The code specifies a video file path and sets the playback speed. The \"subtitle_detector\" processor is applied to a JSON file.",
        "type": "comment"
    },
    "4262": {
        "file_id": 549,
        "content": "/tests/medialang_reference/audiolang.mdl.j2",
        "type": "filepath"
    },
    "4263": {
        "file_id": 549,
        "content": "The code defines a sequence of media items to be played. It includes audio and video files, with options for speed adjustment and text-to-speech conversion. The code also utilizes a loop to create multiple instances of these media items, replacing some variables like 'some_number' and 'some_text'.",
        "type": "summary"
    },
    "4264": {
        "file_id": 549,
        "content": "(\".mp3\", speed=1.5\n)\n(\"/root/Desktop/works/pyjom/src/samples/video/dog_with_text.mp4\",\n    speed=1.5, video=false\n)\n    (\"/root/Desktop/works/pyjom/src/samples/video/IxEQhCslT.mp4\",\n        padding=\"black\"\n    )\n        (\"text://you did a good job\",\n            converter=\"voice\", provider=\"tts_male\",\n            speed=2\n        )\n{% for i in range(some_number) %}\n(\"/root/Desktop/works/pyjom/src/samples/video/dog_with_text.mp4\",\n    speed={{ some_number }}\n)\n    (\"text://{{ some_text }}\",\n        converter=\"voice\"\n    )\n{% endfor %}",
        "type": "code",
        "location": "/tests/medialang_reference/audiolang.mdl.j2:1-23"
    },
    "4265": {
        "file_id": 549,
        "content": "The code defines a sequence of media items to be played. It includes audio and video files, with options for speed adjustment and text-to-speech conversion. The code also utilizes a loop to create multiple instances of these media items, replacing some variables like 'some_number' and 'some_text'.",
        "type": "comment"
    },
    "4266": {
        "file_id": 550,
        "content": "/tests/medialang_reference/audiolang.mdl",
        "type": "filepath"
    },
    "4267": {
        "file_id": 550,
        "content": "The code represents a sequence of media items and text to be processed by the program. It includes audio, video files, and text strings for conversion. The media items are specified with their respective paths and properties like speed and padding. The text strings are to be converted using the \"voice\" converter and may have additional properties like provider and speed.",
        "type": "summary"
    },
    "4268": {
        "file_id": 550,
        "content": "(\".mp3\", speed=1.5\n)\n(\"/root/Desktop/works/pyjom/src/samples/video/dog_with_text.mp4\",\n    speed=1.5, video=false\n)\n    (\"/root/Desktop/works/pyjom/src/samples/video/IxEQhCslT.mp4\",\n        padding=\"black\"\n    )\n        (\"text://you did a good job\",\n            converter=\"voice\", provider=\"tts_male\",\n            speed=2\n        )\n(\"/root/Desktop/works/pyjom/src/samples/video/dog_with_text.mp4\",\n    speed=1.5\n)\n    (\"text://you did a bad job\",\n        converter=\"voice\"\n    )",
        "type": "code",
        "location": "/tests/medialang_reference/audiolang.mdl:1-20"
    },
    "4269": {
        "file_id": 550,
        "content": "The code represents a sequence of media items and text to be processed by the program. It includes audio, video files, and text strings for conversion. The media items are specified with their respective paths and properties like speed and padding. The text strings are to be converted using the \"voice\" converter and may have additional properties like provider and speed.",
        "type": "comment"
    },
    "4270": {
        "file_id": 551,
        "content": "/tests/moviepy_loop_video_till_target/test.py",
        "type": "filepath"
    },
    "4271": {
        "file_id": 551,
        "content": "This code imports the \"main\" function from the \"loop_till_target\" module and sets the target duration of the video to 20 seconds. It uses a GIF file named \"cute_cat_gif\" as input, applies the main function to it, and saves the resulting video as \"cute_cat_gif_20_secs_plus.gif\". The code also checks if the final duration of the video is greater than or equal to the target duration using an assertion statement.",
        "type": "summary"
    },
    "4272": {
        "file_id": 551,
        "content": "from loop_till_target import main\ntarget_secs = 20\nvideo_in = \"/root/Desktop/works/pyjom/samples/video/cute_cat_gif.gif\"\n# no right codec! fuck. GIF not supported?\nvideo_out = f\"/root/Desktop/works/pyjom/samples/video/cute_cat_gif_{target_secs}_secs_plus.gif\"\nfvd = main(video_in, target_secs, f_out=video_out, in_place=False,debug=True)\nassert fvd >= target_secs",
        "type": "code",
        "location": "/tests/moviepy_loop_video_till_target/test.py:1-11"
    },
    "4273": {
        "file_id": 551,
        "content": "This code imports the \"main\" function from the \"loop_till_target\" module and sets the target duration of the video to 20 seconds. It uses a GIF file named \"cute_cat_gif\" as input, applies the main function to it, and saves the resulting video as \"cute_cat_gif_20_secs_plus.gif\". The code also checks if the final duration of the video is greater than or equal to the target duration using an assertion statement.",
        "type": "comment"
    },
    "4274": {
        "file_id": 552,
        "content": "/tests/moviepy_loop_video_till_target/loop_till_target.py",
        "type": "filepath"
    },
    "4275": {
        "file_id": 552,
        "content": "This code uses ffmpeg to create a video clip with repeating segments, splitting the input video into original and reversed parts, and concatenates them based on loop strategy. It replaces sections of the input video until reaching the target duration and saves the output at specified location.",
        "type": "summary"
    },
    "4276": {
        "file_id": 552,
        "content": "import os\n# moviepy's shit.\nfrom moviepy.editor import VideoFileClip  # , concatenate_videoclips\n# import moviepy.video.fx.all as vfx\ndef main(\n    f_in: str,\n    target_secs: float,\n    f_out: str = \"\",\n    in_place: bool = True,\n    debug: bool = False,\n    # accuracy_float:int=4\n    # audio:bool=False, # it will cause trouble?\n):\n    # print(\"___\")\n    # print(\"AUDIO?\",audio)\n    # print(\"IN PLACE?\",in_place)\n    # print(\"___\")\n    assert os.path.exists(f_in)\n    assert target_secs > 0\n    # target_secs_str =(\"{\"+f':.{accuracy_float}f'+\"}\").format(target_secs)\n    targetFilePath = f_out\n    if not in_place:\n        assert f_out != \"\"\n    else:\n        targetFilePath = f_in\n    clip = VideoFileClip(f_in)\n    # if not audio:\n    #     clip = clip.without_audio()\n    # newclip = clip.fx(vfx.time_mirror) # error?\n    # newclip = clip\n    import ffmpeg\n    file_input_split = ffmpeg.input(f_in).filter_multi_output(\n        \"split\"\n    )  # this is infinite split.\n    videoDuration = clip.duration\n    import math\n    import tempfile",
        "type": "code",
        "location": "/tests/moviepy_loop_video_till_target/loop_till_target.py:1-47"
    },
    "4277": {
        "file_id": 552,
        "content": "The code imports necessary libraries and defines a function \"main\" that takes input file, target duration, output file (optional), performs in-place editing (optional), and debug mode (optional). It asserts the existence of the input file and positive target duration. Depending on options, it either splits or mirrors the video using ffmpeg before processing.",
        "type": "comment"
    },
    "4278": {
        "file_id": 552,
        "content": "    import shutil\n    fileExtension = f_in.split(\".\")[-1]\n    assert fileExtension != \"\"\n    loopStrategy = [\n        (-1) ** i for i in range(math.ceil(target_secs / videoDuration))\n    ]  # zero division error?\n    if debug:\n        print(\"Loop strategy:\")\n        print(loopStrategy)\n    clips = []\n    file_input_original = file_input_split[0].filter_multi_output(\"split\")\n    file_input_reverse = (\n        file_input_split[1].filter(\"reverse\").filter_multi_output(\"split\")\n    )\n    for index, signal in enumerate(loopStrategy):\n        mindex = index // 2\n        if signal == 1:\n            file_input = file_input_original[mindex]\n            clips.append(file_input)\n        else:\n            file_input_reverse2 = file_input_reverse[mindex]\n            clips.append(file_input_reverse2)\n    # final = concatenate_videoclips(clips)\n    final = ffmpeg.concat(*clips)\n    finalVideoDuration = len(loopStrategy) * videoDuration\n    with tempfile.NamedTemporaryFile(\n        \"w+\",\n        suffix=f\".{fileExtension}\",\n    ) as f:",
        "type": "code",
        "location": "/tests/moviepy_loop_video_till_target/loop_till_target.py:48-82"
    },
    "4279": {
        "file_id": 552,
        "content": "This code is creating a video clip with repeating segments. It splits the input video into two parts, original and reversed. Then, it loops through a list of loop strategies to determine which segment (original or reversed) should be used for each iteration. The final video is created by concatenating these segments together using ffmpeg. The resulting video's duration will be determined by the length of the loop strategy list multiplied by the original video's duration.",
        "type": "comment"
    },
    "4280": {
        "file_id": 552,
        "content": "        tmpFilePath = f.name\n        # warning! what is the audio shit?\n        # print(\"TMP FILE PATH?\",tmpFilePath)\n        # breakpoint()\n        # final.write_videofile(tmpFilePath, fps=clip.fps)\n        # finalVideoDuration = final.duration\n        final.output(tmpFilePath).run(overwrite_output=True)\n        shutil.copy(tmpFilePath, targetFilePath)\n    return finalVideoDuration\nif __name__ == \"__main__\":\n    import argparse\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"-i\", \"--input\", help=\"input file\", required=True, type=str)\n    parser.add_argument(\"-o\", \"--output\", help=\"output file\", default=\"\", type=str)\n    parser.add_argument(\n        \"-r\",\n        \"--replace\",\n        help=\"replace original input file\",\n        action=\"store_true\",\n        default=False,\n    )\n    # parser.add_argument(\n    #     \"-a\",\n    #     \"--audio\",\n    #     help=\"include audio from input\",\n    #     action=\"store_true\",\n    #     default=False,\n    # )\n    parser.add_argument(\n        \"-t\", \"--target\", help=\"target seconds\", required=True, type=float",
        "type": "code",
        "location": "/tests/moviepy_loop_video_till_target/loop_till_target.py:83-116"
    },
    "4281": {
        "file_id": 552,
        "content": "This code takes an input video file and replaces a specific section of the video with another video until a target duration is reached. The final output is saved at the specified output location.",
        "type": "comment"
    },
    "4282": {
        "file_id": 552,
        "content": "    )\n    args = parser.parse_args()\n    if not args.replace:\n        assert args.output != \"\"\n    main(\n        args.input,\n        args.target,\n        f_out=args.output,\n        in_place=args.replace,\n        # audio=args.audio\n    )",
        "type": "code",
        "location": "/tests/moviepy_loop_video_till_target/loop_till_target.py:117-128"
    },
    "4283": {
        "file_id": 552,
        "content": "The code initializes a parser, parses command line arguments, asserts the absence of replace flag or an output path specified, and then calls the main function with the input, target, output (if applicable), and replace (if applicable) arguments.",
        "type": "comment"
    },
    "4284": {
        "file_id": 553,
        "content": "/tests/readbility_webpage_to_markdown_simplification/test_readability.py",
        "type": "filepath"
    },
    "4285": {
        "file_id": 553,
        "content": "Code imports necessary libraries, sets URL for webpage, retrieves response from the page using GET request, initializes a Readability Document object with the page's text, prints document summary and title.",
        "type": "summary"
    },
    "4286": {
        "file_id": 553,
        "content": "import requests\nfrom readability import Document\nurl='https://zhuanlan.zhihu.com/p/384614837'\nresponse = requests.get(url)\ndoc = Document(response.text)\nprint(doc.summary())\nprint()\nprint(doc.title())\n# print()\n# print(dir(doc))",
        "type": "code",
        "location": "/tests/readbility_webpage_to_markdown_simplification/test_readability.py:1-10"
    },
    "4287": {
        "file_id": 553,
        "content": "Code imports necessary libraries, sets URL for webpage, retrieves response from the page using GET request, initializes a Readability Document object with the page's text, prints document summary and title.",
        "type": "comment"
    },
    "4288": {
        "file_id": 554,
        "content": "/tests/readbility_webpage_to_markdown_simplification/test_node_readbility.js",
        "type": "filepath"
    },
    "4289": {
        "file_id": 554,
        "content": "The code requires the 'node-readability' module and uses it to fetch an article from a specified URL. It then logs the article content, title, HTML source code, DOM, response object from the request library, and closes the article to prevent leaks.",
        "type": "summary"
    },
    "4290": {
        "file_id": 554,
        "content": "var read = require('node-readability');\nurl = \"https://zhuanlan.zhihu.com/p/384614837\"\n    // 'http://howtonode.org/really-simple-file-uploads'\nread(url, function(err, article, meta) {\n    // Main Article\n    console.log(article.content); // still html\n    // Title\n    console.log(article.title);\n    // HTML Source Code\n    // console.log(article.html);\n    // // DOM\n    // console.log(article.document);\n    // Response Object from Request Lib\n    // console.log(meta);\n    // Close article to clean up jsdom and prevent leaks\n    article.close();\n});",
        "type": "code",
        "location": "/tests/readbility_webpage_to_markdown_simplification/test_node_readbility.js:1-19"
    },
    "4291": {
        "file_id": 554,
        "content": "The code requires the 'node-readability' module and uses it to fetch an article from a specified URL. It then logs the article content, title, HTML source code, DOM, response object from the request library, and closes the article to prevent leaks.",
        "type": "comment"
    },
    "4292": {
        "file_id": 555,
        "content": "/tests/readbility_webpage_to_markdown_simplification/test_mozilla.js",
        "type": "filepath"
    },
    "4293": {
        "file_id": 555,
        "content": "Code loads a web page containing an image of a cat, uses jsdom to parse the HTML, and then uses the Readability library from @mozilla/readability to extract the article content. The extracted article is logged to the console.",
        "type": "summary"
    },
    "4294": {
        "file_id": 555,
        "content": "const jsdom = require(\"jsdom\");\nconst { JSDOM } = jsdom;\ndoc = new jsdom.JSDOM(\"<body>Look at this cat: <img src='./cat.jpg'></body>\"); // load this shit from the web or something...\n// make it into a server.\nconst { Readability } = require('@mozilla/readability');\nlet reader = new Readability(doc.window.document);\narticle = reader.parse();\nconsole.log(article);",
        "type": "code",
        "location": "/tests/readbility_webpage_to_markdown_simplification/test_mozilla.js:1-8"
    },
    "4295": {
        "file_id": 555,
        "content": "Code loads a web page containing an image of a cat, uses jsdom to parse the HTML, and then uses the Readability library from @mozilla/readability to extract the article content. The extracted article is logged to the console.",
        "type": "comment"
    },
    "4296": {
        "file_id": 556,
        "content": "/tests/readbility_webpage_to_markdown_simplification/README.md",
        "type": "filepath"
    },
    "4297": {
        "file_id": 556,
        "content": "These are test links for the readability_webpage_to_markdown_simplification functionality.",
        "type": "summary"
    },
    "4298": {
        "file_id": 556,
        "content": "test links:\nhttps://www.macbookproslow.com/is-macbook-air-good-for-programming/\nhttps://zhuanlan.zhihu.com/p/384614837\nhttps://mp.weixin.qq.com/s?src=11&timestamp=1663090785&ver=4042&signature=8bWivjRcA5sicP22nFtzBBEP8LeQJa9rHgTA7wd7QTteh8Rcj0uc2QS1VeZjaI*PPjt90MNn9vigukae1keLI7GYXzbLXl93djqb5K7iPuOdbz2NBgvbxq6wImUD05XX&new=1",
        "type": "code",
        "location": "/tests/readbility_webpage_to_markdown_simplification/README.md:1-4"
    },
    "4299": {
        "file_id": 556,
        "content": "These are test links for the readability_webpage_to_markdown_simplification functionality.",
        "type": "comment"
    }
}