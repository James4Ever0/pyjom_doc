{
    "1200": {
        "file_id": 104,
        "content": "from lazero.utils.json import jsonify\n# ellipsis = type(...)\n# serve my video, serve my cat video, dog video, set priority, serve others video\n# by means of query? or just directly ask me for it.\n# you'd better mimic the video that you have never recommend, and these audience have never seen before.\nimport time\n# utils.\ndef default(value, default_, isInstance=lambda v: v in [..., None]):\n    if isInstance(value):\n        return default_\n    return value\nimport datetime\nfrom typing import Union, Literal\nfrom functools import lru_cache\nimport random\n# you might want to add this to bilibili platform api, if there's no use of pyjom.commons\nfrom pyjom.platforms.bilibili.credentials import getCredentialByDedeUserId\nfrom pyjom.platforms.bilibili.utils import (\n    linkFixer,\n    videoDurationStringToSeconds,\n    clearHtmlTags,\n)\nfrom lazero.search.preprocessing import getFourVersionsOfProcessedLine\nimport jieba\nimport opencc\nimport jieba.analyse as ana\nimport progressbar\nimport pydantic\n@lru_cache(maxsize=4)\ndef getOpenCCConverter(converter_type: str = \"t2s\"):",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:1-43"
    },
    "1201": {
        "file_id": 104,
        "content": "This code appears to be a part of a larger program that deals with video recommendations and retrieval on the bilibili platform. It imports various libraries and functions, such as jieba for text processing, opencc for Chinese-to-simplified Chinese conversion, and pydantic for data validation. The getOpenCCConverter function is a memoized function that converts text using OpenCC's \"t2s\" type.",
        "type": "comment"
    },
    "1202": {
        "file_id": 104,
        "content": "    converter = opencc.OpenCC(converter_type)\n    return converter\ndef isChineseCharacter(char):\n    assert len(char) == 1\n    return char >= \"\\u4e00\" and char <= \"\\u9fff\"\ndef containChineseCharacters(text):\n    for char in text:\n        if isChineseCharacter(char):\n            return True\n    return False\nfrom lazero.utils.mathlib import extract_span\ndef textPreprocessing(text):\n    converter = getOpenCCConverter()\n    text = converter.convert(text)\n    (\n        final_line,\n        final_cutted_line,\n        final_stemmed_line,\n        final_cutted_stemmed_line,\n    ) = getFourVersionsOfProcessedLine(text)\n    # breakpoint()\n    wordlist = jieba.lcut(final_cutted_line)\n    final_wordlist = []\n    for w in wordlist:\n        word = w.strip()\n        if len(word) > 0:\n            final_wordlist.append(word)\n    flags = [int(containChineseCharacters(word)) for word in final_wordlist]\n    chineseSpans = extract_span(flags, target=1)\n    nonChineseSpans = extract_span(flags, target=0)\n    finalSpans = [(span, True) for span in chineseSpans] + [",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:44-82"
    },
    "1203": {
        "file_id": 104,
        "content": "This code snippet performs text preprocessing on a given text. It uses the OpenCC library to convert the text to simplified Chinese if needed, and then applies Jieba's jieba.lcut method for word segmentation. The resulting words are checked for their presence in the Chinese character range (u4e00-u9fff). Flags are created based on whether each word contains a Chinese character or not. The extract_span function is then used to identify spans of consecutive words with similar flags, which are assumed to be either Chinese or non-Chinese text.",
        "type": "comment"
    },
    "1204": {
        "file_id": 104,
        "content": "        (span, False) for span in nonChineseSpans\n    ]\n    finalSpans.sort(key=lambda span: span[0])\n    finalWordList = []\n    for span, isChineseSpan in finalSpans:\n        subWordList = final_wordlist[span[0] : span[1]]\n        subChars = \"\".join(subWordList)\n        subCharList = [c for c in subChars]  # 直接给你逐字切割了 说不定就有用了\n        if isChineseSpan:\n            subWordList = jieba.lcut_for_search(subChars)\n        finalWordList.extend(subWordList)\n        finalWordList.extend(subCharList)\n    return \" \".join(finalWordList)\nfrom nltk.corpus import stopwords\n@lru_cache(maxsize=1)\ndef getStopwords(languages: tuple = (\"chinese\", \"english\")):\n    stopword_list = []\n    for lang in languages:\n        stopword_list.extend(stopwords.words(lang))\n    return stopword_list\ndef keywordExtracting(\n    text,\n    method: Literal[\"tfidf\", \"random\"] = \"tfidf\",\n    languages: tuple = (\"chinese\", \"english\"),\n    topK: int = 5,\n):\n    # remove all stopwords.\n    keyword_list = textPreprocessing(text).split(\" \")\n    stopword_list = getStopwords(languages=languages)",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:83-117"
    },
    "1205": {
        "file_id": 104,
        "content": "This code performs text preprocessing and keyword extraction. It removes stopwords, utilizes a custom function for Chinese word segmentation, and implements TF-IDF or random selection of top keywords from the preprocessed text. It also stores commonly used stopwords in memory using LRU cache.",
        "type": "comment"
    },
    "1206": {
        "file_id": 104,
        "content": "    results = []\n    for k in keyword_list:\n        if k.lower() not in stopword_list:\n            results.append(k)\n    if method == \"random\":\n        random.shuffle(results)\n        return results[:topK]\n    elif method == \"tfidf\":\n        myText = \" \".join(results)\n        tags = ana.extract_tags(myText, topK=topK)\n        return tags\n    else:\n        raise Exception(\"Unknown keyword extraction method: %s\" % method)\n################################BILIBILI QUERY DATA MODELS######################\n# @reloading\nclass queryForm(pydantic.BaseModel):\n    query: str  # required?\n    page_size: Union[int, None] = None\n    page_num: int = 1\n    query_for_search_cached: Union[str, None] = None\n    # you are going to inherit this.\n    @property\n    def query_for_search(\n        self,\n    ):  # make sure the preprocessing is only called once. really?\n        if self.query_for_search_cached is None:\n            query = self.query\n            self.query_for_search_cached = textPreprocessing(query)\n        return self.query_for_search_cached",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:118-151"
    },
    "1207": {
        "file_id": 104,
        "content": "This code performs keyword extraction based on the provided method. It filters out stopwords, shuffles results if using the \"random\" method, and uses TF-IDF for the \"tfidf\" method. The `queryForm` class is a Pydantic model for BiliBili query data models with properties for query, page size, page number, and cached preprocessed search query.",
        "type": "comment"
    },
    "1208": {
        "file_id": 104,
        "content": "# @reloading\nclass searchVideoForm(queryForm):\n    iterate: bool = False\n    params: dict = {}  # let's just see what you've got here.\nfrom bilibili_api.user import VideoOrder\n# @reloading\nclass searchRegisteredVideoForm(queryForm):\n    tid: int = 0\n    dedeuserid: Union[list[str], str, None] = None\n    videoOrder: VideoOrder = VideoOrder.PUBDATE\n# @reloading\nclass searchUserVideoForm(searchRegisteredVideoForm):\n    dedeuserid: str = \"397424026\"\n    method: Literal[\"online\", \"bm25\"] = \"online\"\n    use_credential: bool = False\n# @reloading\nclass registerUserVideoForm(pydantic.BaseModel):\n    bvid: str\n    dedeuserid: str\n    is_mine: bool = False\n    visible: bool = False\n################################BILIBILI QUERY DATA MODELS######################\n# from pyjom.platforms.bilibili.searchDataParser import parseSearchVideoResult # but you never use this shit.\n# will it load the overheads of pyjom.commons?\n# updated anyio. does that work? will it break dependencies?\nimport pyjq\nfrom bilibili_api import sync, search, user, video",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:154-195"
    },
    "1209": {
        "file_id": 104,
        "content": "The code defines four classes: `searchVideoForm`, `searchRegisteredVideoForm`, `searchUserVideoForm`, and `registerUserVideoForm`. These classes inherit from `queryForm` and are used for querying video data on Bilibili. The classes have different parameters, such as `tid`, `dedeuserid`, `videoOrder`, `method`, and `use_credential`, to specify the desired search criteria. The code also imports necessary modules and functions from `bilibili_api` for performing operations on videos, users, and searches.",
        "type": "comment"
    },
    "1210": {
        "file_id": 104,
        "content": "from peewee import *\nfrom playhouse.sqlite_ext import SqliteExtDatabase, FTSModel, SearchField, RowIDField\nBSP = search.bilibiliSearchParams\n# you can query for the server status.\n# make it into a dashboard like thing.\n@lru_cache(maxsize=1)\ndef getMajorMinorTopicMappings(debug: bool = False):\n    majorMinorMappings = {}\n    for key, value in BSP.all.tids.__dict__.items():\n        try:\n            major_tid = value.tid\n            if debug:\n                print(\"MAJOR\", key, major_tid)\n            content = {\"major\": {\"tid\": major_tid, \"name\": key}}\n            majorMinorMappings.update(\n                {major_tid: content, key: content, str(major_tid): content}\n            )\n            for subkey, subvalue in value.__dict__.items():\n                if subkey != \"tid\" and type(subvalue) == int:\n                    if debug:\n                        print(\"MINOR\", subkey, subvalue)\n                    content = {\n                        \"major\": {\"tid\": major_tid, \"name\": key},\n                        \"minor\": {\"tid\": subvalue, \"name\": subkey},",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:197-223"
    },
    "1211": {
        "file_id": 104,
        "content": "This code retrieves major and minor topic mappings from the bilibiliSearchParams database table and stores them in a dictionary called 'majorMinorMappings'. The function is memoized using @lru_cache decorator to avoid redundant queries. The debug parameter, if set to True, will print the major and minor topics during execution.",
        "type": "comment"
    },
    "1212": {
        "file_id": 104,
        "content": "                    }\n                    majorMinorMappings.update(\n                        {subvalue: content, subkey: content, str(subvalue): content}\n                    )\n        except:\n            pass\n    return majorMinorMappings\ndef getTagStringFromTid(tid):\n    majorMinorTopicMappings = getMajorMinorTopicMappings()\n    topic = majorMinorTopicMappings.get(tid, None)\n    tags = []\n    if topic:\n        majorTopic = topic.get(\"major\", {}).get(\"name\", None)\n        minorTopic = topic.get(\"minor\", {}).get(\"name\", None)\n        if majorTopic:\n            tags.append(majorTopic)\n            if minorTopic:\n                tags.append(minorTopic)\n    return \",\".join(tags)\n# also make a decorator for refreshing status, add it to every function.\n# thie refresher is scheduled.\n# you may want to run this beforehand...\nimport schedule\n# do we really need credential for checking our video? you can try.\n@lru_cache(maxsize=3)  # could be bigger.\ndef getUserObject(dedeuserid: str = \"397424026\", use_credential: bool = False):",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:224-257"
    },
    "1213": {
        "file_id": 104,
        "content": "This code defines a function `getTagStringFromTid(tid)` that retrieves topic details from a topic ID (tid) and returns a comma-separated list of major and minor topics. It also uses a decorator to refresh the status, scheduled by calling `schedule()`, and a cached version of `getUserObject()` function with an optional dedeuserid and use_credential parameters.",
        "type": "comment"
    },
    "1214": {
        "file_id": 104,
        "content": "    dedeuserid_int = int(dedeuserid)\n    if use_credential:\n        credential = getCredentialByDedeUserId(\n            dedeuserid\n        )  # this will cache the cookies. so it allows multiple accounts.\n    else:\n        credential = None\n    u = user.User(dedeuserid_int, credential=credential)\n    return u\nfrom lazero.filesystem.env import getHomeDirectory\nfrom pathlib import Path\nimport os\nfrom peewee import *\nclass BilibiliUser(Model):\n    username = CharField()  # can be updated later.\n    user_id = IntegerField(unique=True)  # this is integer.\n    is_mine = BooleanField(default=False)\n    followers = IntegerField(\n        null=True\n    )  # how to get that? every time you get some video you do this shit? will get you blocked.\n    # well you can check it later.\n    avatar = CharField(null=True)  # warning! charfield max length is 255\n    def userInfoExtracter(self, blacklist=[\"id\"]):\n        info = {\n            key: value for key, value in self.__data__.items() if key not in blacklist\n        }\n        return info",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:258-290"
    },
    "1215": {
        "file_id": 104,
        "content": "The code defines a class called BilibiliUser, which inherits from the peewee.Model class. The class has fields for username, user_id (which is unique), is_mine flag, followers count, and avatar URL. A method, userInfoExtracter, is also defined to extract information from the model instance excluding specified keys. Additionally, a function exists to create a new User instance based on the provided dedeuserid and credential.",
        "type": "comment"
    },
    "1216": {
        "file_id": 104,
        "content": "class BilibiliVideo(Model):\n    bvid = CharField(unique=True)\n    typeid = IntegerField(null=True)  # string? wtf?\n    visible = BooleanField(null=True)  # are you sure?\n    last_check = DateTimeField(\n        default=datetime.datetime.now\n    )  # well this is not tested. test it!\n    register_date = DateTimeField(default=datetime.datetime.now)\n    poster = ForeignKeyField(\n        BilibiliUser, field=BilibiliUser.user_id\n    )  # is it my account anyway?\n    play = IntegerField(null=True)\n    pic = CharField(null=True)\n    length = IntegerField(null=True)\n    pubdate = IntegerField(default=0, null=True)\n    review = IntegerField(null=True)  # you want to update? according to this?\n    favorites = IntegerField(default=0, null=True)\n    title = CharField(null=True)\n    tag = CharField(null=True)\n    description = CharField(null=True)\n    def videoInfoExtractor(\n        self, blacklist=[\"id\", \"last_check\", \"register_date\", \"poster\"]\n    ):\n        info = {\n            key: value for key, value in self.__data__.items() if key not in blacklist",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:293-318"
    },
    "1217": {
        "file_id": 104,
        "content": "This code defines a BilibiliVideo class that inherits from Model and includes various fields such as bvid, typeid, visible, last_check, register_date, poster, play, pic, length, pubdate, review, favorites, title, and tag. The videoInfoExtractor method takes a blacklist parameter and returns information excluding the specified fields.",
        "type": "comment"
    },
    "1218": {
        "file_id": 104,
        "content": "        }\n        poster = self.poster\n        try:\n            info[\n                \"poster\"\n            ] = (\n                poster.userInfoExtracter()\n            )  # well it will return as always. no live fetching! it is stored in database.\n        except:\n            import traceback\n            traceback.print_exc()\n            print(\"userinfo might be missing from videoinfo.\")\n        try:\n            info[\"typeid\"] = int(info[\"typeid\"])\n        except:\n            pass\n        return info\nclass BilibiliVideoIndex(FTSModel):\n    rowid = RowIDField()\n    # these three must be preprocessed before put into the search engine, or we cannot retrieve the data correctly.\n    title = SearchField()\n    tag = (\n        SearchField()\n    )  # also what the fuck is going on with the tag? why we cannot get the tag/topic name?\n    description = SearchField()\n    class Meta:\n        database = None  # that's good.\n        options = {\"tokenize\": \"porter\"}  # you need manually separate some\n@lru_cache(maxsize=1)\ndef getBilibiliVideoDatabase():",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:319-354"
    },
    "1219": {
        "file_id": 104,
        "content": "This code is initializing a BilibiliVideoIndex model, which extends FTSModel and has three SearchField properties (title, tag, description). It also contains a RowIDField (rowid). The function getBilibiliVideoDatabase() is a cache-friendly function to access the database.",
        "type": "comment"
    },
    "1220": {
        "file_id": 104,
        "content": "    db_dir = Path(getHomeDirectory()) / \".bilibili_video\"\n    if not os.path.exists(db_dir):\n        os.mkdir(db_dir)\n    db_path = db_dir / \"database.db\"  # sure this works?\n    # db = SqliteDatabase(db_path)\n    db = SqliteExtDatabase(\n        db_path, pragmas={\"journal_mode\": \"wal\", \"cache_size\": -1024 * 64}\n    )\n    # test the full text search function elsewhere. please?\n    return db\ndef getBilibiliVideoDatabaseAndCreateTables():\n    db = getBilibiliVideoDatabase()\n    db.create_tables([BilibiliUser, BilibiliVideo, BilibiliVideoIndex])\n    return db\n# no need to decorate this thing. only put some 'unchecked' video into array.\ndef registerUser(dedeuserid: str, is_mine: Union[bool, None] = None):\n    user_id = int(dedeuserid)\n    u = BilibiliUser.get_or_none(user_id=user_id)\n    if u is None:  # this is to create.\n        if is_mine is None:\n            is_mine = False\n        userObject = user.User(user_id)\n        userInfo = sync(userObject.get_user_info())\n        # print(userInfo)\n        # print(dir(userInfo))",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:355-383"
    },
    "1221": {
        "file_id": 104,
        "content": "The code sets up a SQLite database for the Bilibili video platform. It creates a directory if it doesn't exist, defines the database path, and initializes an SqliteExtDatabase object with specified pragmas. The getBilibiliVideoDatabaseAndCreateTables function creates necessary tables using the defined database, and registerUser function retrieves or creates a BilibiliUser based on the provided dedeuserid.\n\nThe code sets up a SQLite database for the Bilibili video platform by initializing an SqliteExtDatabase object with specified pragmas and creating required tables. The getBilibiliVideoDatabaseAndCreateTables function utilizes this setup, while the registerUser function handles user retrieval or creation based on dedeuserid.",
        "type": "comment"
    },
    "1222": {
        "file_id": 104,
        "content": "        # breakpoint()\n        # dict_keys(['list', 're_version', 'total'])\n        # in the 'list' we've got a few recent followers.\n        followersInfo = sync(userObject.get_followers())\n        username = userInfo[\"name\"]\n        followers = followersInfo[\"total\"]\n        avatar = userInfo[\"face\"]\n        (\n            u,\n            _,\n        ) = BilibiliUser.get_and_update_or_create(  # this is wrong. maybe the username is updated.\n            user_id=user_id,\n            username=username,\n            is_mine=is_mine,\n            followers=followers,\n            avatar=avatar,\n        )\n        # when to update? maybe later.\n    elif is_mine is not None and u.is_mine != is_mine:\n        u.is_mine = is_mine\n        u.save()\n    return u\n# @refresh_status_decorator\ndef searchVideos(\n    query: str,\n    iterate: bool = False,\n    page_start: int = 1,\n    params={\"duration\": BSP.all.duration._10分钟以下},  # is that right? maybe?\n    page_size: int = ...,\n):  # what do you expect? you want the xml object let's get it!",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:384-415"
    },
    "1223": {
        "file_id": 104,
        "content": "The code appears to be fetching user and video information from the Bilibili platform, handling updates for user profiles, and searching for videos based on a given query. It utilizes functions like `get_followers()`, `BilibiliUser.get_and_update_or_create()`, and `searchVideos()`. The code also includes a refresh status decorator, and handles user profile updates if the 'is_mine' flag changes.",
        "type": "comment"
    },
    "1224": {
        "file_id": 104,
        "content": "    # search the thing directly? or you distill keywords from it?\n    search_type = search.SearchObjectType.VIDEO\n    # or you use some baidu magic?\n    # anyway, let's begin.\n    # warning: this is coroutine.\n    # you might want some magic. with 'suppressException' and pickledFunction?\n    def getResultParsed(result):\n        mresult = pyjq.all(\n            \".result[] | {mid, author, pic, play, is_pay, duration, bvid, description, title, pubdate, tag, typename, typeid, review, favorites, danmaku, rank_score, like, upic} | select (.title != null and .bvid != null)\",\n            result,\n        )\n        return mresult\n    def getResult(page):\n        result = sync(\n            search.search_by_type(\n                query,\n                search_type,\n                params=params,\n                page=page,\n                **jsonify(dict(page_size=page_size)),\n            )\n        )\n        return result\n    result = getResult(page_start)\n    numPages = result[\"numPages\"]  # usually we select the topmost candidates.",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:416-442"
    },
    "1225": {
        "file_id": 104,
        "content": "This code searches for results on Bilibili using the search_type parameter and query. It uses coroutines to get the result, then extracts and returns parsed data from the result. The function gets the result by calling a search API with specified parameters and retrieves the number of pages from the returned result.",
        "type": "comment"
    },
    "1226": {
        "file_id": 104,
        "content": "    # print(result)\n    if numPages < page_start:\n        page_start_current = 1\n    else:\n        page_start_current = page_start\n        mresult = getResultParsed(result)\n        for v in mresult:\n            yield v\n    if not iterate:\n        page_range = range(page_start_current, page_start_current + 1)\n    else:\n        import progressbar\n        print(f\"iterating page range: {page_start_current}-{numPages}\")\n        page_range = progressbar.progressbar(range(page_start_current, numPages + 1))\n    for page in page_range:\n        if page != page_start:\n            result = getResult(page)\n            mresult = getResultParsed(result)\n            for v in mresult:\n                yield v\n    # you can use the upic to render some deceptive ads, but better not?\n    # so you want to persist these results or not?\n    # better persist so we can reuse.\n    # no persistance?\n    # check some interesting result.\n    # no selection?\n    # you should use the parser found elsewhere. or not?\n    # breakpoint()\n    # remove keyword highlight from title. will you?",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:443-474"
    },
    "1227": {
        "file_id": 104,
        "content": "The code is responsible for iterating through a range of pages, fetching data from each page, and processing the results. It also includes checks to see if persistence is required or if any selections need to be made. Additionally, it considers whether to remove keyword highlights from titles. The code may also handle potential errors or breakpoints with a `breakpoint()` statement.",
        "type": "comment"
    },
    "1228": {
        "file_id": 104,
        "content": "    # result['result'][0].keys()\n    # keys = [\n    #     \"type\",\n    #     \"id\",\n    #     \"author\",\n    #     \"mid\",\n    #     \"typeid\",\n    #     \"typename\",\n    #     \"arcurl\",\n    #     \"aid\",\n    #     \"bvid\",\n    #     \"title\",\n    #     \"description\",\n    #     \"arcrank\",\n    #     \"pic\",\n    #     \"play\",\n    #     \"video_review\",\n    #     \"favorites\",\n    #     \"tag\",\n    #     \"review\",\n    #     \"pubdate\",\n    #     \"senddate\",\n    #     \"duration\",\n    #     \"badgepay\",\n    #     \"hit_columns\",\n    #     \"view_type\",\n    #     \"is_pay\",\n    #     \"is_union_video\",\n    #     \"rec_tags\",\n    #     \"new_rec_tags\",\n    #     \"rank_score\",\n    #     \"like\",\n    #     \"upic\",\n    #     \"corner\",\n    #     \"cover\",\n    #     \"desc\",\n    #     \"url\",\n    #     \"rec_reason\",\n    #     \"danmaku\",\n    # ]\n    # rank score is important!\n# you need my credential!\n# better reuse the code.\ndef checkVideoInDatabase(bvid: str):\n    # we use peewee (of course our modified version)\n    db = getBilibiliVideoDatabase()\n    db.create_tables([BilibiliVideo, BilibiliUser])",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:475-525"
    },
    "1229": {
        "file_id": 104,
        "content": "This code is defining a function `checkVideoInDatabase` that takes a video bvid as input, initializes a Peewee database, creates tables for BilibiliVideo and BilibiliUser, and checks if the video already exists in the database. It returns True if the video is found, otherwise False.",
        "type": "comment"
    },
    "1230": {
        "file_id": 104,
        "content": "    result = BilibiliVideo.get_or_none(BilibiliVideo.bvid == bvid)\n    return result  # check it elsewhere?\n# get my videos first!\nimport math\n# @refresh_status_decorator\nfrom bilibili_api.user import VideoOrder\ndef indexAndGetVideoObject(\n    v, bilibiliUser\n):  # let's wrap this shit. eliminate those 'erroneous' display.\n    try:\n        v[\"typeid\"] = int(v[\"typeid\"])\n    except:\n        pass\n    favdict = {}\n    favorites = v.get(\"favorites\", None)\n    if favorites is not None:\n        favdict[\"favorites\"] = favorites\n    bilibiliVideo, flag = BilibiliVideo.get_and_update_or_create(\n        bvid=v[\"bvid\"],\n        typeid=v[\"typeid\"],\n        visible=True,  # are you sure?\n        last_check=datetime.datetime.now(),  # well this is not tested. test it!\n        poster=bilibiliUser,  # is it my account anyway?\n        play=v[\"play\"],\n        pic=linkFixer(v[\"pic\"]),\n        length=videoDurationStringToSeconds(v.get(\"length\", v.get(\"duration\"))),\n        review=v.get(\"comment\", v.get(\"review\")),\n        pubdate=v.get(\"created\", v.get(\"pubdate\")),",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:526-558"
    },
    "1231": {
        "file_id": 104,
        "content": "This code retrieves a BilibiliVideo object based on the provided bvid and typeid, updates or creates it if necessary, and fills in various attributes from the given video dictionary. The poster attribute is set to bilibiliUser, assuming it belongs to that user's account. The visible attribute is set to True by default, but this may need verification. The last_check timestamp is set to the current datetime, and the code attempts to fix the pic URL with a linkFixer function call.",
        "type": "comment"
    },
    "1232": {
        "file_id": 104,
        "content": "        description=v[\"description\"],\n        title=clearHtmlTags(v[\"title\"]),  # it may contain highlights. be warned\n        tag=v[\"tag\"],\n        **favdict,\n        # _debug=True\n    )\n    # print(\"f\", flag)\n    # print(v)\n    # print(bilibiliUser)\n    # breakpoint()\n    bilibiliVideoIndex, _ = BilibiliVideoIndex.get_and_update_or_create(\n        rowid=bilibiliVideo.id,\n        description=textPreprocessing(bilibiliVideo.description),\n        tag=textPreprocessing(bilibiliVideo.tag),\n        title=textPreprocessing(bilibiliVideo.title),\n    )\n    return bilibiliVideo\ndef getUserVideos(\n    tid=0,\n    keyword=\"\",\n    order=VideoOrder.PUBDATE,\n    dedeuserid: str = \"397424026\",\n    use_credential: bool = False,\n    stop_on_duplicate: bool = True,\n    sleep: int = 2,\n    page_num: int = 1,\n    page_size: int = 30,\n):  # all videos? just at init.\n    pn = page_num\n    # some stop condition for early termination.\n    # if any of the video exists in the database, we stop this shit.\n    bilibiliUser = registerUser(\n        dedeuserid,",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:559-593"
    },
    "1233": {
        "file_id": 104,
        "content": "The code retrieves a user's videos from Bilibili and processes them, updating the database with the video information. It also provides options for filtering and pagination.",
        "type": "comment"
    },
    "1234": {
        "file_id": 104,
        "content": "    )\n    u = getUserObject(dedeuserid=dedeuserid, use_credential=use_credential)\n    # tid\tint, optional\t分区 ID. Defaults to 0（全部）\n    # pn\tint, optional\t页码，从 1 开始. Defaults to 1.\n    # ps\t(int, optional)\t每一页的视频数. Defaults to 30.\n    # keyword\tstr, optional\t搜索关键词. Defaults to \"\".\n    # order\tVideoOrder, optional\t排序方式. Defaults to VideoOrder.PUBDATE\n    # this is async. use sync.\n    stopped = False\n    while not stopped:\n        videos = sync(\n            u.get_videos(pn=pn, keyword=keyword, tid=tid, order=order, ps=page_size)\n        )\n        # print(videos)\n        # dict_keys(['list', 'page', 'episodic_button', 'is_risk', 'gaia_res_type', 'gaia_data'])\n        page = videos[\"page\"]  # pagination options\n        numPages = math.ceil(page[\"count\"] / page[\"ps\"])\n        # print('NUM PAGES',numPages)\n        # topicDict = videos[\"list\"][\"tlist\"]\n        # {'1': {'tid': 1, 'count': 13, 'name': '动画'}, '160': {'tid': 160, 'count': 257, 'name': '生活'}, '181': {'tid': 181, 'count': 2, 'name': '影视'}, '188': {'t",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:594-613"
    },
    "1235": {
        "file_id": 104,
        "content": "This code is retrieving videos from the Bilibili platform, using a specific user object and various parameters such as pagination and keyword. It fetches data in pages and calculates the number of pages based on the total count of videos. The code handles pagination and possibly retrieves topic information based on different categories (tid).",
        "type": "comment"
    },
    "1236": {
        "file_id": 104,
        "content": "id': 188, 'count': 4, 'name': '科技'}, '217': {'tid': 217, 'count': 4, 'name': '动物圈'}, '234': {'tid': 234, 'count': 1, 'name': '运动'}, '3': {'tid': 3, 'count': 9, 'name': '音乐'}, '36': {'tid': 36, 'count': 30, 'name': '知识'}, '4': {'tid': 4, 'count': 67, 'name': '游戏'}}\n        # breakpoint()\n        video_list = videos[\"list\"][\"vlist\"]\n        # breakpoint()\n        if video_list == []:\n            break\n        for v in video_list:\n            bvid = v[\"bvid\"]\n            subTypeId = v[\"typeid\"]\n            tagString = getTagStringFromTid(subTypeId)\n            v.update({\"tag\": tagString})\n            result = checkVideoInDatabase(bvid)\n            if result and stop_on_duplicate:\n                stopped = True\n                break\n            # print(v)\n            # dict_keys(['comment', 'typeid', 'play', 'pic', 'subtitle', 'description', 'copyright', 'title', 'review', 'author', 'mid', 'created', 'length', 'video_review', 'aid', 'bvid', 'hide_click', 'is_pay', 'is_union_video', 'is_steins_gate', 'is_live_playback'])",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:613-629"
    },
    "1237": {
        "file_id": 104,
        "content": "The code is iterating through a list of videos and for each video, it updates the tag string using getTagStringFromTid function. Then, it checks if the video already exists in the database using checkVideoInDatabase function. If the video is found and stop_on_duplicate is True, the loop breaks and stopped is set to True.",
        "type": "comment"
    },
    "1238": {
        "file_id": 104,
        "content": "            # breakpoint()\n            # bad idea. you should get the bilibiliUser before you do this.\n            bilibiliVideo = indexAndGetVideoObject(v, bilibiliUser)\n            yield bilibiliVideo\n        # videos['list']['vlist'][0].keys()\n        # dict_keys(['comment', 'typeid', 'play', 'pic', 'subtitle', 'description', 'copyright', 'title', 'review', 'author', 'mid', 'created', 'length', 'video_review', 'aid', 'bvid', 'hide_click', 'is_pay', 'is_union_video', 'is_steins_gate', 'is_live_playback'])\n        if pn >= numPages:\n            break\n        elif not stop_on_duplicate:\n            break  # this is the hint of merely using this as a search tool\n        time.sleep(sleep)\n        pn += 1\n# cannot resolve 217?\ndef resolveSubTidsFromTid(tid: int):\n    if type(tid) != int:\n        tid = int(tid)\n    MMTM = getMajorMinorTopicMappings()\n    allTids = [t for t in MMTM.keys() if type(t) == int]\n    if tid == 0:\n        return allTids\n    elif tid not in allTids:\n        raise Exception(\"Invalid tid: %d\" % tid)",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:630-653"
    },
    "1239": {
        "file_id": 104,
        "content": "This code appears to be part of a larger program responsible for interacting with the Bilibili platform's database. It utilizes functions like `indexAndGetVideoObject`, `getMajorMinorTopicMappings`, and `resolveSubTidsFromTid`. The main functionality seems to involve looping through pages of videos, obtaining video objects, and resolving subtopic IDs from a given topic ID. There is also a mechanism for handling duplicate or redundant data and an optional sleep function to control the speed at which the program retrieves information.",
        "type": "comment"
    },
    "1240": {
        "file_id": 104,
        "content": "    else:\n        myTids = set()\n        myTids.add(tid)\n        # print(\"ALL TIDS?\")\n        # import rich\n        # rich.print(allTids)\n        # rich.print(MMTM)\n        myTopic = MMTM[tid]\n        # myTopic = allTids[tid]\n        if myTopic.get(\"minor\", None) == None:\n            # this is a major topic\n            for t in allTids:\n                subTopic = MMTM[t]\n                if subTopic.get(\"major\", {}).get(\"tid\", None) == tid:\n                    subTid = subTopic.get(\"minor\", {}).get(\"tid\", tid)\n                    myTids.add(subTid)\n        return list(myTids)\ndef searchRegisteredVideosAndGetResultList(\n    keyword: str,\n    tid: int = 0,\n    dedeuserid: Union[str, None, list[str]] = \"397424026\",\n    videoOrder=VideoOrder.PUBDATE,  # FAVOURITE, VIEW\n    page_num: int = 1,\n    page_size: int = 10,\n):\n    resultList = []\n    resolvedTids = resolveSubTidsFromTid(tid)\n    condition = (BilibiliVideo.typeid in resolvedTids) & (BilibiliVideo.visible == True)\n    if dedeuserid is not None:\n        if type(dedeuserid) == str:",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:654-686"
    },
    "1241": {
        "file_id": 104,
        "content": "Code resolves subtopics from a given topic ID and returns a list of associated topic IDs. It checks if the topic is major or minor, then searches for subtopics related to the main topic. Finally, it adds the subtopic's minor topic IDs to the list. This function can be used to find videos related to specific keywords within registered topics and return a result list based on video order preference.",
        "type": "comment"
    },
    "1242": {
        "file_id": 104,
        "content": "            dedeuserids = [dedeuserid]\n        else:\n            dedeuserids = dedeuserid\n        dedeuserids = [int(d) for d in dedeuserids]\n    else:\n        dedeuserids = None\n        # print(\"DEDEUSERIDS:\", dedeuserids)\n    # vlist = [v for v in (BilibiliVideo.select().where(condition) or [])]\n    # http://docs.peewee-orm.com/en/latest/peewee/relationships.html#relationships\n    def getVgen(selector, videoOrder):\n        nonlocal condition, dedeuserids\n        vgen = selector\n        # breakpoint()\n        if dedeuserids:\n            from functools import reduce\n            condition &= reduce(\n                lambda a, b: a | b,\n                [BilibiliUser.user_id == int(userid) for userid in dedeuserids],\n            )\n            vgen = vgen.join(BilibiliUser).where(\n                condition\n            )  # this statement does not work.\n        else:\n            vgen = vgen.where(condition)\n        favorites = BilibiliVideo.favorites\n        pubdate = BilibiliVideo.pubdate\n        view = BilibiliVideo.play",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:687-716"
    },
    "1243": {
        "file_id": 104,
        "content": "This code retrieves bilibili videos based on a given condition. It takes into account dedeuserids, which are either provided as a list or None. If dedeuserids is not None, it applies the condition to filter the videos by specific users. Finally, it sorts and selects the videos based on favorites, pubdate, and view count.",
        "type": "comment"
    },
    "1244": {
        "file_id": 104,
        "content": "        if videoOrder == VideoOrder.FAVORITE:  # this is fake ordering.\n            order = favorites.desc()  # desc\n        elif videoOrder == VideoOrder.VIEW:\n            order = view.desc()  # desc\n        elif videoOrder == VideoOrder.PUBDATE:  # also desc.\n            order = pubdate.desc()  # most recent video.\n        else:\n            order = None\n        if order is not None:\n            vgen = vgen.order_by(order)\n        return vgen\n    # user_video_ids = [v.id for v in vgen or []]\n    # print('user of videos',set([v.poster.user_id for v in vgen or []]))\n    # breakpoint()\n    results = getVgen(\n        BilibiliVideoIndex.search_bm25(keyword).join(\n            BilibiliVideo, on=(BilibiliVideoIndex.rowid == BilibiliVideo.id)\n        ),\n        videoOrder,\n    ).paginate(  # again this is wrong.\n        page_num, page_size\n    )\n    for index, video_index in enumerate(results):\n        bilibiliVideo = BilibiliVideo.get(id=video_index.rowid)  # this shall be fast.\n        # what is the count? you need to reorder?",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:717-742"
    },
    "1245": {
        "file_id": 104,
        "content": "The code retrieves videos based on a specified ordering (favorites, view count, or publication date) and performs a search using the BM25 algorithm. It then paginates the results and retrieves additional information for each video by calling `BilibiliVideo.get()`. The code also includes a comment indicating that reordering might be necessary in the future.",
        "type": "comment"
    },
    "1246": {
        "file_id": 104,
        "content": "        # bvid = bilibiliVideo.bvid\n        # cover = bilibiliVideo.pic\n        order = None\n        # you should return the video_index.\n        resultList.append((bilibiliVideo, order))\n    # resultList.sort(key=lambda x: x[1])\n    return resultList\ndef searchRegisteredVideos(\n    keyword: str,\n    tid: int = 0,\n    dedeuserid: Union[list[str], str, None] = \"397424026\",\n    videoOrder=VideoOrder.PUBDATE,  # FAVOURITE, VIEW\n    page_num: int = 1,\n    page_size: int = 30,\n):\n    resultList = searchRegisteredVideosAndGetResultList(\n        tid=tid,\n        dedeuserid=dedeuserid,\n        videoOrder=videoOrder,\n        page_num=page_num,\n        page_size=page_size,\n        keyword=keyword,\n    )\n    for v, _ in resultList:\n        yield v  # this is bilibiliVideoIndex, but you also needs the bvid.\ndef searchUserVideos(\n    keyword: str,\n    tid: int = 0,\n    dedeuserid: str = \"397424026\",\n    method: Literal[\"online\", \"bm25\"] = \"online\",\n    use_credential: bool = False,\n    videoOrder=VideoOrder.PUBDATE,  # FAVOURITE, VIEW",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:743-778"
    },
    "1247": {
        "file_id": 104,
        "content": "This code defines functions for searching registered and user videos on Bilibili. The functions take a keyword, video order, tid, dedeuserid, page number, and page size as parameters. It searches for videos based on the provided parameters and returns a list of bilibiliVideoIndex objects along with their orders.",
        "type": "comment"
    },
    "1248": {
        "file_id": 104,
        "content": "    page_num: int = 1,\n    page_size: int = 30,\n):  # you can support this in database?\n    # you want keyword search or not? it's better than searching in database. i think.\n    # but database search saves bandwidth.\n    # better use semantic search. but now we use hybrid search instead.\n    # hybrid search: metatopic plus bm25\n    # or not?\n    # just dump that shit.\n    # check if keyword overlaps.\n    # how to search my video? and how to measure relevance?\n    if method == \"online\":\n        resultList = []\n        order = None\n        for v in getUserVideos(\n            tid=tid,\n            order=videoOrder,\n            keyword=keyword,\n            dedeuserid=dedeuserid,\n            use_credential=use_credential,\n            stop_on_duplicate=False,\n            page_num=page_num,\n            page_size=page_size,\n        ):\n            # what is the content? plan to update?\n            # print(\"SEARCHED USER VIDEO ID:\", v_id)\n            resultList.append((v, order))\n        # info = u.get_videos(keyword=keyword,order=videoOrder)",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:779-806"
    },
    "1249": {
        "file_id": 104,
        "content": "The code performs a hybrid search for videos, combining metatopic and BM25 search algorithms, to find the most relevant results based on a given keyword. It also retrieves video information and stores it in a list for further processing or display.",
        "type": "comment"
    },
    "1250": {
        "file_id": 104,
        "content": "    elif method == \"bm25\":\n        # export all video? shit?\n        # you should tokenize the thing.\n        # but this search does not have limitations!\n        resultList = searchRegisteredVideosAndGetResultList(\n            tid=tid,\n            dedeuserid=dedeuserid,\n            videoOrder=videoOrder,\n            page_num=page_num,\n            page_size=page_size,\n            keyword=keyword,\n        )\n    for v, _ in resultList:\n        yield v  # this is bilibiliVideoIndex, but you also needs the bvid.\n# you can make excerpt from video to lure people into viewing your video.\ndef getVideoInfo(bvid: str):\n    v = video.Video(bvid=bvid)\n    info = sync(v.get_info())\n    return info\ndef registerUserVideo(\n    bvid: str,\n    dedeuserid: str,\n    is_mine: bool = False,\n    visible: bool = False,  # no checking on video visibility? maybe we need to do this after search.\n):  # this is the video i just post. must be regularly checked then add to candidate list. you can check it when another call for my videos has been issued.",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:807-837"
    },
    "1251": {
        "file_id": 104,
        "content": "The code is performing a search for registered videos on Bilibili platform, utilizing the BM25 search algorithm. It returns the video results without any limitations and allows for further processing like excerpt generation to attract viewers. The code also includes functions for getting video information and registering user videos with optional visibility settings.",
        "type": "comment"
    },
    "1252": {
        "file_id": 104,
        "content": "    # register user first, then register the video.\n    # you will store it to database.\n    u = registerUser(dedeuserid, is_mine)\n    # check if exists.\n    v = BilibiliVideo.get_or_none(BilibiliVideo.bvid == bvid)\n    new = v is None\n    if new:\n        BilibiliVideo.create(bvid=bvid, visible=visible, poster=u)  # it must be new.\n    return new\n# grace period to be one day. that's long enough. or not?\n# we still need some more experiment.\ndef checkVideoVisibility(bvid: str, debug: bool = False):\n    visible = False  # you might want some 'err' parameter. but that only indicates inavalibility of certain video, not video flagged as permanently invisible.\n    try:\n        info = getVideoInfo(bvid)  # getting shit? we need some normal video for test.\n        state = info[\"state\"]\n        visible = state == 0\n    except:\n        if debug:\n            import traceback\n            traceback.print_exc()\n            print(\"error when checking video status: %s\" % bvid)\n    return visible\n# check api doc for hint.\ndef checkRegisteredVideo(",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:838-869"
    },
    "1253": {
        "file_id": 104,
        "content": "This code is responsible for checking the visibility of a bilibili video. It first checks if the user and video are registered in the database, and then fetches the video information to determine its state. If the state is 0, the video is considered visible; otherwise, it's invisible. In case of an error during the process, the debug parameter can be used to print the exception for further investigation. The code also includes a function to register user and video in the database, and another function for checking if a video has been registered before. The grace period for checking video visibility is set to one day, but it suggests that more experimentation might be needed to optimize this duration.",
        "type": "comment"
    },
    "1254": {
        "file_id": 104,
        "content": "    bvid: str,\n    grace_period=datetime.timedelta(days=1),\n    check_interval=datetime.timedelta(hours=1),\n):  # maybe the video is not immediately visible after registration.\n    # check if they are published or not.\n    # ____CI____CI____CI____ (before check video info. decide to check or not.)\n    # __________GP__________ (after check video info. decide to delete or not.)\n    published = False\n    bilibiliVideo = BilibiliVideo.get_or_none(bvid=bvid)\n    now = datetime.datetime.now()\n    needCheck = False\n    if bilibiliVideo:\n        visible = bilibiliVideo.visible\n        needCheck = now - bilibiliVideo.last_check >= check_interval\n        needRemove = now - bilibiliVideo.register_date >= grace_period\n        if (\n            visible and needRemove\n        ):  # do not remove. it just need to be check again, when using checkPublishedVideo. this value is used for double check.\n            published = True\n        else:\n            if needCheck:\n                visible = checkVideoVisibility(bvid)\n                if visible:",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:870-892"
    },
    "1255": {
        "file_id": 104,
        "content": "Checks if a video is published or not by comparing its registration date and last check time with the given grace period and check interval. If needed, it calls `checkVideoVisibility` function to verify visibility.",
        "type": "comment"
    },
    "1256": {
        "file_id": 104,
        "content": "                    published = True\n                elif needRemove:\n                    bilibiliVideo.delete_instance()\n    # you update that 'last_check' and compare it with 'checkin_date'\n    # you can schedule check every hour. not all the time.\n    # basically the same thing. but we do not delete these video till the time is too late, after check.\n    return published, not needCheck\n# seems bilibili can automatically categorize video.\n# we just need to find out how?\ndef checkPublishedVideo(bvid: str):  # this is only done during retrieval.\n    # if published, the video is taken down afterwards, we will delete it.\n    # check if video is still visible or taken down.\n    # if video is not visible then we delete this video from database.\n    # v = video.Video(bvid=bvid)\n    # print(info)\n    # dict_keys(['bvid', 'aid', 'videos', 'tid', 'tname', 'copyright', 'pic', 'title', 'pubdate', 'ctime', 'desc', 'desc_v2', 'state', 'duration', 'forward', 'rights', 'owner', 'stat', 'dynamic', 'dimension', 'pre",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:893-910"
    },
    "1257": {
        "file_id": 104,
        "content": "This code is for a database platform, specifically Bilibili. It checks if videos are still visible or taken down and deletes them if not. The code updates 'last_check' and compares it with 'checkin_date', scheduling check every hour. It also mentions that Bilibili automatically categorizes videos, and this function is used during retrieval to find out how it does so.",
        "type": "comment"
    },
    "1258": {
        "file_id": 104,
        "content": "miere', 'teenage_mode', 'is_chargeable_season', 'is_story', 'no_cache', 'subtitle', 'is_season_display', 'user_garb', 'honor_reply', 'like_icon'])\n    #  'state': -4,\n    # bad state! what is the meaning of this state?\n    # normal; state -> 0\n    avaliable = False\n    bilibiliVideo = BilibiliVideo.get_or_none(bvid=bvid)\n    if (\n        bilibiliVideo is not None\n    ):  # might be our 'registered' video but not yet been published.\n        published, needCheckAgain = checkRegisteredVideo(bvid)\n        if published:\n            if not needCheckAgain:\n                published = True\n            else:\n                visible = checkVideoVisibility(bvid)\n                avaliable = visible\n                if not visible:\n                    # remove that thing.\n                    bilibiliVideoIndex = BilibiliVideo.get_or_none(\n                        rowid=bilibiliVideo.id\n                    )\n                    bilibiliVideo.delete_instance()\n                    if bilibiliVideoIndex is not None:\n                        # remove that thing.",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:910-933"
    },
    "1259": {
        "file_id": 104,
        "content": "Checking if a Bilibili video with the given bvid exists and is available. If it exists, checks if it has been published or needs further checking. If unpublished or visibility issues, deletes the entry in the database.",
        "type": "comment"
    },
    "1260": {
        "file_id": 104,
        "content": "                        bilibiliVideoIndex.delete_instance()\n                else:\n                    bilibiliVideo.last_check = datetime.datetime.now()\n                    bilibiliVideo.visible = True\n                    bilibiliVideo.save()\n    else:\n        print(\"video %s is not registered.\" % bvid)\n    # info['stat'].keys()\n    # dict_keys(['aid', 'view', 'danmaku', 'reply', 'favorite', 'coin', 'share', 'now_rank', 'his_rank', 'like', 'dislike', 'evaluation', 'argue_msg'])\n    # breakpoint()\n    # if anything goes wrong, do not return the state.\n    # if you want update, better do it here. we are checking and updating the video.\n    # we use some random video for test.\n    return avaliable\n# i suggest you to use sqlalchemy. since this is no ordinary task.\n# you cannot just check every video of your own in the past.\n## following code is for test purpose.\n# shall write some server.\n# not fastapi!\ndef searchAndRegisterVideos(\n    query: str,\n    iterate: bool = False,\n    page_start: int = 1,\n    params={\"duration\": BSP.all.duration._10分钟以下},",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:934-963"
    },
    "1261": {
        "file_id": 104,
        "content": "This code deletes a bilibiliVideoInstance if it's not registered, otherwise updates the last_check and makes it visible. If something goes wrong, it doesn't return state, and suggests using SQLAlchemy for more complex tasks. The function allows searching and registering videos, with optional parameters like query, iterate, page_start, and params. It mentions testing the code with a random video and recommends writing a server (not FastAPI).",
        "type": "comment"
    },
    "1262": {
        "file_id": 104,
        "content": "    # 'order': BSP.all.order.综合排序\n    # # you can add this parameter later on.\n    page_size: int = ...,\n):\n    results = searchVideos(\n        query,\n        iterate=iterate,\n        page_start=page_start,\n        params=params,\n        page_size=page_size,\n    )\n    # db = getBilibiliVideoDatabaseAndCreateTables()\n    # this database connection will be established elsewhere.\n    for v in results:  # shall you called them 'tags' instead of 'tag'.\n        # print(v)\n        # breakpoint()\n        mid, author, upic = v[\"mid\"], v[\"author\"], v[\"upic\"]\n        bilibiliUser, _ = BilibiliUser.get_and_update_or_create(\n            username=author, user_id=mid, avatar=linkFixer(upic)\n        )\n        # v.update({'comment':v['review'],'created':v['pubdate']})\n        bilibiliVideo = indexAndGetVideoObject(v, bilibiliUser)\n        # bilibiliVideo, _ = BilibiliVideo.get_and_update_or_create(\n        #     bvid=v[\"bvid\"],\n        #     typeid=v[\"typeid\"],\n        #     visible=True,  # are you sure?\n        #     last_check=datetime.datetime.now(),  # well this is not tested. test it!",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:964-990"
    },
    "1263": {
        "file_id": 104,
        "content": "This code searches videos based on a query and iterate parameter, retrieves results, and establishes a database connection elsewhere. It then iterates through the results, gets or creates BilibiliUser objects, indexes and retrieves video objects for each result, and potentially updates or creates BilibiliVideo objects.",
        "type": "comment"
    },
    "1264": {
        "file_id": 104,
        "content": "        #     poster=bilibiliUser,  # is it my account anyway?\n        #     play=v[\"play\"],\n        #     pic=linkFixer(v[\"pic\"]),\n        #     length=videoDurationStringToSeconds(v[\"duration\"]),\n        #     review=v[\"review\"],\n        #     pubdate=v[\"pubdate\"],\n        #     favorites=v[\"favorites\"],\n        #     description=v[\"description\"],\n        #     title=v[\"title\"],\n        #     tag=v[\"tag\"],\n        # )\n        # bilibiliVideoIndex, _ = BilibiliVideoIndex.get_and_update_or_create(\n        #     rowid=bilibiliVideo.id,\n        #     description=textPreprocessing(bilibiliVideo.description),\n        #     tag=textPreprocessing(bilibiliVideo.tag),\n        #     title=textPreprocessing(bilibiliVideo.title),\n        # )\n        yield bilibiliVideo\n# @reloading\ndef getVideoInfosFromVideoGenerator(vgen):\n    vlist = []\n    for v in vgen:\n        if type(v) == BilibiliVideo:\n            vlist.append(v.videoInfoExtractor())\n    return vlist\ndef searchVideosByForm(form:searchUserVideoForm, default_page_size:int=30):",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:991-1019"
    },
    "1265": {
        "file_id": 104,
        "content": "This code is retrieving video information from a generator and creating a list of BilibiliVideo objects. It then returns this list after extracting video information from each object in the generator. The get_and_update_or_create function updates or creates a new BilibiliVideoIndex record based on the description, tag, and title fields. The searchVideosByForm function searches for videos using a provided form and a default page size of 30.",
        "type": "comment"
    },
    "1266": {
        "file_id": 104,
        "content": "    vgen = searchUserVideos(\n        form.query_for_search,\n        form.tid,\n        form.dedeuserid,\n        form.method,\n        form.use_credential,\n        form.videoOrder,\n        form.page_num,\n        default(form.page_size, default_page_size),\n    )\n    videoInfos = getVideoInfosFromVideoGenerator(vgen)\n    return videoInfos\ndef refresh_latest_video_of_user(uid: int):  # must be online.\n    form = searchUserVideoForm(method=\"online\", tid=0, query=\"\", dedeuserid=str(uid))\n    videoInfos = searchVideosByForm(form)\ndef refresh_status(\n    grace_period=datetime.timedelta(days=1),\n    check_interval=datetime.timedelta(hours=1),\n    sleep: int = 2,\n    target_user_uids: list[int] = [397424026],\n):\n    for uid in target_user_uids:\n        try:\n            refresh_latest_video_of_user(uid)\n            time.sleep(sleep)\n        except:\n            import traceback\n            traceback.print_exc()\n            print(f\"Failed to refresh latest video status of user {uid}\")\n    # what to do? just select and update?\n    # but you need the database object. it is loop dependency!",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:1020-1053"
    },
    "1267": {
        "file_id": 104,
        "content": "This code defines functions for searching videos and refreshing the latest video status of a user. The 'searchVideosByForm' function takes search parameters and returns a list of video information. 'refresh_latest_video_of_user' searches for the latest online video of a specified user. In 'refresh_status', the code loops through a list of target users, refreshes their latest video status, and handles exceptions with sleep and error printing. The code seems to be part of a larger system that requires database interaction to select and update records.",
        "type": "comment"
    },
    "1268": {
        "file_id": 104,
        "content": "    # well we can split the function.\n    # just for initialization?\n    now_minus_check_interval = datetime.datetime.now() - check_interval\n    selector = BilibiliVideo.select(BilibiliVideo.bvid).where(\n        (BilibiliVideo.last_check < now_minus_check_interval)\n        & (\n            BilibiliVideo.visible == False\n        )  # only check invisible videos. invisible videos will be removed after 1 day of inavaliability.\n    )  # need check or not?\n    print(\"refreshing video status\")\n    for bvid in progressbar.progressbar(selector):\n        checkRegisteredVideo(\n            bvid, grace_period=grace_period, check_interval=check_interval\n        )\n        time.sleep(sleep)\n    return\ndef refresh_status_decorator(func):\n    def wrapper(*args, **kwargs):\n        schedule.run_pending()\n        return func(*args, **kwargs)\n    return wrapper\n@refresh_status_decorator  # this might prevent you adding the decorator everywhere?\ndef getBilibiliVideoDatabaseCreateTablesAndRefreshStatus():\n    db = getBilibiliVideoDatabaseAndCreateTables()",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:1054-1082"
    },
    "1269": {
        "file_id": 104,
        "content": "This function initializes a database and checks for invisible Bilibili videos, updating their status after a day of invisibility. It uses progressbar to track progress and sleep for a brief period between iterations. The getBilibiliVideoDatabaseCreateTablesAndRefreshStatus function creates tables and calls the refresh_status decorator on another function.",
        "type": "comment"
    },
    "1270": {
        "file_id": 104,
        "content": "    return db\n# somewhere here:\n# https://fastapi.tiangolo.com/es/tutorial/debugging/\n@lru_cache(maxsize=1)\ndef bootstrap():\n    db = getBilibiliVideoDatabaseAndCreateTables()\n    refresh_status()  # ensure the database is connected.\n    schedule.every(20).minutes.do(refresh_status)\ndef bilibiliRecommendationServer(\n    welcome_message=\"bilibili recommendation server\", port=7341\n):\n    bootstrap()\n    from fastapi import FastAPI\n    import uvicorn\n    import pydantic\n    app = FastAPI()\n    @app.get(\"/\")\n    # #@reloading\n    def server_hello():\n        schedule.run_pending()\n        return welcome_message\n    # just asking. post or get?\n    @app.post(\"/searchVideos\")  # what do you want to have? all fields?\n    # #@reloading\n    def search_videos(form: searchVideoForm):\n        # print('received params:',params) # it is str.\n        # breakpoint()\n        schedule.run_pending()\n        params = {\n            \"duration\": BSP.all.duration._10分钟以下\n        } | form.params  # this is default parameter.\n        # breakpoint()",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:1083-1123"
    },
    "1271": {
        "file_id": 104,
        "content": "The code initializes the Bilibili video database, sets up a scheduler to refresh the status periodically, and creates a FastAPI application for serving a recommendation server with a welcome message route (\"/\") and a search route (\"/searchVideos\"). The search route accepts a POST request with parameters.",
        "type": "comment"
    },
    "1272": {
        "file_id": 104,
        "content": "        vgen = searchAndRegisterVideos(\n            form.query_for_search,\n            iterate=form.iterate,\n            page_start=form.page_num,\n            params=params,\n            page_size=default(form.page_size, ...),\n        )\n        videoInfos = getVideoInfosFromVideoGenerator(vgen)\n        return videoInfos\n    @app.post(\"/searchRegisteredVideos\")\n    # #@reloading\n    def search_registered_videos(form: searchRegisteredVideoForm):\n        schedule.run_pending()\n        vgen = searchRegisteredVideos(\n            form.query_for_search,\n            form.tid,\n            form.dedeuserid,\n            form.videoOrder,\n            form.page_num,\n            default(form.page_size, 30),\n        )\n        videoInfos = getVideoInfosFromVideoGenerator(vgen)\n        return videoInfos\n    @app.post(\"/searchUserVideos\")\n    # #@reloading\n    def search_user_videos(form: searchUserVideoForm):\n        schedule.run_pending()\n        videoInfos = searchVideosByForm(form)\n        return videoInfos\n    @app.post(\"/registerUserVideo\")",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:1124-1157"
    },
    "1273": {
        "file_id": 104,
        "content": "This code appears to contain various endpoints for searching and registering videos on a platform. It utilizes form data to query for specific search results, and then retrieves the video information from the generated video generators. It also schedules tasks and handles different types of video forms.",
        "type": "comment"
    },
    "1274": {
        "file_id": 104,
        "content": "    # #@reloading\n    def register_user_video(form: registerUserVideoForm):\n        schedule.run_pending()\n        new = registerUserVideo(form.bvid, form.dedeuserid, form.is_mine, form.visible)\n        if new:\n            print(\"----\")\n            print(\"registered user video:\", form.bvid)\n            print(\"user:\", form.dedeuserid)\n            print(\"is_mine:\", form.is_mine)\n            print(\"visible:\", form.visible)\n            print(\"----\")\n        else:\n            print(\"video already registered.\")\n        return {\"is_new\": new}\n    uvicorn.run(app, host=\"0.0.0.0\", port=port)\nif __name__ == \"__main__\":\n    bilibiliRecommendationServer()",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:1158-1178"
    },
    "1275": {
        "file_id": 104,
        "content": "This code registers a user video on Bilibili platform. It utilizes the registerUserVideoForm to store necessary information, schedules pending tasks for execution, and prints details if the registration is successful or not. The code also runs the Uvicorn server for the application, specifying the host and port. If this file is executed directly, it calls bilibiliRecommendationServer() function.",
        "type": "comment"
    },
    "1276": {
        "file_id": 105,
        "content": "/pyjom/platforms/bilibili/credentials.py",
        "type": "filepath"
    },
    "1277": {
        "file_id": 105,
        "content": "The code handles bilibili login/logout, stores credentials in TinyDB, verifies them and provides functions for SMS-based credential input/removal. It uses a decorator `bilibiliCredential` that retrieves user credentials and wraps function calls with them.",
        "type": "summary"
    },
    "1278": {
        "file_id": 105,
        "content": "# you need to manage login/logout and credential storage.\n# first you need to get 'home' directory\nfrom lazero.search.api import getHomeDirectory\nimport os\nfrom bilibili_api import sync, Credential\nfrom bilibili_api.user import get_self_info\nfrom bilibili_api import settings\nfrom bilibili_api.login import (\n    # login_with_password,\n    login_with_sms,\n    send_sms,\n    PhoneNumber,\n    # Check,\n)\nsettings.geetest_auto_open = False\nhome = getHomeDirectory()\ndbPath = os.path.join(home, \".bilibili_api.json\")\nimport tinydb\ndb = tinydb.TinyDB(dbPath)  # is this variable shared in this module?\nUser = tinydb.Query()\ndef verifyCredential(credential, returnName=True):\n    try:\n        name = sync(get_self_info(credential))[\"name\"]\n        print(\"credential is valid for:\", name)\n        db.upsert(\n            {\n                \"name\": name,  # does not show up in credential.\n                \"dedeuserid\": credential.dedeuserid,\n                \"bili_jct\": credential.bili_jct,\n                \"buvid3\": credential.buvid3,\n                \"sessdata\": credential.sessdata,",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/credentials.py:2-38"
    },
    "1279": {
        "file_id": 105,
        "content": "The code manages login/logout and credential storage for the Bilibili API. It retrieves the 'home' directory, creates a TinyDB instance at the specified path to store user credentials, and provides a function `verifyCredential` to check if a given credential is valid. The code also sets geetest_auto_open to False and imports necessary modules for Bilibili API interaction.",
        "type": "comment"
    },
    "1280": {
        "file_id": 105,
        "content": "            },\n            User.dedeuserid == credential.dedeuserid,\n        )\n        if returnName:\n            return name\n        else:\n            return True\n    except:\n        import traceback\n        traceback.print_exc()\n        print(\"invalid credential:\", credential)\n        return False\ndef removeCredentialByDedeUserId(dedeuserid: str):\n    try:\n        db.remove(User.dedeuserid == dedeuserid)\n        return True\n    except:\n        import traceback\n        traceback.print_exc()\n        print(\n            \"error when removing credential from database for dedeuserid:\", dedeuserid\n        )\n        return False\n# from lazero.program.functools import skipException\nfrom lazero.program.functools import suppressException\n# @skipException(defaultReturn = None, breakpoint_flag=True, debug_flag=True, global_variables=globals(), local_variables=locals()) # send_sms is not definded here. WTF?\n@suppressException(defaultReturn=None, showException=True)  # trycatch based.\ndef getCredentialViaSMS():\n    phone = input(\"请输入手机号：\")",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/credentials.py:39-74"
    },
    "1281": {
        "file_id": 105,
        "content": "The code is a Python implementation for managing bilibili credentials. The `getCredentialViaSMS` function allows users to input their phone number and retrieves the corresponding credential via SMS verification. The `removeCredentialByDedeUserId` function removes a credential from the database based on the provided dedeuserid. Both functions handle exceptions using try-except blocks, providing error messages and returning False if any errors occur during execution.",
        "type": "comment"
    },
    "1282": {
        "file_id": 105,
        "content": "    print(\"正在登录。\")\n    send_sms(PhoneNumber(phone, country=\"+86\"))  # 默认设置地区为中国大陆\n    code = input(\"请输入验证码：\")\n    c = login_with_sms(PhoneNumber(phone, country=\"+86\"), code)\n    credential = c\n    # first, check if this is a valid credential.\n    name = verifyCredential(credential)\n    return credential, name\ndef getCredentialByDedeUserId(dedeuserid: str = \"397424026\"):\n    dataList = db.search(User.dedeuserid == dedeuserid)\n    if len(dataList) != 1:\n        if len(dataList) != 0:\n            # remove all related records.\n            print(\"multiple credentials found for dedeuserid:\", dedeuserid)\n            removeCredentialByDedeUserId(dedeuserid)\n        else:\n            print(\"no credential found for dedeuserid:\", dedeuserid)\n    else:\n        # check validity.\n        data = dataList[0].copy()\n        print(\"try to login credential fetched from db:\", data)\n        oldName = data.pop(\"name\")\n        print(\"previous name:\", oldName)\n        credential = Credential(**data)\n        name = verifyCredential(credential)",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/credentials.py:75-101"
    },
    "1283": {
        "file_id": 105,
        "content": "The code is responsible for logging in to a Bilibili account and retrieving the user's credentials. It first attempts to log in using an SMS verification code, then checks if the provided credential is valid by verifying it with the database. The function `getCredentialByDedeUserId` allows fetching credentials based on the given dedeuserid. If multiple or no credentials are found for the specified id, appropriate error messages are printed and potentially irrelevant records are removed from the database.",
        "type": "comment"
    },
    "1284": {
        "file_id": 105,
        "content": "        if name != False:\n            print(\"login successful:\", name)\n            return credential\n        else:\n            print(\"login failed with existing credential for user:\", oldName)\n            removeCredentialByDedeUserId(\n                dedeuserid\n            )  # warning. my credential has been removed because of that async problem. please relogin.\n    # anyway if you are here, nothing in database related to this dedeuserid now.\n    # you choose to login via SMS.\n    while True:\n        # could be troublesome.\n        result = getCredentialViaSMS()\n        if result != None:  # has type check here?\n            credential, name = result\n            if name != False:\n                print(\"登录成功\")\n                # update with this credential!\n                # next, check if this is the credential we need.\n                if credential.dedeuserid == dedeuserid:\n                    return credential\n                else:\n                    print(\"dedeuserid not right.\")\n                    print(",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/credentials.py:102-125"
    },
    "1285": {
        "file_id": 105,
        "content": "The code checks if the provided name is not False and prints \"login successful\" along with the name. If the name is False, it prints a failed login message and removes the existing credential associated with the user. The code then allows the user to log in via SMS. It retrieves the credential from SMS and checks if the dedeuserid matches the desired value. If it does, the credential is returned; otherwise, a message is printed indicating that the dedeuserid is incorrect.",
        "type": "comment"
    },
    "1286": {
        "file_id": 105,
        "content": "                        \"user %s (dedeuserid: %s) does not have dedeuserid: %s\"\n                        % (name, credential.dedeuserid, dedeuserid)\n                    )\n        else:\n            print(\"登陆失败\")\ndef bilibiliCredential(func):\n    def wrapper(*args, dedeuserid=\"397424026\", **kwargs):\n        credential = getCredentialByDedeUserId(dedeuserid)\n        if type(kwargs) != dict:\n            kwargs = {}\n        return func(*args, **(kwargs | {'credential': credential}))\n    return wrapper",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/credentials.py:126-140"
    },
    "1287": {
        "file_id": 105,
        "content": "The code defines a decorator called `bilibiliCredential` that takes a function as input and returns a new function wrapper. The wrapper retrieves the credentials for a specific `dedeuserid`, and if the user exists, it passes the function call with the credential as an argument. If the keyword arguments are not of type dictionary, it converts them into an empty dictionary.",
        "type": "comment"
    },
    "1288": {
        "file_id": 106,
        "content": "/pyjom/medialang/core.py",
        "type": "filepath"
    },
    "1289": {
        "file_id": 106,
        "content": "The code defines classes for media language items with functionalities like script representation, validation, exception management, formatting, and executing scripts in a Medialang environment.",
        "type": "summary"
    },
    "1290": {
        "file_id": 106,
        "content": "from pyjom.commons import *\nfrom pyjom.medialang.commons import *\nfrom pyjom.medialang.processors import *\nimport re\nimport traceback\nclass lexicalItem:\n    def __init__(self, path, **kwargs):\n        self.path = path\n        self.args = kwargs\n        self.indent = 0\n        self.index = 0\n    def __repr__(self):\n        indent = \"    \" * self.indent\n        mRepr = []\n        mRepr.append(\"{}___medialang_item_[{}]\".format(indent, self.index))\n        mRepr.append(\"{}item path:\".format(indent)+\"  \"+ self.path)\n        mRepr.append(\"{}item args:\".format(indent)+\"  \"+ str(self.args))\n        return \"\\n\".join(mRepr) # is this magic?\nclass lexicalGroup:\n    def __init__(self, items=[]):\n        self.items = []\n        self.index = 0\n        self.indent = 0\n        for item in items:\n            assert type(item) == lexicalItem\n            self.items.append(item)\n    def append(self, item):\n        assert type(item) == lexicalItem\n        self.items.append(item)\n    def dump(self):\n        for item in self.items:\n            yield item # you yield NONE? WTF?",
        "type": "code",
        "location": "/pyjom/medialang/core.py:1-39"
    },
    "1291": {
        "file_id": 106,
        "content": "This code defines two classes, `lexicalItem` and `lexicalGroup`, used in the pyjom library for storing and manipulating media language items. The `lexicalItem` class has an `__init__` method that takes a path and optional keyword arguments, and provides an `__repr__` method to represent the item. The `lexicalGroup` class initializes with a list of items, and has methods for appending items and dumping the group's contents. The code also imports necessary modules and checks types of items in the group.",
        "type": "comment"
    },
    "1292": {
        "file_id": 106,
        "content": "    def __repr__(self):\n        indent = \"    \" * self.indent\n        mRepr = []\n        mRepr.append(\"{}____________medialang_line_[{}]\".format(indent, self.index))\n        # print(\"ITEMS:\", self.items)\n        for i, item in enumerate(self.dump()):\n            item.indent = self.indent + 1\n            item.index = i\n            mRepr.append(item)\n        # should we return nothing?\n        return \"\\n\".join(mRepr)\nclass lexicalScript:\n    def __init__(self, lines=[]):\n        self.lines = []\n        self.indent = 0\n        self.index = 0\n        for line in lines:\n            assert type(line) == lexicalGroup\n            self.lines.append(line)\n    def append(self, line):\n        assert type(line) == lexicalGroup\n        self.lines.append(line)\n    def dump(self):\n        for line in self.lines:\n            yield line\n    def __repr__(self):\n        indent = \"    \" * self.indent\n        mRepr = []\n        mRepr.append(\"{}____________medialang_script_[{}]\".format(indent, self.index))\n        for i, item in enumerate(self.dump()):",
        "type": "code",
        "location": "/pyjom/medialang/core.py:41-75"
    },
    "1293": {
        "file_id": 106,
        "content": "This code defines two classes, `medialang_line` and `lexicalScript`, with a `__repr__` method that represents the objects. The `__repr__` method returns an indented representation of each object's properties. The `lexicalScript` class also has an `append` method to add new lines to the script.",
        "type": "comment"
    },
    "1294": {
        "file_id": 106,
        "content": "            item.indent = self.indent + 1\n            item.index = i\n            mRepr.append(item)\n        return \"\\n\".join(mRepr)\nclass Medialang:\n    def __init__(\n        self,\n        script_path=None,\n        script=None,\n        script_obj=None,\n        encoding=\"utf-8\",\n        indent=4,\n        template=False,\n        template_args={},\n        verbose=True,\n        medialangTmpdir=medialangTmpDir\n    ):\n        self.verbose = verbose\n        self.medialangTmpDir = medialangTmpDir\n        self.indent = \" \" * indent\n        self.script_path = script_path\n        self.script_obj = script_obj\n        self.script = script\n        self.encoding = encoding\n        lexList = [script_path, script, script_obj]\n        lexCheck = sum([int(x is None) for x in lexList]) == 2\n        if not lexCheck:\n            raise Exception(\n                \"Can only pass one value to either of script_path, script, script_obj:\\n{}\".format(\n                    lexList\n                )\n            )\n        if script_path is None:\n            if script is None:",
        "type": "code",
        "location": "/pyjom/medialang/core.py:76-110"
    },
    "1295": {
        "file_id": 106,
        "content": "This code snippet initializes a Medialang object with various parameters, including script path, script content, and encoding. It also checks for valid input to ensure only one of these values is provided. The exception handling raises an error if the input does not meet this requirement.",
        "type": "comment"
    },
    "1296": {
        "file_id": 106,
        "content": "                assert script_obj is not None\n                assert template is False\n                self.script_obj = script_obj\n            else:\n                assert type(script) == str\n                self.script = script\n        else:\n            assert type(script_path) == str\n            try:\n                abspath = getAbsoluteFilePath(script_path)\n            except:\n                medialangFatalError(\n                    \"Failed to resolve script path: {}\".format(script_path), __file__\n                )\n            self.script_path = abspath\n            extension = getFileExtension(script_path)\n            if template:\n                assert extension == \"j2\"\n            else:\n                assert extension in [\"mdl\", \"media\"]\n            with open(abspath, \"r\", encoding=encoding) as f:\n                self.script = f.read()\n        if self.script_obj is not None:\n            self.script = self.generate(self.script_obj)\n        else:\n            if template:\n                assert type(template_args) == dict",
        "type": "code",
        "location": "/pyjom/medialang/core.py:111-138"
    },
    "1297": {
        "file_id": 106,
        "content": "This code ensures that the user provides a valid script or script path. It checks if the script is an object, a string, or a file path. If it's a string or a file path, it verifies its type and resolves any relative paths to absolute paths. It then loads the content of the script file and assigns it to 'self.script'. If a script object is provided, the method generates the script using the object. If a template is specified with the script, it asserts that the extension of the script is \"j2\". Otherwise, it asserts that the extension is either \"mdl\" or \"media\". Finally, if a 'template_args' dictionary is provided, it asserts its type and stores the script in 'self.script'.",
        "type": "comment"
    },
    "1298": {
        "file_id": 106,
        "content": "                self.script = renderTemplate(self.script, template_args)\n            self.script_obj = self.parse(self.script)\n    def generate_item(self, item_obj, line_max_char=40, level=0):\n        # content = item_obj.content\n        path = item_obj.path\n        item_lines = ['\"{}\"'.format(path)]\n        # print(\"item_lines:\",item_lines)\n        args = item_obj.args\n        # print(\"path:\",path)\n        for key in args.keys():\n            assert not key.startswith(\"#\")\n            # print(\"key:\",key)\n            mitem = args[key]\n            if type(mitem) is str:\n                mitem = '\"{}\"'.format(mitem)\n            elif type(mitem) in [float, int]:\n                mitem = str(mitem)\n            elif mitem in [True, False]:\n                mitem = str(mitem).lower()\n            else:\n                mitem_trial = json.dumps(mitem)\n                if len(mitem_trial) < line_max_char:\n                    mitem = mitem_trial\n                else:\n                    mitem = json.dumps(mitem, indent=self.indent)",
        "type": "code",
        "location": "/pyjom/medialang/core.py:139-164"
    },
    "1299": {
        "file_id": 106,
        "content": "This code defines a class that generates items from item objects, handles different data types, and formats the output within a specified line length. The class also has methods to render templates and parse scripts.",
        "type": "comment"
    }
}