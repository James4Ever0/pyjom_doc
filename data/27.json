{
    "2700": {
        "file_id": 298,
        "content": "/tests/calculate_separate_video_scene_duration_in_dog_video_with_bgm/generate_random_clip_lengths.py",
        "type": "filepath"
    },
    "2701": {
        "file_id": 298,
        "content": "This code generates 30 random clip lengths using a truncated Gaussian distribution with mean and standard deviation, ensuring values are within specified bounds. It utilizes the truncnorm function from scipy.stats for generating the distribution.",
        "type": "summary"
    },
    "2702": {
        "file_id": 298,
        "content": "std, mean = 1.6674874515595588, 2.839698412698412\nscale, loc = std, mean\n# using gaussian distribution\n# accepting both mean and standard deviation\n# this is truncated gaussian, not just normal distribution\nmyclip_a, myclip_b = 0.6, 7.833\n# while you need to make sure the value is in bound.\n# import random\nfrom scipy.stats import truncnorm\na, b = (myclip_a - loc) / scale, (myclip_b - loc) / scale\nrandVar = truncnorm(a,b)\nrandomFunction = lambda: randVar.rvs(1)[0]*scale+loc\n# inBound = lambda number: min(nMax, max(nMin, number))\n# randomFunction = lambda: inBound(random.gauss(mean, std))\nfor _ in range(30):\n    print(randomFunction())",
        "type": "code",
        "location": "/tests/calculate_separate_video_scene_duration_in_dog_video_with_bgm/generate_random_clip_lengths.py:1-21"
    },
    "2703": {
        "file_id": 298,
        "content": "This code generates 30 random clip lengths using a truncated Gaussian distribution with mean and standard deviation, ensuring values are within specified bounds. It utilizes the truncnorm function from scipy.stats for generating the distribution.",
        "type": "comment"
    },
    "2704": {
        "file_id": 299,
        "content": "/tests/calculate_separate_video_scene_duration_in_dog_video_with_bgm/download_sample.sh",
        "type": "filepath"
    },
    "2705": {
        "file_id": 299,
        "content": "This code uses yt-dlp to download a sample video from Bilibili at the given URL and save it as \"sample.mp4\".",
        "type": "summary"
    },
    "2706": {
        "file_id": 299,
        "content": "yt-dlp -o sample.mp4 https://www.bilibili.com/video/BV1HS4y1w7PK",
        "type": "code",
        "location": "/tests/calculate_separate_video_scene_duration_in_dog_video_with_bgm/download_sample.sh:1-1"
    },
    "2707": {
        "file_id": 299,
        "content": "This code uses yt-dlp to download a sample video from Bilibili at the given URL and save it as \"sample.mp4\".",
        "type": "comment"
    },
    "2708": {
        "file_id": 300,
        "content": "/tests/qq_go_cqhttp/launch.sh",
        "type": "filepath"
    },
    "2709": {
        "file_id": 300,
        "content": "The code changes the directory to \"go-cqhttp\" and executes the \"go-cqhttp\" script, which likely starts the CQHTTP bot.",
        "type": "summary"
    },
    "2710": {
        "file_id": 300,
        "content": "cd go-cqhttp\n./go-cqhttp",
        "type": "code",
        "location": "/tests/qq_go_cqhttp/launch.sh:1-2"
    },
    "2711": {
        "file_id": 300,
        "content": "The code changes the directory to \"go-cqhttp\" and executes the \"go-cqhttp\" script, which likely starts the CQHTTP bot.",
        "type": "comment"
    },
    "2712": {
        "file_id": 301,
        "content": "/tests/qq_go_cqhttp/build.sh",
        "type": "filepath"
    },
    "2713": {
        "file_id": 301,
        "content": "This code navigates to the \"go-cqhttp\" directory and compiles it using the Go language's 'build' command.",
        "type": "summary"
    },
    "2714": {
        "file_id": 301,
        "content": "cd go-cqhttp\ngo build",
        "type": "code",
        "location": "/tests/qq_go_cqhttp/build.sh:1-2"
    },
    "2715": {
        "file_id": 301,
        "content": "This code navigates to the \"go-cqhttp\" directory and compiles it using the Go language's 'build' command.",
        "type": "comment"
    },
    "2716": {
        "file_id": 302,
        "content": "/tests/qq_go_cqhttp/tests/download_group_files.py",
        "type": "filepath"
    },
    "2717": {
        "file_id": 302,
        "content": "The code connects to a local server, retrieves status, and handles errors. It provides functions for downloading QQ group files and directories using different APIs, handling subfolders recursively, and checking for existing files. The `group_file_wholesale_downloader` function is used to download group files to a specific path, running in a loop for each group ID with optional retry and sleep mechanisms.",
        "type": "summary"
    },
    "2718": {
        "file_id": 302,
        "content": "import pathlib\nimport os\nimport requests\n# again 0.0.0.0 not avaliable. must be localhost.\nbaseurl = \"http://localhost:5700/\"\n# go-cqhttp client does not support adding friends, searching groups or something! test if we can login opqbot and this shit at the same time!\n# it is working but unable to know if it is going to kill me.\nimport time\ndef check_connection():\n    while True:\n        try:\n            response = requests.get(baseurl+\"get_status\", timeout=5)\n            response_json = response.json()\n            print(\"GO_CQHTTP STATUS:\", response_json)\n            data_json = response_json[\"data\"]\n            assert data_json[\"online\"] == True\n            print(\"connection ok\")\n            break\n        except:\n            import traceback\n            traceback.print_exc()\n            print(\"Connection error.\")\n            time.sleep(3)\ndef get_url(api):\n    assert not api.startswith(\"/\")\n    return baseurl+api\ndef ensure_dir(download_path):\n    if not os.path.exists(download_path):\n        os.mkdir(download_path)",
        "type": "code",
        "location": "/tests/qq_go_cqhttp/tests/download_group_files.py:1-34"
    },
    "2719": {
        "file_id": 302,
        "content": "This code checks the connection to a local server, retrieves and prints the status, handles errors by retrying, and provides a function for generating full URLs. It seems related to testing or managing a program that interacts with CQHTTP, a third-party service.",
        "type": "comment"
    },
    "2720": {
        "file_id": 302,
        "content": "# api = \"get_group_file_system_info\"\ndef get_group_file(group_id, file_id, busid):\n    api = \"get_group_file_url\"\n    url = get_url(api)\n    params = {\"group_id\": group_id, \"file_id\": file_id, \"busid\": busid}\n    r = requests.get(url, params=params)\n    # print(r.content)\n    content = r.json()\n    data = content[\"data\"]\n    if data!=None:\n        download_url = data[\"url\"]\n        print(\"DOWNLOAD URL:\", download_url)\n        return download_url\ndef try_pass(function):\n    try:\n        function()\n    except:\n        pass\ndef downloader(url, filepath, skip_exist=True):\n    lock = filepath+\".lock\"\n    # check lock related operations.\n    if os.path.exists(lock):\n        try_pass(lambda: os.remove(lock))\n        try_pass(lambda: os.remove(filepath))\n    # do skip if flag \"skip_exists\" is set.\n    if skip_exist:\n        if os.path.exists(filepath):\n            return  # no overwritting existing files.\n    # download command\n    cmd = 'curl -L -o \"{}\" \"{}\"'.format(filepath, url)\n    # download main logic\n    # touch lock first.",
        "type": "code",
        "location": "/tests/qq_go_cqhttp/tests/download_group_files.py:36-77"
    },
    "2721": {
        "file_id": 302,
        "content": "This code defines a function for getting group file URLs, downloading files using curl, and includes optional checks for existing files and locking mechanisms.",
        "type": "comment"
    },
    "2722": {
        "file_id": 302,
        "content": "    pathlib.Path(lock).touch()\n    os.system(cmd)\n    try_pass(lambda: os.remove(lock))\ndef recursive_get_qq_group_files(api, group_id, basepath=None, folder_id=None, download_path=\"qq_group_file_download\"):\n    ensure_dir(download_path)\n    if basepath is None:\n        basepath = os.path.join(download_path, str(group_id))\n    ensure_dir(basepath)\n    if api == \"get_group_root_files\":\n        params = {\"group_id\": group_id}  # integer for group id\n    elif api == \"get_group_files_by_folder\":\n        # integer for group id\n        params = {\"group_id\": group_id, \"folder_id\": folder_id}\n    else:\n        raise Exception(\"Unknown recursive_get_qq_group_files api\", api)\n    url = get_url(api)\n    r = requests.get(url, params=params)\n# r = requests.get(url)\n    content = r.json()\n    # print(content)\n    # breakpoint()\n    data = content[\"data\"]\n    base_files = data[\"files\"]\n    base_folders = data[\"folders\"]  # may walk recursively.\n    base_files = [] if base_files == None else base_files\n    base_folders = [] if base_folders == None else base_folders",
        "type": "code",
        "location": "/tests/qq_go_cqhttp/tests/download_group_files.py:78-109"
    },
    "2723": {
        "file_id": 302,
        "content": "Creates a directory for group files based on the group ID, downloads QQ group files recursively and handles different APIs.",
        "type": "comment"
    },
    "2724": {
        "file_id": 302,
        "content": "    # print(base_files)\n    for bfile in base_files:\n        file_id = bfile[\"file_id\"]  # prefixed with /, no need to check?\n        # any expired files present? may cause download errors?\n        file_name = bfile[\"file_name\"]\n        busid = bfile[\"busid\"]\n        download_url = get_group_file(group_id, file_id, busid)\n        if download_url == None: continue\n        filepath = os.path.join(basepath, file_name)\n        print(\"FILEPATH:\", filepath)\n        yield download_url, filepath\n        # download those base files!\n    for bfolder in base_folders:\n        # we have group_id though.\n        folder_id = bfolder[\"folder_id\"]\n        folder_name = bfolder[\"folder_name\"]\n        new_basepath = os.path.join(basepath, folder_name)\n        for download_url, filepath in recursive_get_qq_group_files(\"get_group_files_by_folder\", group_id, basepath=new_basepath, folder_id=folder_id):\n            yield download_url, filepath\n        # all the same logic.\n        # now do recursive folder search.\n    # how to download these shits? curl?",
        "type": "code",
        "location": "/tests/qq_go_cqhttp/tests/download_group_files.py:111-134"
    },
    "2725": {
        "file_id": 302,
        "content": "This code downloads group files and folders from QQ group. It first retrieves base files by iterating through the base_files list, using get_group_file to obtain the download URL for each file and storing it in the filepath. Then, it recursively downloads files within specified folders using recursive_get_qq_group_files function. This code uses os.path.join to construct file paths and continues if a download URL is None.",
        "type": "comment"
    },
    "2726": {
        "file_id": 302,
        "content": "def group_file_wholesale_downloader(group_id, download_path=\"qq_group_file_download\", skip_exist=True):\n    for download_url, filepath in recursive_get_qq_group_files(\"get_group_root_files\", group_id, download_path=download_path):\n        downloader(download_url, filepath, skip_exist=skip_exist)\n# group_id = 927825838 # more files but no base_files.\n# group_id = 537384511 # less files but have base_files\n# make it dynamic!\ndownload_path = \"/root/Desktop/works/pyjom/tests/wechat_bots/msimg32.dll_wechat_hook_webapi/official_qq_group_files\"\ngroup_ids = [927825838, 537384511] # i know i am in these groups.\n#  import time\ncheck_connection() # failsafe or not?\nfor group_id in group_ids:\n    #  while True:\n        #  try:\n    group_file_wholesale_downloader(group_id, download_path=download_path, skip_exist=True)\n    #  break\n        #  except: time.sleep(10) # auto retry.\n        # there is no need for any failsafes. maybe we are outside the groups.\n# already downloaded. waiting for updates?",
        "type": "code",
        "location": "/tests/qq_go_cqhttp/tests/download_group_files.py:137-159"
    },
    "2727": {
        "file_id": 302,
        "content": "The code defines a function `group_file_wholesale_downloader` that downloads QQ group files for specified group IDs to a specific path. It uses recursive calls to `recursive_get_qq_group_files` and `downloader` functions. The provided example group IDs (927825838, 537384511) are used with the download path \"/root/Desktop/works/pyjom/tests/wechat_bots/msimg32.dll_wechat_hook_webapi/official_qq_group_files\". The code runs this function in a loop for each group ID, potentially with retry and sleep mechanisms if needed.",
        "type": "comment"
    },
    "2728": {
        "file_id": 303,
        "content": "/tests/karaoke_effects/translator.yml",
        "type": "filepath"
    },
    "2729": {
        "file_id": 303,
        "content": "This code sets up a session with online translators and uses Uvicorn for FastAPI apps on different ports, while managing Clash operations through a bash script. It also updates Clash automatically via a Python script.",
        "type": "summary"
    },
    "2730": {
        "file_id": 303,
        "content": "# all online translators, with retry automatically.\nsession_name: translator\nwindows:\n  - window_name: dev window\n    layout: tiled\n    panes:\n    # for main translator gateway\n      - shell_command:\n        - cd /root/Desktop/works/pyjom/tests/karaoke_effects\n        - python3 -m uvicorn --port 8974 fastapi_translator:app\n    # for lingua api\n      - shell_command:\n        - cd /root/Desktop/works/pyjom/tests/karaoke_effects\n        - python3 -m uvicorn --port 8978 loadLingua_jpype_fastapi:app\n    # the deepl hacked api\n      - shell_command:\n        - cd /root/Desktop/works/pyjom/tests/deepl_free_translator/deepl-api-rs\n        # - env ROCKET_PORT=8281 http_proxy=\"\" https_proxy=\"\" ./executable_deepl\n        # what is the fucking use of that clash shit?\n        - env ROCKET_PORT=8281 http_proxy=http://localhost:8381 https_proxy=http://localhost:8381 ./executable_deepl\n    # for clash\n      - shell_command:\n        - cd /root/Desktop/works/pyjom/tests/karaoke_effects\n        - bash launch_clash.sh # clash command",
        "type": "code",
        "location": "/tests/karaoke_effects/translator.yml:1-24"
    },
    "2731": {
        "file_id": 303,
        "content": "This code defines a session with multiple panes for online translators, lingua API, deepl hacked API, and clash. It uses Uvicorn to run FastAPI applications on different ports, with environment variables set for the deepl hacked API to connect through Clash using the Clash proxy. The code also mentions a bash script (launch_clash.sh) for managing Clash operations.",
        "type": "comment"
    },
    "2732": {
        "file_id": 303,
        "content": "    # clash auto updates\n      - shell_command:\n        - cd /root/Desktop/works/pyjom/tests/karaoke_effects\n        - sleep 3 # wait for clash to be ready?\n        - python3 clash_auto_update.py",
        "type": "code",
        "location": "/tests/karaoke_effects/translator.yml:25-29"
    },
    "2733": {
        "file_id": 303,
        "content": "This code triggers an automatic update for the Clash software by executing a Python script. It changes directory to the project's location, waits 3 seconds for the program to be ready, and then runs the update script.",
        "type": "comment"
    },
    "2734": {
        "file_id": 304,
        "content": "/tests/karaoke_effects/test_split_different_lang.py",
        "type": "filepath"
    },
    "2735": {
        "file_id": 304,
        "content": "The code imports libraries, defines a list of multilingual test cases, and uses `getTextListTranslated` to translate them. It prints the translated results for demonstration purposes.",
        "type": "summary"
    },
    "2736": {
        "file_id": 304,
        "content": "# example of TDD.\nimport os\n# os.environ['http_proxy'] = \"\"\n# os.environ['https_proxy'] = \"\"\n# os.environ['all_proxy'] = \"\"\ntests = [\n    [\"リンの麺は終わった\", \"リンの麺は終わった\"],\n    # only japanese\n    [\n        \"リンの麺は終わった Lina的面吃完了没有\",\n        \"リンの麺は終わった Lina的面吃完了没有\",\n    ],  # japanese with chinese containing english\n    [\n        \"Lina I miss you Lina我想你了\",\n        \"Lina I miss you Lina我想你了\",\n    ],  # english with chinese containing english\n    [\"向前冲 冲 冲\", \"向前冲 冲 冲\"],  # only chinese\n    [\"go go go\", \"go go go\"],  # chinese containing english (overall)\n]\n# build a classifier for this? wtf?\n# whatlang?\nfrom lyrictoolbox import getTextListTranslated\nif __name__ == \"__main__\":\n    # result = translate('hello world')\n    # print(\"RESULT:\", result)\n    # result = translate('hello world', backend='baidu')\n    # print(\"RESULT:\", result)\n    # exit()\n    for test in tests:\n        # we need to demostrate this workflow.\n        newLyricArray = getTextListTranslated(test)\n        print(\"_________RESULT_________\")\n        for elem in newLyricArray:",
        "type": "code",
        "location": "/tests/karaoke_effects/test_split_different_lang.py:1-38"
    },
    "2737": {
        "file_id": 304,
        "content": "This code imports necessary libraries, defines a list of test cases containing text in different languages, and uses the `getTextListTranslated` function from the `lyrictoolbox` module to translate the texts. The translated results are then printed for demonstration purposes.",
        "type": "comment"
    },
    "2738": {
        "file_id": 304,
        "content": "            print(elem)\n        print(\"_________RESULT_________\")",
        "type": "code",
        "location": "/tests/karaoke_effects/test_split_different_lang.py:39-40"
    },
    "2739": {
        "file_id": 304,
        "content": "Testing function by printing each element and a separator line to indicate the end of the input.",
        "type": "comment"
    },
    "2740": {
        "file_id": 305,
        "content": "/tests/karaoke_effects/test_pylrc.py",
        "type": "filepath"
    },
    "2741": {
        "file_id": 305,
        "content": "The code retrieves music file duration, parses LRC file for lyrics and their start times, sorts and filters them, calculates end times based on durations, and prints the final output.",
        "type": "summary"
    },
    "2742": {
        "file_id": 305,
        "content": "import pylrc\nfrom MediaInfo import MediaInfo\ndef getMusicDuration(musicPath):\n    info = MediaInfo(filename=musicPath)\n    info = info.getInfo()\n    # print(info)\n    # breakpoint()\n    length = info[\"duration\"]\n    length = float(length)\n    return length\nmusicPath = \"/root/Desktop/works/pyjom/tests/music_analysis/exciting_bgm.mp3\"\nmusicDuration = getMusicDuration(musicPath)\nlrc_file = open(\"/root/Desktop/works/pyjom/tests/music_analysis/exciting_bgm.lrc\")\nlrc_string = \"\".join(lrc_file.readlines())\nlrc_file.close()\nsubs = pylrc.parse(lrc_string)\nlyricDurationThresholds = (0.5, 4)\ntextArray = []\nfor sub in subs:\n    startTime = sub.time\n    text = sub.text\n    textArray.append((startTime, text))\ntextArray.sort(key=lambda x: x[0])\nlastStartTime = textArray[0][0]\nnewTextArray = [{\"start\": textArray[0][0], \"text\": textArray[0][1]}]\nfor startTime, text in textArray[1:]:\n    if startTime - lastStartTime < lyricDurationThresholds[0]:\n        continue\n    else:\n        lastStartTime = startTime\n        newTextArray.append({\"text\": text, \"start\": startTime})",
        "type": "code",
        "location": "/tests/karaoke_effects/test_pylrc.py:1-43"
    },
    "2743": {
        "file_id": 305,
        "content": "This code retrieves the duration of a music file, reads its associated LRC file, parses it to extract lyrics and their start times, sorts them, filters out consecutive lyric lines within threshold time intervals, and stores the result in a new list of dictionaries containing \"text\" and \"start\" keys.",
        "type": "comment"
    },
    "2744": {
        "file_id": 305,
        "content": "# now calculate the end time, please?\n# you may want to translate this if you have to.\n# when it does not contains anything in chinese.\n# using deepl?\n# put that aside please? focus on this shit...\nimport numpy as np\nlyricDurations = [np.mean(lyricDurationThresholds)]\nfor index, elem in enumerate(newTextArray):\n    text = elem[\"text\"]\n    start = elem[\"start\"]\n    nextIndex = index + 1\n    if nextIndex < len(newTextArray):\n        nextElem = newTextArray[nextIndex]\n        nextStart = nextElem[\"start\"]\n        end = nextStart - start\n        if end > lyricDurationThresholds[0] and end < lyricDurationThresholds[1]:\n            lyricDurations.append(end)\n        end = min(end, lyricDurationThresholds[1], musicDuration - start) + start\n    else:\n        end = np.mean(lyricDurations) + start\n        end = min(musicDuration, end)\n    newTextArray[index].update({\"end\": end})\nfor elem in newTextArray:\n    print(elem)\n# great. now let's do the freaking work?",
        "type": "code",
        "location": "/tests/karaoke_effects/test_pylrc.py:45-73"
    },
    "2745": {
        "file_id": 305,
        "content": "This code calculates the end time of each lyric element in a newTextArray based on its start time and the given lyricDurationThresholds. It appends the calculated end times to the lyricDurations list, updates the end time for each element in newTextArray, and then prints all elements with their start and end times.",
        "type": "comment"
    },
    "2746": {
        "file_id": 306,
        "content": "/tests/karaoke_effects/test_detect_different_language.py",
        "type": "filepath"
    },
    "2747": {
        "file_id": 306,
        "content": "The code uses three libraries to detect language in sample text, but faces challenges due to unstable vector tools and unreliable language detection. Testing shows it fails to correctly identify Chinese in the example \"你好\".",
        "type": "summary"
    },
    "2748": {
        "file_id": 306,
        "content": "sample = \"Last Friday night. 影響包含\"\nimport pycld2 as cld2\ntext_content = sample\n_, _, _, detected_language = cld2.detect(text_content, returnVectors=True)\nprint(detected_language)  # unknown! fucking shit\n# ((0, 323, 'FRENCH', 'fr'), (323, 64, 'ENGLISH', 'en'))\n# this vector tool is very unstable. so as the freaking cld3 'get_frequent_language' shit\n# ((0, 30, 'Unknown', 'un'),)\nimport cld3\nresult = cld3.get_frequent_languages(sample, num_langs=3)\nprint(result)\n# what the fuck?\n# [LanguagePrediction(language='uz', probability=0.44310665130615234, is_reliable=False, proportion=0.5757575631141663), LanguagePrediction(language='zh', probability=0.9812981486320496, is_reliable=True, proportion=0.42424243688583374)]\nprint(cld3.get_language(\"last friday night do it all again this friday night\"))\n# not very freaking reliable.\nimport whatlang\nresult = whatlang.detect_language(\"last friday night\")\nprint(result)\nprint(whatlang.detect_language(\"你好\"))\n# from loadLingua_jpype import getLinguaDetectedLanguageLabel\n# print(getLinguaDetectedLanguageLabel('你好'))",
        "type": "code",
        "location": "/tests/karaoke_effects/test_detect_different_language.py:1-36"
    },
    "2749": {
        "file_id": 306,
        "content": "The code attempts to detect the language of a given sample text using different libraries: `pycld2`, `cld3`, and `whatlang`. However, it encounters issues with instability in vector tools, unpredictable results, and lack of reliability in detected languages.",
        "type": "comment"
    },
    "2750": {
        "file_id": 306,
        "content": "from loadLingua_pyjnius import pyjniusLinguaDetectLanguageLabel\nprint(pyjniusLinguaDetectLanguageLabel(\"你好\"))",
        "type": "code",
        "location": "/tests/karaoke_effects/test_detect_different_language.py:37-39"
    },
    "2751": {
        "file_id": 306,
        "content": "Testing if the code detects Chinese language correctly. It prints the detected language for the input \"你好\".",
        "type": "comment"
    },
    "2752": {
        "file_id": 307,
        "content": "/tests/karaoke_effects/test_baidu_language_recognize.py",
        "type": "filepath"
    },
    "2753": {
        "file_id": 307,
        "content": "This code imports the PaddleHub library and initializes two modules, \"baidu_translate\" for language translation and \"baidu_language_recognition\" for language recognition. It then defines a text to be recognized as \"私は日本人です\", sets the expected language code as the output of the language recognition model's recognize function, and prints the resulting language code.",
        "type": "summary"
    },
    "2754": {
        "file_id": 307,
        "content": "import paddlehub as hub\nlanguage_translation_model = hub.Module(name=\"baidu_translate\")\nlanguage_recognition_model = hub.Module(name=\"baidu_language_recognition\")\n# text = \"hello world\"\n# \"zh\", 'en', 'jp'\n# text = \"請輸入要轉換簡繁體的中文漢字\" # zh\ntext = \"私は日本人です\"\nlanguage_code = language_recognition_model.recognize(text)\nprint(\"language_code: %s\" % language_code)",
        "type": "code",
        "location": "/tests/karaoke_effects/test_baidu_language_recognize.py:1-11"
    },
    "2755": {
        "file_id": 307,
        "content": "This code imports the PaddleHub library and initializes two modules, \"baidu_translate\" for language translation and \"baidu_language_recognition\" for language recognition. It then defines a text to be recognized as \"私は日本人です\", sets the expected language code as the output of the language recognition model's recognize function, and prints the resulting language code.",
        "type": "comment"
    },
    "2756": {
        "file_id": 308,
        "content": "/tests/karaoke_effects/starJumping.py",
        "type": "filepath"
    },
    "2757": {
        "file_id": 308,
        "content": "The code creates a karaoke-style animation by calculating syllable positions, applying colors and effects, and using alpha blending and timing utilities for playback.",
        "type": "summary"
    },
    "2758": {
        "file_id": 308,
        "content": "\"\"\"\nInline effects is a method to define exclusive effects for syllables.\nFields \"Actor\" and \"Effect\" can also be used to define exclusive effects, but you will define them for the whole line.\nIn this example, romajis are looking for inline effects\n\"m1\" and \"m2\" to choose a main effect to apply to syls' text.\nKanjis are looking for lines' field \"Effect\", to choose what kind of effect we want to apply.\nIn addition, for romaji there's a star jumping over syls by frame-per-frame positioning.\nIn this example we can also see in action another utility provided by PyonFX: ColorUtility.\nIt is used to extract color changes from some lines and interpolate them for each generated line without effort.\nColors will add a really nice touch to your KFXs, so it is important to have a comfy way to set up them and use them in your effects.\nIn the translation lines we will create some clipped text colorated as an example of the application.\nYou can also make some simpler usage, like just applying color changes to the whole line, which is what karaokers normally do.",
        "type": "code",
        "location": "/tests/karaoke_effects/starJumping.py:1-14"
    },
    "2759": {
        "file_id": 308,
        "content": "This code defines a method for inline effects, allowing exclusive effects to be applied to syllables. It uses the \"Actor\" and \"Effect\" fields to define effects for whole lines. Romajis look for \"m1\" and \"m2\" to choose main effects, while kanjis search for line's field \"Effect\". Star jumping is applied using frame-per-frame positioning. The code also demonstrates the use of ColorUtility for extracting color changes and interpolating them for each generated line.",
        "type": "comment"
    },
    "2760": {
        "file_id": 308,
        "content": "It could look like much code for such a simple effect, but it's needed and an easy method with much potential for extensions.\n\"\"\"\n### THIS VARIANT IS GREAT. ###\n# from tkinter import CENTER\nfrom pyonfx import *\nimport random\nimport math\nio = Ass(\n    \"/root/Desktop/works/pyjom/tests/karaoke_effects/in2.ass\",\n    path_output=\"starJumping.ass\",\n)\nmeta, styles, lines = io.get_data()\n# Creating the star and extracting all the color changes from the input file\nstar = Shape.star(5, 4, 10)\nCU = ColorUtility(lines)\ndef romaji(line, l):\n    # Setting up a delay, we will use it as duration time of the leadin and leadout effects\n    delay = 100\n    # Setting up offset variables, we will use them for the \\move in leadin and leadout effects\n    off_x = 35\n    off_y = 15\n    # Leadin Effect\n    mDelay = 0\n    # lastStartTime = line.start_time\n    for syl in Utils.all_non_empty(line.syls):\n        l.layer = 0\n        # l.start_time = syl.end_time\n        l.start_time = line.start_time\n        # l.start_time = (\n        #     line.start_time + 25 * syl.i - delay - 80",
        "type": "code",
        "location": "/tests/karaoke_effects/starJumping.py:16-53"
    },
    "2761": {
        "file_id": 308,
        "content": "Creating a star shape and extracting color changes from an input file, setting up delay and offset variables for leadin and leadout effects.",
        "type": "comment"
    },
    "2762": {
        "file_id": 308,
        "content": "        # )  # Remove 80 to start_time to let leadin finish a little bit earlier than the main effect of the first syllable\n        # l.end_time = lastStartTime # wtf?\n        # lastStartTime = syl.start_time\n        l.end_time = syl.start_time\n        # l.end_time = line.start_time + syl.start_time # wtf?\n        l.dur = l.end_time - l.start_time\n        if l.dur <= 0:\n            continue\n        l.text = (\n            \"{\\\\an5\\\\move(%.3f,%.3f,%.3f,%.3f,0,%d)\\\\blur2\\\\t(0,%d,\\\\blur0)\\\\fad(%d,0)}%s\"\n            % (\n                syl.center + math.cos(syl.i / 2) * off_x,\n                syl.middle + math.sin(syl.i / 4) * off_y,\n                syl.center,\n                syl.middle,\n                delay,\n                delay,\n                delay,\n                syl.text,\n            )\n        )\n        io.write_line(l)\n    # Main Effect\n    for syl in Utils.all_non_empty(line.syls):\n        l.layer = 1\n        l.start_time = syl.start_time\n        # l.start_time = line.start_time + syl.start_time\n        l.end_time = syl.end_time + 100",
        "type": "code",
        "location": "/tests/karaoke_effects/starJumping.py:54-85"
    },
    "2763": {
        "file_id": 308,
        "content": "This code defines a karaoke effect for star jumping animation. It calculates the layer position, duration, and text formatting for each syllable in a line of lyrics. The main effect starts after the lead-in, with an optional delay, and continues for an additional 100 milliseconds after the end of each syllable.",
        "type": "comment"
    },
    "2764": {
        "file_id": 308,
        "content": "        l.dur = l.end_time - l.start_time\n        c1 = \"&H81F4FF&\"\n        c3 = \"&H199AAA&\"\n        # Change color if inline_fx is m1\n        if syl.inline_fx == \"m1\":\n            c1 = \"&H8282FF&\"\n            c3 = \"&H191AAA&\"\n        on_inline_effect_2 = \"\"\n        # Apply rotation if inline_fx is m2\n        if syl.inline_fx == \"m2\":\n            on_inline_effect_2 = \"\\\\t(0,%d,\\\\frz%.3f)\\\\t(%d,%d,\\\\frz0)\" % (\n                l.dur / 4,\n                random.uniform(-40, 40),\n                l.dur / 4,\n                l.dur,\n            )\n        l.text = (\n            \"{\\\\an5\\\\pos(%.3f,%.3f)%s\\\\t(0,80,\\\\fscx105\\\\fscy105\\\\1c%s\\\\3c%s)\\\\t(80,%d,\\\\fscx100\\\\fscy100\\\\1c%s\\\\3c%s)}%s\"\n            % (\n                syl.center,\n                syl.middle,\n                on_inline_effect_2,\n                c1,\n                c3,\n                l.dur - 80,\n                line.styleref.color1,\n                line.styleref.color3,\n                syl.text,\n            )\n        )\n        io.write_line(l)\n        # Animating star shape that jumps over the syllables",
        "type": "code",
        "location": "/tests/karaoke_effects/starJumping.py:86-122"
    },
    "2765": {
        "file_id": 308,
        "content": "This code applies colors and rotation to a star shape that jumps over syllables based on the inline_fx value. If inline_fx is \"m1\", it changes the colors; if inline_fx is \"m2,\" it applies rotation. The resulting star shape is then written to a file.",
        "type": "comment"
    },
    "2766": {
        "file_id": 308,
        "content": "        # Jump-in to the first syl\n        jump_height = 18\n        if syl.i == 0:\n            FU = FrameUtility(line.start_time - line.leadin / 2, line.start_time)\n            for s, e, i, n in FU:\n                l.start_time = s\n                l.end_time = e\n                frame_pct = i / n\n                x = syl.center - syl.width * (1 - frame_pct)\n                y = syl.top - math.sin(frame_pct * math.pi) * jump_height\n                alpha = 255\n                alpha += FU.add(0, syl.duration, -255)\n                alpha = Convert.alpha_dec_to_ass(int(alpha))\n                l.text = (\n                    \"{\\\\alpha%s\\\\pos(%.3f,%.3f)\\\\bord1\\\\blur1\\\\1c%s\\\\3c%s\\\\p1}%s\"\n                    % (alpha, x, y, c1, c3, star)\n                )\n                io.write_line(l)\n        # Jump to the next syl or to the end of line\n        jump_width = (\n            line.syls[syl.i + 1].center - syl.center\n            if syl.i != len(line.syls) - 1\n            else syl.width\n        )\n        # FU = FrameUtility(\n        #     line.start_time + syl.start_time, line.start_time + syl.end_time",
        "type": "code",
        "location": "/tests/karaoke_effects/starJumping.py:123-152"
    },
    "2767": {
        "file_id": 308,
        "content": "Code snippet performs the following:\n1. Jumps into first syllable, with jump height determined by variable `jump_height`.\n2. Uses `FrameUtility` for timing calculations based on line's start time minus lead-in time divided by 2 to start frame.\n3. Loops through each segment of `FrameUtility`, adjusting start and end times, and positioning the text accordingly.\n4. Calculates alpha value, which is then converted using `Convert.alpha_dec_to_ass` for blending effect.\n5. Writes each line to `io` (presumably an output stream).",
        "type": "comment"
    },
    "2768": {
        "file_id": 308,
        "content": "        # )\n        FU = FrameUtility(syl.start_time, syl.end_time)\n        for s, e, i, n in FU:\n            l.start_time = s\n            l.end_time = e\n            frame_pct = i / n\n            x = syl.center + frame_pct * jump_width\n            y = syl.top - math.sin(frame_pct * math.pi) * jump_height\n            alpha = 0\n            # Last jump should fade-out\n            if syl.i == len(line.syls) - 1:\n                alpha += FU.add(0, syl.duration, 255)\n            alpha = Convert.alpha_dec_to_ass(int(alpha))\n            l.text = \"{\\\\alpha%s\\\\pos(%.3f,%.3f)\\\\bord1\\\\blur1\\\\1c%s\\\\3c%s\\\\p1}%s\" % (\n                alpha,\n                x,\n                y,\n                c1,\n                c3,\n                star,\n            )\n            io.write_line(l)\n    # Leadout Effect\n    for syl in Utils.all_non_empty(line.syls):\n        l.layer = 0\n        l.start_time = syl.end_time\n        # l.start_time = line.start_time + syl.end_time + 100\n        l.end_time = line.end_time\n        # l.end_time = line.end_time - 25 * (len(line.syls) - syl.i) + delay + 100",
        "type": "code",
        "location": "/tests/karaoke_effects/starJumping.py:153-186"
    },
    "2769": {
        "file_id": 308,
        "content": "Code snippet applies a star jumping effect to the text of each syllable in a line, and adds a leadout effect at the end. The star jumping effect adjusts the position and fades out the last jump, while the leadout effect is triggered after all syllables have been processed.",
        "type": "comment"
    },
    "2770": {
        "file_id": 308,
        "content": "        # l.end_time = line.end_time - 25 * (len(line.syls) - syl.i) + delay + 100\n        l.dur = l.end_time - l.start_time\n        if l.dur <= 0:\n            continue\n        l.text = (\n            \"{\\\\an5\\\\move(%.3f,%.3f,%.3f,%.3f,%d,%d)\\\\t(%d,%d,\\\\blur2)\\\\fad(0,%d)}%s\"\n            % (\n                syl.center,\n                syl.middle,\n                syl.center + math.cos(syl.i / 2) * off_x,\n                syl.middle + math.sin(syl.i / 4) * off_y,\n                l.dur - delay,\n                l.dur,\n                l.dur - delay,\n                l.dur,\n                delay,\n                syl.text,\n            )\n        )\n        io.write_line(l)\ndef kanji(line, l):\n    # Setting up a delay, we will use it as duration time of the leadin and leadout effects\n    delay = 300\n    # Setting up offset variables, we will use them for the \\move in leadin and leadout effects\n    off_x = 35\n    off_y = 15\n    # Leadin Effect\n    for syl in Utils.all_non_empty(line.syls):\n        l.layer = 0\n        l.start_time = line.start_time",
        "type": "code",
        "location": "/tests/karaoke_effects/starJumping.py:187-221"
    },
    "2771": {
        "file_id": 308,
        "content": "This code snippet is adding leadin effects to a line of text. It calculates the start time and duration for each syllable in the line, adjusting the position of the \\move effect based on the syllable index. The delay value is used as the duration for leadin and leadout effects.",
        "type": "comment"
    },
    "2772": {
        "file_id": 308,
        "content": "        # l.start_time = (\n        #     line.start_time + 25 * syl.i - delay - 80\n        # )  # Remove 80 to start_time to let leadin finish a little bit earlier than the main effect of the first syllable\n        l.end_time = syl.start_time\n        # l.end_time = line.start_time + syl.start_time\n        l.dur = l.end_time - l.start_time\n        if l.dur <= 0:\n            continue\n        l.text = (\n            \"{\\\\an5\\\\move(%.3f,%.3f,%.3f,%.3f,0,%d)\\\\blur2\\\\t(0,%d,\\\\blur0)\\\\fad(%d,0)}%s\"\n            % (\n                syl.center + math.cos(syl.i / 2) * off_x,\n                syl.middle + math.sin(syl.i / 4) * off_y,\n                syl.center,\n                syl.middle,\n                delay,\n                delay,\n                delay,\n                syl.text,\n            )\n        )\n        io.write_line(l)\n    # Main Effect\n    for syl in Utils.all_non_empty(line.syls):\n        l.layer = 1\n        l.start_time = syl.start_time\n        # l.start_time = line.start_time + syl.start_time\n        l.end_time = syl.end_time + 100",
        "type": "code",
        "location": "/tests/karaoke_effects/starJumping.py:223-254"
    },
    "2773": {
        "file_id": 308,
        "content": "Code snippet is defining a star jumping animation effect for syllables in a line of karaoke lyrics. It calculates start and end times, layer, and text positioning based on syllable index and other variables. The main effect is applied to all non-empty syllables with a duration of 100ms extra to ensure it finishes properly.",
        "type": "comment"
    },
    "2774": {
        "file_id": 308,
        "content": "        l.dur = l.end_time - l.start_time\n        c1 = \"&H81F4FF&\"\n        c3 = \"&H199AAA&\"\n        # Change color if effect field is m1\n        if line.effect == \"m1\":\n            c1 = \"&H8282FF&\"\n            c3 = \"&H191AAA&\"\n        on_inline_effect_2 = \"\"\n        # Apply rotation if effect field is m2\n        if line.effect == \"m2\":\n            on_inline_effect_2 = \"\\\\t(0,%d,\\\\frz%.3f)\\\\t(%d,%d,\\\\frz0)\" % (\n                l.dur / 4,\n                random.uniform(-40, 40),\n                l.dur / 4,\n                l.dur,\n            )\n        l.text = (\n            \"{\\\\an5\\\\pos(%.3f,%.3f)%s\\\\t(0,80,\\\\fscx105\\\\fscy105\\\\1c%s\\\\3c%s)\\\\t(80,%d,\\\\fscx100\\\\fscy100\\\\1c%s\\\\3c%s)}%s\"\n            % (\n                syl.center,\n                syl.middle,\n                on_inline_effect_2,\n                c1,\n                c3,\n                l.dur - 80,\n                line.styleref.color1,\n                line.styleref.color3,\n                syl.text,\n            )\n        )\n        io.write_line(l)\n    # Leadout Effect",
        "type": "code",
        "location": "/tests/karaoke_effects/starJumping.py:255-291"
    },
    "2775": {
        "file_id": 308,
        "content": "This code dynamically sets the colors and applies rotation based on an \"effect\" field. If \"m1\", it changes colors, if \"m2\", applies rotation using a random angle within -40 to 40 degrees. The applied effects are combined with other formatting attributes to create the final line of text which is then written out.",
        "type": "comment"
    },
    "2776": {
        "file_id": 308,
        "content": "    for syl in Utils.all_non_empty(line.syls):\n        l.layer = 0\n        l.start_time = syl.end_time + 100\n        # l.start_time = line.start_time + syl.end_time + 100\n        l.end_time = line.end_time\n        # l.end_time = line.end_time - 25 * (len(line.syls) - syl.i) + delay + 100\n        l.dur = l.end_time - l.start_time\n        if l.dur <= 0:\n            continue\n        l.text = (\n            \"{\\\\an5\\\\move(%.3f,%.3f,%.3f,%.3f,%d,%d)\\\\t(%d,%d,\\\\blur2)\\\\fad(0,%d)}%s\"\n            % (\n                syl.center,\n                syl.middle,\n                syl.center + math.cos(syl.i / 2) * off_x,\n                syl.middle + math.sin(syl.i / 4) * off_y,\n                l.dur - delay,\n                l.dur,\n                l.dur - delay,\n                l.dur,\n                delay,\n                syl.text,\n            )\n        )\n        io.write_line(l)\ndef sub(line, l):\n    # Translation Effect\n    l.layer = 0\n    l.start_time = line.start_time - line.leadin / 2\n    l.end_time = line.end_time + line.leadout / 2",
        "type": "code",
        "location": "/tests/karaoke_effects/starJumping.py:292-327"
    },
    "2777": {
        "file_id": 308,
        "content": "The code iterates through non-empty syllables in a line, sets the layer and start time for each, calculates end time and duration, then creates a translation effect by writing it to the output.",
        "type": "comment"
    },
    "2778": {
        "file_id": 308,
        "content": "    l.dur = l.end_time - l.start_time\n    # Getting interpolated color changes (notice that we do that only after having set up all the times, that's important)\n    colors = CU.get_color_change(l)\n    # Base text\n    l.text = \"{\\\\an5\\\\pos(%.3f,%.3f)\\\\fad(%d,%d)}%s\" % (\n        line.center,\n        line.middle,\n        line.leadin / 2,\n        line.leadout / 2,\n        line.text,\n    )\n    io.write_line(l)\n    # Random clipped text colorated\n    l.layer = 1\n    for i in range(1, int(line.width / 80)):\n        x_clip = line.left + random.uniform(0, line.width)\n        y_clip = line.top - 5\n        clip = (\n            x_clip,\n            y_clip,\n            x_clip + random.uniform(10, 30),\n            y_clip + line.height + 10,\n        )\n        l.text = \"{\\\\an5\\\\pos(%.3f,%.3f)\\\\fad(%d,%d)\\\\clip(%d,%d,%d,%d)%s}%s\" % (\n            line.center,\n            line.middle,\n            line.leadin / 2,\n            line.leadout / 2,\n            clip[0],\n            clip[1],\n            clip[2],\n            clip[3],\n            colors,",
        "type": "code",
        "location": "/tests/karaoke_effects/starJumping.py:328-365"
    },
    "2779": {
        "file_id": 308,
        "content": "This code is creating a line of text with interpolated color changes and random clipped, colored text for karaoke effects. It sets the duration, gets color change values, defines the text's position and fade-in/out duration, writes the base text, and generates multiple lines with randomly clipped, colored text based on the line width.",
        "type": "comment"
    },
    "2780": {
        "file_id": 308,
        "content": "            line.text,\n        )\n        io.write_line(l)\nfor line in lines:\n    # Generating lines\n    if line.styleref.alignment >= 7:\n        lineModSource = line.copy()\n        break\n    elif line.styleref.alignment >= 4:\n        lineModSource = line.copy()\n        break\nfrom test_pylrc import *\n# just a test.\nshiftAdjust = 600\nfor elem in newTextArray:\n    lineMod = lineModSource.copy()\n    lineMod.start_time = max(0, elem[\"start\"] * 1000 - shiftAdjust)\n    lineMod.end_time = elem[\"end\"] * 1000 - shiftAdjust\n    lineMod.duration = lineMod.end_time - lineMod.start_time\n    lineMod.text = elem[\"text\"].strip().replace(\"  \", \"\")\n    # print(lineMod)\n    lineMod.words = lineMod.text.split(\" \")\n    # lineMod.syls =\n    # print(dir(lineMod))\n    # breakpoint()\n    sylList = []\n    wordCount = len(lineMod.words)\n    sylDuration = (lineMod.end_time - lineMod.start_time) / wordCount\n    textLength = len(lineMod.text)\n    charShift = 30\n    absWordCenterShiftList = []\n    prevWordShift = 0\n    CENTER = 1600 / 2\n    wordWidthList = []",
        "type": "code",
        "location": "/tests/karaoke_effects/starJumping.py:366-403"
    },
    "2781": {
        "file_id": 308,
        "content": "The code is generating lines and applying modifications to them based on alignment values. It then creates new line objects with adjusted start and end times, duration, text content, and splits the text into words. The code also calculates word position shifts and other variables for further processing.",
        "type": "comment"
    },
    "2782": {
        "file_id": 308,
        "content": "    for word in lineMod.words:\n        wordWidth = len(word) * charShift\n        wordWidthList.append(wordWidth)\n        wordLength = len(word) + 1\n        wordCenterShift = (charShift * wordLength) / 2\n        wordShift = charShift * wordLength\n        absWordCenterShift = (\n            CENTER - (textLength * charShift) / 2 + prevWordShift + wordCenterShift\n        )\n        absWordCenterShiftList.append(absWordCenterShift)\n        prevWordShift += wordShift\n    # CENTER + centerShift*charShift\n    getCenter = lambda index: absWordCenterShiftList[index]\n    getWidth = lambda index: wordWidthList[index]\n    mSylYShift = 700\n    for index, word in enumerate(lineMod.words):\n        syl = Syllable()\n        syl.text = word\n        syl.i = index\n        syl.center = getCenter(index)\n        syl.width = getWidth(index)\n        syl.top = 25 + mSylYShift\n        syl.inline_fx = \"m2\"\n        syl.middle = 49.0 + mSylYShift\n        syl.bottom = 73.0 + mSylYShift\n        syl.start_time = lineMod.start_time + index * sylDuration",
        "type": "code",
        "location": "/tests/karaoke_effects/starJumping.py:404-429"
    },
    "2783": {
        "file_id": 308,
        "content": "This code calculates word positions and dimensions for a karaoke effect. It iterates through each word in a line, determines the width of each word based on character shift, and then calculates the center position and overall position of the word. Finally, it creates an instance of the Syllable class for each word with the calculated properties and sets the start time based on the word index and duration.",
        "type": "comment"
    },
    "2784": {
        "file_id": 308,
        "content": "        syl.end_time = syl.start_time + sylDuration\n        syl.duration = sylDuration\n        sylList.append(syl)\n    lineMod.syls = sylList\n    # print(lineMod.syls)\n    # breakpoint()\n    # pyonfx.ass_core.Syllable\n    source = lineMod.copy()\n    target = lineMod.copy()\n    romaji(source, target)\n    lineMod2 = lineMod.copy()\n    translateShift = -200\n    for i in range(len(lineMod2.syls)):\n        lineMod2.syls[i].top += translateShift\n        lineMod2.syls[i].middle += translateShift\n        lineMod2.syls[i].bottom += translateShift\n    source = lineMod2.copy()\n    target = lineMod2.copy()\n    # elif line.styleref.alignment >= 4:\n    kanji(source, target)\n    # else:\n    #     sub(line, line.copy())\n# how to deal with the tra\nio.save()\n# io.open_aegisub()\nsample_video = \"/root/Desktop/works/pyjom/samples/video/karaoke_effects_source.mp4\"\nio.open_mpv(video_path=sample_video)  # ain't see shit...",
        "type": "code",
        "location": "/tests/karaoke_effects/starJumping.py:430-460"
    },
    "2785": {
        "file_id": 308,
        "content": "This code is manipulating and modifying a line of karaoke lyrics by adding a translation shift, updating the syllable positions, and applying kanji (Chinese characters) to specific alignments. It then saves the changes and opens an associated video file for playback.",
        "type": "comment"
    },
    "2786": {
        "file_id": 309,
        "content": "/tests/karaoke_effects/lyricToAss_test.py",
        "type": "filepath"
    },
    "2787": {
        "file_id": 309,
        "content": "This code imports necessary functions and utilizes them to generate an animated .ass file from a music file and its corresponding .lrc file, then previews it with a sample video.",
        "type": "summary"
    },
    "2788": {
        "file_id": 309,
        "content": "# this is the complete process.\nfrom lyrictoolbox import *\n# from .lyrictoolbox import previewAssWithVideo\n# from .lyrictoolbox import getTextListTranslated\nif __name__ == \"__main__\":\n    musicPath = \"/root/Desktop/works/pyjom/tests/music_analysis/exciting_bgm.mp3\"\n    lrcPath = \"/root/Desktop/works/pyjom/tests/music_analysis/exciting_bgm.lrc\"\n    sample_video = \"/root/Desktop/works/pyjom/samples/video/karaoke_effects_source.mp4\"\n    import os\n    assPath = os.path.abspath(\"test.ass\")\n    lrcToAnimatedAss(musicPath, lrcPath, assPath)\n    previewAssWithVideo(sample_video, assPath)",
        "type": "code",
        "location": "/tests/karaoke_effects/lyricToAss_test.py:1-15"
    },
    "2789": {
        "file_id": 309,
        "content": "This code imports necessary functions and utilizes them to generate an animated .ass file from a music file and its corresponding .lrc file, then previews it with a sample video.",
        "type": "comment"
    },
    "2790": {
        "file_id": 310,
        "content": "/tests/karaoke_effects/loadSomeCustomClashYaml.py",
        "type": "filepath"
    },
    "2791": {
        "file_id": 310,
        "content": "This code imports yaml and defines two functions for converting YAML strings between Python-friendly and Go-compatible formats. It then loads a file (Clash.yaml) using a custom loader, converts the string, and prints the loaded data.",
        "type": "summary"
    },
    "2792": {
        "file_id": 310,
        "content": "import yaml\n# yaml.add_constructor(mCustomLoaderTag, create_ref, Loader)\ndef goYamlToPyYaml(docString):\n    docString = docString.replace(\"!<str>\", \"!!str\")\n    return docString\ndef pyYamlToGoYaml(docString):\n    docString = docString.replace(\"!!str\", \"!<str>\")\n    return docString\nif __name__ == \"__main__\":\n    fileName = \"Clash.yaml\"\n    docString = open(fileName, \"r\").read()\n    mCustomLoaderTag = \"!<str>\"\n    class Ref(object):\n        def __init__(self, data):\n            self.data = data\n        def __repr__(self):\n            return '\"%s\"' % self.data\n    def create_ref(loader, node):\n        # print(dir(loader))\n        # breakpoint()\n        value = loader.costruct_string(node)\n        return Ref(value)\n    class Loader(yaml.SafeLoader):\n        pass\n    docString = goYamlToPyYaml(docString)\n    a = yaml.load(docString)\n    print(a)",
        "type": "code",
        "location": "/tests/karaoke_effects/loadSomeCustomClashYaml.py:1-41"
    },
    "2793": {
        "file_id": 310,
        "content": "This code imports yaml and defines two functions for converting YAML strings between Python-friendly and Go-compatible formats. It then loads a file (Clash.yaml) using a custom loader, converts the string, and prints the loaded data.",
        "type": "comment"
    },
    "2794": {
        "file_id": 311,
        "content": "/tests/karaoke_effects/loadLingua_pyjnius.py",
        "type": "filepath"
    },
    "2795": {
        "file_id": 311,
        "content": "This code imports necessary modules, sets Java classpath, prints a message, creates a language detector object, defines a function to detect language from a sample text, and tests the detector with a sample input.",
        "type": "summary"
    },
    "2796": {
        "file_id": 311,
        "content": "import jnius_config\n# jnius_config.add_options('-Xrs', '-Xmx4096')\njnius_config.set_classpath(\n    \".\", \"/root/Desktop/works/pyjom/tests/karaoke_effects/classpath/lingua.jar\"\n)\nimport jnius\njnius.autoclass(\"java.lang.System\").out.println(\"Running Java Program Using Pyjnius!\")\npyjniusLinguaDetector = (\n    jnius.autoclass(\"com.github.pemistahl.lingua.api.LanguageDetectorBuilder\")\n    .fromAllLanguages()\n    .build()\n)\ndef pyjniusLinguaDetectLanguageLabel(sample):\n    result = pyjniusLinguaDetector.detectLanguageOf(sample)\n    # print(result, type(result))\n    # breakpoint()\n    strResult = result.toString()\n    return strResult\nif __name__ == \"__main__\":\n    sample = \"hello world\"\n    result = pyjniusLinguaDetector.detectLanguageOf(sample)\n    print(result, type(result))\n    # breakpoint()\n    strResult = result.toString()\n    print(strResult, type(strResult))",
        "type": "code",
        "location": "/tests/karaoke_effects/loadLingua_pyjnius.py:1-32"
    },
    "2797": {
        "file_id": 311,
        "content": "This code imports necessary modules, sets Java classpath, prints a message, creates a language detector object, defines a function to detect language from a sample text, and tests the detector with a sample input.",
        "type": "comment"
    },
    "2798": {
        "file_id": 312,
        "content": "/tests/karaoke_effects/loadLingua_jpype_fastapi.py",
        "type": "filepath"
    },
    "2799": {
        "file_id": 312,
        "content": "The code uses JPype to interact with Java from Python and FastAPI, imports necessary packages, sets up a Java virtual machine, creates an instance of the language detector, defines a function to detect languages using Lingua API, and handles exceptions while analyzing text language with LangID.",
        "type": "summary"
    }
}