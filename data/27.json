{
    "2700": {
        "file_id": 290,
        "content": "/tests/anime_highlight_cuts/bittorrent_downloader/kill_aria2c.sh",
        "type": "filepath"
    },
    "2701": {
        "file_id": 290,
        "content": "This command is killing the aria2c process with a SIGINT signal, specifically targeting the specified anime episode titled 'Yahari Ore no Seishun Lovecome wa Machigatte Iru. [Ma10p_1080p]' from the Kamigami & VCB-Studio group.",
        "type": "summary"
    },
    "2702": {
        "file_id": 290,
        "content": "ps aux | grep '[Kamigami&VCB-Studio] Yahari Ore no Seishun Lovecome wa Machigatte Iru. [Ma10p_1080p]' | grep -v grep | awk '{print $1}' | xargs -Iabc kill -s INT abc",
        "type": "code",
        "location": "/tests/anime_highlight_cuts/bittorrent_downloader/kill_aria2c.sh:1-1"
    },
    "2703": {
        "file_id": 290,
        "content": "This command is killing the aria2c process with a SIGINT signal, specifically targeting the specified anime episode titled 'Yahari Ore no Seishun Lovecome wa Machigatte Iru. [Ma10p_1080p]' from the Kamigami & VCB-Studio group.",
        "type": "comment"
    },
    "2704": {
        "file_id": 291,
        "content": "/tests/anime_highlight_cuts/bittorrent_downloader/dynamic_import.mjs",
        "type": "filepath"
    },
    "2705": {
        "file_id": 291,
        "content": "Code imports and initializes two modules, FfmpegCommand and WebTorrent, using dynamic import. The code checks the data types of the imported functions, with FfmpegCommand being a function and WebTorrent appearing as a class in the console despite its data type being \"function\".",
        "type": "summary"
    },
    "2706": {
        "file_id": 291,
        "content": "const FfmpegCommand = (await import(`${process.env.NODE_PATH}/fluent-ffmpeg/index.js`)).default \nconst WebTorrent = (await import(`${process.env.NODE_PATH}/webtorrent/index.js`)).default \n// promise!\n// shit this ESM can directly use await statements.\nconsole.log(FfmpegCommand)\nconsole.log(typeof(FfmpegCommand)) // \"function\", with default name.\nconsole.log(WebTorrent)\nconsole.log(typeof(WebTorrent)) // \"function\"? why i see \"class\" in console.log?\n// this syntax is not recommended. autocompletion will not work.",
        "type": "code",
        "location": "/tests/anime_highlight_cuts/bittorrent_downloader/dynamic_import.mjs:1-12"
    },
    "2707": {
        "file_id": 291,
        "content": "Code imports and initializes two modules, FfmpegCommand and WebTorrent, using dynamic import. The code checks the data types of the imported functions, with FfmpegCommand being a function and WebTorrent appearing as a class in the console despite its data type being \"function\".",
        "type": "comment"
    },
    "2708": {
        "file_id": 292,
        "content": "/tests/anime_highlight_cuts/bittorrent_downloader/download_given_file_to_given_name.sh",
        "type": "filepath"
    },
    "2709": {
        "file_id": 292,
        "content": "This script downloads a torrent file using aria2c and removes temporary files once finished. The script sets the base path, torrent name, and file ID for the download. It also includes two different command variations for stopping the download after completion with timeout options. The commands use kill and grep to end the aria2c process with a signal and remove temporary files.",
        "type": "summary"
    },
    "2710": {
        "file_id": 292,
        "content": "# how to end downloading when finished?\n# using some command?\nBASE_PATH=\"/Users/jamesbrown/Downloads/anime_download\"\n# DOWNLOAD_FILE_PATH=\"$BASE_PATH/sample.webp\"\nTORRENT_NAME=\"[Kamigami&VCB-Studio] Yahari Ore no Seishun Lovecome wa Machigatte Iru. [Ma10p_1080p]\"\n# torrent name might be different.\nTORRENT_PATH=\"$BASE_PATH/$TORRENT_NAME.torrent\"\n# echo \"ps aux | grep '$TORRENT_NAME' | grep -v grep | awk '{print \\$1}' | xargs -Iabc kill -s INT abc\" > kill_aria2c.sh\nFILE_ID=\"117\"\n# timeout set to what?\n# rm \"$DOWNLOAD_FILE_PATH\"\nrm -rf \"$TORRENT_NAME\"\nrm -rf \"$TORRENT_NAME.aria2\"\n# this will be ignored.\n# change directory to our temp directory.\n# this speed shall be precalculated.\n# \n# you may check integrity.\n# just count seeders.\n# aria2c -x 16 --select-file=\"$FILE_ID\" --seed-time=0 --file-allocation=none \"$TORRENT_PATH\"\n# aria2c -x 16 --select-file=\"$FILE_ID\" --seed-time=0 --file-allocation=none --lowest-speed-limit=300K --bt-stop-timeout=60 \"$TORRENT_PATH\"",
        "type": "code",
        "location": "/tests/anime_highlight_cuts/bittorrent_downloader/download_given_file_to_given_name.sh:1-27"
    },
    "2711": {
        "file_id": 292,
        "content": "This script downloads a torrent file using aria2c and removes temporary files once finished. The script sets the base path, torrent name, and file ID for the download. It also includes two different command variations for stopping the download after completion with timeout options. The commands use kill and grep to end the aria2c process with a signal and remove temporary files.",
        "type": "comment"
    },
    "2712": {
        "file_id": 293,
        "content": "/tests/qq_go_cqhttp/launch.sh",
        "type": "filepath"
    },
    "2713": {
        "file_id": 293,
        "content": "The code changes the directory to \"go-cqhttp\" and executes the \"go-cqhttp\" script, which likely starts the CQHTTP bot.",
        "type": "summary"
    },
    "2714": {
        "file_id": 293,
        "content": "cd go-cqhttp\n./go-cqhttp",
        "type": "code",
        "location": "/tests/qq_go_cqhttp/launch.sh:1-2"
    },
    "2715": {
        "file_id": 293,
        "content": "The code changes the directory to \"go-cqhttp\" and executes the \"go-cqhttp\" script, which likely starts the CQHTTP bot.",
        "type": "comment"
    },
    "2716": {
        "file_id": 294,
        "content": "/tests/qq_go_cqhttp/build.sh",
        "type": "filepath"
    },
    "2717": {
        "file_id": 294,
        "content": "This code navigates to the \"go-cqhttp\" directory and compiles it using the Go language's 'build' command.",
        "type": "summary"
    },
    "2718": {
        "file_id": 294,
        "content": "cd go-cqhttp\ngo build",
        "type": "code",
        "location": "/tests/qq_go_cqhttp/build.sh:1-2"
    },
    "2719": {
        "file_id": 294,
        "content": "This code navigates to the \"go-cqhttp\" directory and compiles it using the Go language's 'build' command.",
        "type": "comment"
    },
    "2720": {
        "file_id": 295,
        "content": "/tests/qq_go_cqhttp/tests/download_group_files.py",
        "type": "filepath"
    },
    "2721": {
        "file_id": 295,
        "content": "The code connects to a local server, retrieves status, and handles errors. It provides functions for downloading QQ group files and directories using different APIs, handling subfolders recursively, and checking for existing files. The `group_file_wholesale_downloader` function is used to download group files to a specific path, running in a loop for each group ID with optional retry and sleep mechanisms.",
        "type": "summary"
    },
    "2722": {
        "file_id": 295,
        "content": "import pathlib\nimport os\nimport requests\n# again 0.0.0.0 not avaliable. must be localhost.\nbaseurl = \"http://localhost:5700/\"\n# go-cqhttp client does not support adding friends, searching groups or something! test if we can login opqbot and this shit at the same time!\n# it is working but unable to know if it is going to kill me.\nimport time\ndef check_connection():\n    while True:\n        try:\n            response = requests.get(baseurl+\"get_status\", timeout=5)\n            response_json = response.json()\n            print(\"GO_CQHTTP STATUS:\", response_json)\n            data_json = response_json[\"data\"]\n            assert data_json[\"online\"] == True\n            print(\"connection ok\")\n            break\n        except:\n            import traceback\n            traceback.print_exc()\n            print(\"Connection error.\")\n            time.sleep(3)\ndef get_url(api):\n    assert not api.startswith(\"/\")\n    return baseurl+api\ndef ensure_dir(download_path):\n    if not os.path.exists(download_path):\n        os.mkdir(download_path)",
        "type": "code",
        "location": "/tests/qq_go_cqhttp/tests/download_group_files.py:1-34"
    },
    "2723": {
        "file_id": 295,
        "content": "This code checks the connection to a local server, retrieves and prints the status, handles errors by retrying, and provides a function for generating full URLs. It seems related to testing or managing a program that interacts with CQHTTP, a third-party service.",
        "type": "comment"
    },
    "2724": {
        "file_id": 295,
        "content": "# api = \"get_group_file_system_info\"\ndef get_group_file(group_id, file_id, busid):\n    api = \"get_group_file_url\"\n    url = get_url(api)\n    params = {\"group_id\": group_id, \"file_id\": file_id, \"busid\": busid}\n    r = requests.get(url, params=params)\n    # print(r.content)\n    content = r.json()\n    data = content[\"data\"]\n    if data!=None:\n        download_url = data[\"url\"]\n        print(\"DOWNLOAD URL:\", download_url)\n        return download_url\ndef try_pass(function):\n    try:\n        function()\n    except:\n        pass\ndef downloader(url, filepath, skip_exist=True):\n    lock = filepath+\".lock\"\n    # check lock related operations.\n    if os.path.exists(lock):\n        try_pass(lambda: os.remove(lock))\n        try_pass(lambda: os.remove(filepath))\n    # do skip if flag \"skip_exists\" is set.\n    if skip_exist:\n        if os.path.exists(filepath):\n            return  # no overwritting existing files.\n    # download command\n    cmd = 'curl -L -o \"{}\" \"{}\"'.format(filepath, url)\n    # download main logic\n    # touch lock first.",
        "type": "code",
        "location": "/tests/qq_go_cqhttp/tests/download_group_files.py:36-77"
    },
    "2725": {
        "file_id": 295,
        "content": "This code defines a function for getting group file URLs, downloading files using curl, and includes optional checks for existing files and locking mechanisms.",
        "type": "comment"
    },
    "2726": {
        "file_id": 295,
        "content": "    pathlib.Path(lock).touch()\n    os.system(cmd)\n    try_pass(lambda: os.remove(lock))\ndef recursive_get_qq_group_files(api, group_id, basepath=None, folder_id=None, download_path=\"qq_group_file_download\"):\n    ensure_dir(download_path)\n    if basepath is None:\n        basepath = os.path.join(download_path, str(group_id))\n    ensure_dir(basepath)\n    if api == \"get_group_root_files\":\n        params = {\"group_id\": group_id}  # integer for group id\n    elif api == \"get_group_files_by_folder\":\n        # integer for group id\n        params = {\"group_id\": group_id, \"folder_id\": folder_id}\n    else:\n        raise Exception(\"Unknown recursive_get_qq_group_files api\", api)\n    url = get_url(api)\n    r = requests.get(url, params=params)\n# r = requests.get(url)\n    content = r.json()\n    # print(content)\n    # breakpoint()\n    data = content[\"data\"]\n    base_files = data[\"files\"]\n    base_folders = data[\"folders\"]  # may walk recursively.\n    base_files = [] if base_files == None else base_files\n    base_folders = [] if base_folders == None else base_folders",
        "type": "code",
        "location": "/tests/qq_go_cqhttp/tests/download_group_files.py:78-109"
    },
    "2727": {
        "file_id": 295,
        "content": "Creates a directory for group files based on the group ID, downloads QQ group files recursively and handles different APIs.",
        "type": "comment"
    },
    "2728": {
        "file_id": 295,
        "content": "    # print(base_files)\n    for bfile in base_files:\n        file_id = bfile[\"file_id\"]  # prefixed with /, no need to check?\n        # any expired files present? may cause download errors?\n        file_name = bfile[\"file_name\"]\n        busid = bfile[\"busid\"]\n        download_url = get_group_file(group_id, file_id, busid)\n        if download_url == None: continue\n        filepath = os.path.join(basepath, file_name)\n        print(\"FILEPATH:\", filepath)\n        yield download_url, filepath\n        # download those base files!\n    for bfolder in base_folders:\n        # we have group_id though.\n        folder_id = bfolder[\"folder_id\"]\n        folder_name = bfolder[\"folder_name\"]\n        new_basepath = os.path.join(basepath, folder_name)\n        for download_url, filepath in recursive_get_qq_group_files(\"get_group_files_by_folder\", group_id, basepath=new_basepath, folder_id=folder_id):\n            yield download_url, filepath\n        # all the same logic.\n        # now do recursive folder search.\n    # how to download these shits? curl?",
        "type": "code",
        "location": "/tests/qq_go_cqhttp/tests/download_group_files.py:111-134"
    },
    "2729": {
        "file_id": 295,
        "content": "This code downloads group files and folders from QQ group. It first retrieves base files by iterating through the base_files list, using get_group_file to obtain the download URL for each file and storing it in the filepath. Then, it recursively downloads files within specified folders using recursive_get_qq_group_files function. This code uses os.path.join to construct file paths and continues if a download URL is None.",
        "type": "comment"
    },
    "2730": {
        "file_id": 295,
        "content": "def group_file_wholesale_downloader(group_id, download_path=\"qq_group_file_download\", skip_exist=True):\n    for download_url, filepath in recursive_get_qq_group_files(\"get_group_root_files\", group_id, download_path=download_path):\n        downloader(download_url, filepath, skip_exist=skip_exist)\n# group_id = 927825838 # more files but no base_files.\n# group_id = 537384511 # less files but have base_files\n# make it dynamic!\ndownload_path = \"/root/Desktop/works/pyjom/tests/wechat_bots/msimg32.dll_wechat_hook_webapi/official_qq_group_files\"\ngroup_ids = [927825838, 537384511] # i know i am in these groups.\n#  import time\ncheck_connection() # failsafe or not?\nfor group_id in group_ids:\n    #  while True:\n        #  try:\n    group_file_wholesale_downloader(group_id, download_path=download_path, skip_exist=True)\n    #  break\n        #  except: time.sleep(10) # auto retry.\n        # there is no need for any failsafes. maybe we are outside the groups.\n# already downloaded. waiting for updates?",
        "type": "code",
        "location": "/tests/qq_go_cqhttp/tests/download_group_files.py:137-159"
    },
    "2731": {
        "file_id": 295,
        "content": "The code defines a function `group_file_wholesale_downloader` that downloads QQ group files for specified group IDs to a specific path. It uses recursive calls to `recursive_get_qq_group_files` and `downloader` functions. The provided example group IDs (927825838, 537384511) are used with the download path \"/root/Desktop/works/pyjom/tests/wechat_bots/msimg32.dll_wechat_hook_webapi/official_qq_group_files\". The code runs this function in a loop for each group ID, potentially with retry and sleep mechanisms if needed.",
        "type": "comment"
    },
    "2732": {
        "file_id": 296,
        "content": "/tests/dapp_ethereum_python_crypto/test.py",
        "type": "filepath"
    },
    "2733": {
        "file_id": 296,
        "content": "The code uses Web3 to connect to a local Ethereum node, imports necessary libraries, checks connection status and account balance, unlocks accounts, sends transactions, and verifies received funds.",
        "type": "summary"
    },
    "2734": {
        "file_id": 296,
        "content": "from web3 import Web3\n# testnet, bitcoind, regtest\n# https://bitcoin.stackexchange.com/questions/42026/is-it-possible-to-use-bitcoind-as-a-private-blockchain\n# mine only when pending transaction happens:\n# https://ethereum.stackexchange.com/questions/3151/how-to-make-miner-to-mine-only-when-there-are-pending-transactions\n# maybe you want money even if without transaction, or low in cash.\n# https://hackernoon.com/hands-on-creating-your-own-local-private-geth-node-beginner-friendly-3d45902cc612\nlink = \"/root/.ethereum/geth.ipc\"\nweb3 = Web3(Web3.IPCProvider(link))\nprint(web3.isConnected())\n# account_genesis = \"0xde478bde26d711414fae26133e759d8a82a202ab\"  # aka: eth.coinbase\n# account_genesis = \"0x6fe20a7157fdb705278fffda4ea0ebf4694f31ea\"\naccount_genesis = \"0xd6e79c8d5b7d41cc1a3b98373c98618ea267852f\"\naccount_genesis = Web3.toChecksumAddress(account_genesis)\npassword_genesis = \"abcdefg\"\n# let's see!\n# target_account = \"0x033799af9b29e1d7dbf3c8dd64647df345f67bf1\"\ntarget_account = \"0x463f061d2add7987e2a7d14920e18194107ea991\"",
        "type": "code",
        "location": "/tests/dapp_ethereum_python_crypto/test.py:1-26"
    },
    "2735": {
        "file_id": 296,
        "content": "The code imports Web3, sets the IPC link to connect to a local Ethereum node, checks the connection status, assigns an account address and password, and specifies a target account.",
        "type": "comment"
    },
    "2736": {
        "file_id": 296,
        "content": "target_account = Web3.toChecksumAddress(target_account)\n# you was connected ethereum to mainnet! not good.\n# anyway, we need money!\nb = web3.eth.get_balance(web3.eth.coinbase)\nprint(b)\n# proof of authority, puppeth\n## need password!\nweb3.geth.personal.unlock_account(web3.eth.coinbase, password_genesis)\nweb3.eth.send_transaction(\n    {\n        \"to\": target_account,\n        \"from\": web3.eth.coinbase,\n        \"value\": 1,\n    }\n)\nweb3.geth.personal.lock_account(web3.eth.coinbase)\n# you can choose to use 'with' statement.\nb = web3.eth.get_balance(target_account)\nprint(b)\n# still no money! fuck.",
        "type": "code",
        "location": "/tests/dapp_ethereum_python_crypto/test.py:27-52"
    },
    "2737": {
        "file_id": 296,
        "content": "Code connects to Ethereum mainnet, checks balance of the coinbase account, unlocks account using a password, sends transaction to target_account, and verifies if funds have been received.",
        "type": "comment"
    },
    "2738": {
        "file_id": 297,
        "content": "/tests/dapp_ethereum_python_crypto/README.md",
        "type": "filepath"
    },
    "2739": {
        "file_id": 297,
        "content": "The code is expressing the difficulty in validating a 'hacker' program within AGI and the need to create dummy crypto elements for testing purposes.",
        "type": "summary"
    },
    "2740": {
        "file_id": 297,
        "content": "not sure how to validate my 'hacker' program in AGI. just create some dummy crypto things.",
        "type": "code",
        "location": "/tests/dapp_ethereum_python_crypto/README.md:1-1"
    },
    "2741": {
        "file_id": 297,
        "content": "The code is expressing the difficulty in validating a 'hacker' program within AGI and the need to create dummy crypto elements for testing purposes.",
        "type": "comment"
    },
    "2742": {
        "file_id": 298,
        "content": "/tests/render_and_recognize_long_text_to_filter_unwanted_characters/test_render.py",
        "type": "filepath"
    },
    "2743": {
        "file_id": 298,
        "content": "The code utilizes pygame and specific libraries to generate text, render it, set up a game display window, and save the updated display as output_name.",
        "type": "summary"
    },
    "2744": {
        "file_id": 298,
        "content": "import os\n# https://github.com/ntasfi/PyGame-Learning-Environment/issues/26\nos.environ[\"SDL_VIDEODRIVER\"] = \"dummy\"\nimport pygame\npygame.init()\nblack, white = pygame.Color('black'), pygame.Color('white')\n# pillow can also do that\n# https://plainenglish.io/blog/generating-text-on-image-with-python-eefe4430fe77\ntextContent = \"\".join([\"中\",\"ぁ\"]+[f\"[{index+1}]\" for index in range(100)]) # will see [100] at the end of text if successful.\n# pygame.font.get_fonts()\n# install your font to system please? but why all lower case font names?\n# fontName = \"notosans\"\n# this font is bad.\nfontSize = 40\n# font = pygame.font.SysFont(fontName,fontSize)\n# fontPath = \"/usr/share/fonts/truetype/noto/NotoSans-Regular.ttf\" # shit this fails.\nfontPath = \"./get_and_merge_fonts/GoNotoCurrent.ttf\"\n# use some kind of super large merged notofont.\nfont = pygame.font.Font(fontPath, fontSize)\noutput_name = \"test_render.png\"\nword_surface = font.render(textContent, False, black)\nword_width, word_height = word_surface.get_size()\nmargin=20\nSIZE=(word_width+margin*2, word_height+margin*2)",
        "type": "code",
        "location": "/tests/render_and_recognize_long_text_to_filter_unwanted_characters/test_render.py:1-33"
    },
    "2745": {
        "file_id": 298,
        "content": "The code imports necessary libraries, sets the video driver, initializes pygame, defines colors, generates text content with 100 placeholders, selects a font (GoNotoCurrent.ttf), renders the text, and determines the size of the rendered image.",
        "type": "comment"
    },
    "2746": {
        "file_id": 298,
        "content": "image = pygame.display.set_mode(SIZE, pygame.RESIZABLE)\nimage.fill(white)\nimage.blit(word_surface,(margin,margin))\npygame.display.update()\npygame.image.save(image,output_name)",
        "type": "code",
        "location": "/tests/render_and_recognize_long_text_to_filter_unwanted_characters/test_render.py:34-38"
    },
    "2747": {
        "file_id": 298,
        "content": "Initializes game display window with specified size, fills it with white color, blits word image onto the surface, updates pygame display and saves the updated display to output_name.",
        "type": "comment"
    },
    "2748": {
        "file_id": 299,
        "content": "/tests/render_and_recognize_long_text_to_filter_unwanted_characters/test_pytesseract.py",
        "type": "filepath"
    },
    "2749": {
        "file_id": 299,
        "content": "This code uses the pytesseract library to extract text from an image. It specifies a list of supported languages (English, Chinese Simplified, Chinese Traditional, Japanese), combines them into a single language code, and applies it to the \"test_render.png\" image file. The resulting extracted text is then printed out. However, there may be many incorrect results due to the complexity of character recognition in different languages.",
        "type": "summary"
    },
    "2750": {
        "file_id": 299,
        "content": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\nimport pytesseract\n# pytesseract.get_languages(config=\"\")\nlangs =['eng','chi_sim','chi_tra','jpn']\nlangCode = \"+\".join(langs)\npicPath = \"test_render.png\"\noutput = pytesseract.image_to_string(picPath, lang=langCode)\nprint(\"OUTPUT?\")\nprint(output)\n# many incorrect results?",
        "type": "code",
        "location": "/tests/render_and_recognize_long_text_to_filter_unwanted_characters/test_pytesseract.py:1-15"
    },
    "2751": {
        "file_id": 299,
        "content": "This code uses the pytesseract library to extract text from an image. It specifies a list of supported languages (English, Chinese Simplified, Chinese Traditional, Japanese), combines them into a single language code, and applies it to the \"test_render.png\" image file. The resulting extracted text is then printed out. However, there may be many incorrect results due to the complexity of character recognition in different languages.",
        "type": "comment"
    },
    "2752": {
        "file_id": 300,
        "content": "/tests/medialang_reference/videolang.mdl",
        "type": "filepath"
    },
    "2753": {
        "file_id": 300,
        "content": "The code defines two media streams: the first one is a video with a .mp4 extension and a speed of 1.5, while the second one is an audio file also with a .mp4 extension located at \"/root/Desktop/works/pyjom/src/samples/video/dog_with_text.mp4\", set to play at 1.5 speed but without video output.",
        "type": "summary"
    },
    "2754": {
        "file_id": 300,
        "content": "(\".mp4\", speed=1.5\n)\n(\"/root/Desktop/works/pyjom/src/samples/video/dog_with_text.mp4\",\n    speed=1.5, video=false\n)",
        "type": "code",
        "location": "/tests/medialang_reference/videolang.mdl:1-6"
    },
    "2755": {
        "file_id": 300,
        "content": "The code defines two media streams: the first one is a video with a .mp4 extension and a speed of 1.5, while the second one is an audio file also with a .mp4 extension located at \"/root/Desktop/works/pyjom/src/samples/video/dog_with_text.mp4\", set to play at 1.5 speed but without video output.",
        "type": "comment"
    },
    "2756": {
        "file_id": 301,
        "content": "/tests/medialang_reference/recursive_audiolang.mdl",
        "type": "filepath"
    },
    "2757": {
        "file_id": 301,
        "content": "This code sets the audio language model and specifies its configuration. It uses a subtitle detector with an input file located at \"/root/Desktop/works/pyjom/src/samples/video/dog_with_text.mp4\". The speed of processing is set to 1.5x, and the output file is generated from the template at \"/root/Desktop/works/pyjom/src/test/audiolang.mdl.j2\" with format arguments \"some_number\": 2 and \"some_text\": \"shit\".",
        "type": "summary"
    },
    "2758": {
        "file_id": 301,
        "content": "(\".mp3\", processor=\"subtitle_detector\"\n)\n(\"/root/Desktop/works/pyjom/src/samples/video/dog_with_text.mp4\",\n    speed=1.5\n)\n(\"/root/Desktop/works/pyjom/src/test/audiolang.mdl.j2\",\n    format_args={\"some_number\": 2, \"some_text\": \"shit\"}\n)",
        "type": "code",
        "location": "/tests/medialang_reference/recursive_audiolang.mdl:1-10"
    },
    "2759": {
        "file_id": 301,
        "content": "This code sets the audio language model and specifies its configuration. It uses a subtitle detector with an input file located at \"/root/Desktop/works/pyjom/src/samples/video/dog_with_text.mp4\". The speed of processing is set to 1.5x, and the output file is generated from the template at \"/root/Desktop/works/pyjom/src/test/audiolang.mdl.j2\" with format arguments \"some_number\": 2 and \"some_text\": \"shit\".",
        "type": "comment"
    },
    "2760": {
        "file_id": 302,
        "content": "/tests/medialang_reference/processor_multi.mdl",
        "type": "filepath"
    },
    "2761": {
        "file_id": 302,
        "content": "The code is creating a pipeline to process a video file and associated .json files. It uses a video file \"dog_with_text.mp4\" at 1.5x speed, followed by subtitle detection and active region detection on the .json files.",
        "type": "summary"
    },
    "2762": {
        "file_id": 302,
        "content": "(\"/root/Desktop/works/pyjom/src/samples/video/dog_with_text.mp4\",\n    speed=1.5\n)\n(\".json\", processor=\"subtitle_detector\"\n)\n(\".json\",\n    processor=\"active_region_detector\"\n)",
        "type": "code",
        "location": "/tests/medialang_reference/processor_multi.mdl:1-10"
    },
    "2763": {
        "file_id": 302,
        "content": "The code is creating a pipeline to process a video file and associated .json files. It uses a video file \"dog_with_text.mp4\" at 1.5x speed, followed by subtitle detection and active region detection on the .json files.",
        "type": "comment"
    },
    "2764": {
        "file_id": 303,
        "content": "/tests/medialang_reference/processor_demo.mdl",
        "type": "filepath"
    },
    "2765": {
        "file_id": 303,
        "content": "The code specifies a video file path and sets the playback speed. The \"subtitle_detector\" processor is applied to a JSON file.",
        "type": "summary"
    },
    "2766": {
        "file_id": 303,
        "content": "(\".json\", processor=\"subtitle_detector\"\n)\n(\"/root/Desktop/works/pyjom/samples/video/dog_with_text.mp4\",\n    speed=1.5\n)",
        "type": "code",
        "location": "/tests/medialang_reference/processor_demo.mdl:1-6"
    },
    "2767": {
        "file_id": 303,
        "content": "The code specifies a video file path and sets the playback speed. The \"subtitle_detector\" processor is applied to a JSON file.",
        "type": "comment"
    },
    "2768": {
        "file_id": 304,
        "content": "/tests/medialang_reference/audiolang.mdl.j2",
        "type": "filepath"
    },
    "2769": {
        "file_id": 304,
        "content": "The code defines a sequence of media items to be played. It includes audio and video files, with options for speed adjustment and text-to-speech conversion. The code also utilizes a loop to create multiple instances of these media items, replacing some variables like 'some_number' and 'some_text'.",
        "type": "summary"
    },
    "2770": {
        "file_id": 304,
        "content": "(\".mp3\", speed=1.5\n)\n(\"/root/Desktop/works/pyjom/src/samples/video/dog_with_text.mp4\",\n    speed=1.5, video=false\n)\n    (\"/root/Desktop/works/pyjom/src/samples/video/IxEQhCslT.mp4\",\n        padding=\"black\"\n    )\n        (\"text://you did a good job\",\n            converter=\"voice\", provider=\"tts_male\",\n            speed=2\n        )\n{% for i in range(some_number) %}\n(\"/root/Desktop/works/pyjom/src/samples/video/dog_with_text.mp4\",\n    speed={{ some_number }}\n)\n    (\"text://{{ some_text }}\",\n        converter=\"voice\"\n    )\n{% endfor %}",
        "type": "code",
        "location": "/tests/medialang_reference/audiolang.mdl.j2:1-23"
    },
    "2771": {
        "file_id": 304,
        "content": "The code defines a sequence of media items to be played. It includes audio and video files, with options for speed adjustment and text-to-speech conversion. The code also utilizes a loop to create multiple instances of these media items, replacing some variables like 'some_number' and 'some_text'.",
        "type": "comment"
    },
    "2772": {
        "file_id": 305,
        "content": "/tests/medialang_reference/audiolang.mdl",
        "type": "filepath"
    },
    "2773": {
        "file_id": 305,
        "content": "The code represents a sequence of media items and text to be processed by the program. It includes audio, video files, and text strings for conversion. The media items are specified with their respective paths and properties like speed and padding. The text strings are to be converted using the \"voice\" converter and may have additional properties like provider and speed.",
        "type": "summary"
    },
    "2774": {
        "file_id": 305,
        "content": "(\".mp3\", speed=1.5\n)\n(\"/root/Desktop/works/pyjom/src/samples/video/dog_with_text.mp4\",\n    speed=1.5, video=false\n)\n    (\"/root/Desktop/works/pyjom/src/samples/video/IxEQhCslT.mp4\",\n        padding=\"black\"\n    )\n        (\"text://you did a good job\",\n            converter=\"voice\", provider=\"tts_male\",\n            speed=2\n        )\n(\"/root/Desktop/works/pyjom/src/samples/video/dog_with_text.mp4\",\n    speed=1.5\n)\n    (\"text://you did a bad job\",\n        converter=\"voice\"\n    )",
        "type": "code",
        "location": "/tests/medialang_reference/audiolang.mdl:1-20"
    },
    "2775": {
        "file_id": 305,
        "content": "The code represents a sequence of media items and text to be processed by the program. It includes audio, video files, and text strings for conversion. The media items are specified with their respective paths and properties like speed and padding. The text strings are to be converted using the \"voice\" converter and may have additional properties like provider and speed.",
        "type": "comment"
    },
    "2776": {
        "file_id": 306,
        "content": "/tests/keepalive_service/test.sh",
        "type": "filepath"
    },
    "2777": {
        "file_id": 306,
        "content": "This line of code is running the \"keepalive\" executable with the argument \"echo abc\". The purpose seems to be testing and logging that the process is still alive.",
        "type": "summary"
    },
    "2778": {
        "file_id": 306,
        "content": "./keepalive echo abc",
        "type": "code",
        "location": "/tests/keepalive_service/test.sh:1-1"
    },
    "2779": {
        "file_id": 306,
        "content": "This line of code is running the \"keepalive\" executable with the argument \"echo abc\". The purpose seems to be testing and logging that the process is still alive.",
        "type": "comment"
    },
    "2780": {
        "file_id": 307,
        "content": "/tests/keepalive_service/install.sh",
        "type": "filepath"
    },
    "2781": {
        "file_id": 307,
        "content": "This line of code copies the 'keepalive' file to '/usr/local/bin/' directory, allowing it to be accessed and executed system-wide.",
        "type": "summary"
    },
    "2782": {
        "file_id": 307,
        "content": "cp keepalive /usr/local/bin/",
        "type": "code",
        "location": "/tests/keepalive_service/install.sh:1-1"
    },
    "2783": {
        "file_id": 307,
        "content": "This line of code copies the 'keepalive' file to '/usr/local/bin/' directory, allowing it to be accessed and executed system-wide.",
        "type": "comment"
    },
    "2784": {
        "file_id": 308,
        "content": "/tests/cpm_chinese_chitchat_model_gpt2/test.sh",
        "type": "filepath"
    },
    "2785": {
        "file_id": 308,
        "content": "This code changes the directory to GPT2-chitchat, checks RAM consumption and urges to buy new RAM for CPU model testing. It runs 'interact.py' with no CUDA and using a specific model path.",
        "type": "summary"
    },
    "2786": {
        "file_id": 308,
        "content": "# no fucking gpu. just test how much RAM it consumes.\ncd GPT2-chitchat # 1.8GB mem consumption. freaking hell.\n# BUY NEW RAM AND RUN MODELS ON CPU!\npython3 interact.py --no_cuda --model_path ../model",
        "type": "code",
        "location": "/tests/cpm_chinese_chitchat_model_gpt2/test.sh:1-4"
    },
    "2787": {
        "file_id": 308,
        "content": "This code changes the directory to GPT2-chitchat, checks RAM consumption and urges to buy new RAM for CPU model testing. It runs 'interact.py' with no CUDA and using a specific model path.",
        "type": "comment"
    },
    "2788": {
        "file_id": 309,
        "content": "/tests/cpm_chinese_chitchat_model_gpt2/init.sh",
        "type": "filepath"
    },
    "2789": {
        "file_id": 309,
        "content": "Code is cloning the GPT2-chitchat repository with a single commit from GitHub.",
        "type": "summary"
    },
    "2790": {
        "file_id": 309,
        "content": "git clone --depth 1 https://github.com/yangjianxin1/GPT2-chitchat",
        "type": "code",
        "location": "/tests/cpm_chinese_chitchat_model_gpt2/init.sh:1-1"
    },
    "2791": {
        "file_id": 309,
        "content": "Code is cloning the GPT2-chitchat repository with a single commit from GitHub.",
        "type": "comment"
    },
    "2792": {
        "file_id": 310,
        "content": "/tests/nearly_duplicate_frames_detection_removal/test.py",
        "type": "filepath"
    },
    "2793": {
        "file_id": 310,
        "content": "The code imports libraries, checks for still images, and uses scene detection with the scenedetect library. It retrieves video duration, sets adaptive detector, and stores results in an output file. Another code reads a CSV file into a DataFrame, prints first 5 rows, and pauses execution at breakpoint.",
        "type": "summary"
    },
    "2794": {
        "file_id": 310,
        "content": "# source = \"/root/Desktop/works/pyjom/samples/video/nearly_duplicate_frames_detection.gif\"  # this is evil. it defeats my shit.\nsource = \"/root/Desktop/works/pyjom/samples/video/nearly_duplicate_frames_detection_30fps_blend.mp4\"  # this is evil. it defeats my shit.\n# source = \"/root/Desktop/works/pyjom/samples/video/nearly_duplicate_frames_detection_30fps.gif\"  # this is evil. it defeats my shit.\n# is it still image?\n# we can also detect more shits. right?\nimport sys\nimport os\nos.chdir(\"../../\")\nsys.path.append(\".\")\nfrom pyjom.commons import extract_span\nimport scenedetect\nfrom caer.video.frames_and_fps import get_duration\nstats_file_path = \"/media/root/parrot/pyjom/tests/nearly_duplicate_frames_detection_removal/output.csv\"\nduration = get_duration(source)\nprint(\"DURATION:\", duration)\ncuts = scenedetect.detect(\n    video_path=source, stats_file_path=stats_file_path, show_progress=True, \n    # detector=scenedetect.ContentDetector()\n    detector=scenedetect.AdaptiveDetector(),\n) # no fucking cuts???\nimport pandas",
        "type": "code",
        "location": "/tests/nearly_duplicate_frames_detection_removal/test.py:1-28"
    },
    "2795": {
        "file_id": 310,
        "content": "Code imports necessary libraries, checks if the source is a still image, and uses scenedetect library for scene detection. It gets video duration, sets adaptive detector, and stores results in output.csv file. No cuts are found in the video.",
        "type": "comment"
    },
    "2796": {
        "file_id": 310,
        "content": "df = pandas.read_csv(stats_file_path)\nprint(df.head())\nbreakpoint()",
        "type": "code",
        "location": "/tests/nearly_duplicate_frames_detection_removal/test.py:30-32"
    },
    "2797": {
        "file_id": 310,
        "content": "This code reads a CSV file (stats_file_path) into a pandas DataFrame named 'df', then prints the first 5 rows of the DataFrame, and finally pauses execution at this breakpoint.",
        "type": "comment"
    },
    "2798": {
        "file_id": 311,
        "content": "/tests/nearly_duplicate_frames_detection_removal/pyav_effective_fps.py",
        "type": "filepath"
    },
    "2799": {
        "file_id": 311,
        "content": "This code measures the keyframe percentage in a video file using Python and the AV library. It opens a video source, iterates over each frame, appends the keyframes to a list, calculates the percentage of keyframes relative to total frames, and prints the result.",
        "type": "summary"
    }
}