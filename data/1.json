{
    "100": {
        "file_id": 8,
        "content": "            if needSegment:\n                start = random.uniform(0, musicLength - segmentLength)\n                end = start + segmentLength\n                ffmpeg.input(filepath, ss=start, to=end).output(segmentName).run(\n                    overwrite_output=True\n                )\n            else:\n                pathlib.Path(segmentName).touch()\n                segmentName = filepath\n            # you will change to given directory, will you?\n            commandLine = [\"npx\", \"ts-node\", \"midomi_music_recognize.ts\", segmentName]\n            success, data = runCommandAndProcessSongRecognizationJson(\n                commandLine,\n                midomiSongRecognizationResultProcessMethod,\n                raw_data=raw_data,\n                debug=debug,\n                timeout=timeout,\n                workingDirectory=\"/root/Desktop/works/pyjom/tests/music_recognization/AmadeusCore\",\n            )\n        if success:\n            break\n    return success, data\ndef recognizeMusicFromFile(\n    filepath,\n    backend: Literal[\"songrec\", \"shazamio\", \"midomi\", None] = None,",
        "type": "code",
        "location": "/pyjom/musictoolbox.py:355-381"
    },
    "101": {
        "file_id": 8,
        "content": "This code segment is responsible for recognizing music from a given file using different backends. It first checks if there is a need to segment the audio and then uses FFmpeg to extract a segment or touches an existing file as the input. Next, it runs a command line with various arguments including the input file, backend type, raw data, debug mode, timeout, and working directory. The function returns success status and processed data if successful, otherwise continues trying with different backends until success is achieved.",
        "type": "comment"
    },
    "102": {
        "file_id": 8,
        "content": "    raw_data=False,\n    debug=False,\n):  # if not returning raw_data, only track data and artist data are returned.\n    assert os.path.exists(filepath)\n    # if returning raw_data, must also return the provider name, for easy parsing.\n    # you can try all methods. but if all three methods fails, you know what to do. what indicates the recognizer has failed?\n    # you can try something erotic.\n    if backend is None:  # auto\n        musicDuration = getAudioDuration(filepath)\n        if musicDuration <= 15:\n            backend = \"midomi\"\n        else:\n            backend = \"songrec\"\n    methods = {\n        \"midomi\": recognizeMusicFromFileMidomi,\n        \"songrec\": recognizeMusicFromFileSongrec,\n        \"shazamio\": recognizeMusicFromFileShazamIO,\n    }\n    keys = list(methods.keys())\n    keys.sort(key=lambda x: -int(x == backend))\n    for key in keys:\n        method = methods[key]\n        success, data = method(filepath, debug=debug)\n        if debug:\n            print(\"DATA:\")\n            print(data)\n            print(\"RETURN FROM MUSIC RECOGNIZE METHOD: %s\" % key)",
        "type": "code",
        "location": "/pyjom/musictoolbox.py:382-408"
    },
    "103": {
        "file_id": 8,
        "content": "This function uses a series of methods to recognize music from a file and returns track data, artist data, and raw data if specified. It checks the duration of the audio file and chooses the appropriate method (midomi, songrec, or shazamio) based on the duration. If no backend is specified, it automatically selects the best method for the given file duration. The code also prints debug information if requested.",
        "type": "comment"
    },
    "104": {
        "file_id": 8,
        "content": "            print(\"SUCCESS:\", success)\n        if success:\n            if raw_data:\n                return success, data, key\n            else:\n                return success, data\n        if debug:\n            break  # no retry then.\n    if raw_data:\n        return False, {}, \"\"\n    return False, {}\n############ SEARCH NETEASE MUSIC, GET SIMILAR MUSIC BY ID, DOWNLOAD MUSIC AND LYRICS ############\nimport requests\nfrom lazero.program.functools import suppressException\nclass neteaseMusic:\n    def __init__(self, port: int = 4042):\n        self.baseUrl = \"http://localhost:{}\".format(port)\n    def verifyResponseCodeAndGetJson(\n        self, response, debug: bool = False, success_codes: list[int] = [200]\n    ):\n        response_json = response.json()  # check search_result.json\n        if success_codes != []:\n            code = response_json[\"code\"]\n            if not code in success_codes:\n                if debug:\n                    print(response_json)\n                import traceback\n                traceback.print_exc()",
        "type": "code",
        "location": "/pyjom/musictoolbox.py:409-443"
    },
    "105": {
        "file_id": 8,
        "content": "Imports necessary libraries and defines a class for interacting with Netease Music. The class has a constructor to set the port, and methods to search music, get similar music by ID, download music and lyrics. It also handles exceptions and checks response codes.",
        "type": "comment"
    },
    "106": {
        "file_id": 8,
        "content": "                raise Exception(\"ERROR CODE IN NETEASE API RESPONSE:\", code)\n        return response_json\n    def requestWithParamsGetJson(\n        self,\n        suffix: str,\n        params: dict = {},\n        debug: bool = False,\n        success_codes: list[int] = [200],\n        refresh: bool = False,\n    ):\n        if refresh:\n            params.update({\"timestamp\": getJSTimeStamp()})\n        suffix = suffix.strip()\n        if not suffix.startswith(\"/\"):\n            suffix = \"/\" + suffix\n        link = self.baseUrl + suffix\n        result = requests.get(link, params=params)\n        result_json = self.verifyResponseCodeAndGetJson(\n            result, debug=debug, success_codes=success_codes\n        )\n        return result_json\n    @suppressException(tries=2, defaultReturn={})\n    def searchNeteaseMusicByQuery(\n        self, query: Union[list, str], debug: bool = False, refresh: bool = False\n    ):\n        if type(query) == str:\n            query = query.strip()\n        else:\n            query = [elem.strip() for elem in query]",
        "type": "code",
        "location": "/pyjom/musictoolbox.py:444-474"
    },
    "107": {
        "file_id": 8,
        "content": "This code defines a class method to request data from a Netease API using GET requests and handle the response. It takes parameters like suffix, query, debug flag, success codes, and refresh flag. The method handles refreshing timestamps if needed, constructs the URL, makes a GET request with the parameters, verifies the response code, and returns the JSON data or raises an exception if an error occurs.",
        "type": "comment"
    },
    "108": {
        "file_id": 8,
        "content": "            query = \" \".join([elem for elem in query if len(elem) > 0])\n        assert len(query) > 0\n        search_result_json = self.requestWithParamsGetJson(\n            \"/search\",\n            params={\"keywords\": query},\n            debug=debug,\n            refresh=refresh,\n        )\n        return search_result_json\n    @suppressException(defaultReturn=[])\n    def getSimilarMusicByIdFromNetease(\n        self, music_id: int, debug: bool = False, refresh: bool = False\n    ):\n        r_json = self.requestWithParamsGetJson(\n            \"/simi/song\", params={\"id\": music_id}, debug=debug, refresh=refresh\n        )\n        song_ids = []\n        for song in r_json[\"songs\"]:\n            name = song[\"name\"]\n            song_id = song[\"id\"]\n            song_ids.append(song_id)\n            # what you want?\n        return song_ids\n    @suppressException()\n    def getMusicUrlFromNetease(\n        self, music_id: int, debug: bool = False, refresh: bool = False\n    ):\n        r_json = self.requestWithParamsGetJson(\n            \"/song/url\", params={\"id\": music_id}, debug=debug, refresh=refresh",
        "type": "code",
        "location": "/pyjom/musictoolbox.py:475-505"
    },
    "109": {
        "file_id": 8,
        "content": "The code contains functions to search and retrieve similar music by ID, as well as fetching the URL of a specific song from the Netease API. It makes requests with parameters, handles exceptions, and returns search results or song IDs.",
        "type": "comment"
    },
    "110": {
        "file_id": 8,
        "content": "        )  # this song might expire. warning!\n        # expire in a few seconds.\n        url = r_json[\"data\"][0].get(\"url\", None)\n        return url  # you may test this url. later.\n    @suppressException(defaultReturn=False)\n    def checkMusicFromNetEase(\n        self, music_id: int, debug: bool = False, refresh: bool = False\n    ):\n        # {\n        #   \"success\": true,\n        #   \"message\": \"ok\"\n        # }\n        # no need to check the return code.\n        r_json = self.requestWithParamsGetJson(\n            \"check/music\",\n            params={\"id\": music_id},\n            debug=debug,\n            refresh=refresh,\n            success_codes=[],\n        )\n        assert r_json[\"success\"] == True\n        assert r_json[\"message\"] == \"ok\"\n        return True\n    @suppressException()\n    def getMusicLyricFromNetease(\n        self,\n        music_id: int,\n        debug: bool = False,\n        refresh: bool = False,\n        minLyricStringLength: int = 50,\n    ):\n        r_json = self.requestWithParamsGetJson(\n            \"/lyric\",",
        "type": "code",
        "location": "/pyjom/musictoolbox.py:506-540"
    },
    "111": {
        "file_id": 8,
        "content": "The code defines two functions: `checkMusicFromNetEase` and `getMusicLyricFromNetease`. The first function checks if a music URL exists by sending a GET request to the \"check/music\" endpoint with the given music ID. It returns True if the response is successful. The second function retrieves the lyrics of the specified music ID from the \"/lyric\" endpoint and raises exceptions for errors. Both functions use the `requestWithParamsGetJson` method, which sends a GET request to an endpoint, receives JSON data, and handles success codes or exceptions based on parameters provided.",
        "type": "comment"
    },
    "112": {
        "file_id": 8,
        "content": "            params={\"id\": music_id},\n            debug=debug,\n            refresh=refresh,\n        )\n        # warning: the fetched lrc could be not so clean. clean it somehow!\n        lyric_string = r_json[\"lrc\"][\"lyric\"]\n        if lyric_string != None and type(lyric_string) == str:\n            if len(lyric_string) > minLyricStringLength:\n                return lyric_string\n    @suppressException(tries=2, defaultReturn=((None, None), None))\n    def getMusicAndLyricWithKeywords(\n        self,\n        keywords: str,\n        similar: bool = False,\n        debug: bool = False,\n        min_audio_length: float = 2 * 60,\n        max_audio_length: float = 5 * 60\n    ):  # minimum 2.5 minutes of music.\n        import pyjq\n        # store the downloaded file in some place please?\n        search_data_json = self.searchNeteaseMusicByQuery(keywords, debug=debug)\n        # print(search_data_json)\n        song_ids = pyjq.all(\n            \".result.songs[] | select (.id !=null) | .id\", search_data_json\n        )  # incorrect. use pyjq.all",
        "type": "code",
        "location": "/pyjom/musictoolbox.py:541-567"
    },
    "113": {
        "file_id": 8,
        "content": "This code defines a function that searches for music and its corresponding lyrics using keywords. It also includes error suppression and checks if the downloaded file is stored or not. The function takes in parameters such as keywords, similarity flag, debug mode, minimum and maximum audio lengths. It uses Pyjq to query the music data and extracts song IDs from the search results.",
        "type": "comment"
    },
    "114": {
        "file_id": 8,
        "content": "        # print(song_ids)\n        # breakpoint()\n        song_id = random.choice(song_ids)\n        # how to parse this shit?\n        if similar:\n            similar_song_ids = self.getSimilarMusicByIdFromNetease(song_id, debug=debug)\n            song_id = random.choice(similar_song_ids)\n        # now download the music.\n        music_url = self.getMusicUrlFromNetease(song_id, debug=debug, refresh=True)\n        # download the music right now.\n        r = requests.get(music_url)\n        if debug:\n            print(\"download music status code:\", r.status_code)\n        assert r.status_code == 200  # are you sure the code is ok?\n        music_format = music_url.split(\".\")[-1]\n        music_content = r.content\n        # how to get song duration?\n        import tempfile\n        with tempfile.NamedTemporaryFile(\n            mode=\"wb\", suffix=\".{}\".format(music_format)\n        ) as f:\n            name = f.name\n            name = os.path.abspath(name)\n            f.write(music_content)\n            song_duration = getAudioDuration(name)",
        "type": "code",
        "location": "/pyjom/musictoolbox.py:568-594"
    },
    "115": {
        "file_id": 8,
        "content": "This code randomly selects a song, if similar music is specified, it chooses one from the similar list. It then downloads the selected music and stores it temporarily for later use. The song duration is determined using a helper function.",
        "type": "comment"
    },
    "116": {
        "file_id": 8,
        "content": "        if song_duration < min_audio_length:\n            raise Exception(\"audio too short, total {} seconds\".format(song_duration))\n        elif song_duration > max_audio_length:\n            raise Exception(\"audio too long, total {} seconds\".format(song_duration))\n        lyric_string = self.getMusicLyricFromNetease(song_id)\n        if debug:\n            print(\"LYRICS:\", lyric_string)\n        if type(lyric_string) ==str and lyric_string.strip() !=\"\":\n            from pyjom.lyrictoolbox import (\n                cleanLrcFromWeb,\n            )  # cleaning needs song duration.\n            lyric_string = cleanLrcFromWeb(lyric_string, song_duration)\n        return (music_content, music_format), lyric_string\n############ SEARCH NETEASE MUSIC, GET SIMILAR MUSIC BY ID, DOWNLOAD MUSIC AND LYRICS ############",
        "type": "code",
        "location": "/pyjom/musictoolbox.py:595-611"
    },
    "117": {
        "file_id": 8,
        "content": "This code checks the song duration against specified minimum and maximum audio lengths, raises exceptions if necessary, retrieves lyrics from Netease using getMusicLyricFromNetease method, prints or logs the lyric string if in debug mode, checks if the lyric string is a non-empty string, cleans the LRC from web by calling cleanLrcFromWeb function and passing song duration as argument, and returns music content, format, and cleaned lyrics.",
        "type": "comment"
    },
    "118": {
        "file_id": 9,
        "content": "/pyjom/README.md",
        "type": "filepath"
    },
    "119": {
        "file_id": 9,
        "content": "The code discusses the challenges of a censored internet and half-automated media project, requiring manual interfaces for data selection and labeling. It aims for future automation improvements and mentions data storage in /dev/shm.",
        "type": "summary"
    },
    "120": {
        "file_id": 9,
        "content": "due to heavy censored internet and the half-automated nature of media project, require interfaces to select and label data on the fly, when the project is somehow stablized.\nmanual labels can be therefore used later for better automation.\nsimple generation logic will be applied first, establishing basic feedback loop. then we may feature the details, enhancing product quality and so on.\nthis project may be the shadow of nature of life. no offense.\nsorting by priority is always crucial for all of us, all the time.\ndata stored in /dev/shm will be lost after reboot.\nafter months, if not years, you might blend in with this project.\nmany websites may match the structural complexity of yours.",
        "type": "code",
        "location": "/pyjom/README.md:1-15"
    },
    "121": {
        "file_id": 9,
        "content": "The code discusses the challenges of a censored internet and half-automated media project, requiring manual interfaces for data selection and labeling. It aims for future automation improvements and mentions data storage in /dev/shm.",
        "type": "comment"
    },
    "122": {
        "file_id": 10,
        "content": "/pyjom/requirements.txt",
        "type": "filepath"
    },
    "123": {
        "file_id": 10,
        "content": "This code specifies dependencies for a Python project. It requires the 'parse', 'requests', and 'command-spawner' packages, along with a custom package named 'nudenet' which provides nude detection functionality in video or picture files.",
        "type": "summary"
    },
    "124": {
        "file_id": 10,
        "content": "parse\nrequests\ncommand-spawner\nnudenet # nude detection in video/picture",
        "type": "code",
        "location": "/pyjom/requirements.txt:1-4"
    },
    "125": {
        "file_id": 10,
        "content": "This code specifies dependencies for a Python project. It requires the 'parse', 'requests', and 'command-spawner' packages, along with a custom package named 'nudenet' which provides nude detection functionality in video or picture files.",
        "type": "comment"
    },
    "126": {
        "file_id": 11,
        "content": "/pyjom/mathlib.py",
        "type": "filepath"
    },
    "127": {
        "file_id": 11,
        "content": "This code uses a Kalman Filter for time series smoothing, provides utility functions, manages overlapping intervals, handles range merging and sorting, includes Bezier curve function, applies exponential network to multiple inputs, and has a window-based maximum average finding function.",
        "type": "summary"
    },
    "128": {
        "file_id": 11,
        "content": "# moved to lazero.utils.mathlib\nfrom lazero.utils.mathlib import *\n# # not overriding math.\n# # do some ranged stuff here...\n# from pykalman import KalmanFilter\n# import numpy as np\n# def superMean(mList:list,default=0):\n#     if len(mList) == 0: return  default\n#     return np.mean(mList)\n# def superMax(mList:list,default=0):\n#     if len(mList) == 0: return default\n#     return max(mList)\n# def superMin(mList:list,default=0):\n#     if len(mList) == 0: return default\n#     return min(mList)\n# def uniq(mList, ordered=True, random=False):\n#     if ordered:\n#         result = []\n#         for elem in mList:\n#             if elem not in result:\n#                 result.append(elem)\n#     else:\n#         result = list(set(mList))\n#     if random:\n#         import random\n#         random.shuffle(result)\n#     return result\n# def get1DArrayEMA(mArray, N=5):\n#     weights = np.exp(np.linspace(0, 1, N))\n#     weights = weights / np.sum(weights)\n#     ema = np.convolve(weights, mArray, mode=\"valid\")\n#     return ema\n# def Kalman1D(observations, damping=0.2):",
        "type": "code",
        "location": "/pyjom/mathlib.py:1-40"
    },
    "129": {
        "file_id": 11,
        "content": "This code defines several utility functions for numerical operations, including mean, max, min, unique values (with optional ordering and shuffling), Exponential Moving Average (EMA), and a Kalman Filter. It imports necessary libraries like numpy and pykalman.",
        "type": "comment"
    },
    "130": {
        "file_id": 11,
        "content": "#     # To return the smoothed time series data\n#     observation_covariance = damping\n#     initial_value_guess = observations[0]\n#     transition_matrix = 1\n#     transition_covariance = 0.1\n#     initial_value_guess\n#     kf = KalmanFilter(\n#         initial_state_mean=initial_value_guess,\n#         initial_state_covariance=observation_covariance,\n#         observation_covariance=observation_covariance,\n#         transition_covariance=transition_covariance,\n#         transition_matrices=transition_matrix,\n#     )\n#     pred_state, state_cov = kf.smooth(observations)\n#     return pred_state\n# def getContinualNonSympyMergeResult(inputMSetCandidates):\n#     # basically the same example.\n#     # assume no overlapping here.\n#     import sympy\n#     def unionToTupleList(myUnion):\n#         unionBoundaries = list(myUnion.boundary)\n#         unionBoundaries.sort()\n#         leftBoundaries = unionBoundaries[::2]\n#         rightBoundaries = unionBoundaries[1::2]\n#         return list(zip(leftBoundaries, rightBoundaries))",
        "type": "code",
        "location": "/pyjom/mathlib.py:41-66"
    },
    "131": {
        "file_id": 11,
        "content": "The code snippet initializes a KalmanFilter object for smoothing time series data. It defines the observation_covariance, transition_covariance, and other parameters before creating the KalmanFilter instance. The function then calls `kf.smooth(observations)` to perform the smoothing operation and returns the smoothed state. Additionally, there's a helper function that converts a sympy Union set to a list of (left_boundary, right_boundary) tuples.",
        "type": "comment"
    },
    "132": {
        "file_id": 11,
        "content": "#     def tupleSetToUncertain(mSet):\n#         mUncertain = None\n#         for start, end in mSet:\n#             if mUncertain is None:\n#                 mUncertain = sympy.Interval(start, end)\n#             else:\n#                 mUncertain += sympy.Interval(start, end)\n#         typeUncertain = type(mUncertain)\n#         return mUncertain, typeUncertain\n#     def mergeOverlappedInIntervalTupleList(intervalTupleList):\n#         mUncertain, _ = tupleSetToUncertain(intervalTupleList)\n#         mUncertainBoundaryList = list(mUncertain.boundary)\n#         mUncertainBoundaryList.sort()\n#         mergedIntervalTupleList = list(\n#             zip(mUncertainBoundaryList[::2], mUncertainBoundaryList[1::2])\n#         )\n#         return mergedIntervalTupleList\n#     # mSet = mergeOverlappedInIntervalTupleList([(0, 1), (2, 3)])\n#     # mSet2 = mergeOverlappedInIntervalTupleList([(0.5, 1.5), (1.6, 2.5)])\n#     # print(\"MSET\", mSet)\n#     # print(\"MSET2\", mSet2)\n#     mSetCandidates = [\n#         mergeOverlappedInIntervalTupleList(x) for x in inputMSetCandidates",
        "type": "code",
        "location": "/pyjom/mathlib.py:68-94"
    },
    "133": {
        "file_id": 11,
        "content": "This code defines two functions: \"tupleSetToUncertain\" and \"mergeOverlappedInIntervalTupleList\". The first function takes a set of intervals represented as tuples, converts them into a Sympy Interval object representing the union of these intervals, and returns both the object and its type. The second function merges overlapping intervals from a list of interval tuples and returns the merged intervals as a list of start-end pairs. It uses the first function to convert the input intervals into a Sympy Interval object, extracts the boundary points, sorts them, and then zips them back into start-end pairs for the output list.",
        "type": "comment"
    },
    "134": {
        "file_id": 11,
        "content": "#     ]\n#     mSetUnified = [x for y in mSetCandidates for x in y]\n#     leftBoundaryList = set([x[0] for x in mSetUnified])\n#     rightBoundaryList = set([x[1] for x in mSetUnified])\n#     # they may freaking overlap.\n#     # if want nearby-merge strategy, simply just expand all intervals, merge them with union and shrink the individual intervals inside union respectively.\n#     markers = {\n#         \"enter\": {k: [] for k in leftBoundaryList},\n#         \"exit\": {k: [] for k in rightBoundaryList},\n#     }\n#     for index, mSetCandidate in enumerate(mSetCandidates):\n#         leftBoundaryListOfCandidate = [x[0] for x in mSetCandidate]\n#         rightBoundaryListOfCandidate = [x[1] for x in mSetCandidate]\n#         for leftBoundaryOfCandidate in leftBoundaryListOfCandidate:\n#             markers[\"enter\"][leftBoundaryOfCandidate].append(index)  # remap this thing!\n#         for rightBoundaryOfCandidate in rightBoundaryListOfCandidate:\n#             markers[\"exit\"][rightBoundaryOfCandidate].append(index)  # remap this thing!",
        "type": "code",
        "location": "/pyjom/mathlib.py:95-113"
    },
    "135": {
        "file_id": 11,
        "content": "This code creates a dictionary of markers for left and right boundaries. It first combines all set candidates into one list, then creates sets for the left and right boundary lists. It then populates the \"enter\" and \"exit\" dictionaries with the indices where each boundary is encountered. This information can be used for further processing, such as merging nearby intervals or identifying overlapping boundaries.",
        "type": "comment"
    },
    "136": {
        "file_id": 11,
        "content": "#     # now, iterate through the boundaries of mSetUnified.\n#     unifiedBoundaryList = leftBoundaryList.union(\n#         rightBoundaryList\n#     )  # call me a set instead of a list please? now we must sort this thing\n#     unifiedBoundaryList = list(unifiedBoundaryList)\n#     unifiedBoundaryList.sort()\n#     unifiedBoundaryMarks = {}\n#     finalMappings = {}\n#     # print(\"MARKERS\", markers)\n#     # breakpoint()\n#     for index, boundary in enumerate(unifiedBoundaryList):\n#         previousMark = unifiedBoundaryMarks.get(index - 1, [])\n#         enterList = markers[\"enter\"].get(boundary, [])\n#         exitList = markers[\"exit\"].get(boundary, [])\n#         currentMark = set(previousMark + enterList).difference(set(exitList))\n#         currentMark = list(currentMark)\n#         unifiedBoundaryMarks.update({index: currentMark})\n#         # now, handle the change? or not?\n#         # let's just deal those empty ones, shall we?\n#         if previousMark == []:  # inside it is empty range.\n#             # elif currentMark == []:",
        "type": "code",
        "location": "/pyjom/mathlib.py:115-136"
    },
    "137": {
        "file_id": 11,
        "content": "This code is iterating through the boundaries of two lists, unifying them into a sorted list called `unifiedBoundaryList`. It then creates empty dictionaries `unifiedBoundaryMarks` and `finalMappings`. The `markers` dictionary is used to determine which markers correspond to the current boundary. The code calculates the current mark by combining previous markers, entering markers for the current boundary, and removing any exiting markers for the current boundary. It then updates `unifiedBoundaryMarks` with the new index and current marker list. If the previous marker list was empty (indicating an empty range), it does something (code missing).",
        "type": "comment"
    },
    "138": {
        "file_id": 11,
        "content": "#             if index == 0:\n#                 continue  # just the start, no need to note this down.\n#             else:\n#                 finalMappings.update(\n#                     {\n#                         \"empty\": finalMappings.get(\"empty\", [])\n#                         + [(unifiedBoundaryList[index - 1], boundary)]\n#                     }\n#                 )\n#             # the end of previous mark! this interval belongs to previousMark\n#         else:\n#             key = previousMark.copy()\n#             key.sort()\n#             key = tuple(key)\n#             finalMappings.update(\n#                 {\n#                     key: finalMappings.get(key, [])\n#                     + [(unifiedBoundaryList[index - 1], boundary)]\n#                 }\n#             )\n#             # also the end of previous mark! belongs to previousMark.\n#     ### NOW THE FINAL OUTPUT ###\n#     finalCats = {}\n#     for key, value in finalMappings.items():\n#         # value is an array containing subInterval tuples.\n#         value = mergeOverlappedInIntervalTupleList(value)",
        "type": "code",
        "location": "/pyjom/mathlib.py:137-163"
    },
    "139": {
        "file_id": 11,
        "content": "This code appears to be working with a list of intervals and categorizing them into different types. It checks for the start of each interval, updates a dictionary (finalMappings) accordingly, and then handles the end of an interval by assigning it to the previous category. Finally, it processes the finalMappings dictionary to create the final output (finalCats).",
        "type": "comment"
    },
    "140": {
        "file_id": 11,
        "content": "#         valueCorrected = [(mStart, mEnd) for mStart, mEnd in value if mStart < mEnd]\n#         finalCats.update({key: valueCorrected})\n#     # print(\"______________FINAL CATS______________\")\n#     # print(finalCats)\n#     return finalCats\n# def getContinualMappedNonSympyMergeResult(mRangesDict, concatSymbol=\"|\", noEmpty=True):\n#     mKeyMaps = list(mRangesDict.keys())\n#     mSetCandidates = [mRangesDict[key] for key in mKeyMaps]\n#     # the next step will automatically merge all overlapped candidates.\n#     finalCats = getContinualNonSympyMergeResult(mSetCandidates)\n#     finalCatsMapped = {\n#         concatSymbol.join([mKeyMaps[k] for k in mTuple]): finalCats[mTuple]\n#         for mTuple in finalCats.keys()\n#         if type(mTuple) == tuple\n#     }\n#     if not noEmpty:\n#         finalCatsMapped.update(\n#             {k: finalCats[k] for k in finalCats.keys() if type(k) != tuple}\n#         )\n#     return finalCatsMapped\n#     # default not to output empty set?\n# def getContinualMappedNonSympyMergeResultWithRangedEmpty(",
        "type": "code",
        "location": "/pyjom/mathlib.py:164-190"
    },
    "141": {
        "file_id": 11,
        "content": "This code defines two functions, `getContinualMappedNonSympyMergeResult` and `getContinualMappedNonSympyMergeResultWithRangedEmpty`. These functions merge overlapping ranges of values into a single range. They can be used to handle cases where the input is a list of ranges, and we want to merge all ranges that overlap. The merged result is returned as a dictionary with keys being concatenated keys (in the first function) or including non-tuple keys if `noEmpty` flag is set (in the second function).",
        "type": "comment"
    },
    "142": {
        "file_id": 11,
        "content": "#     mRangesDict, start, end, concatSymbol=\"|\"\n# ):\n#     import uuid\n#     emptySetName = str(uuid.uuid4())\n#     newRangesDict = mRangesDict.copy()\n#     newRangesDict.update({emptySetName: [(start, end)]})\n#     newRangesDict = getContinualMappedNonSympyMergeResult(\n#         newRangesDict, concatSymbol=\"|\", noEmpty=True\n#     )\n#     newRangesDict = {\n#         key: [\n#             (mStart, mEnd)\n#             for mStart, mEnd in newRangesDict[key]\n#             if mStart >= start and mEnd <= end and mStart < mEnd\n#         ]\n#         for key in newRangesDict.keys()\n#     }\n#     newRangesDict = {\n#         key: newRangesDict[key]\n#         for key in newRangesDict.keys()\n#         if newRangesDict[key] != []\n#     }\n#     finalNewRangesDict = {}\n#     for key in newRangesDict.keys():\n#         mergedEmptySetName = \"{}{}\".format(concatSymbol, emptySetName)\n#         if mergedEmptySetName in key:\n#             newKey = key.replace(mergedEmptySetName,\"\")\n#             finalNewRangesDict.update({newKey:newRangesDict[key]})",
        "type": "code",
        "location": "/pyjom/mathlib.py:191-219"
    },
    "143": {
        "file_id": 11,
        "content": "This code creates a new dictionary by filtering and merging overlapping ranges. It copies the input dictionary, adds an empty set range, filters non-overlapping ranges, removes empty sets, and finally merges overlapping empty sets.",
        "type": "comment"
    },
    "144": {
        "file_id": 11,
        "content": "#         elif key == emptySetName:\n#             finalNewRangesDict.update({'empty':newRangesDict[key]})\n#         else:\n#             finalNewRangesDict.update({key:newRangesDict[key]})\n#     return finalNewRangesDict\n# def mergedRangesToSequential(renderDict):\n#     renderList = []\n#     for renderCommandString in renderDict.keys():\n#         commandTimeSpans = renderDict[renderCommandString].copy()\n#         # commandTimeSpan.sort(key=lambda x: x[0])\n#         for commandTimeSpan in commandTimeSpans:\n#             mStart, mEnd = commandTimeSpan\n#             if mStart < mEnd:\n#                 renderList.append([renderCommandString, commandTimeSpan].copy())\n#     renderList.sort(key=lambda x: x[1][0])\n#     return renderList\n#     # for renderCommandString, commandTimeSpan in renderList:\n#     #     print(renderCommandString, commandTimeSpan)\n#     # so this is arranged as such:\n#     # [(renderCommandString, commandTimeSpan), ...]\n# def sequentialToMergedRanges(sequence):\n#     mergedRanges = {}\n#     for commandString, commandTimeSpan in sequence:",
        "type": "code",
        "location": "/pyjom/mathlib.py:220-244"
    },
    "145": {
        "file_id": 11,
        "content": "This code seems to handle the merging and sorting of ranges for a set of commands based on their start and end times. It appears that `mergedRangesToSequential` takes a dictionary of command strings and time spans, sorts the command time spans by start time, and then creates a new list with each command and its sorted time span. The code also includes functions for updating a dictionary based on specific conditions and converting a sorted sequence back into merged ranges.",
        "type": "comment"
    },
    "146": {
        "file_id": 11,
        "content": "#         mergedRanges.update({commandString: mergedRanges.get(commandString,[])+[commandTimeSpan]})\n#     mergedRanges = getContinualMappedNonSympyMergeResult(mergedRanges)\n#     return mergedRanges\n# import bezier\n# def bezierCurve(start=(0, 0), end=(1, 1), skew=0):\n#     # skew: (-0.5,0.5) otherwise this shit will look ugly.\n#     assert skew >= -0.5\n#     assert skew <= 0.5\n#     x_start, y_start = start\n#     x_end, y_end = end\n#     x_diff = x_end - x_start\n#     y_diff = y_end - y_start\n#     nodes1 = np.asfortranarray(\n#         [\n#             [x_start, x_diff * (0.5 + skew), x_end],\n#             [y_start, y_diff * (0.5 - skew), y_end],\n#         ]\n#     )\n#     curve1 = bezier.Curve(nodes1, degree=2)\n#     curve_params = {\"x_start\": x_start, \"x_diff\": x_diff, \"x_end\": x_end}\n#     return curve1, curve_params\n# def evaluateBezierCurve(input_value: float, curve, curve_params: dict):\n#     x_start = curve_params[\"x_start\"]\n#     x_end = curve_params[\"x_end\"]\n#     assert x_start <= input_value\n#     assert x_end >= input_value",
        "type": "code",
        "location": "/pyjom/mathlib.py:245-274"
    },
    "147": {
        "file_id": 11,
        "content": "This code defines a function `bezierCurve` that takes three arguments: start, end, and skew. It then uses the given values to create a Bezier curve by defining nodes based on the input parameters and returns the created curve along with a dictionary of curve parameters. The separate function `evaluateBezierCurve` is defined to evaluate a previously created Bezier curve at a specific input value, taking as arguments the input value, the created curve, and the dictionary of curve parameters. The function checks if the input value falls within the start and end points of the curve before returning the evaluated x-coordinate.",
        "type": "comment"
    },
    "148": {
        "file_id": 11,
        "content": "#     x_diff = curve_params[\"x_diff\"]\n#     s = (input_value - x_start) / x_diff\n#     points = curve.evaluate(s)\n#     # we only get the single point.\n#     point = points.T[0]\n#     x, y = point\n#     result = y\n#     return result\n# def multiParameterExponentialNetwork(\n#     *args,\n#     input_bias=0.05,\n#     curve_function=bezierCurve,\n#     curve_function_kwargs={\"start\": (0, 0), \"end\": (1, 1), \"skew\": 0},\n#     evaluate_function=evaluateBezierCurve\n# ):\n#     curve, curve_params = curve_function(**curve_function_kwargs)\n#     value = evaluate_function(input_bias, curve, curve_params)\n#     for index, input_value in enumerate(args):\n#         apply_list = [input_value] * (index + 1)\n#         for apply_item in apply_list:\n#             value += (1 - value) * evaluate_function(apply_item, curve, curve_params)\n#     return value\n# def getCursorOfMaxAverageInWindow(referenceData, windowSize, dataDuration, superSampleRate=8):\n#     assert windowSize<dataDuration\n#     # we supersample this reference data?\n#     fp = referenceData",
        "type": "code",
        "location": "/pyjom/mathlib.py:275-303"
    },
    "149": {
        "file_id": 11,
        "content": "The code defines a function `multiParameterExponentialNetwork` that takes multiple inputs and applies an exponential network function to each of them. The result is the average value after applying the function to all inputs. Another function, `getCursorOfMaxAverageInWindow`, calculates the cursor of maximum average in a given window size for a dataset, asserting that the window size is less than the data duration.",
        "type": "comment"
    },
    "150": {
        "file_id": 11,
        "content": "#     xp = np.linspace(0,dataDuration, len(fp))\n#     interpolated_xp = np.linspace(0, dataDuration, len(fp)*superSampleRate)\n#     fp = np.array(fp)\n#     interpolated_fp = []\n#     for x in interpolated_xp:\n#         interpolated_value = np.interp(x, xp, fp)\n#         interpolated_fp.append(interpolated_value)\n#     interpolated_fp = np.array(interpolated_fp)\n#     moving_sum_span = 0\n#     for index, value in enumerate(interpolated_xp):\n#         if value - windowSize >=0: break\n#         moving_sum_span = index\n#     moving_sum_span +=1\n#     moving_sum = np.convolve(interpolated_fp, np.ones(moving_sum_span),'valid')\n#     max_index = np.argmax(moving_sum)\n#     cursor = interpolated_fp[max_index]\n#     cursor = min(dataDuration-windowSize,cursor)\n#     return cursor",
        "type": "code",
        "location": "/pyjom/mathlib.py:304-322"
    },
    "151": {
        "file_id": 11,
        "content": "This code interpolates data, applies a moving average window, and returns the cursor value at the peak of the smoothed signal.",
        "type": "comment"
    },
    "152": {
        "file_id": 12,
        "content": "/pyjom/lyrictoolbox.py",
        "type": "filepath"
    },
    "153": {
        "file_id": 12,
        "content": "The code imports modules, uses APIs for censoring and translation, applies effects, renders customizable lyrics, formats ASS files, handles errors, and provides previewing and conversion functions using lyrictools and pylrc libraries.",
        "type": "summary"
    },
    "154": {
        "file_id": 12,
        "content": "import pylrc\nfrom MediaInfo import MediaInfo\nfrom pyonfx import *\nfrom typing import Literal\n# wildcard not allowed in function\nfrom pyjom.commons import redisLRUCache\n# change the lyric font and font size for hanzi and romaji\nimport os\nos.environ[\"http_proxy\"] = \"\"\nos.environ[\"https_proxy\"] = \"\"\nimport string\nimport zhon.hanzi\nenglishPuncturals = string.punctuation\nchinesePuncturals = zhon.hanzi.punctuation\ndef removeChinesePunctuation(text):\n    for elem in chinesePuncturals:\n        text = text.replace(elem, \"\")\n    return text\ndef removeLeadingAndTrailingPunctuation(text):\n    for elem in englishPuncturals + chinesePuncturals:\n        if text.startswith(elem):\n            text = text[1:]\n        if text.endswith(elem):\n            if elem == \".\":\n                continue\n            text = text[:-1]\n    return text\ndef removeUnnecessaryPunctuation(text):\n    text = removeChinesePunctuation(text)\n    text = removeLeadingAndTrailingPunctuation(text)\n    return text\ndef getMusicDuration(musicPath):\n    info = MediaInfo(filename=musicPath)  # the music path is not right.",
        "type": "code",
        "location": "/pyjom/lyrictoolbox.py:1-47"
    },
    "155": {
        "file_id": 12,
        "content": "The code imports various modules, sets proxy environment variables, and defines functions for removing Chinese punctuation, leading/trailing punctuation, and unnecessary punctuation. The \"getMusicDuration\" function uses MediaInfo to get the duration of a music file at a given path.",
        "type": "comment"
    },
    "156": {
        "file_id": 12,
        "content": "    info = info.getInfo()\n    # print(info)\n    # breakpoint()\n    length = info[\"duration\"]\n    length = float(length)\n    return length\ndef lrcToTextArray(musicPath, lrcPath):\n    assert lrcPath.endswith(\".lrc\")\n    musicDuration = getMusicDuration(musicPath)\n    with open(lrcPath) as lrc_file:\n        lrc_string = \"\".join(lrc_file.readlines())\n    # lrc_file.close()\n    subs = pylrc.parse(lrc_string)\n    lyricDurationThresholds = (0.3, 4)\n    textArray = []\n    for sub in subs:\n        startTime = sub.time\n        text = sub.text\n        textArray.append((startTime, text))\n    textArray.sort(key=lambda x: x[0])\n    lastStartTime = textArray[0][0]\n    newTextArray = [{\"start\": textArray[0][0], \"text\": textArray[0][1]}]\n    for startTime, text in textArray[1:]:\n        if startTime - lastStartTime < lyricDurationThresholds[0]:\n            continue\n        else:\n            lastStartTime = startTime\n            newTextArray.append({\"text\": text, \"start\": startTime})\n    # now calculate the end time, please?\n    # you may want to translate this if you have to.",
        "type": "code",
        "location": "/pyjom/lyrictoolbox.py:48-88"
    },
    "157": {
        "file_id": 12,
        "content": "This function reads an LRC file and extracts lyrics into a text array. It calculates music duration, parses the LRC string using pylrc library, defines lyric duration thresholds, and creates a sorted list of time-stamped lyrics. If consecutive lyrics are too close together, it combines them into one entry. The function could benefit from calculating the end times of each lyric segment.",
        "type": "comment"
    },
    "158": {
        "file_id": 12,
        "content": "    # when it does not contains anything in chinese.\n    # using deepl?\n    # put that aside please? focus on this shit...\n    import numpy as np\n    lyricDurations = [np.mean(lyricDurationThresholds)]\n    for index, elem in enumerate(newTextArray):\n        text = elem[\"text\"]\n        start = elem[\"start\"]\n        nextIndex = index + 1\n        if nextIndex < len(newTextArray):\n            nextElem = newTextArray[nextIndex]\n            nextStart = nextElem[\"start\"]\n            end = nextStart - start\n            if end > lyricDurationThresholds[0] and end < lyricDurationThresholds[1]:\n                lyricDurations.append(end)\n            end = min(end, lyricDurationThresholds[1], musicDuration - start) + start\n        else:\n            end = np.mean(lyricDurations) + start\n            end = min(musicDuration, end)\n        newTextArray[index].update({\"end\": end})\n    return newTextArray\n    # [{'text':text,'start':start,'end':end}, ...]\ndef lastSpaceSpliter(text):\n    text = text.strip()\n    # index = 0\n    for index in range(len(text) - 1, -1, -1):",
        "type": "code",
        "location": "/pyjom/lyrictoolbox.py:89-119"
    },
    "159": {
        "file_id": 12,
        "content": "This function iterates through an array of lyrics and calculates the duration of each lyric. If a lyric's duration falls within a specified range, its end time is updated accordingly. The function then returns the modified array with each element containing 'text', 'start', and 'end' information.",
        "type": "comment"
    },
    "160": {
        "file_id": 12,
        "content": "        # print(index)\n        elem = text[index]\n        if elem == \" \":\n            print(\"LAST SPACE FOUND AT %d\", index)\n            # do it right now, and return the value here.\n            mTuple = (text[0:index].strip(), text[index:].strip())\n            return mTuple, True\n    return text, False  # not a list.\n# if there is a single shit failed to pass this 'lastSpaceSpliter' test, this is not a bilingual lrc file from netease.\ndef getJiebaCuttedText(text):\n    import jieba\n    textList = jieba.lcut(text)\n    textList = [elem.strip() for elem in textList]\n    textList = [elem for elem in textList if len(elem) > 0]\n    return textList\n# from loadLingua_pyjnius import pyjniusLinguaDetectLanguageLabel\n# from loadLingua_jpype import getLinguaDetectedLanguageLabel as pyjniusLinguaDetectLanguageLabel\ndef pyjniusLinguaDetectLanguageLabel(text):\n    import requests\n    url = \"http://localhost:{}/langid\".format(8978)\n    with requests.get(url, params={\"text\": text}) as r:\n        response = r.json()\n        if response[\"code\"] == 200:",
        "type": "code",
        "location": "/pyjom/lyrictoolbox.py:120-150"
    },
    "161": {
        "file_id": 12,
        "content": "Function getJiebaCuttedText takes a text input and returns a list of words after cutting the text using jieba. The list contains only non-empty words with length greater than 0. This function is used to split the input text into individual words for further analysis.\n\nThe code snippet checks if a space character is found in the input text. If a space is found, it prints the index of the last space and returns a tuple containing the substrings before and after the last space, along with a boolean indicating that the input text is a lyric. If no space is found, it returns the original text and sets the boolean to False.\n\nThe function pyjniusLinguaDetectLanguageLabel sends a GET request to a local server (http://localhost:8978) with the input text as a parameter. It expects the server to return a JSON response containing language detection information. If the code of the response is 200, it implies a successful detection and the function returns the detected language label.",
        "type": "comment"
    },
    "162": {
        "file_id": 12,
        "content": "            return response[\"result\"]\n        else:\n            print(\"ERROR WHEN FETCHING LANGUAGE ID\")\n            print(response)\n            breakpoint()\nnativeLangFlagStandard = \"CHINESE\"\n# need to make this thing totally bilingual if we have to.\n# for test in tests:\ndef getLyricsLanguageType(test):\n    isBilingual = False\n    needToTranslate = True  # not useful for our bilingual shit.\n    print(\"_______________TEST SUBJECT_______________\")\n    for elem in test:\n        print(elem)\n    print(\"_______________TEST SUBJECT_______________\")\n    flags = [int(flag) for _, flag in [lastSpaceSpliter(elem) for elem in test]]\n    print(flags)\n    if sum(flags) < len(flags) * 0.8:\n        print(\"NOT A BILIGUAL LYRICS FILE\")\n    else:\n        # having the potential of being a bilingual shit.\n        # process this shit separately.\n        # double check if this is really bilingual.\n        foreignLangList = []\n        nativeLangList = []\n        for elem in test:\n            text, flag = lastSpaceSpliter(elem)\n            if flag:",
        "type": "code",
        "location": "/pyjom/lyrictoolbox.py:151-182"
    },
    "163": {
        "file_id": 12,
        "content": "This code seems to check if a given text is bilingual or not. It does this by iterating through the test data, splitting each element into text and flag. If the sum of flags in the test is less than 80% of the total number of elements, it concludes that the lyrics are not bilingual. Otherwise, it processes the data separately to determine if it is truly bilingual.",
        "type": "comment"
    },
    "164": {
        "file_id": 12,
        "content": "                # this line might be bilingual.\n                foreignLang, nativeLang = text\n                foreignLangList.append(foreignLang)\n                nativeLangList.append(nativeLang)\n        foreignLangString = \" \".join(foreignLangList)\n        nativeLangString = \" \".join(nativeLangList)\n        # import whatlang\n        # nativeLangFlagStandard = \"Cmn\"\n        # foreignLangFlag = whatlang.detect_language(foreignLangString)\n        # nativeLangFlag = whatlang.detect_language(nativeLangString)\n        # import cld3\n        # nativeLangFlagStandard = \"zh\"\n        # foreignLangFlag = cld3.get_language(foreignLangString)\n        # nativeLangFlag = cld3.get_language(nativeLangString)\n        # from textblob import TextBlob\n        # nativeLangFlagStandard = \"zh\"\n        # foreignLangFlag = TextBlob(foreignLangString).detect_language()\n        # nativeLangFlag = TextBlob(nativeLangString).detect_language()\n        # import langid\n        # nativeLangFlagStandard = \"zh\"\n        # foreignLangFlag = langid.classify(foreignLangString)",
        "type": "code",
        "location": "/pyjom/lyrictoolbox.py:183-207"
    },
    "165": {
        "file_id": 12,
        "content": "This code snippet is likely trying to determine the language of a given text. It attempts this by using different libraries such as whatlang, cld3, TextBlob and langid. The nativeLangFlagStandard is set to \"Cmn\" or \"zh\" for comparison with the detected languages from these libraries.",
        "type": "comment"
    },
    "166": {
        "file_id": 12,
        "content": "        # nativeLangFlag = langid.classify(nativeLangString)\n        foreignLangFlag = (pyjniusLinguaDetectLanguageLabel(foreignLangString), 1)\n        nativeLangFlag = (pyjniusLinguaDetectLanguageLabel(nativeLangString), 1)\n        # there's no probability out there! WTF?\n        print(foreignLangFlag)\n        print(nativeLangFlag)\n        # breakpoint()\n        if (\n            foreignLangFlag[0] != nativeLangFlagStandard\n            and nativeLangFlag[0] == nativeLangFlagStandard\n        ):\n            # this is for sure the bilingual shit.\n            isBilingual = True\n            print(\"BILINGUAL LYRIC FILE IDENTIFIED.\")\n            # then? how shall we judge this?\n            # let the jieba.lcut to handle the cutting. please?\n            # remove all blanks in the list.\n        else:\n            print(\"NOT A BILIGUAL LYRICS FILE\")\n    # what you are going to do with this shit?\n    if not isBilingual:\n        print(\"checking main language\")\n        lyricString = \" \".join(test)\n        mainLanguage = pyjniusLinguaDetectLanguageLabel(lyricString)",
        "type": "code",
        "location": "/pyjom/lyrictoolbox.py:208-233"
    },
    "167": {
        "file_id": 12,
        "content": "The code uses the pyjniusLinguaDetectLanguageLabel function to classify the foreign and native language strings of a lyric file. If the foreign language does not match the native language standard, it assumes the file is bilingual. It then prints whether it is a bilingual or non-bilingual lyrics file. If non-bilingual, it checks the main language using the same function.",
        "type": "comment"
    },
    "168": {
        "file_id": 12,
        "content": "        print(\"main language id:\", mainLanguage)\n        if mainLanguage == nativeLangFlagStandard:\n            print(\"no need to translate\")\n            needToTranslate = False\n        else:\n            print(\"need to translate\")\n    return isBilingual, needToTranslate\ndef translate(text: str, backend=\"baidu\"):  # deepl is shit. fucking shit.\n    # import time\n    # time.sleep(delay)\n    import requests\n    url = \"http://localhost:8974/translate\"\n    mTranslate = lambda text, backend, timeout: requests.get(\n        url, params={\"backend\": backend, \"text\": text}, timeout=timeout\n    )\n    backendList = [\"deepl\", \"baidu\"]\n    if backend == \"random\":\n        import random\n        backend = random.choice(backendList)\n    assert backend in backendList\n    translatedText = text\n    if text.strip() == \"\":\n        return text\n    try:\n        with mTranslate(text, backend, timeout=10) as conn:\n            result = conn.json()\n            print(\"TRANSLATOR RESULT:\", result)\n            if result[\"code\"] == 200:\n                translatedText = result[\"result\"]",
        "type": "code",
        "location": "/pyjom/lyrictoolbox.py:234-266"
    },
    "169": {
        "file_id": 12,
        "content": "The code defines a function `translate` which takes a text and an optional backend parameter. It checks if the text is empty, returns it as is if so. If not, it sends a GET request to a local server for translation using the specified backend (default is 'baidu'). It also has an option to use a random backend from the available options. The function returns the translated text if the translation is successful (status code 200), or the original text otherwise.",
        "type": "comment"
    },
    "170": {
        "file_id": 12,
        "content": "            else:\n                print(\"SOME ERROR DURING TRANSLATION, PLEASE CHECK SERVER\")\n            # it just never return.\n    except:\n        import traceback\n        traceback.print_exc()\n    return translatedText\n    # we know the translator cannot respond the same shit to us right?\ndef waitForServerUp(port, message, timeout=1):\n    import requests\n    while True:\n        try:\n            url = \"http://localhost:{}\".format(port)\n            with requests.get(url, timeout=timeout, proxies=None) as r:\n                if type(message) == str:\n                    text = r.text.strip('\"').strip(\"'\")\n                else:\n                    text = r.json()\n                print(\"SERVER AT PORT %d RESPONDS:\" % port, [text])\n                assert text == message\n                print(\"SERVER AT PORT %d IS UP\" % port)\n                break\n        except:\n            import traceback\n            traceback.print_exc()\n            print(\"SERVER AT PORT %d MIGHT NOT BE UP\" % port)\n            print(\"EXPECTED MESSAGE:\", [message])",
        "type": "code",
        "location": "/pyjom/lyrictoolbox.py:267-298"
    },
    "171": {
        "file_id": 12,
        "content": "This function checks if a server is up and running by continuously sending requests to it on a specified port. If the server responds correctly, it returns success. Otherwise, it prints an error message and continues waiting until the timeout is reached or the server becomes active.",
        "type": "comment"
    },
    "172": {
        "file_id": 12,
        "content": "            import time\n            time.sleep(1)\nwaitForServerUp(8974, \"unified translator hooked on some clash server\")\nwaitForServerUp(8978, \"say hello to jpype fastapi server\")\nwaitForServerUp(8677, \"clash update controller\", timeout=10)  # probe the clash updator\nwaitForServerUp(\n    8932, {\"response\": \"DFAFilter based Chinese text filter(censor)\"}\n)  # this is text filter.\ndef censorTextWithTextFilter(text):\n    port = 8932\n    import requests\n    url = \"http://localhost:{}/filter\".format(port)\n    with requests.get(url, params={\"text\": text}) as r:\n        data = r.json()\n        return data[\"response\"]\n@redisLRUCache()\ndef getTextListTranslated(test, translate_method=\"baidu\"):\n    newLyricArray = []\n    import progressbar\n    isBilingual, needToTranslate = getLyricsLanguageType(test)\n    if isBilingual:\n        for elem in progressbar.progressbar(test):\n            text, flag = lastSpaceSpliter(elem)\n            if flag:  # splited!\n                foreignText, nativeText = text\n            else:\n                foreignText = text",
        "type": "code",
        "location": "/pyjom/lyrictoolbox.py:299-334"
    },
    "173": {
        "file_id": 12,
        "content": "The code imports necessary modules, sets up servers, and defines functions for censoring text with a text filter, translating lyrics, and handles bilingual lyrics. It uses a progress bar and calls external APIs for translation and censoring. The code waits for specific server ports to be active before proceeding.",
        "type": "comment"
    },
    "174": {
        "file_id": 12,
        "content": "                nativeText = translate(foreignText, backend=translate_method)\n            if foreignText != nativeText:\n                newLyricArray.append((foreignText, nativeText))\n            else:\n                newLyricArray.append((foreignText,))\n    else:\n        if needToTranslate:\n            for elem in progressbar.progressbar(test):\n                foreignText = elem\n                nativeText = translate(foreignText, backend=translate_method)\n                if not nativeText == foreignText:\n                    newLyricArray.append((foreignText, nativeText))\n                else:\n                    newLyricArray.append((foreignText,))\n        else:\n            newLyricArray = [(elem,) for elem in test.copy()]\n    return newLyricArray\ndef textArrayWithTranslatedListToAss(\n    textArray,\n    translatedList,\n    assPath,\n    shiftAdjust=600,\n    censor=True,\n    puncturalRemoval=True,\n    template_path=\"/root/Desktop/works/pyjom/tests/karaoke_effects/in2.ass.j2\",  # but the style. you know.\n    # aegisub use system fonts. you pass font name into it.",
        "type": "code",
        "location": "/pyjom/lyrictoolbox.py:335-362"
    },
    "175": {
        "file_id": 12,
        "content": "The code is a function that takes an array of text and translates it using the specified backend method. If there's a translation difference, it adds the original and translated text to the newLyricArray. If not, it just adds the original text. If no needToTranslate, it creates newLyricArray with elements from test. The function returns the newLyricArray after processing.",
        "type": "comment"
    },
    "176": {
        "file_id": 12,
        "content": "    ass_template_configs={},\n    assStyleConfig={},\n    tempdir=\"/dev/shm/medialang/lyrictoolbox\"\n    # editly does not support to put the .ass subtitle directly.\n):\n    defaultStyleConfig = {\n        \"original\": {\n            \"method\": \"romaji\",\n            \"style\": \"Romaji\",\n            \"cutOneByOne\": False,\n            \"charShift\": 35,\n        },  # this is default. you can change this.\n        \"translated\": {\n            \"method\": \"kanji\",\n            \"style\": \"Kanji\",\n            \"cutOneByOne\": True,\n            \"charShift\": 25,  # smaller?\n        },\n    }\n    # newTextArray = [] # dummy shit. must be removed immediately.\n    styleConfig = defaultStyleConfig.copy()\n    for key in styleConfig.keys():\n        styleConfig[key].update(assStyleConfig.get(key, {}))\n    import random\n    import math\n    import jinja2\n    from lazero.filesystem.io import readFile\n    default_template_configs = {\n        \"defaultFontname\": \"Arial\",\n        \"defaultFontsize\": 48,  # integer?\n        \"translationFontname\": \"Migu 1P\",\n        \"translationFontsize\": 48,",
        "type": "code",
        "location": "/pyjom/lyrictoolbox.py:363-395"
    },
    "177": {
        "file_id": 12,
        "content": "This code is initializing default and style configurations for subtitles, handling both original and translated languages. It uses a copy of the defaultStyleConfig, merges it with assStyleConfig, and assigns the result to styleConfig. The code imports necessary libraries and defines default_template_configs for font names and sizes.",
        "type": "comment"
    },
    "178": {
        "file_id": 12,
        "content": "        \"kanjiFontname\": \"Migu 1P\",\n        \"kanjiFontsize\": 60,  # 46,  # increase. make 'kanji' one char at a time.\n        \"romajiFontname\": \"Migu 1P\",\n        \"romajiFontsize\": 60,  # 38,  # increase to 60. expand the space!\n    }\n    mTemplateConfigs = default_template_configs.copy()\n    mTemplateConfigs.update(ass_template_configs)\n    template = jinja2.Template(source=readFile(template_path))\n    template_configured = template.render(**mTemplateConfigs)\n    from lazero.filesystem.temp import (\n        tmpfile,\n        getRandomFileNameUnderDirectoryWithExtension,\n    )\n    from lazero.filesystem.io import writeFile\n    template_configured_savedPath = getRandomFileNameUnderDirectoryWithExtension(\n        \"ass\", tempdir, check=False\n    )\n    with tmpfile(template_configured_savedPath):\n        writeFile(template_configured_savedPath, template_configured)\n        io = Ass(template_configured_savedPath, path_output=assPath)\n    meta, styles, lines = io.get_data()\n    # Creating the star and extracting all the color changes from the input file",
        "type": "code",
        "location": "/pyjom/lyrictoolbox.py:396-420"
    },
    "179": {
        "file_id": 12,
        "content": "The code sets default template configuration, updates it with additional ass-specific configurations. It then renders the updated template and saves it to a temporary file path. Finally, it reads the rendered template from the temporary file and initializes an Ass object using the path to the saved template. The data (meta, styles, lines) is extracted from this object.",
        "type": "comment"
    },
    "180": {
        "file_id": 12,
        "content": "    star = Shape.star(5, 4, 10)\n    CU = ColorUtility(lines)\n    # test this elsewhere. please?\n    def romaji(line, l):\n        # Setting up a delay, we will use it as duration time of the leadin and leadout effects\n        delay = 100\n        # Setting up offset variables, we will use them for the \\move in leadin and leadout effects\n        off_x = 35\n        off_y = 15\n        # Leadin Effect\n        mDelay = 0\n        # lastStartTime = line.start_time\n        for syl in Utils.all_non_empty(line.syls):\n            l.layer = 0\n            # l.start_time = syl.end_time\n            l.start_time = line.start_time\n            # l.start_time = (\n            #     line.start_time + 25 * syl.i - delay - 80\n            # )  # Remove 80 to start_time to let leadin finish a little bit earlier than the main effect of the first syllable\n            # l.end_time = lastStartTime # wtf?\n            # lastStartTime = syl.start_time\n            l.end_time = syl.start_time\n            # l.end_time = line.start_time + syl.start_time # wtf?",
        "type": "code",
        "location": "/pyjom/lyrictoolbox.py:421-447"
    },
    "181": {
        "file_id": 12,
        "content": "This code defines a function `romaji` that takes in a line of lyrics and its associated data, and applies leadin and leadout effects to the syllables within the line. It sets up delay and offset variables for timing and positioning the effect, and iterates through each syllable in the line to apply the effects accordingly.",
        "type": "comment"
    },
    "182": {
        "file_id": 12,
        "content": "            l.dur = l.end_time - l.start_time\n            if l.dur <= 0:\n                continue\n            l.text = (\n                \"{\\\\an5\\\\move(%.3f,%.3f,%.3f,%.3f,0,%d)\\\\blur2\\\\t(0,%d,\\\\blur0)\\\\fad(%d,0)}%s\"\n                % (\n                    syl.center + math.cos(syl.i / 2) * off_x,\n                    syl.middle + math.sin(syl.i / 4) * off_y,\n                    syl.center,\n                    syl.middle,\n                    delay,\n                    delay,\n                    delay,\n                    syl.text,\n                )\n            )\n            io.write_line(l)\n        # Main Effect\n        for syl in Utils.all_non_empty(line.syls):\n            l.layer = 1\n            l.start_time = syl.start_time\n            # l.start_time = line.start_time + syl.start_time\n            l.end_time = syl.end_time + 100\n            l.dur = l.end_time - l.start_time\n            c1 = \"&H81F4FF&\"\n            c3 = \"&H199AAA&\"\n            # Change color if inline_fx is m1\n            if syl.inline_fx == \"m1\":",
        "type": "code",
        "location": "/pyjom/lyrictoolbox.py:448-480"
    },
    "183": {
        "file_id": 12,
        "content": "This code is setting up lyrics animation for a specific line in a song. It calculates the duration and position of each syllable, applies animations based on their timing, and writes the effect data to be processed by the renderer. The inline_fx parameter determines the color change if the syllable has the \"m1\" effect applied.",
        "type": "comment"
    },
    "184": {
        "file_id": 12,
        "content": "                c1 = \"&H8282FF&\"\n                c3 = \"&H191AAA&\"\n            on_inline_effect_2 = \"\"\n            # Apply rotation if inline_fx is m2\n            if syl.inline_fx == \"m2\":\n                on_inline_effect_2 = \"\\\\t(0,%d,\\\\frz%.3f)\\\\t(%d,%d,\\\\frz0)\" % (\n                    l.dur / 4,\n                    random.uniform(-40, 40),\n                    l.dur / 4,\n                    l.dur,\n                )\n            l.text = (\n                \"{\\\\an5\\\\pos(%.3f,%.3f)%s\\\\t(0,80,\\\\fscx105\\\\fscy105\\\\1c%s\\\\3c%s)\\\\t(80,%d,\\\\fscx100\\\\fscy100\\\\1c%s\\\\3c%s)}%s\"\n                % (\n                    syl.center,\n                    syl.middle,\n                    on_inline_effect_2,\n                    c1,\n                    c3,\n                    l.dur - 80,\n                    line.styleref.color1,\n                    line.styleref.color3,\n                    syl.text,\n                )\n            )\n            io.write_line(l)\n            # Animating star shape that jumps over the syllables\n            # Jump-in to the first syl",
        "type": "code",
        "location": "/pyjom/lyrictoolbox.py:481-512"
    },
    "185": {
        "file_id": 12,
        "content": "This code applies a rotation effect to inline_fx \"m2\", sets the on_inline_effect_2 variable, and constructs a formatted string for text with animation and color properties. It writes this line to an io file while also creating a jumping star shape animation for syllables.",
        "type": "comment"
    },
    "186": {
        "file_id": 12,
        "content": "            jump_height = 18\n            if syl.i == 0:\n                FU = FrameUtility(line.start_time - line.leadin / 2, line.start_time)\n                for s, e, i, n in FU:\n                    l.start_time = s\n                    l.end_time = e\n                    frame_pct = i / n\n                    x = syl.center - syl.width * (1 - frame_pct)\n                    y = syl.top - math.sin(frame_pct * math.pi) * jump_height\n                    alpha = 255\n                    alpha += FU.add(0, syl.duration, -255)\n                    alpha = Convert.alpha_dec_to_ass(int(alpha))\n                    l.text = (\n                        \"{\\\\alpha%s\\\\pos(%.3f,%.3f)\\\\bord1\\\\blur1\\\\1c%s\\\\3c%s\\\\p1}%s\"\n                        % (alpha, x, y, c1, c3, star)\n                    )\n                    io.write_line(l)\n            # Jump to the next syl or to the end of line\n            jump_width = (\n                line.syls[syl.i + 1].center - syl.center\n                if syl.i != len(line.syls) - 1\n                else syl.width",
        "type": "code",
        "location": "/pyjom/lyrictoolbox.py:513-538"
    },
    "187": {
        "file_id": 12,
        "content": "This code calculates the positions and alpha values for text overlays on each syllable in a line, using FrameUtility to determine the timing. It applies a sinusoidal function to adjust y-coordinates based on frame percentage, and handles alpha values by adding them over time from FU. It also checks if it's the first syllable of the line to initialize FrameUtility correctly.",
        "type": "comment"
    },
    "188": {
        "file_id": 12,
        "content": "            )\n            # FU = FrameUtility(\n            #     line.start_time + syl.start_time, line.start_time + syl.end_time\n            # )\n            FU = FrameUtility(syl.start_time, syl.end_time)\n            for s, e, i, n in FU:\n                l.start_time = s\n                l.end_time = e\n                frame_pct = i / n\n                x = syl.center + frame_pct * jump_width\n                y = syl.top - math.sin(frame_pct * math.pi) * jump_height\n                alpha = 0\n                # Last jump should fade-out\n                if syl.i == len(line.syls) - 1:\n                    alpha += FU.add(0, syl.duration, 255)\n                alpha = Convert.alpha_dec_to_ass(int(alpha))\n                l.text = (\n                    \"{\\\\alpha%s\\\\pos(%.3f,%.3f)\\\\bord1\\\\blur1\\\\1c%s\\\\3c%s\\\\p1}%s\"\n                    % (\n                        alpha,\n                        x,\n                        y,\n                        c1,\n                        c3,\n                        star,\n                    )",
        "type": "code",
        "location": "/pyjom/lyrictoolbox.py:539-567"
    },
    "189": {
        "file_id": 12,
        "content": "This code generates lyric information for each syllable in a line, including start and end times, position on screen, and alpha transparency. It also handles the last jump with a fade-out effect. The code uses FrameUtility to calculate frame percentage, adjusts y-coordinate based on frame percentage using sine function, and applies specific colors for text.",
        "type": "comment"
    },
    "190": {
        "file_id": 12,
        "content": "                )\n                io.write_line(l)\n        # Leadout Effect\n        for syl in Utils.all_non_empty(line.syls):\n            l.layer = 0\n            l.start_time = syl.end_time\n            # l.start_time = line.start_time + syl.end_time + 100\n            l.end_time = line.end_time\n            # l.end_time = line.end_time - 25 * (len(line.syls) - syl.i) + delay + 100\n            # l.end_time = line.end_time - 25 * (len(line.syls) - syl.i) + delay + 100\n            l.dur = l.end_time - l.start_time\n            if l.dur <= 0:\n                continue\n            l.text = (\n                \"{\\\\an5\\\\move(%.3f,%.3f,%.3f,%.3f,%d,%d)\\\\t(%d,%d,\\\\blur2)\\\\fad(0,%d)}%s\"\n                % (\n                    syl.center,\n                    syl.middle,\n                    syl.center + math.cos(syl.i / 2) * off_x,\n                    syl.middle + math.sin(syl.i / 4) * off_y,\n                    l.dur - delay,\n                    l.dur,\n                    l.dur - delay,\n                    l.dur,\n                    delay,",
        "type": "code",
        "location": "/pyjom/lyrictoolbox.py:568-595"
    },
    "191": {
        "file_id": 12,
        "content": "This code adjusts the start and end times of each lyric line to create a leadout effect, where subsequent lines fade in after the previous ones have finished. It iterates over each syllable in a line, sets their duration based on the line's start and end times, and applies animation properties for the lyric display.",
        "type": "comment"
    },
    "192": {
        "file_id": 12,
        "content": "                    syl.text,\n                )\n            )\n            io.write_line(l)\n    def kanji(line, l):\n        # Setting up a delay, we will use it as duration time of the leadin and leadout effects\n        delay = 300\n        # Setting up offset variables, we will use them for the \\move in leadin and leadout effects\n        off_x = 35\n        off_y = 15\n        # Leadin Effect\n        for syl in Utils.all_non_empty(line.syls):\n            l.layer = 0\n            l.start_time = line.start_time\n            # l.start_time = (\n            #     line.start_time + 25 * syl.i - delay - 80\n            # )  # Remove 80 to start_time to let leadin finish a little bit earlier than the main effect of the first syllable\n            l.end_time = syl.start_time\n            # l.end_time = line.start_time + syl.start_time\n            l.dur = l.end_time - l.start_time\n            if l.dur <= 0:\n                continue\n            l.text = (\n                \"{\\\\an5\\\\move(%.3f,%.3f,%.3f,%.3f,0,%d)\\\\blur2\\\\t(0,%d,\\\\blur0)\\\\fad(%d,0)}%s\"",
        "type": "code",
        "location": "/pyjom/lyrictoolbox.py:596-624"
    },
    "193": {
        "file_id": 12,
        "content": "This code calculates the start and end times for a lead-in effect in a lyric animation, with adjustable delay, offsets, and duration. It iterates through syllables, setting the layer, start time, and end time accordingly while applying specific formatting to the text.",
        "type": "comment"
    },
    "194": {
        "file_id": 12,
        "content": "                % (\n                    syl.center + math.cos(syl.i / 2) * off_x,\n                    syl.middle + math.sin(syl.i / 4) * off_y,\n                    syl.center,\n                    syl.middle,\n                    delay,\n                    delay,\n                    delay,\n                    syl.text,\n                )\n            )\n            io.write_line(l)\n        # Main Effect\n        for syl in Utils.all_non_empty(line.syls):\n            l.layer = 1\n            l.start_time = syl.start_time\n            # l.start_time = line.start_time + syl.start_time\n            l.end_time = syl.end_time + 100\n            l.dur = l.end_time - l.start_time\n            c1 = \"&H81F4FF&\"\n            c3 = \"&H199AAA&\"\n            # Change color if effect field is m1\n            if line.effect == \"m1\":\n                c1 = \"&H8282FF&\"\n                c3 = \"&H191AAA&\"\n            on_inline_effect_2 = \"\"\n            # Apply rotation if effect field is m2\n            if line.effect == \"m2\":\n                on_inline_effect_2 = \"\\\\t(0,%d,\\\\frz%.3f)\\\\t(%d,%d,\\\\frz0)\" % (",
        "type": "code",
        "location": "/pyjom/lyrictoolbox.py:625-658"
    },
    "195": {
        "file_id": 12,
        "content": "This code seems to be responsible for generating lines of text with effects based on the input lyrics and effect fields. It calculates the position of each line using sine and cosine functions, sets the start and end times, adjusts colors depending on the effect field, and applies rotation if the effect is set to \"m2\". The code then writes these lines with their respective properties to a file.",
        "type": "comment"
    },
    "196": {
        "file_id": 12,
        "content": "                    l.dur / 4,\n                    random.uniform(-40, 40),\n                    l.dur / 4,\n                    l.dur,\n                )\n            l.text = (\n                \"{\\\\an5\\\\pos(%.3f,%.3f)%s\\\\t(0,80,\\\\fscx105\\\\fscy105\\\\1c%s\\\\3c%s)\\\\t(80,%d,\\\\fscx100\\\\fscy100\\\\1c%s\\\\3c%s)}%s\"\n                % (\n                    syl.center,\n                    syl.middle,\n                    on_inline_effect_2,\n                    c1,\n                    c3,\n                    l.dur - 80,\n                    line.styleref.color1,\n                    line.styleref.color3,\n                    syl.text,\n                )\n            )\n            io.write_line(l)\n        # Leadout Effect\n        for syl in Utils.all_non_empty(line.syls):\n            l.layer = 0\n            l.start_time = syl.end_time + 100\n            # l.start_time = line.start_time + syl.end_time + 100\n            l.end_time = line.end_time\n            # l.end_time = line.end_time - 25 * (len(line.syls) - syl.i) + delay + 100\n            l.dur = l.end_time - l.start_time",
        "type": "code",
        "location": "/pyjom/lyrictoolbox.py:659-690"
    },
    "197": {
        "file_id": 12,
        "content": "This code appears to handle the rendering of lyrics for a song, applying various effects and positioning them on the screen. It seems to involve manipulating line durations, layer positions, and colors based on different parameters such as syllable positions and timing. The \"Leadout Effect\" suggests that it may also handle transitions or overlays between lines of lyrics.",
        "type": "comment"
    },
    "198": {
        "file_id": 12,
        "content": "            if l.dur <= 0:\n                continue\n            l.text = (\n                \"{\\\\an5\\\\move(%.3f,%.3f,%.3f,%.3f,%d,%d)\\\\t(%d,%d,\\\\blur2)\\\\fad(0,%d)}%s\"\n                % (\n                    syl.center,\n                    syl.middle,\n                    syl.center + math.cos(syl.i / 2) * off_x,\n                    syl.middle + math.sin(syl.i / 4) * off_y,\n                    l.dur - delay,\n                    l.dur,\n                    l.dur - delay,\n                    l.dur,\n                    delay,\n                    syl.text,\n                )\n            )\n            io.write_line(l)\n    def sub(line, l):\n        # Translation Effect\n        l.layer = 0\n        l.start_time = line.start_time - line.leadin / 2\n        l.end_time = line.end_time + line.leadout / 2\n        l.dur = l.end_time - l.start_time\n        # Getting interpolated color changes (notice that we do that only after having set up all the times, that's important)\n        colors = CU.get_color_change(l)\n        # Base text\n        l.text = \"{\\\\an5\\\\pos(%.3f,%.3f)\\\\fad(%d,%d)}%s\" % (",
        "type": "code",
        "location": "/pyjom/lyrictoolbox.py:691-724"
    },
    "199": {
        "file_id": 12,
        "content": "The code calculates the duration and positioning of lyrics on a timeline based on syllable information. It then applies text formatting and color changes to create a visual effect. The function sub sets the layer, start time, end time, and duration for each line of lyrics, taking into account leadin and leadout times. It also retrieves interpolated color changes for the line using a utility function CU.get_color_change().",
        "type": "comment"
    }
}