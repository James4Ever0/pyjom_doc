{
    "100": {
        "file_id": 17,
        "content": "/externals/torchrec_init.sh",
        "type": "filepath"
    },
    "101": {
        "file_id": 17,
        "content": "This script clones torchrec, modifies setup.py, installs torchrec, and fixes paths for installation in third_party/fbgemm/fbgemm_gpu directory. It also exports CUB_DIR, CUDA_BIN_PATH, and CUDACXX environment variables before the final installation.",
        "type": "summary"
    },
    "102": {
        "file_id": 17,
        "content": "# git clone --depth 1 --recurse-submodules https://github.com/pytorch/torchrec\ncd torchrec\n# modify the freaking setup.py first. don't want no trouble.\n# python3 setup.py install\nexport CUB_DIR=/usr/include/cub\nexport CUDA_BIN_PATH=/usr/lib/nvidia-cuda-toolkit\nexport CUDACXX=/usr/bin/nvcc\ncp -R /usr/local/lib/python3.9/dist-packages/torch/include/* third_party/fbgemm/fbgemm_gpu/include # great shit.\npython3 setup.py install \n# the freaking fix.\n# cd third_party/fbgemm/fbgemm_gpu\n# cp -R /usr/local/lib/python3.9/dist-packages/torch/include/* ./include # great shit.\n# export CUB_DIR=/usr/include/cub\n# export CUDA_BIN_PATH=/usr/lib/nvidia-cuda-toolkit\n# export CUDACXX=/usr/bin/nvcc\n# python3 setup.py install ",
        "type": "code",
        "location": "/externals/torchrec_init.sh:1-17"
    },
    "103": {
        "file_id": 17,
        "content": "This script clones torchrec, modifies setup.py, installs torchrec, and fixes paths for installation in third_party/fbgemm/fbgemm_gpu directory. It also exports CUB_DIR, CUDA_BIN_PATH, and CUDACXX environment variables before the final installation.",
        "type": "comment"
    },
    "104": {
        "file_id": 18,
        "content": "/pyjom/README.md",
        "type": "filepath"
    },
    "105": {
        "file_id": 18,
        "content": "The code discusses the challenges of a censored internet and half-automated media project, requiring manual interfaces for data selection and labeling. It aims for future automation improvements and mentions data storage in /dev/shm.",
        "type": "summary"
    },
    "106": {
        "file_id": 18,
        "content": "due to heavy censored internet and the half-automated nature of media project, require interfaces to select and label data on the fly, when the project is somehow stablized.\nmanual labels can be therefore used later for better automation.\nsimple generation logic will be applied first, establishing basic feedback loop. then we may feature the details, enhancing product quality and so on.\nthis project may be the shadow of nature of life. no offense.\nsorting by priority is always crucial for all of us, all the time.\ndata stored in /dev/shm will be lost after reboot.\nafter months, if not years, you might blend in with this project.\nmany websites may match the structural complexity of yours.",
        "type": "code",
        "location": "/pyjom/README.md:1-15"
    },
    "107": {
        "file_id": 18,
        "content": "The code discusses the challenges of a censored internet and half-automated media project, requiring manual interfaces for data selection and labeling. It aims for future automation improvements and mentions data storage in /dev/shm.",
        "type": "comment"
    },
    "108": {
        "file_id": 19,
        "content": "/pyjom/audiotoolbox.py",
        "type": "filepath"
    },
    "109": {
        "file_id": 19,
        "content": "This code detects audio duration and volume using audioread library, adjusts media file volume with ffmpeg, normalizes audio, and handles errors.",
        "type": "summary"
    },
    "110": {
        "file_id": 19,
        "content": "# first and foremost is the audio correction, the volume detector, the audio detector.\n# https://trac.ffmpeg.org/wiki/AudioVolume\n# but first how to get the audio duration?\n# for video we have caer. but for audio?\nimport audioread\nfrom lazero.utils.logger import sprint\nimport ffmpeg\nfrom typing import Literal\nfrom pyjom.commons import *\nimport parse\ndef getAudioBitrate(mediaPath):\n    return int(getMediaBitrate(mediaPath, audioOnly=True)[\"streams\"][0][\"bit_rate\"])\ndef getAudioDuration(audioFilePath):\n    with audioread.audio_open(audioFilePath) as f:\n        totalSeconds = f.duration\n    return totalSeconds  # is this float number or integer?\n    # how about let's test this?\ndef detect_volume_average(mediapath, debug=False):\n    # ffmpeg -i input.wav -filter:a volumedetect -f null /dev/null\n    # audio = ffmpeg.input(mediapath)\n    audio = ffmpeg.input(mediapath).audio\n    # does not have audio track, so error occurs.\n    # don't know how to capture the track. anyway, do put the audio into the test video.\n    # might have exception. what to do with it then??",
        "type": "code",
        "location": "/pyjom/audiotoolbox.py:1-32"
    },
    "111": {
        "file_id": 19,
        "content": "This code retrieves the audio duration and volume average from an input media file using the audioread library. The getAudioDuration function returns the total duration in seconds, while the detect_volume_average function processes the media path to obtain the volume average. However, it may encounter exceptions if the audio track is not available or the track cannot be captured properly.",
        "type": "comment"
    },
    "112": {
        "file_id": 19,
        "content": "    volDict = {}\n    error = False\n    try:\n        stdout, stderr = (\n            audio.filter(\"volumedetect\")\n            .output(\"/dev/null\", f=\"null\")\n            .run(capture_stdout=True, capture_stderr=True)\n        )\n        # where is the output?\n        stderr = stderr.decode(\"utf-8\")\n        stderr_lines = stderr.split(\"\\n\")\n        formatString = \"[Parsed_volumedetect{}] {volumeType}_volume: {value:g} dB\"\n        for line in stderr_lines:\n            line = line.strip()\n            result = parse.parse(formatString, line)\n            if result is not None:\n                volumeType, value = result[\"volumeType\"], result[\"value\"]\n                volDict.update({volumeType: value})\n    except:\n        import traceback\n        traceback.print_exc()\n        # print(stderr)\n        # nothing will be shown in stderr, if there is no audio in the media container.\n        print(\"error when detecting volume for: %s\" % mediapath)\n        error = True\n    if debug:\n        print(\"MEDIA PATH: %s\" % mediapath)\n        print(\"VOLUME:\", volDict)",
        "type": "code",
        "location": "/pyjom/audiotoolbox.py:33-61"
    },
    "113": {
        "file_id": 19,
        "content": "This code attempts to detect the volume of audio files and stores the volume details in a dictionary. It uses the \"volumedetect\" filter, redirects output to \"/dev/null\", captures both stdout and stderr, and parses the error output for volume information. If there's no audio in the media container, it will show an error message. Debug mode prints the media path and volume dictionary if set.",
        "type": "comment"
    },
    "114": {
        "file_id": 19,
        "content": "        sprint(\"ERROR STATUS:\", error)\n    return volDict, error\ndef adjustVolumeInMedia(\n    mediaPath,\n    outputPath,\n    targets={\n        \"mean\": -10.8,  # -13.2 fuck.\n        \"max\": 0.0,\n    },  # what is the real value anyway? we want the volume fetched from web.\n    overwrite_output=False,\n    bitrate=320000,\n    algorithm: Literal[\"rms\", \"ebu\", \"peak\"] = \"rms\",\n):  # must set target volume.\n    # use ffmpeg-normalize?\n    # use aac for mp4 output. let's do it!\n    target_level = targets.get(\"mean\", None)\n    true_peak = targets.get(\"max\", None)\n    commandline = [\n        \"ffmpeg-normalize\",\n        \"-o\",\n        outputPath,\n        \"-pr\",\n        \"-nt\",\n        algorithm,\n    ]\n    commandline += [\"-b:a\", str(bitrate)]  # the bitrate part.\n    # now much better. let's see if we have other methods.\n    # VOLUME NORMALIZATION SUCCESSFUL\n    # MEDIA PATH: normalized.mp4\n    # VOLUME: {'mean': -11.0, 'max': 0.0}\n    # ERROR STATUS: False\n    # commandline = [\"ffmpeg-normalize\", \"-o\", outputPath, \"-pr\"]\n    # VOLUME: {'mean': -13.2, 'max': 0.0}",
        "type": "code",
        "location": "/pyjom/audiotoolbox.py:62-97"
    },
    "115": {
        "file_id": 19,
        "content": "The function adjusts the volume of media files located at a specific path. It accepts parameters for output file path, target volume levels (mean and max), overwrite option, bitrate, and algorithm type. It uses ffmpeg-normalize command line tool to normalize the audio, and returns a dictionary containing mean and max volume values upon successful execution. If an error occurs, it returns the error status as well.",
        "type": "comment"
    },
    "116": {
        "file_id": 19,
        "content": "    # the 'mean' is still not correctified.\n    # ERROR STATUS: False\n    # video codec we use 'copy' if the extension name is the same.\n    outputPathExtension = outputPath.lower().split(\".\")[-1]\n    mediaPathExtension = mediaPath.lower().split(\".\")[-1]\n    outputMediaType = determineMediaTypeByExtension(outputPathExtension)\n    # treat this as a common repository.\n    if outputPathExtension == mediaPathExtension and outputMediaType == \"video\":\n        commandline += [\"-c:v\", \"copy\"]\n    # problem is, the container must be video compabible.\n    # list the thing here?\n    if outputPathExtension == \"mp4\":\n        commandline += [\"-c:a\", \"aac\"]\n    if target_level:\n        commandline += [\"-t\", str(target_level)]\n    if true_peak:\n        commandline += [\"-tp\", str(true_peak)]\n    if overwrite_output:\n        commandline += [\"-f\"]\n    commandline += [mediaPath]\n    status = subprocess.run(commandline)  # is it even successful?\n    returncode = status.returncode\n    try:\n        assert returncode == 0\n        print(\"VOLUME NORMALIZATION SUCCESSFUL\")",
        "type": "code",
        "location": "/pyjom/audiotoolbox.py:98-122"
    },
    "117": {
        "file_id": 19,
        "content": "This code is normalizing the volume of a video file and correcting its container type if necessary. It checks the input and output extensions, sets the video and audio codecs, handles target level, true peak, and overwrite settings, and runs subprocess command to execute FFmpeg for processing. The script prints \"VOLUME NORMALIZATION SUCCESSFUL\" if returncode is 0, indicating successful volume normalization.",
        "type": "comment"
    },
    "118": {
        "file_id": 19,
        "content": "        return outputPath\n    except:\n        import traceback\n        traceback.print_exc()\n        print(\"error when normalizing audio for media: %s\" % mediaPath)\n    # media = ffmpeg.input(videoPath)\n    # audio = media.audio\n    # video = media.video\n    # audio = audio.filter()",
        "type": "code",
        "location": "/pyjom/audiotoolbox.py:123-132"
    },
    "119": {
        "file_id": 19,
        "content": "This code snippet is responsible for normalizing audio for a given media file. If an error occurs during the process, it prints the error message and stack trace using the traceback module.",
        "type": "comment"
    },
    "120": {
        "file_id": 20,
        "content": "/pyjom/commons.py",
        "type": "filepath"
    },
    "121": {
        "file_id": 20,
        "content": "The code imports libraries, handles data operations and errors, interacts with Redis caching, supports debug mode, and maps media file extensions. It detects corrupted content, checks server availability, utilizes ffprobe and mediainfo for media details, configures YOLOv5 model, writes to a file, and prints log path.",
        "type": "summary"
    },
    "122": {
        "file_id": 20,
        "content": "import traceback\nfrom pyjom.config import *\nfrom typing import Union\nfrom pyjom.mathlib import checkMinMaxDict\nimport datetime\nimport os\nimport shutil\nimport socket\nimport json\nimport mimetypes\nimport jinja2\nimport copy\nimport uuid\nimport numpy as np\nimport torch\nimport pathlib\nimport site\nimport sys\nimport random\n# from functools import lru_cache\ncommonRedisPort = 9291\nos.system(\"ulimit -n 1048576\")\nfrom lazero.utils.logger import sprint\nfrom functools import lru_cache\nimport time\ndef getJSTimeStamp():\n    return int(time.time() * 1000)\nfrom pymilvus import connections\n@lru_cache(maxsize=1)\ndef connectMilvusDatabase(alias=\"default\", host=\"localhost\", port=\"19530\"):\n    connection = connections.connect(\n        alias=alias, host=host, port=port\n    )  # can we reconnect?\n    print(\"milvus connected\")\n    return connection\n# what is the redis connection?\nimport redis\n@lru_cache(maxsize=1)\ndef getRedisConnection(host=\"localhost\", port=commonRedisPort):\n    connection = redis.Redis(host=host, port=port)\n    return connection\ndef removeRedisValueByKey(",
        "type": "code",
        "location": "/pyjom/commons.py:1-58"
    },
    "123": {
        "file_id": 20,
        "content": "The code imports various libraries and defines several functions. It connects to Milvus and Redis databases, gets the current JSTimeStamp, and provides functions for connecting to these databases and removing a Redis value by key. The redis connection is cached using LRU cache for performance optimization.",
        "type": "comment"
    },
    "124": {
        "file_id": 20,
        "content": "    key: str, debug: bool = False, host=\"localhost\", port=commonRedisPort\n):\n    connection = getRedisConnection(host=host, port=port)\n    returnCode = connection.delete(key)\n    messages = {\n        0: \"key {} not found\".format(key),\n        1: \"delete key {} successfully\".format(key),\n    }\n    if debug:\n        print(messages.get(returnCode, \"unknown return code: {}\".format(returnCode)))\n    return returnCode\ndef removeRedisValueByKeys(\n    keys: list[str], debug: bool = False, host=\"localhost\", port=commonRedisPort\n):\n    for key in keys:\n        removeRedisValueByKey(key, debug=debug, host=host, port=port)\n# @lru_cache(maxsize=1)\n# def getSafeEvalEnvironment():\n#     return sf\ndef safe_eval(\n    code, safenodes=[\"List\", \"Dict\", \"Tuple\", \"Set\", \"Expression\", \"Constant\", \"Load\"]\n):  # strange.\n    from evalidate import safeeval\n    result = safeeval(code, {}, safenodes=safenodes)\n    return result\nimport pickle, dill\ncommonIterableDataTypes = [tuple, list, dict, set]\ncommonNonIterableDataTypes = [int, float, str, bool]",
        "type": "code",
        "location": "/pyjom/commons.py:59-96"
    },
    "125": {
        "file_id": 20,
        "content": "This code includes two functions, one for deleting a single key from Redis and the other for deleting multiple keys. It also has constants for data types and imports necessary libraries for handling data serialization and evaluation. The getSafeEvalEnvironment function is likely used to cache an environment for safe evaluation, although it is not currently utilized. The safe_eval function uses the evalidate library to evaluate input code within a restricted environment. Common iterable and non-iterable data types are defined for potential usage throughout the codebase.",
        "type": "comment"
    },
    "126": {
        "file_id": 20,
        "content": "commonDataTypes = commonNonIterableDataTypes + commonIterableDataTypes\ndef stringifiableCheck(value, debug: bool = False):\n    try:\n        str_value = repr(value)\n        restored_value = safe_eval(value)\n        return restored_value == value\n    except:\n        if debug:\n            traceback.print_exc()\n    return False\ndef setRedisValueByKey(\n    key: str,\n    value,\n    dataType=None,\n    encoding: str = \"utf-8\",\n    host=\"localhost\",\n    port=commonRedisPort,\n    debug: bool = False,\n):\n    def stringifyAndEncode(value):\n        data = repr(value)\n        data = data.encode(encoding)\n        return data\n    connection = getRedisConnection(host=host, port=port)\n    if dataType is None:\n        dataType = type(value)\n        if dataType in commonDataTypes and stringifiableCheck(\n            value, debug=debug\n        ):  # this automation only happens when leaving blank for dataType.\n            data = stringifyAndEncode(value)\n        else:\n            dataType = \"dill\"\n            data = dill.dumps(value)\n    else:",
        "type": "code",
        "location": "/pyjom/commons.py:97-135"
    },
    "127": {
        "file_id": 20,
        "content": "This code defines functions for handling data types and communicating with Redis. It checks if a value is stringifiable, encodes it, and stores it in Redis based on the provided data type. If no data type is given, it automatically determines the type and performs encoding if necessary.",
        "type": "comment"
    },
    "128": {
        "file_id": 20,
        "content": "        if dataType in commonDataTypes:\n            data = stringifyAndEncode(value)\n        elif dataType == \"dill\":\n            data = dill.dumps(value)\n        elif dataType == \"pickle\":\n            data = pickle.dumps(value)\n        else:\n            raise Exception(\"unknown dataType:\", dataType)\n    connection.set(key, data)\n    return dataType\ndef getRedisValueByKey(\n    key: str,\n    dataType=None,\n    encoding: str = \"utf-8\",\n    debug: bool = False,\n    host=\"localhost\",\n    port=commonRedisPort,\n):\n    connection = getRedisConnection(host=host, port=port)\n    value = connection.get(key)\n    if value is not None:\n        if debug:\n            print('data \"{}\" is not None'.format(key))\n        if dataType == None:\n            return dataType\n        elif dataType in commonDataTypes:\n            decoded_value = value.decode(encoding)\n            if dataType in commonNonIterableDataTypes:\n                if dataType == str:\n                    return decoded_value\n                else:\n                    return dataType(decoded_value)",
        "type": "code",
        "location": "/pyjom/commons.py:136-169"
    },
    "129": {
        "file_id": 20,
        "content": "The code handles data storage and retrieval from Redis. It checks the data type, encodes or serializes the value accordingly (using stringifyAndEncode, dill, or pickle), and stores it in Redis using set method. The getRedisValueByKey function retrieves a value by key and decodes it based on the specified data type, if provided. It returns None if the value is not found or the data type is not specified. The code also handles debugging messages and exceptions for unknown data types.",
        "type": "comment"
    },
    "130": {
        "file_id": 20,
        "content": "            else:\n                # safe eval using nsjail?\n                return safe_eval(decoded_value)\n        elif dataType == \"pickle\":\n            return pickle.loads(value)\n        elif dataType == \"dill\":\n            return dill.loads(value)\n        else:\n            raise Exception(\"unknown dataType:\", dataType)\n    if debug:\n        print('data \"{}\" is None'.format(key))\ndef getRedisCachedSet(\n    setName: str,\n    debug: bool = False,\n    host=\"localhost\",\n    port=commonRedisPort,\n    dataType=\"dill\",\n) -> set:\n    # so we know this datatype is set!\n    # but what is our plan? we use dill by default.\n    data = getRedisValueByKey(\n        setName, debug=debug, host=host, port=port, dataType=dataType\n    )\n    if data is None:\n        return set()\n    assert type(data) == set\n    return data\ndef addToRedisCachedSet(\n    item,\n    setName: str,\n    debug: bool = False,\n    host=\"localhost\",\n    port=commonRedisPort,\n    dataType=\"dill\",\n):\n    cachedSet = getRedisCachedSet(\n        setName, debug=debug, host=host, port=port, dataType=dataType",
        "type": "code",
        "location": "/pyjom/commons.py:170-210"
    },
    "131": {
        "file_id": 20,
        "content": "This code defines functions to interact with Redis cached sets. The `getRedisCachedSet` function retrieves a set from Redis, deserializing the data using either pickle or dill depending on the specified data type. If the data is None, it returns an empty set. The `addToRedisCachedSet` function adds an item to a Redis cached set after first retrieving the existing set and updating it with the new item before saving it back to Redis. Both functions support debug mode and have default values for host, port, and data type (dill).",
        "type": "comment"
    },
    "132": {
        "file_id": 20,
        "content": "    )\n    cachedSet.add(item)\n    setRedisValueByKey(setName, cachedSet, dataType=dataType, host=host, port=port)\n    return cachedSet\ndef shuffleAndPopFromList(mlist):\n    import random\n    random.shuffle(mlist)\n    return mlist.pop(0)\ndef getMediaBitrate(mediaPath, audioOnly=False, videoOnly=False):\n    # demo output:\n    # {'programs': [], 'streams': [{'bit_rate': '130770'}]}\n    commandArguments = [\n        \"ffprobe\",\n        \"-i\",\n        mediaPath,\n        \"-v\",\n        \"quiet\",\n    ]\n    if audioOnly:\n        commandArguments += [\n            \"-select_streams\",\n            \"a:0\",\n        ]\n    elif videoOnly:\n        commandArguments += [\n            \"-select_streams\",\n            \"v:0\",\n        ]\n    commandArguments += [\n        \"-show_entries\",\n        \"stream=bit_rate\",\n        \"-hide_banner\",\n        \"-print_format\",\n        \"json\",\n    ]\n    result = subprocess.run(commandArguments, capture_output=True, encoding=\"UTF-8\")\n    stdout = result.stdout\n    stderr = result.stderr\n    try:\n        assert result.returncode == 0",
        "type": "code",
        "location": "/pyjom/commons.py:211-255"
    },
    "133": {
        "file_id": 20,
        "content": "1. Defines functions for caching, shuffling lists, and retrieving media bitrate.\n2. Uses Redis to store sets of data with configurable host and port.\n3. Shuffles a list of items and returns the first item in the new order.\n4. Retrieves the bitrate of a video or audio stream using ffprobe, then prints it in JSON format.",
        "type": "comment"
    },
    "134": {
        "file_id": 20,
        "content": "        stdout_json = json.loads(stdout)\n        return stdout_json\n    except:\n        import traceback\n        traceback.print_exc()\n        print(\"potential error logs:\")\n        print(stderr)\n        print(\"error when getting media bitrate\")\n        return {}\ndef getFileExtensionToMeaningDictFromString(inputString):\n    inputStringList = inputString.split(\"\\n\")\n    fileExtensionToMeaningDict = {}\n    for line in inputStringList:\n        line = line.strip()\n        if len(line) < 5:\n            continue\n        # try:\n        meaning, extensions = line.split(\" - \")  # problem fixed.\n        # except:\n        #     print('line:',[line])\n        #     breakpoint()\n        meaning = meaning.strip()\n        extensions = extensions.split(\" or \")\n        for extension in extensions:\n            extension = extension.strip()\n            if len(extension) > 0:\n                fileExtensionToMeaningDict.update({extension: meaning})\n    return fileExtensionToMeaningDict\n@lru_cache(maxsize=1)\ndef getMediaFileExtensionToMeaningDict():",
        "type": "code",
        "location": "/pyjom/commons.py:256-290"
    },
    "135": {
        "file_id": 20,
        "content": "This code loads a JSON from stdout, handles potential errors by printing them and returns an empty dictionary. It also defines a function to create a file extension to meaning dictionary using input string lines. Lastly, it caches a media file extension to meaning dictionary with the help of @lru_cache decorator.",
        "type": "comment"
    },
    "136": {
        "file_id": 20,
        "content": "    # no input needed.\n    videoExtensions = \"\"\"MP4 or MPEG4 video file - .mp4\n264 video file - .h264\nAVI video file - .avi\nMKV or Matroska Multimedia Container - .mkv\nMPEG video file - .mpeg or .mpg\nMOV or Apple QuickTime video file - .mov\nApple MP4 video file - .m4v\nAdobe flash video - .flv\n3GP video file - .3gp\nWindows Media Video file - .wmv\nDVD Video Object - .vob\"\"\"\n    imageExtensions = \"\"\"JPEG image - .jpeg or .jpg\nPNG image - .png\nGIF image - .gif\nPhotoshop or PSD image - .psd\nAdobe Illustrator image - .ai\nTIFF image - .tif or .tiff\"\"\"\n    documentExtensions = \"\"\"Microsoft Word file - .doc or .docx\nPDF file - .pdf\nText file - .txt\nMicrosoft Excel file - .xls\nMicrosoft Excel Open XML file - .xlsx\nMicrosoft Excel file with macros - .xlsm\nMicrosoft PowerPoint presentation - .ppt\nMicrosoft PowerPoint slide show - .pps\nMicrosoft PowerPoint Open XML presentation - .pptx\"\"\"\n    audioExtensions = \"\"\"MP3 audio file - .mp3\nAAC audio file - .aac\nAC3 audio file - .ac3\nWAV audio file - .wav\nWMA audio file - .wma\nOgg Vorbis audio file - .ogg",
        "type": "code",
        "location": "/pyjom/commons.py:291-323"
    },
    "137": {
        "file_id": 20,
        "content": "The code defines various file extensions for video, image, document, and audio formats. It includes common extension types for each category, allowing the codebase to identify and handle different file types appropriately.",
        "type": "comment"
    },
    "138": {
        "file_id": 20,
        "content": "MIDI audio file - .midi or .mid\nCD audio file - .cda\nAIF audio file - .aif\"\"\"\n    mapping = [\n        (\"video\", videoExtensions),\n        (\"audio\", audioExtensions),\n        (\"image\", imageExtensions),  # gif could be video.\n        (\"document\", documentExtensions),\n    ]\n    mediaFileExtensionToMeaningDict = {\n        key: getFileExtensionToMeaningDictFromString(value) for key, value in mapping\n    }\n    return mediaFileExtensionToMeaningDict\ndef determineMediaTypeByExtension(extension):\n    extension = extension.strip()\n    if not extension.startswith(\".\"):\n        extension = \".\" + extension\n    extension_lower = extension.lower()\n    # this has to be cached.\n    mediaFileExtensionToMeaningDict = getMediaFileExtensionToMeaningDict()\n    for (\n        mediaType,\n        fileExtensionToMeaningDict,\n    ) in mediaFileExtensionToMeaningDict.items():\n        for fileExtension, meaning in fileExtensionToMeaningDict.items():\n            if fileExtension.lower == extension_lower:\n                return mediaType\n    return \"unknown\"",
        "type": "code",
        "location": "/pyjom/commons.py:324-353"
    },
    "139": {
        "file_id": 20,
        "content": "This code defines a function getMediaFileExtensionToMeaningDict() that maps file extensions to their meanings (video, audio, image, document). It also includes a determineMediaTypeByExtension() function which takes an extension as input, checks it against the mapping and returns the corresponding media type. This code suggests that caching is necessary for efficiency.",
        "type": "comment"
    },
    "140": {
        "file_id": 20,
        "content": "def corruptMediaFilter(\n    mediaPath, tag: str = \"media\", bad_words: list[str] = [\"invalid\", \"failed\", \"error\"]\n):\n    if not os.path.exists(mediaPath):\n        print(\"{} file does not exist\".format(tag))\n    import ffmpeg\n    not_nice = [word.lower() for word in bad_words]\n    corrupted = False\n    try:\n        stdout, stderr = (\n            ffmpeg.input(mediaPath)\n            .output(\"null\", f=\"null\")\n            .run(capture_stdout=True, capture_stderr=True)\n        )\n        stderr_lower = stderr.decode(\"utf-8\").lower()\n        for word in not_nice:\n            if word in stderr_lower:\n                print(\"{} is corrupted\".format(tag))\n                corrupted = True\n                break\n    except:\n        import traceback\n        traceback.print_exc()\n        corrupted = True\n        print(\"corrupt {}\".format(tag))\n    if not corrupted:\n        print(\"video is fine\")\n    # return True for fine video.\n    valid = not corrupted\n    sprint(\"{} file path:\".format(tag), mediaPath)\n    return valid\n## bring about 'redis cache' for faster testing.",
        "type": "code",
        "location": "/pyjom/commons.py:356-392"
    },
    "141": {
        "file_id": 20,
        "content": "This function named 'corruptMediaFilter' takes the path of a media file and checks for potentially corrupted content by scanning the ffmpeg output. If any 'bad words' found in stderr, it considers the file corrupted. If no issues found, it declares the video as fine and returns True. It also prints status updates to stdout about file existence, corruption status, and video condition.",
        "type": "comment"
    },
    "142": {
        "file_id": 20,
        "content": "import redis\nfrom redis_lru import RedisLRU\n# from functools import lru_cache\noneDay = 60 * 60 * 24  # one day?\nredisExpire = oneDay * 7  # god damn it!\n# @lru_cache(maxsize=1)\ndef redisLRUCache(\n    ttl=redisExpire,\n    redisAddress=\"127.0.0.1\",\n    redisPort=commonRedisPort,\n    max_size=20,\n    debug=True,\n):\n    client = redis.StrictRedis(host=redisAddress, port=redisPort)\n    cache = RedisLRU(client, max_size=max_size, debug=debug)\n    return cache(ttl=ttl)\n# this is root. this is not site-packages.\ndef frameSizeFilter(frameMeta, frame_size_filter):\n    width, height = frameMeta[\"width\"], frameMeta[\"height\"]\n    flagWidth, (minWidth, maxWidth) = checkMinMaxDict(\n        width, frame_size_filter.get(\"width\", {}), getMinMaxVal=True\n    )  # type: ignore\n    flagHeight, (minHeight, maxHeight) = checkMinMaxDict(\n        height, frame_size_filter.get(\"height\", {}), getMinMaxVal=True\n    )  # type: ignore\n    if not (flagWidth and flagHeight):\n        print(\"Filter out invalid video with shape of {}x{}\".format(width, height))",
        "type": "code",
        "location": "/pyjom/commons.py:393-423"
    },
    "143": {
        "file_id": 20,
        "content": "This code defines a function `redisLRUCache` that utilizes Redis LRU cache for storing data with Time-To-Live (TTL) and optional parameters like TTL, redisAddress, redisPort, max_size, and debug. It also includes a helper function `frameSizeFilter` that checks the dimensions of a frame against specified width and height ranges from a frame_size_filter dictionary. If both dimensions are filtered out, it prints a message indicating an invalid video shape.",
        "type": "comment"
    },
    "144": {
        "file_id": 20,
        "content": "        print(\n            \"Valid Width and Height are {}-{}x{}-{}\".format(\n                minWidth, maxWidth, minHeight, maxHeight\n            )\n        )\n        return False\n    return True\n# site_path = pathlib.Path([x for x in site.getsitepackages() if \"site-packages\" in x][0])\nos.environ[\"USE_NVIDIA_OPENCV\"] = \"yes\"\nif os.environ[\"USE_NVIDIA_OPENCV\"] == \"yes\":\n    site_path = pathlib.Path(\"/usr/local/lib/python3.9/site-packages\")\n    cv2_libs_dir = (\n        site_path / \"cv2\" / f\"python-{sys.version_info.major}.{sys.version_info.minor}\"\n    )\n    print(cv2_libs_dir)\n    cv2_libs = sorted(cv2_libs_dir.glob(\"*.so\"))\n    if len(cv2_libs) == 1:\n        print(\"INSERTING:\", cv2_libs[0].parent)\n        sys.path.insert(1, str(cv2_libs[0].parent))\nmimetypes.init()\ndef waitForServerUp(\n    port, message, timeout=1, messageLength: Union[None, int] = None  # for netease.\n):  # this messageLength is the length of the binary message.\n    import requests\n    while True:\n        try:\n            url = \"http://localhost:{}\".format(port)",
        "type": "code",
        "location": "/pyjom/commons.py:424-457"
    },
    "145": {
        "file_id": 20,
        "content": "This code checks if the OpenCV library is installed correctly and sets the system path accordingly. It also initializes mimetypes and defines a function waitForServerUp that makes HTTP requests to localhost on a specified port, waiting for a response until the timeout is reached. The function accepts optional parameters for message and messageLength (for netease).",
        "type": "comment"
    },
    "146": {
        "file_id": 20,
        "content": "            with requests.get(url, timeout=timeout) as r:\n                if messageLength is not None:\n                    contentLength = len(r.content)\n                    if messageLength <= contentLength:\n                        break\n                else:\n                    if type(message) == str:\n                        text = r.text.strip('\"').strip(\"'\")\n                    else:\n                        text = r.json()\n                    print(\"SERVER AT PORT %d RESPONDS:\" % port, [text])\n                    assert text == message\n                    print(\"SERVER AT PORT %d IS UP\" % port)\n                    break\n        except:\n            import traceback\n            traceback.print_exc()\n            print(\"SERVER AT PORT %d MIGHT NOT BE UP\" % port)\n            print(\"EXPECTED MESSAGE:\", [message])\n            import time\n            time.sleep(1)\nclass D2Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\ndef doRectOverlap(l1, r1, l2, r2):\n    # if rectangle has area 0, no overlap",
        "type": "code",
        "location": "/pyjom/commons.py:458-490"
    },
    "147": {
        "file_id": 20,
        "content": "Code fetches a message from server using URL, checks its length against expected length and prints the received response. If there is a mismatch, it raises an error. If the connection fails, it waits for a second before trying again.",
        "type": "comment"
    },
    "148": {
        "file_id": 20,
        "content": "    if l1.x == r1.x or l1.y == r1.y or r2.x == l2.x or l2.y == r2.y:\n        return False\n    # If one rectangle is on left side of other\n    if l1.x >= r2.x or l2.x >= r1.x:\n        return False\n    if l1.y >= r2.y or l2.y >= r1.y:\n        return False\n    return True\ndef checkRectOverlap(rect0, rect1):\n    assert len(rect0) == 2\n    assert len(rect1) == 2\n    return doRectOverlap(\n        D2Point(*rect0[0]), D2Point(*rect0[1]), D2Point(*rect1[0]), D2Point(*rect1[1])\n    )\ndef getOverlapRect(rect0, rect1):\n    if checkRectOverlap(rect0, rect1):\n        leftXList = (rect0[0][0], rect1[0][0])\n        leftYList = (rect0[0][1], rect1[0][1])\n        rightXList = (rect0[1][0], rect1[1][0])\n        rightYList = (rect0[1][1], rect1[1][1])\n        leftX = max(leftXList)\n        leftY = max(leftYList)\n        rightX = min(rightXList)\n        rightY = min(rightYList)\n        return [(leftX, leftY), (rightX, rightY)]\n    else:\n        return None\ndef makeValueInRange(value, minVal, maxVal):\n    assert minVal < maxVal\n    return min(max(minVal, value), maxVal)",
        "type": "code",
        "location": "/pyjom/commons.py:491-526"
    },
    "149": {
        "file_id": 20,
        "content": "The code checks for rectangle overlap, returns the overlapping rectangle if exists, and clamps values within a given range.",
        "type": "comment"
    },
    "150": {
        "file_id": 20,
        "content": "# this sucks...\ndef infiniteShuffle(access_list, shuffle=True, infinite=True, endMark=True):\n    flag = True\n    while flag:\n        if shuffle:\n            random.shuffle(access_list)\n        for data in access_list:\n            yield data\n        if endMark and infinite:\n            yield None\n        if not infinite:\n            flag = False\ndef inRange(target, mRange, tolerance=1):\n    assert tolerance <= 1\n    assert tolerance > 0\n    start, end = mRange\n    start, end = start * tolerance, end / tolerance\n    return target >= start and target <= end\ndef overlapRange(range_a, range_b):\n    begin_a, end_a = range_a\n    begin_b, end_b = range_b\n    possible_overlap = (max(begin_a, begin_b), min(end_a, end_b))\n    if possible_overlap[0] < possible_overlap[1]:  # overlapping\n        return possible_overlap\n    # return common range.\nfrom lazero.utils.json import jsonWalk2, jsonify, jsonWalk, jsonLocate, jsonUpdate\njson.__dict__.update({\"walk\": jsonWalk, \"locate\": jsonLocate, \"update\": jsonUpdate})\ndef replacer(content, sources=[], target=\"\"):",
        "type": "code",
        "location": "/pyjom/commons.py:529-565"
    },
    "151": {
        "file_id": 20,
        "content": "The code defines a function \"infiniteShuffle\" that shuffles and yields data from an access list, either stopping when the list ends or if set to infinite mode. Function \"inRange\" checks if a target value falls within specified range boundaries with optional tolerance. Function \"overlapRange\" calculates the overlap between two given ranges. The code also updates JSON functions (\"walk\", \"locate\", and \"update\") under the json module. Finally, a function named \"replacer\" is defined, but its functionality isn't clear from the given code snippet.",
        "type": "comment"
    },
    "152": {
        "file_id": 20,
        "content": "    for source in sources:\n        content = content.replace(source, target)\n    return content\ndef multi_replacer(content, replacer_list=[[[], \"\"]]):\n    for sources, target in replacer_list:\n        content = replacer(content, sources=sources, target=target)\n    return content\nfrom pyjom.mathlib import extract_span, convoluted\nimport MediaInfo\nimport subprocess\ndef json_auto_float_int(jsonObj):\n    jsonObj = jsonify(jsonObj)\n    for location, content in jsonWalk(jsonObj):\n        # content = jsonLocate(jsonObj,location)\n        if type(content) == str:\n            if \"/\" in content:\n                try:\n                    content = eval(content)  # could be dangerous!\n                    if type(content) in [float, int]:\n                        jsonUpdate(jsonObj, location=location, update_content=content)\n                except:\n                    pass\n            elif \".\" in content:\n                try:\n                    content = float(content)\n                    jsonUpdate(jsonObj, location=location, update_content=content)",
        "type": "code",
        "location": "/pyjom/commons.py:566-600"
    },
    "153": {
        "file_id": 20,
        "content": "The code appears to be a combination of functions that replace specific strings within a given content, update JSON objects by converting certain string types to either float or int, and potentially include some math-related operations. It seems to involve the use of external libraries such as MediaInfo and subprocess for possibly retrieving additional information or performing computations.",
        "type": "comment"
    },
    "154": {
        "file_id": 20,
        "content": "                except:\n                    pass\n            else:\n                try:\n                    content = int(content)\n                    jsonUpdate(jsonObj, location=location, update_content=content)\n                except:\n                    pass\n    return jsonObj\ndef ffprobe_media_info(filename, video_size: Union[None, str] = None):\n    cmd = \"ffprobe{} -v quiet -print_format json -show_format -show_streams\".format(\n        \" -video_size {}\".format(video_size.strip()) if video_size else \"\"\n    )\n    cmd = cmd.split(\" \")\n    cmd = cmd + [filename]\n    output = subprocess.check_output(cmd)\n    return json_auto_float_int(json.loads(output))\ndef json_media_info(filename):\n    cmd = [\"mediainfo\", \"--Output=JSON\", filename]\n    output = subprocess.check_output(cmd)\n    return json_auto_float_int(json.loads(output))\ndef get_media_info(filename):\n    mdf = MediaInfo.MediaInfo(filename=filename)\n    return json_auto_float_int(mdf.getInfo())\ndef getTextFileLength(path):\n    with open(path, \"r\", encoding=\"utf-8\") as f:",
        "type": "code",
        "location": "/pyjom/commons.py:601-634"
    },
    "155": {
        "file_id": 20,
        "content": "The code contains functions for retrieving media information. It uses ffprobe and mediainfo commands to extract video format, codec, size, duration, bitrate, and other details from the specified file. The information is returned in JSON format after converting floating-point numbers to integers if needed. The getTextFileLength function reads a text file's length using Python's built-in open() function.",
        "type": "comment"
    },
    "156": {
        "file_id": 20,
        "content": "        return len(f.read())\ndef append_sublist(main_dict, sublist_key, item):\n    main_dict[sublist_key] = main_dict.get(sublist_key, []) + [item]\ndef update_subdict(mdict, key, subdict):\n    # print(\"UPDATING SUBDICT\", mdict,key, subdict)\n    if key not in mdict:\n        mdict[key] = subdict\n    else:\n        mdict[key].update(subdict)\n    return mdict\ndef read_json(filepath):\n    with open(filepath, \"r\") as f:\n        return json.loads(f.read())\ndef list_to_range(mlist, rangeLimit):\n    mlist = set(mlist)\n    mlist = list(sorted(mlist))\n    currentRange = []\n    lastElem = None\n    myRanges = []\n    for elem in mlist:\n        if lastElem == None:\n            lastElem = elem\n            currentRange = [elem]\n            continue\n        myRange = elem - lastElem\n        if rangeLimit >= myRange:\n            lastElem = elem\n            if len(currentRange) == 2:\n                currentRange[1] = elem\n            else:\n                currentRange.append(elem)\n        else:\n            myRanges.append(currentRange)\n            lastElem = elem",
        "type": "code",
        "location": "/pyjom/commons.py:635-676"
    },
    "157": {
        "file_id": 20,
        "content": "This code defines functions for working with dictionaries and JSON files. It includes functions to append a sublist, update a subdictionary, read a JSON file, and convert a list of elements into ranges based on their differences. These functions can be used together or separately depending on the specific task at hand.",
        "type": "comment"
    },
    "158": {
        "file_id": 20,
        "content": "            currentRange = [elem]\n    if len(myRanges) > 0:\n        if myRanges[-1] != currentRange:\n            myRanges.append(currentRange)\n    else:\n        myRanges.append(currentRange)\n    return myRanges\n# from youtube science.\ndef list_startswith(a, b):\n    value = 0\n    if len(a) < len(b):\n        return False\n    for i, v in enumerate(b):\n        v0 = a[i]\n        if v == v0:\n            value += 1\n    return value == len(b)\ndef list_endswith(a, b):\n    value = 0\n    if len(a) < len(b):\n        return False\n    c = a[-len(b) :]\n    for i, v in enumerate(b):\n        v0 = c[i]\n        if v == v0:\n            value += 1\n    return value == len(b)\ndef cv2_HWC2CHW(frame):\n    if len(frame.shape) == 3:\n        img = frame[:, :, ::-1].transpose((2, 0, 1))\n    else:\n        img = frame[np.newaxis, :, :]\n    return img\nocrCore = None\nocrConfig = {\n    \"use_angle_cls\": True,\n    \"lang\": \"ch\",\n}  # it can detect english too. but no space included.\ndef configOCR(**kwargs):\n    global ocrCore, ocrConfig\n    if ocrCore is not None:",
        "type": "code",
        "location": "/pyjom/commons.py:677-727"
    },
    "159": {
        "file_id": 20,
        "content": "This code defines several functions related to lists, image conversion, and OCR configuration. It checks if a list starts or ends with another list, converts an image's shape from HWC to CHW, and configures the OCR engine with language options. The global ocrCore and ocrConfig variables store the OCR engine and its configurations, which can be updated using the configOCR function.",
        "type": "comment"
    },
    "160": {
        "file_id": 20,
        "content": "        if kwargs == ocrConfig:\n            pass\n    else:\n        ocrConfig = kwargs\n        from paddleocr import PaddleOCR\n        # breakpoint()\n        ocrCore = PaddleOCR(**kwargs)\n        # breakpoint() # this is not the problem. maybe.\n    return ocrCore\ndef getScriptFileBaseDir(script_file):\n    basepath = os.path.abspath(script_file)\n    basepath = basepath.replace(os.path.basename(basepath), \"\")\n    return basepath\ndef getTemplateFileBaseDir(tmpDir=\"templates\"):\n    basedir = getScriptFileBaseDir(__file__)\n    basedir = os.path.join(basedir, tmpDir)\n    assert os.path.exists(basedir)\n    return basedir\nyolov5_model = None\n@lru_cache(maxsize=1)\ndef configYolov5(model=\"yolov5s\"):\n    global yolov5_model  # not the same\n    if yolov5_model == None:\n        basedir = getTemplateFileBaseDir(tmpDir=\"models/yolov5\")\n        os.environ[\"YOLOV5_MODEL_DIR\"] = basedir\n        localModelPath = os.path.join(\n            basedir, \"ultralytics_yolov5_master/\"\n        )  # required to load it. we have modified this shit somehow.",
        "type": "code",
        "location": "/pyjom/commons.py:728-764"
    },
    "161": {
        "file_id": 20,
        "content": "This code snippet defines a function \"configYolov5\" that retrieves the YOLOv5 model configuration. It first checks if the global variable \"yolov5_model\" is set, and if not, it sets it based on the given \"model\" parameter. The function also includes the paths to the YOLOv5 model directory using the \"getScriptFileBaseDir\" and \"getTemplateFileBaseDir\" functions. Finally, an LRU cache decorator ensures efficient retrieval of the model configuration.",
        "type": "comment"
    },
    "162": {
        "file_id": 20,
        "content": "        modelPath = model\n        # we set enviorment variable instead.\n        # breakpoint()\n        yolov5_model = torch.hub.load(localModelPath, modelPath, source=\"local\")\n    return yolov5_model\ndef getTemplatePath(template_dirs, template_path):\n    basedir = getTemplateFileBaseDir()\n    for template_dir in template_dirs:\n        basedir = os.path.join(basedir, template_dir)\n        assert os.path.exists(basedir)\n    template_path = os.path.join(basedir, template_path)\n    assert os.path.exists(template_path)\n    return template_path\ndef joinScriptFileBaseDir(script_file, local_file_path):\n    basepath = getScriptFileBaseDir(script_file)\n    file_path = os.path.join(basepath, local_file_path)\n    return file_path\ndef renderTemplate(template, template_args, enable_json=True):\n    template = jinja2.Template(template)\n    if enable_json:\n        for key in template_args.keys():\n            data = template_args[key]\n            if type(data) in [dict, list, tuple]:\n                try:\n                    data = json.dumps(data)",
        "type": "code",
        "location": "/pyjom/commons.py:765-795"
    },
    "163": {
        "file_id": 20,
        "content": "Code snippet defines several functions:\n- `getTemplatePath()` joins template directory paths and asserts if the resulting path exists.\n- `joinScriptFileBaseDir()` combines script file base directory with a local file path.\n- `renderTemplate()` renders a Jinja2 template, optionally converting dictionaries/lists to JSON.",
        "type": "comment"
    },
    "164": {
        "file_id": 20,
        "content": "                    template_args[key] = data\n                except:\n                    pass\n    script = template.render(**template_args)\n    return script\ndef configDecorator(func, config=\"config.json\"):\n    def mytarget(*args, **kwargs):\n        return func(*args, **(kwargs | {\"config\": config}))\n    return mytarget\ndef jsonPrettyPrint(feedback, indent=4):\n    assert type(indent) == int\n    mtype = \"json\"\n    feedback_type = type(feedback)\n    if feedback_type != str:\n        try:\n            mfeedback_content = json.dumps(feedback, indent=indent)\n        except:\n            mfeedback_content = str(feedback)\n            mtype = str(feedback_type)\n    else:\n        mfeedback_content = feedback\n        mtype = \"str\"\n    return mtype, mfeedback_content\ndef getFileType(fbase0):\n    # quick dirty fix.\n    # for gif we have a hard fix.\n    translateTable = {\"gif\": \"video\"}  # force conversion.\n    # print(\"FBASE:\", fbase0)\n    suffix = fbase0.split(\".\")[-1]\n    guessedType = translateTable.get(suffix, None)\n    # breakpoint()",
        "type": "code",
        "location": "/pyjom/commons.py:796-833"
    },
    "165": {
        "file_id": 20,
        "content": "commons.py file contains various utility functions, including a template rendering function with exception handling, a decorator that uses a specific configuration file, a function to pretty print JSON data with optional indentation, and a function for guessing the type of a file based on its extension.",
        "type": "comment"
    },
    "166": {
        "file_id": 20,
        "content": "    if guessedType:\n        return guessedType\n    mimestart = mimetypes.guess_type(fbase0)[0]\n    if mimestart != None:\n        mimestart = mimestart.split(\"/\")[0]\n        return mimestart\n    return \"unknown\"\ndef getAbsoluteFilePath(fpath):\n    assert os.path.exists(fpath)\n    if os.path.isabs(fpath):\n        return fpath\n    return os.path.abspath(fpath)\ndef getFileExtension(fpath):\n    basename = os.path.basename(fpath)\n    assert \".\" in basename\n    return basename.split(\".\")[-1]\ndef getLocalFileType(fpath):  # this is guessing, not file probing.\n    fbase = os.path.basename(fpath)\n    return getFileType(fbase)\ndef getHostname():\n    return socket.gethostname()\ndef keywordDecorator(func, **kwargs2):\n    def mytarget(*margs, **kwargs):\n        if \"trace_source\" in kwargs.keys():\n            if kwargs2[\"trace_source\"]:\n                return func(*margs, **(kwargs | kwargs2)), \".\".join(\n                    [__name__, func.__name__]\n                )\n        return func(*margs, **(kwargs | kwargs2))\n    return mytarget",
        "type": "code",
        "location": "/pyjom/commons.py:834-874"
    },
    "167": {
        "file_id": 20,
        "content": "This code includes functions for getting file types, extensions, and local file names. It also includes a decorator for tracing source locations and a function to get the hostname. The \"getFileType\" function uses the guessed type or the mimetype of the file if it exists. The \"getAbsoluteFilePath\" returns an absolute path if given, otherwise it returns the absolute path of the relative path. The \"getFileExtension\" gets the extension of a file name. The \"getLocalFileType\" guesses the file type based on its name. The \"getHostname\" function retrieves the hostname of the current machine. Finally, the \"keywordDecorator\" is used for traceable source locations.",
        "type": "comment"
    },
    "168": {
        "file_id": 20,
        "content": "def decorator(func):\n    def mytarget(*args, **kwargs):\n        return func(*args, **kwargs), \".\".join([__name__, func.__name__])\n    return mytarget\ndef chineseDetector(string):\n    base, celi = 0x4E00, 0x9FA5\n    for elem in string:\n        mydata = ord(elem)\n        if mydata >= base and mydata <= celi:\n            return True\n    return False\ndef getTimestamp():\n    return datetime.datetime.now().timestamp()\ndef dumpTrashDir(trash_dir):\n    if os.path.exists(trash_dir):\n        if os.path.isdir(trash_dir):\n            shutil.rmtree(trash_dir)\n        else:\n            os.remove(trash_dir)\ndef writeFileWithPath(path, fname, content, mode, encoding=None):\n    if not os.path.exists(path):\n        os.makedirs(path)\n    log_path = os.path.join(path, fname)\n    if \"b\" not in mode:\n        if encoding == None:\n            with open(log_path, mode) as f:\n                f.write(content)\n        else:\n            with open(log_path, mode, encoding=encoding) as f:\n                f.write(content)\n    else:\n        with open(log_path, mode) as f:",
        "type": "code",
        "location": "/pyjom/commons.py:877-917"
    },
    "169": {
        "file_id": 20,
        "content": "This code includes functions for a decorator, Chinese detector, timestamp generation, removing trash directories, and writing files. The decorator function takes a function as an argument and returns a wrapper function. The ChineseDetector function checks if a string contains Chinese characters. The getTimestamp function returns the current timestamp. The dumpTrashDir function removes the specified trash directory if it exists and is a directory. The writeFileWithPath function writes content to a file with the given path, filename, and mode.",
        "type": "comment"
    },
    "170": {
        "file_id": 20,
        "content": "            f.write(content)\n    print(\"file written at:\\n{}\".format(log_path))",
        "type": "code",
        "location": "/pyjom/commons.py:918-919"
    },
    "171": {
        "file_id": 20,
        "content": "Writes the content to a file, then prints the log path indicating successful file writing.",
        "type": "comment"
    },
    "172": {
        "file_id": 21,
        "content": "/pyjom/config/__init__.py",
        "type": "filepath"
    },
    "173": {
        "file_id": 21,
        "content": "This code imports all functions and variables from the \"sina\" and \"medialang\" modules within the pyjom.config package. These modules may contain configurations for different components or services used in the application, potentially related to Sina Weibo and Media Language processing.",
        "type": "summary"
    },
    "174": {
        "file_id": 21,
        "content": "from pyjom.config.sina import *\nfrom pyjom.config.medialang import *",
        "type": "code",
        "location": "/pyjom/config/__init__.py:1-2"
    },
    "175": {
        "file_id": 21,
        "content": "This code imports all functions and variables from the \"sina\" and \"medialang\" modules within the pyjom.config package. These modules may contain configurations for different components or services used in the application, potentially related to Sina Weibo and Media Language processing.",
        "type": "comment"
    },
    "176": {
        "file_id": 22,
        "content": "/pyjom/config/medialang/__init__.py",
        "type": "filepath"
    },
    "177": {
        "file_id": 22,
        "content": "This code imports all modules from the \"pyjom.config.medialang.protocols\" package into the current namespace, allowing access to various media language protocols used within the application.",
        "type": "summary"
    },
    "178": {
        "file_id": 22,
        "content": "from pyjom.config.medialang.protocols import *",
        "type": "code",
        "location": "/pyjom/config/medialang/__init__.py:1-1"
    },
    "179": {
        "file_id": 22,
        "content": "This code imports all modules from the \"pyjom.config.medialang.protocols\" package into the current namespace, allowing access to various media language protocols used within the application.",
        "type": "comment"
    },
    "180": {
        "file_id": 23,
        "content": "/pyjom/config/medialang/protocols.py",
        "type": "filepath"
    },
    "181": {
        "file_id": 23,
        "content": "The code defines a dictionary named `medialangProtocols` with two keys: \"input\" and \"output\". The \"input\" key holds an array of protocols for input data sources, while the \"output\" key holds an array of protocols for output data destinations.",
        "type": "summary"
    },
    "182": {
        "file_id": 23,
        "content": "medialangProtocols = {\n    \"input\": [\"http://\", \"https://\", \"text://\", \"subtitle://\", \"sinafetch://\"],\n    \"output\": [\"bilibili_post://\"],\n}",
        "type": "code",
        "location": "/pyjom/config/medialang/protocols.py:1-4"
    },
    "183": {
        "file_id": 23,
        "content": "The code defines a dictionary named `medialangProtocols` with two keys: \"input\" and \"output\". The \"input\" key holds an array of protocols for input data sources, while the \"output\" key holds an array of protocols for output data destinations.",
        "type": "comment"
    },
    "184": {
        "file_id": 24,
        "content": "/pyjom/config/shared.py",
        "type": "filepath"
    },
    "185": {
        "file_id": 24,
        "content": "The code initializes a dictionary named \"pyjom_config\" with a single key-value pair. The key is \"BEZIER_PADDLE_RESNET50_IMAGE_DOG_CAT_DETECTOR_SERVER_INSTANCE\", and its value is set to False. This configuration appears to relate to various components of an image detection system, possibly including a Bezier paddle, Paddle ResNet50 model, Dog/Cat detector, and server instance.",
        "type": "summary"
    },
    "186": {
        "file_id": 24,
        "content": "pyjom_config=dict(BEZIER_PADDLE_RESNET50_IMAGE_DOG_CAT_DETECTOR_SERVER_INSTANCE=False)",
        "type": "code",
        "location": "/pyjom/config/shared.py:1-1"
    },
    "187": {
        "file_id": 24,
        "content": "The code initializes a dictionary named \"pyjom_config\" with a single key-value pair. The key is \"BEZIER_PADDLE_RESNET50_IMAGE_DOG_CAT_DETECTOR_SERVER_INSTANCE\", and its value is set to False. This configuration appears to relate to various components of an image detection system, possibly including a Bezier paddle, Paddle ResNet50 model, Dog/Cat detector, and server instance.",
        "type": "comment"
    },
    "188": {
        "file_id": 25,
        "content": "/pyjom/config/sina/__init__.py",
        "type": "filepath"
    },
    "189": {
        "file_id": 25,
        "content": "The code imports all the functions, classes, and variables from the \"sinaWeibo\" module in the \"pyjom.config.sina\" package.",
        "type": "summary"
    },
    "190": {
        "file_id": 25,
        "content": "from pyjom.config.sina.sinaWeibo import *",
        "type": "code",
        "location": "/pyjom/config/sina/__init__.py:1-1"
    },
    "191": {
        "file_id": 25,
        "content": "The code imports all the functions, classes, and variables from the \"sinaWeibo\" module in the \"pyjom.config.sina\" package.",
        "type": "comment"
    },
    "192": {
        "file_id": 26,
        "content": "/pyjom/config/sina/sinaWeibo.py",
        "type": "filepath"
    },
    "193": {
        "file_id": 26,
        "content": "The code defines a dictionary named \"sinaWeiboApi\" with three API endpoints for interacting with Sina Weibo. The \"search_with_page\" endpoint performs search queries, \"weibo_status_by_blogid\" retrieves a specific weibo status by blog ID, and \"weibo_build_comments\" fetches comments for a given weibo status.",
        "type": "summary"
    },
    "194": {
        "file_id": 26,
        "content": "sinaWeiboApi = {\n    \"search_with_page\": \"http://sinanews.sina.cn/interface/type_of_search.d.html?callback=initFeed&keyword={}&page={}&type=siftWb&size=20&newpage=0&chwm=&imei=&token=&did=&from=&oldchwm=\",\n    \"weibo_status_by_blogid\": \"https://www.weibo.com/ajax/statuses/show?id={}\",\n    \"weibo_build_comments\": \"https://weibo.com/ajax/statuses/buildComments?flow=0&is_reload=1&count={}&id={}&is_show_bulletin=2&is_mix=0&uid={}\",\n}",
        "type": "code",
        "location": "/pyjom/config/sina/sinaWeibo.py:1-5"
    },
    "195": {
        "file_id": 26,
        "content": "The code defines a dictionary named \"sinaWeiboApi\" with three API endpoints for interacting with Sina Weibo. The \"search_with_page\" endpoint performs search queries, \"weibo_status_by_blogid\" retrieves a specific weibo status by blog ID, and \"weibo_build_comments\" fetches comments for a given weibo status.",
        "type": "comment"
    },
    "196": {
        "file_id": 27,
        "content": "/pyjom/imagetoolbox.py",
        "type": "filepath"
    },
    "197": {
        "file_id": 27,
        "content": "This code provides image processing functions such as cropping, text recognition, and K-means clustering using EasyOCR. It also includes a customizable FastAPI server for detecting animals using PaddlePaddle's ResNet50 classifier and applies preprocessing techniques on images to extract animal objects.",
        "type": "summary"
    },
    "198": {
        "file_id": 27,
        "content": "from pyjom.commons import *\nimport numpy as np\nimport cv2\nfrom functools import lru_cache\nfrom lazero.utils.tools import flattenUnhashableList\nfrom typing import Literal\ndef imageCropWithDiagonalRectangle(\n    image, diagonalRectangle, order: Literal[\"opencv\", \"normal\"] = \"opencv\"\n):\n    # order is opencv.\n    assert order in [\"opencv\", \"normal\"]\n    x0, y0, x1, y1 = flattenUnhashableList(diagonalRectangle)\n    imageShape = image.shape\n    if len(imageShape) == 3:\n        if order == \"opencv\":\n            return image[y0:y1, x0:x1, :]\n        elif order == \"normal\":\n            return image[x0:x1, y0:y1, :]\n    elif len(imageShape) == 2:\n        if order == \"opencv\":\n            return image[y0:y1, x0:x1]\n        elif order == \"normal\":\n            return image[x0:x1, y0:y1]\n    else:\n        raise Exception(\"unknown image shape:\", imageShape)\ndef draw_bounding_box_with_contour(\n    contours, image, area_threshold=20, debug=False\n):  # are you sure?\n    # this is the top-k approach.\n    # Call our function to get the list of contour areas",
        "type": "code",
        "location": "/pyjom/imagetoolbox.py:1-35"
    },
    "199": {
        "file_id": 27,
        "content": "The code defines two functions: `imageCropWithDiagonalRectangle` and `draw_bounding_box_with_contour`. The first function crops an image based on a given diagonal rectangle, considering both opencv and normal orders. The second function draws bounding boxes around contours in an image, using the top-k approach. It takes contours, the image, area threshold, and debug flag as inputs.",
        "type": "comment"
    }
}