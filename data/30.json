{
    "3000": {
        "file_id": 346,
        "content": "            stringData = decodedBytes.decode(\"utf-8\")\n            print(\"QRCode content:\")\n            print(stringData)\n            polygon = code.polygon\n            print('POLYGON CONTENT:')\n            print(polygon)\n        return True\n    else:\n        return False\ncv2_custom_build_init()\nimport cv2\nfor image in images:\n# shit! for picture with 2 qrcodes it fails to detect.\n# bbox return None\n    img = cv2.imread(image)\n    result=detect_qr(img)\n    print(\"RESULT:\", result)\n    print(\"_\"*20)",
        "type": "code",
        "location": "/tests/bilibili_video_recommendation_server/detect_qr_code_payments.py:33-52"
    },
    "3001": {
        "file_id": 346,
        "content": "This code reads images containing QR codes and attempts to detect them. If a QR code is detected, it prints the content of the QR code and its polygon shape. If no QR code is detected, it returns False. The current implementation has issues handling images with multiple QR codes.",
        "type": "comment"
    },
    "3002": {
        "file_id": 347,
        "content": "/tests/bilibili_video_recommendation_server/detect_qr_code.py",
        "type": "filepath"
    },
    "3003": {
        "file_id": 347,
        "content": "This code detects and prints data from QR codes in an image using OpenCV and lazero.utils.importers. It displays the image with QR code bounding boxes, waits for user input, then destroys windows.",
        "type": "summary"
    },
    "3004": {
        "file_id": 347,
        "content": "# image = \"test_image_with_qr_code.png\"\n# fail to obtain the qrcode.\n# but we might want use our original qrcode.\n# image = \"output_qrcode2.png\"\nimage = \"MyQRCode1.png\"\n# shit! for picture with 2 qrcodes it fails to detect.\n# bbox return None\nfrom lazero.utils.importers import cv2_custom_build_init\ncv2_custom_build_init()\nimport cv2\nimg = cv2.imread(image)\ndetector = cv2.QRCodeDetector()\ndata, bbox, _ = detector.detectAndDecode(img)\nqrcode_count = len(bbox)\nprint(\"total %d qrcode(s)\" % qrcode_count)\nif bbox is not None:\n    # display the image with lines\n    # print(bbox)\n    # breakpoint()\n    for i in range(len(bbox)):\n        # draw all lines\n        for index in range(4):\n            pt0 = tuple(bbox[i][index % 4].astype(int))\n            pt1 = tuple(bbox[i][(index + 1) % 4].astype(int))\n            cv2.line(\n                img,\n                pt0,\n                pt1,\n                color=(255, 0, 0),\n                thickness=2,\n            )\nif data:\n    print(\"[+] QR Code detected, data:\", data)\n    # what is the link inside the qr code?",
        "type": "code",
        "location": "/tests/bilibili_video_recommendation_server/detect_qr_code.py:1-39"
    },
    "3005": {
        "file_id": 347,
        "content": "The code aims to detect QR codes in an image and print the data contained within them, if any. It loads an image using OpenCV and utilizes the QRCodeDetector class from lazero.utils.importers to identify and decode the QR codes present in the image. If there are multiple QR codes, it displays the image with lines drawn connecting the corners of each QR code's bounding box. The code also checks for any detected data and prints it if available.",
        "type": "comment"
    },
    "3006": {
        "file_id": 347,
        "content": "# display the result\ncv2.imshow(\"img\", img)\ncv2.waitKey(0)\ncv2.destroyAllWindows()",
        "type": "code",
        "location": "/tests/bilibili_video_recommendation_server/detect_qr_code.py:40-43"
    },
    "3007": {
        "file_id": 347,
        "content": "This code displays an image with detected QR codes in a window and waits for the user to close it before destroying all windows.",
        "type": "comment"
    },
    "3008": {
        "file_id": 348,
        "content": "/tests/bilibili_video_recommendation_server/create_invisible_blend_transparent_ebegging.py",
        "type": "filepath"
    },
    "3009": {
        "file_id": 348,
        "content": "This code resizes and composes two images, applying opacity to create an invisible blending effect. The first image is scaled proportionally to the second image using a ratio factor. Both images are then overlaid onto each other with transparency applied, resulting in a final image where the first image serves as a background for the second image.",
        "type": "summary"
    },
    "3010": {
        "file_id": 348,
        "content": "background = \"setu2.jpg\"\nebegging = \"ebegging_template.png\"\nimport pixie\nbgImage = pixie.read_image(background)\nebImage = pixie.read_image(ebegging)\nfactor = 7\nratio_0 = (1200 * factor / 5) / min(bgImage.width, bgImage.height)\nb_w, b_h = int(ratio_0 * bgImage.width), int(ratio_0 * bgImage.height)\nbgImage = bgImage.resize(b_w, b_h)\nratio = min(bgImage.width, bgImage.height) / (\n    max(ebImage.width, ebImage.height) * factor\n)\ne_w, e_h = int(ratio * ebImage.width), int(ratio * ebImage.height)\n# print(e_w, e_h)\n# print(ratio)\n# print(bgImage.width, bgImage.height)\nebImage = ebImage.resize(e_w, e_h)\nebImage.apply_opacity(0.5)\nt_w, t_h = bgImage.width - e_w, bgImage.height - e_h\nbgImage.draw(ebImage, transform=pixie.translate(t_w, t_h))\nbgImage.write_file(\"ebegging_setu_transparent.png\")",
        "type": "code",
        "location": "/tests/bilibili_video_recommendation_server/create_invisible_blend_transparent_ebegging.py:1-31"
    },
    "3011": {
        "file_id": 348,
        "content": "This code resizes and composes two images, applying opacity to create an invisible blending effect. The first image is scaled proportionally to the second image using a ratio factor. Both images are then overlaid onto each other with transparency applied, resulting in a final image where the first image serves as a background for the second image.",
        "type": "comment"
    },
    "3012": {
        "file_id": 349,
        "content": "/tests/bilibili_video_recommendation_server/convert_font.sh",
        "type": "filepath"
    },
    "3013": {
        "file_id": 349,
        "content": "The code is running a Python script, ttc2ttf.py, to convert the 'wqy-microhei.ttc' font file into a .ttf format. This conversion allows for wider compatibility and use across different software platforms. The 'python3' command ensures that the latest version of Python is used to execute the script.",
        "type": "summary"
    },
    "3014": {
        "file_id": 349,
        "content": "python3 ttc2ttf/ttc2ttf.py wqy-microhei.ttc",
        "type": "code",
        "location": "/tests/bilibili_video_recommendation_server/convert_font.sh:1-1"
    },
    "3015": {
        "file_id": 349,
        "content": "The code is running a Python script, ttc2ttf.py, to convert the 'wqy-microhei.ttc' font file into a .ttf format. This conversion allows for wider compatibility and use across different software platforms. The 'python3' command ensures that the latest version of Python is used to execute the script.",
        "type": "comment"
    },
    "3016": {
        "file_id": 350,
        "content": "/tests/bilibili_video_recommendation_server/concat_qrcode.sh",
        "type": "filepath"
    },
    "3017": {
        "file_id": 350,
        "content": "This code uses FFmpeg to concatenate two identical QR Code images, MyQRCode1.png, into one output image named output_qrcode2.png. It overlay the top input image at the upper half and the bottom input image at the lower half of the output image.",
        "type": "summary"
    },
    "3018": {
        "file_id": 350,
        "content": "ffmpeg -i MyQRCode1.png  -vf \"pad=iw:2*ih [top]; movie=MyQRCode1.png[bottom]; [top][bottom] overlay=0:main_h/2\" output_qrcode2.png",
        "type": "code",
        "location": "/tests/bilibili_video_recommendation_server/concat_qrcode.sh:1-1"
    },
    "3019": {
        "file_id": 350,
        "content": "This code uses FFmpeg to concatenate two identical QR Code images, MyQRCode1.png, into one output image named output_qrcode2.png. It overlay the top input image at the upper half and the bottom input image at the lower half of the output image.",
        "type": "comment"
    },
    "3020": {
        "file_id": 351,
        "content": "/tests/bilibili_video_recommendation_server/bilibili_shortlink_get_2.py",
        "type": "filepath"
    },
    "3021": {
        "file_id": 351,
        "content": "This code sets the URL for Bilibili's API click tracking, defines data payload and headers, sends a POST request to track clicks, and parses JSON response for success and link extraction.",
        "type": "summary"
    },
    "3022": {
        "file_id": 351,
        "content": "url = \"https://api.bilibili.com/x/share/click\"\n# url = \"https://111.19.247.143/x/share/click\"\n# is it api.bilibili.com?\n# yes, it is.\n# use post.\n# the damn picture?\n# the damn picture is generated. it needs to be uploaded to tencent.\n# url = \"https://api.bilibili.com/x/share/click\"\n# burl=\"https://www.bilibili.com/video/BV1Wv41157Wz\"\n# burl = \"https://www.bilibili.com/v/pay/charge?upmid=85300402&upurl=%2F%2Fspace.bilibili.com%2F85300402&upname=J4D&upavatar=https%3A%2F%2Fi1.hdslb.com%2Fbfs%2Fface%2F73f1323696c857eb5f47f4a8bd03c1115a056af1.jpg&oid=85300402&otype=up&from=zone\"\n# only from \n# burl = \"https://space.bilibili.com/85300402\" # my space.\nburl = \"https://www.bilibili.com/read/cv19232041\" # my article with e-begging\ndata = {\n    \"build\": 6700300,\n        \"buvid\": 0,\n        \"oid\": burl,\n        \"platform\": \"android\",\n        \"share_channel\": \"COPY\",\n        \"share_id\": \"public.webview.0.0.pv\",\n        \"share_mode\": 3,\n    }\nimport requests\nheaders={'user-agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36'}",
        "type": "code",
        "location": "/tests/bilibili_video_recommendation_server/bilibili_shortlink_get_2.py:1-24"
    },
    "3023": {
        "file_id": 351,
        "content": "This code sets the URL to interact with Bilibili's API for click tracking and defines the necessary data payload. The URL is set to \"https://api.bilibili.com/x/share/click\" after checking if it should use \"api.bilibili.com\". It then sets various parameters in the 'data' dictionary, such as 'oid', 'platform', and 'share_channel'. Finally, it defines headers for an HTTP request using requests library.",
        "type": "comment"
    },
    "3024": {
        "file_id": 351,
        "content": "r=requests.post(url, data=data,headers=headers) # maybe you two share the same user agent!\n# we have the link!\nif r.status_code == 200:\n    # print(r.content)\n    r_json=r.json()\n    code=r_json[\"code\"]\n    if code==0:\n        link=r_json[\"data\"]['content']\n        print(link)",
        "type": "code",
        "location": "/tests/bilibili_video_recommendation_server/bilibili_shortlink_get_2.py:25-33"
    },
    "3025": {
        "file_id": 351,
        "content": "Sending a POST request to the URL with data and headers. If the response status code is 200, parse JSON content, check for success (code=0), and extract the link if successful.",
        "type": "comment"
    },
    "3026": {
        "file_id": 352,
        "content": "/tests/bilibili_video_recommendation_server/ad_template_2.py",
        "type": "filepath"
    },
    "3027": {
        "file_id": 352,
        "content": "The code initializes and adjusts various objects, calculates aspect ratio, applies image transformations and text painting, creates a play button and QR code using Pixie library, handles ad images with masks, and considers night mode.",
        "type": "summary"
    },
    "3028": {
        "file_id": 352,
        "content": "import pixie\nfrom lazero.utils.importers import cv2_custom_build_init\ncv2_custom_build_init()\nimport cv2\ndef getImageW2H(image_path):\n    image = cv2.imread(image_path)\n    height, width = image.shape[:2]\n    w2h = width / height\n    return w2h\nnight_mode = True\nframework_only = False\n# framework_only=True\nad_width, ad_height = 1000, 1000\nfont_path = \"./wqy-microhei0.ttf\"\nfont_bold_path = \"./wqy-microhei1.ttf\"\ncover_path = \"sample_cover.jpg\"\nqrcode_path = \"MyQRCode1.png\"\nplay_button_path = \"play_white_b.png\"\n# play_button_path = \"play_b.png\"\nbilibili_logo_path = \"bili_white_b_cropped.png\"\nplay_count = comment_count = danmaku_count = \"1万\"\n# one extra space.\nstats_text = \" {}播放 {}评论 {}弹幕\".format(play_count, comment_count, danmaku_count)\nqrcode_scan_text = \"\\n\" + \"\\n\".join(list(\"扫码观看\"))\ntitle_text = \"真·朋克！揭秘《赛博朋克2077》屏幕之外的魔幻换弹操作\"\nwhite = pixie.Color(1, 1, 1, 1)\nblack = pixie.Color(0, 0, 0, 1)\nimage = pixie.Image(ad_width, ad_height)\n# we are creating this, not replacing qr code.\nif not framework_only:\n    if night_mode:",
        "type": "code",
        "location": "/tests/bilibili_video_recommendation_server/ad_template_2.py:1-38"
    },
    "3029": {
        "file_id": 352,
        "content": "This code reads an image, calculates its aspect ratio, and then performs various tasks like adjusting the font path based on the night mode, creating a QR code string and a stats text string. It also initializes an image object of specific dimensions and creates a white and black color objects using pixie library. If not in framework-only mode, it checks if night mode is active.",
        "type": "comment"
    },
    "3030": {
        "file_id": 352,
        "content": "        image.fill(black)\n        # irreversible!\n    else:\n        image.fill(white)\nelse:\n    image2 = image.copy()  # as mask.\n# place the cover.\ncover_w2h = getImageW2H(cover_path)\ncover_width = int(ad_width * 0.9)\ncover_height = int(cover_width / cover_w2h)\ncover_round_corner_radius = int(ad_width * 0.05)\ncover = pixie.read_image(cover_path)\ncover = cover.resize(cover_width, cover_height)\n# cover gradient.\ngradient_paint = pixie.Paint(pixie.LINEAR_GRADIENT_PAINT)\ngradient_paint.gradient_handle_positions.append(\n    pixie.Vector2(100, int(cover_height) * 0.8)\n)\ngradient_paint.gradient_handle_positions.append(pixie.Vector2(100, cover_height))\ngradient_paint.gradient_stops.append(pixie.ColorStop(pixie.Color(0, 0, 0, 0), 0))\ngradient_paint.gradient_stops.append(pixie.ColorStop(pixie.Color(0, 0, 0, 0.3), 1))\ncover_mask_path = pixie.Path()\ncover_mask_path.rounded_rect(\n    0, 0, cover_width, cover_height, *([cover_round_corner_radius] * 4)\n)\nstroke_param = 100\nstroke_width = int(ad_width / stroke_param)\nstroke_width_half = int(ad_width / stroke_param / 2)",
        "type": "code",
        "location": "/tests/bilibili_video_recommendation_server/ad_template_2.py:39-71"
    },
    "3031": {
        "file_id": 352,
        "content": "Code resizes cover image to fit 90% of the ad width, sets round corner radius for the cover, reads cover image and creates a gradient paint with two handle positions and color stops. It also generates a rounded rectangular mask path for the cover.",
        "type": "comment"
    },
    "3032": {
        "file_id": 352,
        "content": "cover_mask_path2 = pixie.Path()\ncover_round_corner_radius2 = int(cover_round_corner_radius * 0.85)\ncover_mask_path2.rounded_rect(\n    stroke_width_half,\n    stroke_width_half,\n    cover_width - stroke_width,\n    cover_height - stroke_width,\n    *([cover_round_corner_radius2] * 4)\n)\n# path = cover_mask_path\n# cover.fill_path(cover_mask_path, gradient_paint)\ncover_mask = pixie.Mask(cover_width, cover_height)\ncover_mask.fill_path(cover_mask_path)\ncover.mask_draw(cover_mask)\ncover_transform_width = cover_transform_height = int((ad_width - cover_width) / 2)\ncover_transform = pixie.translate(cover_transform_width, cover_transform_height)\nif framework_only:\n    # image2.fill(black)\n    image2_paint = pixie.Paint(pixie.SOLID_PAINT)\n    image2_paint.color = white\n    image2.fill_path(cover_mask_path, image2_paint, cover_transform)\ncover_stroke_paint = pixie.Paint(pixie.SOLID_PAINT)\ncover_stroke_paint.color = pixie.parse_color(\"#FC427B\")\nimage.stroke_path(\n    cover_mask_path,\n    cover_stroke_paint,\n    cover_transform,\n    stroke_width=stroke_width,",
        "type": "code",
        "location": "/tests/bilibili_video_recommendation_server/ad_template_2.py:72-110"
    },
    "3033": {
        "file_id": 352,
        "content": "This code generates a rounded rectangle mask for an image, applies it to the cover image, and applies a stroke paint with specific color. It also creates a Paint object for possible future use but does not fill in any content if framework_only is True. The stroke width is specified and the transformed width and height of the cover are calculated.",
        "type": "comment"
    },
    "3034": {
        "file_id": 352,
        "content": ")\nif not framework_only:\n    image.draw(cover, cover_transform)  # you can choose to discard the cover\nimage.fill_path(cover_mask_path2, gradient_paint, cover_transform)\n# now place the bilibili logo.\nbilibili_logo = pixie.read_image(bilibili_logo_path)\nbilibili_logo_w2h = getImageW2H(bilibili_logo_path)\nbilibili_logo_width = int(ad_width * 0.2)\nbilibili_logo_height = int(bilibili_logo_width / bilibili_logo_w2h)\nbilibili_logo = bilibili_logo.resize(bilibili_logo_width, bilibili_logo_height)\nbilibili_logo_transform = pixie.translate(\n    cover_transform_width + int(bilibili_logo_height / 8),\n    int(cover_transform_width + (bilibili_logo_height / 4)),\n)\n# bilibili_logo_transform = pixie.translate(\n#     cover_transform_width, 0\n# )\nimage.draw(bilibili_logo, bilibili_logo_transform)\n# now place the play button.\nplay_button = pixie.read_image(play_button_path)\nplay_button_w2h = getImageW2H(play_button_path)\nplay_button_width = play_button_height = int(ad_width * 0.2)\nplay_button = play_button.resize(play_button_width, play_button_height)",
        "type": "code",
        "location": "/tests/bilibili_video_recommendation_server/ad_template_2.py:111-138"
    },
    "3035": {
        "file_id": 352,
        "content": "This code draws a cover image and adds the Bilibili logo and play button on top of it. It resizes the logo and play button to be 20% of the ad width, applies gradient fill to the mask path, and positions the elements accordingly.",
        "type": "comment"
    },
    "3036": {
        "file_id": 352,
        "content": "play_button_transform = pixie.translate(\n    int(cover_transform_width + (cover_width - play_button_width) / 2),\n    int(cover_transform_width + (cover_height - play_button_height) / 2),\n)\nimage.draw(play_button, play_button_transform)\n# place some stats.\nfont = pixie.read_font(font_path)\nfont.size = int(ad_width * 0.04)\nfont.paint.color = pixie.Color(1, 1, 1, 1)\nstats_transform = pixie.translate(\n    int(cover_transform_width * 1.3),\n    cover_transform_width + cover_height - int(font.size * 2),\n)\nimage.fill_text(font, stats_text, transform=stats_transform)\n# place the qrcode.\nqrcode = pixie.read_image(qrcode_path)\nqrcode_width = qrcode_height = int(0.3 * ad_width)\nqrcode = qrcode.resize(qrcode_width, qrcode_height)\nfont = pixie.read_font(font_path)\nfont.size = int(ad_width * 0.04)\nif night_mode:\n    font.paint.color = pixie.Color(1, 1, 1, 1)\nelse:\n    font.paint.color = pixie.Color(0, 0, 0, 1)\nqrcode_scan_text_transform_x = int(ad_width - qrcode_width * 1.1 - font.size * 1)\nqrcode_scan_text_transform = pixie.translate(",
        "type": "code",
        "location": "/tests/bilibili_video_recommendation_server/ad_template_2.py:140-170"
    },
    "3037": {
        "file_id": 352,
        "content": "This code is positioning and drawing a play button, adding some stats text, placing a QR code with a scan text, and adjusting the font size and color. It uses the Pixie library for image transformations and text painting. The code also considers night mode settings to adjust font color accordingly.",
        "type": "comment"
    },
    "3038": {
        "file_id": 352,
        "content": "    qrcode_scan_text_transform_x + qrcode_width, int(ad_height - qrcode_height * 1.1)\n)\nimage.fill_text(font, qrcode_scan_text, transform=qrcode_scan_text_transform)\nqrcode_transform = pixie.translate(\n    int(ad_width - qrcode_width * 1.1 - font.size * 1.2),\n    int(ad_height - qrcode_height * 1.1),\n)\nqrcode_rounded_corner = int(0.05 * ad_width)\nqrcode_stroke_path = pixie.Path()\nqrcode_stroke_path.rounded_rect(\n    0, 0, qrcode_width, qrcode_height, *([qrcode_rounded_corner] * 4)\n)\nimage.stroke_path(\n    qrcode_stroke_path,\n    cover_stroke_paint,\n    qrcode_transform,\n    stroke_width=stroke_width,\n)\nqrcode_mask = pixie.Mask(qrcode_width, qrcode_width)\nqrcode_mask.fill_path(qrcode_stroke_path)\nqrcode.mask_draw(qrcode_mask)\nimage.draw(qrcode, qrcode_transform)\n# now for the title\nfont = pixie.read_font(font_bold_path)\nfont.size = int(ad_width * 0.06)\nif night_mode:\n    font.paint.color = pixie.parse_color(\"#B0B0B0\")\nelse:\n    font.paint.color = pixie.parse_color(\"#4F4F4F\")\n# use some gray text.\n# font.paint.color = pixie.parse_color(\"#4F42B5\")",
        "type": "code",
        "location": "/tests/bilibili_video_recommendation_server/ad_template_2.py:171-209"
    },
    "3039": {
        "file_id": 352,
        "content": "The code creates a QR code and a title using the Pixie library. It first calculates the positions for both elements, fills text in the QR code, defines rounded corners and stroke path for the QR code, masks the QR code with its stroke path, draws the QR code on the image, selects font for the title, adjusts font color based on night mode, and finally fills the title on the image.",
        "type": "comment"
    },
    "3040": {
        "file_id": 352,
        "content": "# font.paint.color = pixie.parse_color(\"#FC427B\")\n# font.paint.color = pixie.Color(0,0,0,1)\ntitle_text_transform = pixie.translate(\n    int(font.size * 0.8), int(ad_height - qrcode_height * 1.1)\n)\ntitle_text_bounds = pixie.Vector2(\n    int(qrcode_scan_text_transform_x - font.size * 1.1), int(qrcode_height)\n)\nimage.fill_text(\n    font, title_text, bounds=title_text_bounds, transform=title_text_transform\n)\ndelta = int(cover_width * 0.02)\nsub_image_params = (\n    cover_transform_width - delta,\n    cover_transform_height - delta,\n    cover_width + 2 * delta,\n    cover_height + 2 * delta,\n)\nstandalone_cover_image = image.sub_image(*sub_image_params)\nstandalone_cover_image.write_file(\"ad_2_standalone_cover.png\")\nimage.write_file(\"ad_2.png\")\nif framework_only:\n    image2.sub_image(*sub_image_params).write_file(\"ad_2_mask.png\")",
        "type": "code",
        "location": "/tests/bilibili_video_recommendation_server/ad_template_2.py:210-232"
    },
    "3041": {
        "file_id": 352,
        "content": "The code sets the font color, determines text transformation and bounds for a title, fills the text in the image, creates a standalone cover image with a margin, writes the main ad image and optional mask images.",
        "type": "comment"
    },
    "3042": {
        "file_id": 353,
        "content": "/tests/bilibili_video_recommendation_server/ad_template_1.py",
        "type": "filepath"
    },
    "3043": {
        "file_id": 353,
        "content": "The code utilizes the Pixie library to create an ad image with a QR code, avatar, and text by loading, resizing, transforming, masking, and drawing on the main picture. It also creates an avatar image with a rounded rectangle shape for Bilibili up and outputs the final result as \"ad_1.png\".",
        "type": "summary"
    },
    "3044": {
        "file_id": 353,
        "content": "# let's try to make it right.\npic_file = \"sample_cover.jpg\"\nqrcode_file = \"MyQRCode1.png\"\n# we need some font for this.\n# font_location = \"/usr/share/fonts/truetype/wqy/wqy-microhei.ttc\" # ttc -> ttf\nfont_location = \"./wqy-microhei0.ttf\"\nimport pixie\nfont = pixie.read_font(font_location)\nfont.size = 20\ntext = \"中文能够显示么 超出了字符边缘能不能显示 Typesetting is the arrangement and composition of text in graphic design and publishing in both digital and traditional medias.\"\n# 可以显示 但是边缘的字符需要被注意到 看看是不是超出了边界\nimage = pixie.Image(200, 200)\nimage.fill(pixie.Color(1, 1, 1, 1))\nimage.fill_text(\n    font, text, bounds=pixie.Vector2(180, 180), transform=pixie.translate(10, 10)\n)\n# print('image type:', type(image))\n# 'pixie.pixie.Image'\n# hard to say.\npath = pixie.Path()\npath.rounded_rect(0, 0, 100, 100, 25, 25, 25, 25)\n# how to use mask?\ncover_width, cover_height = 100, 100\nmask = pixie.Mask(cover_width, cover_height)  # must match mask size?\nmask.fill_path(path)\npicture = pixie.read_image(pic_file)\n# we need to reshape this.\npicture = picture.resize(",
        "type": "code",
        "location": "/tests/bilibili_video_recommendation_server/ad_template_1.py:1-36"
    },
    "3045": {
        "file_id": 353,
        "content": "Code snippet demonstrates image manipulation using the Pixie library. It loads a font file, composes text with it, and creates an image. Then, it creates a rounded rectangle path, applies a mask from that path on the image, and resizes it if needed.",
        "type": "comment"
    },
    "3046": {
        "file_id": 353,
        "content": "    cover_width, cover_height\n)  # recommend to do this in pyjom.imagetoolbox since that will be safer.\npicture.mask_draw(mask)\ntransform = pixie.translate(50, 50)\nqrcode_width = qrcode_height = 50\nqrcode_image = pixie.read_image(qrcode_file)\nqrcode_image = qrcode_image.resize(qrcode_width, qrcode_height)\nqrcode_transform = pixie.translate(150, 150)\nimage.draw(picture, transform=transform)\n# image.draw(picture)\n# image.draw(picture,transform=transform)\nimage.draw(qrcode_image, transform=qrcode_transform)\n# now we try to reverse engineer that thing.\n# not only we need to create ads, we need to modify ads on the fly.\n# detect qr code and replace the code with ours.\n# first of all, the picture needs to be big.\navatar_path = \"up_image.jpg\"\nup_name = \"J4D\"\navatar_width, avatar_height = 50, 50\npath2 = pixie.Path()\npath2.circle(25, 25, 25)\nmask2 = pixie.Mask(avatar_width, avatar_height)\nmask2.fill_path(path2)\navatar = pixie.read_image(avatar_path)\navatar = avatar.resize(avatar_width, avatar_height)\navatar.mask_draw(mask2)",
        "type": "code",
        "location": "/tests/bilibili_video_recommendation_server/ad_template_1.py:37-73"
    },
    "3047": {
        "file_id": 353,
        "content": "Code is creating an ad image with a QR code, avatar, and text. It first loads and resizes the QR code image, then applies transforms to draw it on the main picture. The avatar image is also loaded, resized, and masked with a circular shape before being drawn on the main picture.",
        "type": "comment"
    },
    "3048": {
        "file_id": 353,
        "content": "a_transform = pixie.translate(25, 25)\nimage.draw(avatar, a_transform)\nfont2 = pixie.read_font(font_location)\nfont2.size = 40\nfont2.paint.color = pixie.Color(0, 0.5, 0.953125, 1)\nval = image.fill_text(font2, up_name, transform=pixie.translate(25 + 50, 20))\n# print('VAL',val) # NONE\npath4 = pixie.Path()\npath4.rounded_rect(25+50+50+5,20+5, 90,40, 10,10,10,10)\nmask4 = pixie.Mask(200,200)\nmask4.fill_path(path4)\nimage2 = image.copy()\nimage2.mask_draw(mask4) #?\npath3 = pixie.Path()\npath3.rounded_rect(0,0,100,50,10,10,10,10)\npaint = pixie.Paint(pixie.SOLID_PAINT)\npaint.color = pixie.parse_color(\"#FC427B\")\ntransform3 = pixie.translate(25+50+50, 20)\nimage.fill_path(path3, paint, transform3)\nimage.draw(image2)\nlabel_text = \"UP主\"\nfont3 = pixie.read_font(font_location)\nfont3.size = 30\n# font3.paint.color = pixie.Color(1,0,1, 1)\nfont3.paint.color =  pixie.parse_color(\"#FC427B\")\nimage.fill_text(\n    font3, label_text, transform=pixie.translate(25 + 50 + 50, 20)\n)  # where should i put the thing?\nbilibili_logo_path = \"bilibili_transparent.png\"",
        "type": "code",
        "location": "/tests/bilibili_video_recommendation_server/ad_template_1.py:74-115"
    },
    "3049": {
        "file_id": 353,
        "content": "This code creates an avatar image and applies various transformations, including text and masking operations, using the Pixie library. The final result is a binary image with a rounded rectangle shape and a text label for a Bilibili up.",
        "type": "comment"
    },
    "3050": {
        "file_id": 353,
        "content": "bilibili_logo = pixie.read_image(bilibili_logo_path)\nbilibili_logo = bilibili_logo.resize(50,100)\nimage.draw(bilibili_logo)\nplay_button_path = 'play_button.png'\nplay_button = pixie.read_image(play_button_path)\nplay_button = play_button.resize(50,50)\nt4 = pixie.translate(100,100)\nimage.draw(play_button, t4)\n# you can stroke path! what is it?\n# so no more masking here. we need some png magic.\n# we need to get the raw pixel data.\n# ['apply_opacity', 'arrangement_fill_text', 'arrangement_stroke_text', 'blur', 'copy', 'draw', 'fill', 'fill_gradient', 'fill_path', 'fill_text', 'flip_horizontal', 'flip_vertical', 'get_color', 'height', 'invert', 'magnify_by2', 'mask_draw', 'minify_by2', 'new_context', 'new_mask', 'ref', 'resize', 'set_color', 'shadow', 'stroke_path', 'stroke_text', 'sub_image', 'super_image', 'width', 'write_file']\n# raw_pixel = image.\n# print(dir(image))\n# breakpoint()\n# sorry you cannot do this.\n# image.write_file(\"ad_1.png\")",
        "type": "code",
        "location": "/tests/bilibili_video_recommendation_server/ad_template_1.py:117-135"
    },
    "3051": {
        "file_id": 353,
        "content": "This code reads image files, resizes them, and draws them onto a canvas. It also performs translations and possibly has the capability to apply opacity and stroke path effects. The code then writes the final image as \"ad_1.png\".",
        "type": "comment"
    },
    "3052": {
        "file_id": 354,
        "content": "/tests/bilibili_video_recommendation_server/ad_template_0.py",
        "type": "filepath"
    },
    "3053": {
        "file_id": 354,
        "content": "The code generates a bilibili video recommendation visual using Pixie library, involving avatars, rounded rectangles, and logos for the final image.",
        "type": "summary"
    },
    "3054": {
        "file_id": 354,
        "content": "# let's try to make it right.\npic_file = \"sample_cover.jpg\"\nqrcode_file = \"MyQRCode1.png\"\n# we need some font for this.\n# font_location = \"/usr/share/fonts/truetype/wqy/wqy-microhei.ttc\" # ttc -> ttf\nfont_location = \"./wqy-microhei0.ttf\"\nimport pixie\nfont = pixie.read_font(font_location)\nfont.size = 20\ntext = \"中文能够显示么 超出了字符边缘能不能显示 Typesetting is the arrangement and composition of text in graphic design and publishing in both digital and traditional medias.\"\n# 可以显示 但是边缘的字符需要被注意到 看看是不是超出了边界\nimage = pixie.Image(200, 200)\nimage.fill(pixie.Color(1, 1, 1, 1))\nimage.fill_text(\n    font, text, bounds=pixie.Vector2(180, 180), transform=pixie.translate(10, 10)\n)\n# print('image type:', type(image))\n# 'pixie.pixie.Image'\n# hard to say.\npath = pixie.Path()\npath.rounded_rect(0, 0, 100, 100, 25, 25, 25, 25)\n# how to use mask?\ncover_width, cover_height = 100, 100\nmask = pixie.Mask(cover_width, cover_height)  # must match mask size?\nmask.fill_path(path)\npicture = pixie.read_image(pic_file)\n# we need to reshape this.\npicture = picture.resize(",
        "type": "code",
        "location": "/tests/bilibili_video_recommendation_server/ad_template_0.py:1-36"
    },
    "3055": {
        "file_id": 354,
        "content": "Code snippet is trying to create an image with Chinese text and a rounded rectangle mask. It loads a font file, sets its size, fills the image with white color, draws text using the loaded font, creates a path for a rounded rectangle, generates a mask of the rectangle shape, reads an existing image (sample_cover.jpg), and aims to resize it while maintaining aspect ratio.",
        "type": "comment"
    },
    "3056": {
        "file_id": 354,
        "content": "    cover_width, cover_height\n)  # recommend to do this in pyjom.imagetoolbox since that will be safer.\npicture.mask_draw(mask)\ntransform = pixie.translate(50, 50)\nqrcode_width = qrcode_height = 50\nqrcode_image = pixie.read_image(qrcode_file)\nqrcode_image = qrcode_image.resize(qrcode_width, qrcode_height)\nqrcode_transform = pixie.translate(150, 150)\nimage.draw(picture, transform=transform)\n# image.draw(picture)\n# image.draw(picture,transform=transform)\nimage.draw(qrcode_image, transform=qrcode_transform)\n# now we try to reverse engineer that thing.\n# not only we need to create ads, we need to modify ads on the fly.\n# detect qr code and replace the code with ours.\n# first of all, the picture needs to be big.\navatar_path = \"up_image.jpg\"\nup_name = \"J4D\"\navatar_width, avatar_height = 50, 50\npath2 = pixie.Path()\npath2.circle(25, 25, 25)\nmask2 = pixie.Mask(avatar_width, avatar_height)\nmask2.fill_path(path2)\navatar = pixie.read_image(avatar_path)\navatar = avatar.resize(avatar_width, avatar_height)\navatar.mask_draw(mask2)",
        "type": "code",
        "location": "/tests/bilibili_video_recommendation_server/ad_template_0.py:37-73"
    },
    "3057": {
        "file_id": 354,
        "content": "The code creates an ad image with a QR code and avatar. It reads the QR code image, resizes it, and applies a mask. Then, it reads the avatar image, resizes it, and applies a mask as well. Finally, it combines these elements into the final ad image.",
        "type": "comment"
    },
    "3058": {
        "file_id": 354,
        "content": "a_transform = pixie.translate(25, 25)\nimage.draw(avatar, a_transform)\nfont2 = pixie.read_font(font_location)\nfont2.size = 40\nfont2.paint.color = pixie.Color(0, 0.5, 0.953125, 1)\nval = image.fill_text(font2, up_name, transform=pixie.translate(25 + 50, 20))\n# print('VAL',val) # NONE\npath3 = pixie.Path()\npath3.rounded_rect(0,0,100,50,10,10,10,10)\npaint = pixie.Paint(pixie.SOLID_PAINT)\npaint.color = pixie.parse_color(\"#FC427B\")\ntransform3 = pixie.translate(25+50+50, 20)\nimage.fill_path(path3, paint, transform3)\nlabel_text = \"UP主\"\nfont3 = pixie.read_font(font_location)\nfont3.size = 30\nfont3.paint.color = pixie.Color(1,1,1, 1)\nimage.fill_text(\n    font3, label_text, transform=pixie.translate(25 + 50 + 50, 20)\n)  # where should i put the thing?\nbilibili_logo_path = \"bilibili_transparent.png\"\nbilibili_logo = pixie.read_image(bilibili_logo_path)\nbilibili_logo = bilibili_logo.resize(50,100)\nimage.draw(bilibili_logo)\nplay_button_path = 'play_button.png'\nplay_button = pixie.read_image(play_button_path)\nplay_button = play_button.resize(50,50)",
        "type": "code",
        "location": "/tests/bilibili_video_recommendation_server/ad_template_0.py:74-110"
    },
    "3059": {
        "file_id": 354,
        "content": "This code section is responsible for generating a visual representation of a bilibili video recommendation. It uses the Pixie library to handle image manipulation and drawing, and involves steps such as drawing an avatar, painting text, creating a rounded rectangle, filling the shape, and adding logos. The final result is likely used in a user interface for displaying video recommendations.",
        "type": "comment"
    },
    "3060": {
        "file_id": 354,
        "content": "t4 = pixie.translate(100,100)\nimage.draw(play_button, t4)\n# so no more masking here. we need some png magic.\nimage.write_file(\"ad_0.png\")",
        "type": "code",
        "location": "/tests/bilibili_video_recommendation_server/ad_template_0.py:111-115"
    },
    "3061": {
        "file_id": 354,
        "content": "This code is translating a coordinate (100, 100) using Pixie, then drawing the play_button image over it. Since no more masking is needed, the resulting image is saved as \"ad_0.png\" using png magic.",
        "type": "comment"
    },
    "3062": {
        "file_id": 355,
        "content": "/tests/bilibili_video_recommendation_server/xml_and_json_qq_send/view_qq.sh",
        "type": "filepath"
    },
    "3063": {
        "file_id": 355,
        "content": "This code is using the mitmproxy tool to read a log file named \"qq.log\" for analysis or debugging purposes.",
        "type": "summary"
    },
    "3064": {
        "file_id": 355,
        "content": "mitmproxy -r qq.log",
        "type": "code",
        "location": "/tests/bilibili_video_recommendation_server/xml_and_json_qq_send/view_qq.sh:1-1"
    },
    "3065": {
        "file_id": 355,
        "content": "This code is using the mitmproxy tool to read a log file named \"qq.log\" for analysis or debugging purposes.",
        "type": "comment"
    },
    "3066": {
        "file_id": 356,
        "content": "/tests/bilibili_video_recommendation_server/xml_and_json_qq_send/view_bilibili_qq_share_xml.sh",
        "type": "filepath"
    },
    "3067": {
        "file_id": 356,
        "content": "The provided code is running \"mitmproxy\" and redirecting the log file named \"bilibili_qq_xml_share.log\". This likely involves capturing and analyzing network traffic between a client (possibly a Bilibili app) and their servers, potentially to study video recommendations or QQ sharing feature behavior.",
        "type": "summary"
    },
    "3068": {
        "file_id": 356,
        "content": "mitmproxy -r bilibili_qq_xml_share.log",
        "type": "code",
        "location": "/tests/bilibili_video_recommendation_server/xml_and_json_qq_send/view_bilibili_qq_share_xml.sh:1-1"
    },
    "3069": {
        "file_id": 356,
        "content": "The provided code is running \"mitmproxy\" and redirecting the log file named \"bilibili_qq_xml_share.log\". This likely involves capturing and analyzing network traffic between a client (possibly a Bilibili app) and their servers, potentially to study video recommendations or QQ sharing feature behavior.",
        "type": "comment"
    },
    "3070": {
        "file_id": 357,
        "content": "/tests/bilibili_video_recommendation_server/xml_and_json_qq_send/upload_img2.py",
        "type": "filepath"
    },
    "3071": {
        "file_id": 357,
        "content": "This code utilizes the requests library for URL interactions, cookies, and binary file reading. It handles exact or archive-scale uploads based on URLs, with request headers providing metadata and content type info for image files, then sends POST requests with files, converting responses to JSON format.",
        "type": "summary"
    },
    "3072": {
        "file_id": 357,
        "content": "url = \"https://om.qq.com/image/orginalupload\"\n# php tencent: http://www.ygbks.com/2501.html gtimg\n# python sina: https://www.52pojie.cn/thread-1446200-1-1.html\n\"\"\"\nadd something like this in your website\n<img src='http://inews.gtimg.com/newsapp_ls/0/14966062446/0' width=\"200\"  referrerpolicy=\"no-referrer\" />\n\"\"\"\nfilePath = \"test_cover.jpg\"\nimport requests\n# with open(filepath, \"rb\") as f:\n#     content = f.read()\n# upload elsewhere.\nurl = \"https://om.qq.com/image/exactupload?relogin=1\"\npicUrl = \"https://open.gtimg.cn/open/app_icon/00/95/17/76/100951776_100_m.png\"\nurl = \"https://om.qq.com/image/archscaleupload?isRetImgAttr=1&relogin=1\"\ncookie = {\n\t\"alertclicked\": \"||\",\n\t\"appOmDownClose\": \"1\",\n\t\"csrfToken\": \"csrf-1666038340355\",\n\t\"iip\": \"0\",\n\t\"o_cookie\": \"917521610\",\n\t\"omaccesstoken\": \"00a8d53ee83b92ec4e3111998ca616ad566b9d6fe80814f1be12d2a5c1e7a267baf531f268514a1be2670c9e98da4549a31b36408ed199c6ccd0e069f62ba65438x0\",\n\t\"omtoken\": \"00a8d53ee83b92ec4e3111998ca616ad566b9d6fe80814f1be12d2a5c1e7a267baf531f268514a1be2670c9e98da4549a31b36408ed199c6ccd0e069f62ba65438x0\",",
        "type": "code",
        "location": "/tests/bilibili_video_recommendation_server/xml_and_json_qq_send/upload_img2.py:1-25"
    },
    "3073": {
        "file_id": 357,
        "content": "This code is making multiple requests to different URLs, likely for image uploading purposes. It uses the requests library to interact with the specified URLs and includes cookies for authentication. The code seems to involve various steps including reading a file, opening it in binary mode, and sending it for exact or archive scale upload depending on the URL.",
        "type": "comment"
    },
    "3074": {
        "file_id": 357,
        "content": "\t\"pac_uid\": \"1_917521610\",\n\t\"pgv_info\": \"ssid=s2914806624\",\n\t\"pgv_pvid\": \"977259220\",\n\t\"ptcz\": \"cff0fae128e230ac9cbdca6b44c812da07a8a27199142b3856073da30bd7d37f\",\n\t\"ptui_loginuin\": \"917521610@qq.com\",\n\t\"RK\": \"bNrVuDJjGZ\",\n\t\"ts_last\": \"om.qq.com/userReg/mediaInfo\",\n\t\"ts_uid\": \"6110293192\",\n\t\"TSID\": \"fg2om4ff3b0028rpbovnpafde1\",\n\t\"tvfe_boss_uuid\": \"ba12af7c5a70407c\",\n\t\"userid\": \"22690801\",\n\t\"wxky\": \"1\"\n}\ncookie_str = \"; \".join([\"{}:{}\".format(k, v) for k, v in cookie.items()])\nfiles = {\n    \"Filedata\": open(filePath, \"rb\"),\n    \"id\": \"WU_FILE_0\",\n    \"name\": \"test_cover.jpg\",\n    \"type\": \"image/jpeg\",\n    \"lastModifiedDate\": \"10/18/2022, 4:27:08 AM\",\n    'appKey':'1',\n    'isRetImgAttr':'1',\n    'from':'user',\n    'subModule':'userAuth_individual_head'\n}\nreq_headers = [\n\t\t\t{\n\t\t\t\t\"name\": \"Accept\",\n\t\t\t\t\"value\": \"*/*\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"name\": \"Accept-Encoding\",\n\t\t\t\t\"value\": \"gzip, deflate, br\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"name\": \"Accept-Language\",\n\t\t\t\t\"value\": \"en-US,en;q=0.5\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"name\": \"Connection\",\n\t\t\t\t\"value\": \"keep-alive\"\n\t\t\t},\n\t\t\t# {",
        "type": "code",
        "location": "/tests/bilibili_video_recommendation_server/xml_and_json_qq_send/upload_img2.py:26-68"
    },
    "3075": {
        "file_id": 357,
        "content": "The code is creating a request to upload an image file using the parameters provided in the cookie dictionary and request headers. The cookies are converted into a string format, and the image file is included with additional metadata in the files dictionary. The request headers include information about the desired content type, language preference, and connection type.",
        "type": "comment"
    },
    "3076": {
        "file_id": 357,
        "content": "\t\t\t# \t\"name\": \"Content-Length\",\n\t\t\t# \t\"value\": \"197582\"\n\t\t\t# },\n\t\t\t# {\n\t\t\t\t# \"name\": \"Content-Type\",\n\t\t\t\t# \"value\": \"multipart/form-data; boundary=---------------------------26791228924136332743854048233\"\n\t\t\t# },\n\t\t\t{ # do some cookie hook to get these data in playwright.\n\t\t\t\t\"name\": \"Cookie\",\n\t\t\t\t\"value\": \"userid=22690801; omaccesstoken=00a8d53ee83b92ec4e3111998ca616ad566b9d6fe80814f1be12d2a5c1e7a267baf531f268514a1be2670c9e98da4549a31b36408ed199c6ccd0e069f62ba65438x0\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"name\": \"Host\",\n\t\t\t\t\"value\": \"om.qq.com\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"name\": \"Origin\",\n\t\t\t\t\"value\": \"https://om.qq.com\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"name\": \"Referer\",\n\t\t\t\t\"value\": \"https://om.qq.com/userReg/mediaInfo\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"name\": \"Sec-Fetch-Dest\",\n\t\t\t\t\"value\": \"empty\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"name\": \"Sec-Fetch-Mode\",\n\t\t\t\t\"value\": \"cors\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"name\": \"Sec-Fetch-Site\",\n\t\t\t\t\"value\": \"same-origin\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"name\": \"User-Agent\",\n\t\t\t\t\"value\": \"Mozilla/5.0 (X11; Linux x86_64; rv:91.0) Gecko/20100101 Firefox/91.0\"\n\t\t\t}\n\t\t]\nheaders = {item['name']: item['value'] for item in req_headers}",
        "type": "code",
        "location": "/tests/bilibili_video_recommendation_server/xml_and_json_qq_send/upload_img2.py:69-109"
    },
    "3077": {
        "file_id": 357,
        "content": "This code defines a list of request headers, each represented by a dictionary containing 'name' and 'value'. The 'headers' variable is then generated using a dictionary comprehension, mapping the header names to their respective values. This structured format can be used for making API requests or handling HTTP communication in a program.",
        "type": "comment"
    },
    "3078": {
        "file_id": 357,
        "content": "respone = requests.post(url, files=files,headers=headers)\nres = respone.json()\nprint(res)",
        "type": "code",
        "location": "/tests/bilibili_video_recommendation_server/xml_and_json_qq_send/upload_img2.py:110-112"
    },
    "3079": {
        "file_id": 357,
        "content": "This code sends a POST request to a specified URL, including files in the request body using Python's requests library. The response is then converted to JSON format and stored in 'res', which is printed for output.",
        "type": "comment"
    },
    "3080": {
        "file_id": 358,
        "content": "/tests/bilibili_video_recommendation_server/xml_and_json_qq_send/upload_img.py",
        "type": "filepath"
    },
    "3081": {
        "file_id": 358,
        "content": "This Python script uses the requests library to upload an image to QQ platform, setting up necessary headers, cookies, and metadata for processing. It sends a POST request with session data and tokens to \"om.qq.com\" and prints the response in JSON format.",
        "type": "summary"
    },
    "3082": {
        "file_id": 358,
        "content": "url = \"https://om.qq.com/image/orginalupload\"\n# php tencent: http://www.ygbks.com/2501.html gtimg\n# python sina: https://www.52pojie.cn/thread-1446200-1-1.html\n\"\"\"\nadd something like this in your website\n<img src='http://inews.gtimg.com/newsapp_ls/0/14966062446/0' width=\"200\"  referrerpolicy=\"no-referrer\" />\n\"\"\"\nfilePath = \"test_cover.jpg\"\nimport requests\n# with open(filepath, \"rb\") as f:\n#     content = f.read()\n# upload elsewhere.\nurl = \"https://om.qq.com/image/exactupload?relogin=1\"\npicUrl = \"https://open.gtimg.cn/open/app_icon/00/95/17/76/100951776_100_m.png\"\nurl = \"https://om.qq.com/image/archscaleupload?isRetImgAttr=1&relogin=1\"\ncookie = {\n\t\"alertclicked\": \"||\",\n\t\"appOmDownClose\": \"1\",\n\t\"csrfToken\": \"csrf-1666038340355\",\n\t\"iip\": \"0\",\n\t\"o_cookie\": \"917521610\",\n\t\"omaccesstoken\": \"00a8d53ee83b92ec4e3111998ca616ad566b9d6fe80814f1be12d2a5c1e7a267baf531f268514a1be2670c9e98da4549a31b36408ed199c6ccd0e069f62ba65438x0\",\n\t\"omtoken\": \"00a8d53ee83b92ec4e3111998ca616ad566b9d6fe80814f1be12d2a5c1e7a267baf531f268514a1be2670c9e98da4549a31b36408ed199c6ccd0e069f62ba65438x0\",",
        "type": "code",
        "location": "/tests/bilibili_video_recommendation_server/xml_and_json_qq_send/upload_img.py:1-25"
    },
    "3083": {
        "file_id": 358,
        "content": "This code is attempting to upload an image to the QQ platform using Python. It first specifies the URL for uploading the image and provides a file path for the image. Then, it imports the requests library to handle the HTTP request for uploading the image. The code includes several different URLs for various types of uploads, as well as a dictionary of cookies necessary for authentication during the upload process.",
        "type": "comment"
    },
    "3084": {
        "file_id": 358,
        "content": "\t\"pac_uid\": \"1_917521610\",\n\t\"pgv_info\": \"ssid=s2914806624\",\n\t\"pgv_pvid\": \"977259220\",\n\t\"ptcz\": \"cff0fae128e230ac9cbdca6b44c812da07a8a27199142b3856073da30bd7d37f\",\n\t\"ptui_loginuin\": \"917521610@qq.com\",\n\t\"RK\": \"bNrVuDJjGZ\",\n\t\"ts_last\": \"om.qq.com/userReg/mediaInfo\",\n\t\"ts_uid\": \"6110293192\",\n\t\"TSID\": \"fg2om4ff3b0028rpbovnpafde1\",\n\t\"tvfe_boss_uuid\": \"ba12af7c5a70407c\",\n\t\"userid\": \"22690801\",\n\t\"wxky\": \"1\"\n}\ncookie_str = \";\".join([\"{}:{}\".format(k, v) for k, v in cookie.items()])\nfiles = {\n    \"Filedata\": open(filePath, \"rb\"),\n    \"id\": \"WU_FILE_0\",\n    \"name\": \"test_cover.jpg\",\n    \"type\": \"image/jpeg\",\n    \"lastModifiedDate\": \"10/18/2022, 4:27:08 AM\",\n    'appKey':'1',\n    'isRetImgAttr':'1',\n    'from':'user',\n    'subModule':'userAuth_individual_head'\n}\nreq_headers = [\n\t\t\t{\n\t\t\t\t\"name\": \"Accept\",\n\t\t\t\t\"value\": \"*/*\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"name\": \"Accept-Encoding\",\n\t\t\t\t\"value\": \"gzip, deflate, br\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"name\": \"Accept-Language\",\n\t\t\t\t\"value\": \"en-US,en;q=0.5\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"name\": \"Connection\",\n\t\t\t\t\"value\": \"keep-alive\"\n\t\t\t},\n\t\t\t# {",
        "type": "code",
        "location": "/tests/bilibili_video_recommendation_server/xml_and_json_qq_send/upload_img.py:26-68"
    },
    "3085": {
        "file_id": 358,
        "content": "This code sends an image file to the server for processing. It sets up necessary headers, converts cookie data into a string format, and includes relevant information like user IDs and timestamps in the request. The image is sent with additional metadata such as app key, ret img attr, and source module.",
        "type": "comment"
    },
    "3086": {
        "file_id": 358,
        "content": "\t\t\t# \t\"name\": \"Content-Length\",\n\t\t\t# \t\"value\": \"197582\"\n\t\t\t# },\n\t\t\t# {\n\t\t\t\t# \"name\": \"Content-Type\",\n\t\t\t\t# \"value\": \"multipart/form-data; boundary=---------------------------26791228924136332743854048233\"\n\t\t\t# },\n\t\t\t{\n\t\t\t\t\"name\": \"Cookie\",\n\t\t\t\t\"value\": \"pgv_pvid=977259220; pac_uid=1_917521610; RK=bNrVuDJjGZ; ptcz=cff0fae128e230ac9cbdca6b44c812da07a8a27199142b3856073da30bd7d37f; tvfe_boss_uuid=ba12af7c5a70407c; o_cookie=917521610; iip=0; TSID=fg2om4ff3b0028rpbovnpafde1; pgv_info=ssid=s2914806624; ts_last=om.qq.com/userReg/mediaInfo; ts_uid=6110293192; csrfToken=csrf-1666038340355; appOmDownClose=1; ptui_loginuin=917521610@qq.com; userid=22690801; omaccesstoken=00a8d53ee83b92ec4e3111998ca616ad566b9d6fe80814f1be12d2a5c1e7a267baf531f268514a1be2670c9e98da4549a31b36408ed199c6ccd0e069f62ba65438x0; omtoken=00a8d53ee83b92ec4e3111998ca616ad566b9d6fe80814f1be12d2a5c1e7a267baf531f268514a1be2670c9e98da4549a31b36408ed199c6ccd0e069f62ba65438x0; wxky=1; alertclicked=%7C%7C\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"name\": \"Host\",\n\t\t\t\t\"value\": \"om.qq.com\"",
        "type": "code",
        "location": "/tests/bilibili_video_recommendation_server/xml_and_json_qq_send/upload_img.py:69-82"
    },
    "3087": {
        "file_id": 358,
        "content": "This code represents a request with various headers, including \"Cookie\" header storing multiple QQ session data and tokens, and \"Host\" set to \"om.qq.com\".",
        "type": "comment"
    },
    "3088": {
        "file_id": 358,
        "content": "\t\t\t},\n\t\t\t{\n\t\t\t\t\"name\": \"Origin\",\n\t\t\t\t\"value\": \"https://om.qq.com\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"name\": \"Referer\",\n\t\t\t\t\"value\": \"https://om.qq.com/userReg/mediaInfo\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"name\": \"Sec-Fetch-Dest\",\n\t\t\t\t\"value\": \"empty\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"name\": \"Sec-Fetch-Mode\",\n\t\t\t\t\"value\": \"cors\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"name\": \"Sec-Fetch-Site\",\n\t\t\t\t\"value\": \"same-origin\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"name\": \"User-Agent\",\n\t\t\t\t\"value\": \"Mozilla/5.0 (X11; Linux x86_64; rv:91.0) Gecko/20100101 Firefox/91.0\"\n\t\t\t}\n\t\t]\nheaders = {item['name']: item['value'] for item in req_headers}\nrespone = requests.post(url, files=files,headers=headers)\nres = respone.json()\nprint(res)",
        "type": "code",
        "location": "/tests/bilibili_video_recommendation_server/xml_and_json_qq_send/upload_img.py:83-112"
    },
    "3089": {
        "file_id": 358,
        "content": "The code sends a POST request with specified headers to the given URL using requests library. It uses the provided headers for various purposes such as origin, referer, fetch destination mode, fetch site, and user agent. The response is then printed after converting it to JSON format.",
        "type": "comment"
    },
    "3090": {
        "file_id": 359,
        "content": "/tests/bilibili_video_recommendation_server/xml_and_json_qq_send/test_upload_xml_qq.py",
        "type": "filepath"
    },
    "3091": {
        "file_id": 359,
        "content": "The code creates an Action object for QQ messages, handles cover options, and sends XML/JSON messages using `sendFriendXml`/`sendGroupXml`. The \"SendMsgV2\" function sends a QQ message with XML content via a POST request to \"/v1/LuaApiCaller\", including the title, summary, and URL of a music file.",
        "type": "summary"
    },
    "3092": {
        "file_id": 359,
        "content": "from botoy import Action\nqq = 917521610\nport = 8784\naction = Action(qq=qq, port=port, host=\"127.0.0.1\")\nuser = 1281727431\n# but the goddamn xml format is not right.\n# cover = \"http://inews.gtimg.com/newsapp_bt/0/15352117085/640\"\ncover = \"http://pubminishare-30161.picsz.qpic.cn/d4ad36fa-833e-4018-b994-a2da810f2d54\"\n# just need a better cover. i don't know.\n# cover = \"https://i0.hdslb.com/bfs/archive/c5a0d18ee077fb6a4ac0970ccb0a3788e137d14f.jpg\" # works.\n# content = \"\"\"<?xml version='1.0' encoding='UTF-8' standalone='yes'?><msg templateID=\"123\" url=\"https://b23.tv/5K7qh7K?share_medium=android&amp;share_source=qq&amp;bbid=XY46C7C4C74C8D645671EF7E8F4CC7810054A&amp;ts=1657521142233\" serviceID=\"1\" action=\"web\" actionData=\"\" a_actionData=\"\" i_actionData=\"\" brief=\"[QQ小程序]哔哩哔哩\" flag=\"0\"><item layout=\"2\"><picture cover=\"{}\"/><title>哔哩哔哩</title><summary>【C语言】《带你学C带你飞》</summary></item><source url=\"https://b23.tv/5K7qh7K?share_medium=android&amp;share_source=qq&amp;bbid=XY46C7C4C74C8D645671EF7E8F4CC7810054A&",
        "type": "code",
        "location": "/tests/bilibili_video_recommendation_server/xml_and_json_qq_send/test_upload_xml_qq.py:1-12"
    },
    "3093": {
        "file_id": 359,
        "content": "The code is creating an Action object with QQ number, port, and host. It also includes a variable for the user, cover image URLs, and a template XML message with specific parameters. The current cover URL seems to be causing issues and there are alternative options provided.",
        "type": "comment"
    },
    "3094": {
        "file_id": 359,
        "content": "amp;ts=1657521142233\" icon=\"https://open.gtimg.cn/open/app_icon/00/95/17/76/100951776_100_m.png?t=1657091104\" name=\"哔哩哔哩\" appid=\"0\" action=\"web\" actionData=\"\" a_actionData=\"tencent0://\" i_actionData=\"\"/></msg>\"\"\".format(\n    # cover\n# )\n# content = \"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?><msg templateID=\"123\" url=\"https://b23.tv/uHML5mi?share_medium=android&amp;share_source=qq&amp;bbid=XY1BB721B1F97348DBDE4297FE1B4ABE26BAA&amp;ts=1666023406285\" serviceID=\"1\" action=\"web\" actionData=\"\" a_actionData=\"\" i_actionData=\"\" brief=\"[QQ小程序]哔哩哔哩\" flag=\"0\"><item layout=\"2\"><picture cover=\"{}\"/><title>【AI动画】妮露PV动画 风转换【NovelAI】</title></item><source url=\"https://b23.tv/uHML5mi?share_medium=android&amp;share_source=qq&amp;bbid=XY1BB721B1F97348DBDE4297FE1B4ABE26BAA&amp;ts=1666023406285\" icon=\"http://miniapp.gtimg.cn/public/appicon/432b76be3a548fc128acaa6c1ec90131_200.jpg\" name=\"哔哩哔哩\" appid=\"0\" action=\"app\" actionData=\"\" a_actionData=\"tencent0://\" i_actionData=\"\"/></msg>\"\"\".format(cover)\n# i guess, it is just the way it send the data is different.",
        "type": "code",
        "location": "/tests/bilibili_video_recommendation_server/xml_and_json_qq_send/test_upload_xml_qq.py:12-16"
    },
    "3095": {
        "file_id": 359,
        "content": "This code is formatting XML content for a QQ message template, including the URL, app icon, and app name. The code is using string formatting to replace placeholders with actual data before sending it via QQ.",
        "type": "comment"
    },
    "3096": {
        "file_id": 359,
        "content": "# result= action.sendFriendXml(user=user, content=content)\n# print(result)\n# content=\"\"\"{\"app\":\"com.tencent.gamecenter.gameshare\",\"desc\":\"\",\"view\":\"singleImg\",\"ver\":\"0.0.0.0\",\"prompt\":\"邪少QQXML论坛\",\"appID\":\"\",\"sourceName\":\"\",\"actionData\":\"\",\"actionData_A\":\"\",\"sourceUrl\":\"\",\"meta\":{\"singleImg\":{\"mainImage\":\"https://gchat.qpic.cn/gchatpic_new/3020005669/916530575-2949639428-6E45D21EADE33511C565E25AB432AB59/0?term=2\",\"mainUrl\":\"\"}},\"config\":{\"forward\":1},\"text\":\"\",\"sourceAd\":\"\"}\"\"\"\ngroup = 543780931\n# have error when sending group xml? why?\n# result = action.sendGroupXml(group=group, content=content)\n# successful!\n# this 'com.tencent.structmsg' might be our way. just maybe.\ncontent = \"\"\"{\"app\":\"com.tencent.structmsg\",\"desc\":\"\",\"view\":\"news\",\"ver\":\"0.0.0.1\",\"prompt\":\"邪少QQXML论坛\",\"appID\":100951776,\"sourceName\":\"\",\"actionData\":\"\",\"actionData_A\":\"\",\"sourceUrl\":\"\",\"meta\":{\"singleImg\":{\"mainImage\":\"https://gchat.qpic.cn/gchatpic_new/3020005669/916530575-2949639428-6E45D21EADE33511C565E25AB432AB59/0?term=2\",\"mainUrl\":\"\"}},\"text\":\"\",\"extraApps\":[],\"sourceAd\":\"\",\"config\":{\"forward\":1}}\"\"\"",
        "type": "code",
        "location": "/tests/bilibili_video_recommendation_server/xml_and_json_qq_send/test_upload_xml_qq.py:17-26"
    },
    "3097": {
        "file_id": 359,
        "content": "This code attempts to send XML messages using the `sendFriendXml` and `sendGroupXml` methods. The first content is intended for individual chats, while the second content is meant for group chats. It encounters an error when sending group XML and suggests that using \"com.tencent.structmsg\" might be a solution.",
        "type": "comment"
    },
    "3098": {
        "file_id": 359,
        "content": "# content = \"\"\"{\"app\":\"com.tencent.gamecenter.gameshare\",\"desc\":\"\",\"view\":\"singleImg\",\"ver\":\"0.0.0.0\",\"prompt\":\"邪少QQXML论坛\",\"appID\":\"\",\"sourceName\":\"\",\"actionData\":\"\",\"actionData_A\":\"\",\"sourceUrl\":\"\",\"meta\":{\"singleImg\":{\"mainImage\":\"https://gchat.qpic.cn/gchatpic_new/3020005669/916530575-2949639428-6E45D21EADE33511C565E25AB432AB59/0?term=2\",\"mainUrl\":\"\"}},\"text\":\"\",\"extraApps\":[],\"sourceAd\":\"\",\"config\":{\"forward\":1}}\"\"\"\n# content = \"\"\"<?xml version='1.0' encoding='UTF-8' standalone='yes' ?><msg templateID=\"123\" url=\"https://b23.tv/uHML5mi?share_medium=android&amp;share_source=qq&amp;bbid=XY1BB721B1F97348DBDE4297FE1B4ABE26BAA&amp;ts=1666023406285\" serviceID=\"1\" action=\"web\" actionData=\"\" a_actionData=\"\" i_actionData=\"\" brief=\"[QQ小程序]哔哩哔哩\" flag=\"0\"></msg>\"\"\"\nresult = action.sendGroupJson(group=group, content=content)\n# result = action.sendGroupXml(group=group, content=content)\nprint(result)\n# result = action.sendGroupText(group=group,content='test')\n# result = action.sendGroupText(group=group,content=content)",
        "type": "code",
        "location": "/tests/bilibili_video_recommendation_server/xml_and_json_qq_send/test_upload_xml_qq.py:27-33"
    },
    "3099": {
        "file_id": 359,
        "content": "Sending a group message in JSON format, with the option to send in XML format as well. The content variable holds the message data, and the result is the response from sending the message. Printing the result for further use or logging.",
        "type": "comment"
    }
}