{
    "2100": {
        "file_id": 210,
        "content": "            # treat each as a separate observation in this frame.\n            detections.append({\"identity\": label, \"confidence\": output})\n        dataList.append({\"detections\": detections})\n        # now we apply the thing? the yolov5 thing?\n    detectionConfidence = calculateVideoMeanDetectionConfidence(dataList)\n    filter_result = detectionConfidenceFilter(\n        detectionConfidence, filter_dict=filter_dict, logic=logic\n    )\n    # print(\"DATALIST\", dataList)\n    # print(\"DETECTION CONFIDENCE\", detectionConfidence)\n    # print(\"FILTER RESULT\", filter_result)\n    # breakpoint()\n    return filter_result\nvideoPaths = [\n    \"/root/Desktop/works/pyjom/samples/video/cute_cat_gif.mp4\",\n    \"/root/Desktop/works/pyjom/samples/video/dog_with_text.mp4\",\n    \"/root/Desktop/works/pyjom/samples/video/cat_invalid_without_mestimate.mp4\",\n    \"/root/Desktop/works/pyjom/samples/video/kitty_flash_15fps.gif\",\n    \"/root/Desktop/works/pyjom/samples/video/kitty_flash_15fps.mp4\",\n    \"/root/Desktop/works/pyjom/samples/video/kitty_flash_scaled.mp4\",",
        "type": "code",
        "location": "/tests/unittest_yolov5_dog_cat_filter_filesystemreviewer.py:335-356"
    },
    "2101": {
        "file_id": 210,
        "content": "This code appears to be part of a larger function that takes in video paths, processes each video file using YOLOv5 model for object detection, calculates the mean detection confidence per video, and then applies a filter to the detection confidences based on a specified filter dictionary and logic. The resulting filtered detection confidences are returned. The code seems to be part of a unit test case specifically for testing the dog/cat filter functionality.",
        "type": "comment"
    },
    "2102": {
        "file_id": 210,
        "content": "    \"/root/Desktop/works/pyjom/samples/video/nearly_duplicate_frames_detection_30fps.mp4\",\n]\nfor videoPath in videoPaths:  # this is for each file.\n    # sprint(result)\n    sprint(\"checking video: %s\" % videoPath)\n    filter_result = yolov5VideoDogCatDetector(\n        videoPath\n    )  # this is for short video. not for long video. long video needs to be sliced into smaller chunks\n    # sprint(\"FILTER PASSED?\", filter_result)\n    if not filter_result:\n        sprint(\"CHECKING WITH BEZIER CURVE AND RESNET50\")\n        filter_result = bezierPaddleHubResnet50VideoDogCatDetector(videoPath)\n    if not filter_result:\n        print(\"FILTER FAILED\")\n    else:\n        print(\"FILTER PASSED\")\n    # if not passed, hit it with the bezier curve and resnet50\n    # breakpoint()",
        "type": "code",
        "location": "/tests/unittest_yolov5_dog_cat_filter_filesystemreviewer.py:357-374"
    },
    "2103": {
        "file_id": 210,
        "content": "Iterates through video paths, checks if Yolov5 detector passes the filter. If not, applies Bezier Curve and Resnet50 detector. Prints \"FILTER PASSED\" or \"FILTER FAILED\" based on results.",
        "type": "comment"
    },
    "2104": {
        "file_id": 211,
        "content": "/tests/README.md",
        "type": "filepath"
    },
    "2105": {
        "file_id": 211,
        "content": "This code snippet aims to integrate a recommendation system into the existing LLM (Large Language Model) and scrapers. By doing so, it intends to enhance the overall performance and efficiency of the language model and web scraping processes.",
        "type": "summary"
    },
    "2106": {
        "file_id": 211,
        "content": "use recommendation system to enhance our LLM/scrapers",
        "type": "code",
        "location": "/tests/README.md:1-1"
    },
    "2107": {
        "file_id": 211,
        "content": "This code snippet aims to integrate a recommendation system into the existing LLM (Large Language Model) and scrapers. By doing so, it intends to enhance the overall performance and efficiency of the language model and web scraping processes.",
        "type": "comment"
    },
    "2108": {
        "file_id": 212,
        "content": "/tests/modify_package.sh",
        "type": "filepath"
    },
    "2109": {
        "file_id": 212,
        "content": "This script searches for Python files (.py), then replaces specific module imports (\"from modules\", \"from main\", etc.) with their new corresponding pyjom paths using sed command.",
        "type": "summary"
    },
    "2110": {
        "file_id": 212,
        "content": "find | grep -E \".py\\$\" | xargs -iabc sed -i \"s/from modules/from pyjom.modules/g\" abc\nfind | grep -E \".py\\$\" | xargs -iabc sed -i \"s/from main/from pyjom.main/g\" abc \nfind | grep -E \".py\\$\" | xargs -iabc sed -i \"s/from commons/from pyjom.commons/g\" abc\nfind | grep -E \".py\\$\" | xargs -iabc sed -i \"s/from config/from pyjom.config/g\" abc\nfind | grep -E \".py\\$\" | xargs -iabc sed -i \"s/from medialang/from pyjom.medialang/g\" abc\nfind | grep -E \".py\\$\" | xargs -iabc sed -i \"s/from primitives/from pyjom.primitives/g\" abc",
        "type": "code",
        "location": "/pyjom/modify_package.sh:1-6"
    },
    "2111": {
        "file_id": 212,
        "content": "This script searches for Python files (.py), then replaces specific module imports (\"from modules\", \"from main\", etc.) with their new corresponding pyjom paths using sed command.",
        "type": "comment"
    },
    "2112": {
        "file_id": 213,
        "content": "/tests/launch_test_enviroment.sh",
        "type": "filepath"
    },
    "2113": {
        "file_id": 213,
        "content": "The code is a shell script that launches various environments for testing and services, including servers, APIs, and multiple terminal instances for different tests. It includes commands to ensure proper execution without overlap or conflicts.",
        "type": "summary"
    },
    "2114": {
        "file_id": 213,
        "content": "cd /root/Desktop/works/pyjom/tests/\npython3 launch_test_enviroment.py\n# # launch bilibili recommendation server\n# cd /root/Desktop/works/pyjom/tests/bilibili_video_recommendation_server\n# gnome-terminal -- python3 /root/Desktop/works/pyjom/tests/bilibili_video_recommendation_server/test.py\n# # launch qq cqhttp\n# cd /root/Desktop/works/pyjom/tests/qq_go_cqhttp\n# gnome-terminal -- bash /root/Desktop/works/pyjom/tests/qq_go_cqhttp/launch.sh\n# # make sure milvus is running.\n# cd /root/Desktop/works/pyjom/tests/video_phash_deduplication/\n# bash /root/Desktop/works/pyjom/tests/video_phash_deduplication/config_milvus.sh\n# # launch netease api server. we need it to download new music, currently.\n# # video phash is the last step among all filters.\n# cd /root/Desktop/works/pyjom/externals/NeteaseCloudMusicApi\n# gnome-terminal -- bash /root/Desktop/works/pyjom/externals/NeteaseCloudMusicApi/launch.sh # port is 4042. port 4000 is used. don't know why.\n# # how to check avaliability of netease cloud music api?\n# cd /root/Desktop/works/pyjom/tests/karaoke_effects/",
        "type": "code",
        "location": "/tests/launch_test_enviroment.sh:1-23"
    },
    "2115": {
        "file_id": 213,
        "content": "The code is a shell script that launches various environments for testing and services, including a bilibili recommendation server, qq cqhttp, milvus, netease api server. It also includes commands to ensure the servers are running correctly and provides instructions on how to check the availability of the netease cloud music API.",
        "type": "comment"
    },
    "2116": {
        "file_id": 213,
        "content": "# gnome-terminal -- bash /root/Desktop/works/pyjom/tests/karaoke_effects/load_translator.sh\n# sleep 1\n# cd /root/Desktop/works/pyjom/tests/redis_music_info_persistance\n# gnome-terminal -- bash /root/Desktop/works/pyjom/tests/redis_music_info_persistance/launch_redis.sh\n# sleep 1\n# cd /root/Desktop/works/pyjom/tests/random_giphy_gifs/\n# gnome-terminal -- node /root/Desktop/works/pyjom/tests/random_giphy_gifs/nodejs_server.js\n# sleep 1\n# cd /root/Desktop/works/pyjom/tests/nsfw_violence_drug_detection\n# gnome-terminal -- node /root/Desktop/works/pyjom/tests/nsfw_violence_drug_detection/nsfwjs_test.js",
        "type": "code",
        "location": "/tests/launch_test_enviroment.sh:24-36"
    },
    "2117": {
        "file_id": 213,
        "content": "The code launches multiple terminal instances and scripts for different tests, with each instance running a specific script in the project's directory. The \"sleep 1\" command introduces a pause between commands to allow the previous terminal instance to start before proceeding. This ensures proper execution of each test without overlap or conflicts.",
        "type": "comment"
    },
    "2118": {
        "file_id": 214,
        "content": "/tests/launch_test_enviroment.py",
        "type": "filepath"
    },
    "2119": {
        "file_id": 214,
        "content": "The function launches programs, changes directory, and waits for sleep duration. It asserts file existence, handles errors, and runs commands using os.system(). The code sets up a test environment by launching processes and services, specifying options, handling errors, and providing debugging information.",
        "type": "summary"
    },
    "2120": {
        "file_id": 214,
        "content": "import time\nimport os\ndef launchProgramWithTerminal(\n    directory,\n    intepreter,\n    executable,\n    sleep=None,\n    no_terminal=False,\n    keep_on=True,  # preserve error log\n):\n    try:\n        if type(sleep) in [int, float]:\n            if sleep > 0:  # logic shortcut please?\n                time.sleep(sleep)\n            else:\n                raise Exception(\"negative or zero sleep duration:\", sleep)\n        directory = os.path.abspath(directory)\n        assert os.path.exists(directory)\n        os.chdir(directory)\n        executable_path = os.path.join(directory, executable)\n        assert os.path.exists(executable_path)\n        # mkeep_on = (\n        #     \"{}\"\n        #     if (not keep_on) or no_terminal\n        #     else \"bash -c \\\"{}; echo; echo 'error log above...'; date; bash;\\\"\"\n        # )\n        mkeep_on = (\n            \"{}\"\n            if not keep_on\n            else (\n                \"bash -c \\\"{}; if [[ '$!' -ne 0 ]] then; echo; echo 'error log above...'; date; bash; fi;\\\"\"\n                if no_terminal",
        "type": "code",
        "location": "/tests/launch_test_enviroment.py:1-34"
    },
    "2121": {
        "file_id": 214,
        "content": "This function launches a program with its associated terminal, changes directory to the specified path, and optionally waits for a sleep duration. It asserts the existence of the executable file and handles error logs based on keep_on and no_terminal flags.",
        "type": "comment"
    },
    "2122": {
        "file_id": 214,
        "content": "                else \"bash -c \\\"{}; echo; echo 'error log above...'; date; bash;\\\"\"\n            )\n        )\n        command = f'{\"gnome-terminal -- \" if not no_terminal else \"\"}{mkeep_on.format(f\"{intepreter} {executable_path}\")}'\n        return command\n    except:\n        import traceback\n        traceback.print_exc()\n        print(\"failed while launching program with parameters:\")\n        print(\n            f\"[D]:{directory}\\n[I]{intepreter}\\n[E]{executable}\\n[C]{dict(sleep=sleep, no_terminal=no_terminal)}\"\n        )\n        breakpoint()\n    return None\ndef executeCommand(command):\n    print(\"executing command:\", command)\n    os.system(command)\n# common paths\npyjom_directory = \"/root/Desktop/works/pyjom\"\npyjom_tests = os.path.join(pyjom_directory, \"tests\")\npyjom_externals = os.path.join(pyjom_directory, \"externals\")\nkeepalive_bin = '/usr/local/bin/keepalive'\n# interpreters\nnode_exec = \"/usr/bin/node\"\npython3_exec = \"/usr/bin/python3\"\nbash_exec = \"/bin/bash\"\nlaunchList = [\n    # launch billibili recommendation server",
        "type": "code",
        "location": "/tests/launch_test_enviroment.py:35-70"
    },
    "2123": {
        "file_id": 214,
        "content": "This code launches a program with specified parameters and optional Gnome Terminal. It handles potential errors by printing an exception traceback and breakpoint for debugging. The executeCommand function runs the generated command using os.system(). Common paths, interpreters, and a list of programs to launch are defined.",
        "type": "comment"
    },
    "2124": {
        "file_id": 214,
        "content": "    # do this in qq task.\n    # [\n    #     [\n    #         os.path.join(pyjom_tests, \"bilibili_video_recommendation_server\"),\n    #         python3_exec,\n    #         \"test.py\",\n    #     ],\n    #     {},\n    # ],\n    # launch qq cqhttp\n    [[os.path.join(pyjom_tests, \"qq_go_cqhttp\"), bash_exec, \"launch.sh\"], {}],\n    # make sure milvus is running.\n    [\n        [\n            os.path.join(pyjom_tests, \"video_phash_deduplication\"),\n            bash_exec,\n            \"config_milvus.sh\",\n        ],\n        dict(no_terminal=True),\n    ],\n    # launch netease api server. we need it to download new music, currently.\n    # video phash is the last step among all filters.\n    [\n        [os.path.join(pyjom_externals, \"NeteaseCloudMusicApi\"), bash_exec, \"launch.sh\"],\n        {},\n    ],  # port is 4042. port 4000 is used. don't know why.\n    # how to check avaliability of netease cloud music api?\n    [\n        [os.path.join(pyjom_tests, \"karaoke_effects\"), bash_exec, \"load_translator.sh\"],\n        {},\n    ],\n    [\n        [\n            os.path.join(pyjom_tests, \"redis_music_info_persistance\"),",
        "type": "code",
        "location": "/tests/launch_test_enviroment.py:71-104"
    },
    "2125": {
        "file_id": 214,
        "content": "This code is setting up a test environment by launching multiple processes and services. It includes tasks for the bilibili video recommendation server, QQ CQHTTP, Milvus database, Netease Cloud Music API, Karaoke effects, and Redis music info persistence. Each task consists of the location of the executable and any necessary arguments. The code ensures proper execution by specifying different options for each task.",
        "type": "comment"
    },
    "2126": {
        "file_id": 214,
        "content": "            bash_exec,\n            \"launch_redis.sh\",\n        ],\n        dict(sleep=1),\n    ],\n    [\n        [os.path.join(pyjom_tests, \"random_giphy_gifs\"), node_exec, \"nodejs_server.js\"],\n        dict(sleep=1),\n    ],\n    [\n        [\n            os.path.join(pyjom_tests, \"nsfw_violence_drug_detection\"),\n            node_exec,\n            \"nsfwjs_test.js\",\n        ],\n        dict(sleep=1),\n    ],\n    # [\n    #     [\n    #         os.path.join(pyjom_tests, \"bezier_paddlehub_dogcat_detector_serving\"),\n    #         python3_exec,\n    #         \"server.py\",\n    #     ],\n    #     dict(sleep=1),\n    # ],\n]\nfor argumentList, kwargs in launchList:\n    try:\n        assert type(kwargs) == dict\n        [directory, intepreter, executable] = argumentList\n        command = launchProgramWithTerminal(directory, intepreter, executable, **kwargs)\n        if command is None:\n            raise Exception(\"command is None\")\n        else:\n            executeCommand(command)\n    except:\n        import traceback\n        traceback.print_exc()\n        print(\"error when decomposing program launch parameters\")",
        "type": "code",
        "location": "/tests/launch_test_enviroment.py:105-145"
    },
    "2127": {
        "file_id": 214,
        "content": "The code defines a list of argument lists and their corresponding keyword arguments, then iterates through each set of arguments to launch different programs using the specified interpreter and executable. It handles potential errors by catching exceptions and printing the traceback for debugging purposes.",
        "type": "comment"
    },
    "2128": {
        "file_id": 214,
        "content": "        print(f\"[AL]{argumentList}\\n[KW]{kwargs}\")\n        breakpoint()",
        "type": "code",
        "location": "/tests/launch_test_enviroment.py:146-147"
    },
    "2129": {
        "file_id": 214,
        "content": "The code prints a formatted string containing the command-line arguments (in `argumentList`) and keyword arguments (in `kwargs`), then pauses execution at the breakpoint.",
        "type": "comment"
    },
    "2130": {
        "file_id": 215,
        "content": "/tests/experiment_iterate_and_merge_alike_text_regions.py",
        "type": "filepath"
    },
    "2131": {
        "file_id": 215,
        "content": "This code models a finite state machine, compares two lists of coordinates, and creates a new list based on similar elements and a threshold using nested loops. New items are printed and appended to the sample list, while prevList is copied for potential future use or comparison.",
        "type": "summary"
    },
    "2132": {
        "file_id": 215,
        "content": "# finite state machine.\nsample = [\n    [],\n    [],\n    [],\n    [],\n    [],\n    [],\n    [],\n    [],\n    [[98, 206, 37, 9]],\n    [[98, 200, 165, 137]],\n    [[98, 200, 165, 137]],\n    [[98, 200, 165, 137]],\n    [[98, 200, 165, 137]],\n    [[98, 200, 165, 137]],\n    [[98, 200, 165, 137]],\n    [],\n    [[5, 118, 88, 362]],\n    [[5, 118, 88, 362]],\n    [[5, 115, 89, 365]],\n    [[5, 115, 89, 365]],\n    [[2, 115, 92, 365]],\n    [[2, 115, 92, 365]],\n    [[2, 115, 92, 365]],\n    [[2, 115, 92, 365]],\n    [[2, 116, 91, 364]],\n    [[2, 116, 52, 364]],\n    [[2, 116, 52, 364]],\n    [[58, 242, 93, 238], [2, 117, 52, 363]],\n    [[58, 241, 94, 239], [7, 117, 47, 363]],\n    [[58, 240, 94, 240]],\n    [[58, 240, 94, 240]],\n    [[58, 240, 94, 240]],\n    [[58, 240, 94, 240]],\n    [[59, 240, 93, 240]],\n    [[59, 240, 93, 240]],\n    [[59, 241, 93, 239]],\n    [[59, 241, 93, 239]],\n    [[59, 241, 93, 239]],\n    [[59, 241, 93, 239]],\n    [],\n    [],\n    [],\n    [],\n    [],\n    [],\n    [],\n    [[92, 190, 23, 290]],\n    [[92, 190, 23, 290]],\n    [[92, 190, 23, 290]],",
        "type": "code",
        "location": "/tests/experiment_iterate_and_merge_alike_text_regions.py:1-51"
    },
    "2133": {
        "file_id": 215,
        "content": "This code represents a finite state machine where each sublist within the main list corresponds to a different state. The numbers within the sublists likely represent specific actions, values or conditions associated with that state.",
        "type": "comment"
    },
    "2134": {
        "file_id": 215,
        "content": "    [[90, 190, 25, 290]],\n    [[90, 190, 25, 290]],\n    [[90, 190, 25, 290]],\n    [[90, 190, 25, 290]],\n    [[90, 190, 25, 290]],\n    [[90, 190, 25, 290]],\n    [[92, 190, 23, 290]],\n    [[92, 190, 23, 290]],\n    [[92, 190, 23, 290]],\n    [],\n    [],\n    [],\n    [],\n    [],\n    [],\n    [],\n    [[31, 151, 7, 329]],\n    [[31, 151, 7, 329]],\n    [[31, 151, 7, 329]],\n    [[31, 149, 7, 331]],\n    [[31, 149, 7, 331]],\n    [[31, 149, 7, 331]],\n    [[31, 149, 7, 331]],\n    [[31, 149, 7, 331]],\n    [[31, 149, 7, 331]],\n    [[31, 149, 7, 331]],\n    [[31, 149, 7, 331]],\n    [],\n    [],\n    [],\n    [],\n]\nprevList = []\nnewList = []\nimport numpy as np\ndef alike(array0, array1, threshold):\n    npArray0, npArray1 = np.array(array0), np.array(array1)\n    return max(abs(npArray0 - npArray1)) <= threshold\nnewSample = []\nfor item in sample:\n    newItem = []\n    for elem in item:\n        for prevElem in prevList:\n            if alike(prevElem, elem, 10):\n                # mAlike = True\n                elem = prevElem.copy()\n                break\n        newItem.append(elem.copy())",
        "type": "code",
        "location": "/tests/experiment_iterate_and_merge_alike_text_regions.py:52-104"
    },
    "2135": {
        "file_id": 215,
        "content": "This code compares two lists of coordinates and checks if the elements within each list are similar to a certain threshold. It then creates a new list where similar elements are replaced with the previous element found in the 'prevList' variable. If an element is not similar, it is simply copied into the new list. The code also includes a nested loop that iterates over the sample and prevList variables to perform these operations.",
        "type": "comment"
    },
    "2136": {
        "file_id": 215,
        "content": "    print(newItem)  # showcase.\n    newSample.append(newItem.copy())\n    prevList = newItem.copy()",
        "type": "code",
        "location": "/tests/experiment_iterate_and_merge_alike_text_regions.py:105-107"
    },
    "2137": {
        "file_id": 215,
        "content": "In this code snippet, a new item is printed to showcase its contents, then it is appended to the sample list as a copy of itself, and finally, the previous list (prevList) is also copied for potential later use or comparison.",
        "type": "comment"
    },
    "2138": {
        "file_id": 216,
        "content": "/tests/dog_cat_demo_not_for_test.mdl",
        "type": "filepath"
    },
    "2139": {
        "file_id": 216,
        "content": "The code defines video properties and lists files in the \"/dev/shm/medialang/online\" directory, including details such as file paths, speeds, dimensions, durations, and silent settings. It includes two video configurations with normal speed, silent mode, and one video cut at 0.54 seconds.",
        "type": "summary"
    },
    "2140": {
        "file_id": 216,
        "content": "(\".mp4\", backend=\"editly\",\n    bgm=\"/root/Desktop/works/pyjom/tests/music_analysis/exciting_bgm.mp3\",\n    fast=true\n)\n# TODO: medialang lacks notes and texts, which might be useful for our video compilation.\n(\"/dev/shm/medialang/online/video_[giphy_gWkCsQZ4YlU1a]_[300x214].gif\",\n    video=true, slient=true, speed=1.043468,\n    cutFrom=0.0, cutTo=2.4\n)\n(\"/dev/shm/medialang/online/video_[giphy_2tNwXMxMpUAsiSbyck]_[480x270].gif\",\n    video=true, slient=true, speed=1.2,\n    cutFrom=0.0, cutTo=0.564027\n)\n(\"/dev/shm/medialang/online/video_[giphy_dTYI2Cu25gsTK]_[242x250].gif\",\n    video=true, slient=true, speed=1.006185,\n    cutFrom=0.0, cutTo=6.5\n)\n(\"/dev/shm/medialang/online/video_[giphy_5Y8xYjHG9AcjWlz23h]_[480x480].gif\",\n    video=true, slient=true, speed=0.997826,\n    cutFrom=0.0, cutTo=4.6\n)\n(\"/dev/shm/medialang/online/video_[giphy_iOGRWFLgGBRTxz7i22]_[270x480].gif\",\n    video=true, slient=true, speed=1.050456,\n    cutFrom=0.0, cutTo=10.2\n)\n(\"/dev/shm/medialang/online/video_[giphy_MB7AnGuoZ0ruqsFM1G]_[480x400].gif\",",
        "type": "code",
        "location": "/tests/dog_cat_demo_not_for_test.mdl:1-33"
    },
    "2141": {
        "file_id": 216,
        "content": "This code defines a series of video files with their properties such as file location, video settings (true/false), silence mode (true/false), playback speed, and time duration to be cut from the start and end. The code also mentions that there is a TODO task to add notes and texts to these videos for further use in video compilation.",
        "type": "comment"
    },
    "2142": {
        "file_id": 216,
        "content": "    video=true, slient=true, speed=0.934218,\n    cutFrom=0.0, cutTo=3.017544\n)\n(\"/dev/shm/medialang/online/video_[giphy_UuebWyG4pts3rboawU]_[480x480].gif\",\n    video=true, slient=true, speed=0.976488,\n    cutFrom=0.0, cutTo=5.4\n)\n(\"/dev/shm/medialang/online/video_[giphy_kOEYOwSaKbFra]_[350x197].gif\",\n    video=true, slient=true, speed=1.006486,\n    cutFrom=0.0, cutTo=9.3\n)\n(\"/dev/shm/medialang/online/video_[giphy_QGSEGsTr04bPW]_[450x254].gif\",\n    video=true, slient=true, speed=0.833326,\n    cutFrom=0.0, cutTo=2.3\n)\n(\"/dev/shm/medialang/online/video_[giphy_23kXtcba8igBvs8DQ1]_[400x225].gif\",\n    video=true, slient=true, speed=1.2,\n    cutFrom=0.0, cutTo=11.076082\n)\n(\"/dev/shm/medialang/online/video_[giphy_ANWIS2HYfROI8]_[250x250].gif\",\n    video=true, slient=true, speed=1.04277,\n    cutFrom=0.0, cutTo=5.297297\n)\n(\"/dev/shm/medialang/online/video_[giphy_3oEduYITQ7uOYLPZjq]_[480x270].gif\",\n    video=true, slient=true, speed=0.981427,\n    cutFrom=0.0, cutTo=4.985673\n)\n(\"/dev/shm/medialang/online/video_[giphy_26BRGvcRTuqWhoLzW]_[320x320].gif\",",
        "type": "code",
        "location": "/tests/dog_cat_demo_not_for_test.mdl:34-68"
    },
    "2143": {
        "file_id": 216,
        "content": "This code is listing multiple video files stored in \"/dev/shm/medialang/online/\" directory. Each file has specific properties like speed, cutFrom, and cutTo timings set for possible processing or playback.",
        "type": "comment"
    },
    "2144": {
        "file_id": 216,
        "content": "    video=true, slient=true, speed=0.937354,\n    cutFrom=0.0, cutTo=5.192982\n)\n(\"/dev/shm/medialang/online/video_[giphy_S3KIhtDGjLKWbnwtrQ]_[480x270].gif\",\n    video=true, slient=true, speed=0.990204,\n    cutFrom=0.0, cutTo=7.08\n)\n(\"/dev/shm/medialang/online/video_[giphy_JPayEyQPRCUTe]_[245x177].gif\",\n    video=true, slient=true, speed=0.93862,\n    cutFrom=0.0, cutTo=2.6\n)\n(\"/dev/shm/medialang/online/video_[giphy_TGKnLbfAzkk3DDNt8K]_[320x480].gif\",\n    video=true, slient=true, speed=1.096676,\n    cutFrom=0.0, cutTo=5.066667\n)\n(\"/dev/shm/medialang/online/video_[giphy_3boPPdHk2ueo8]_[480x270].gif\",\n    video=true, slient=true, speed=1.079128,\n    cutFrom=0.0, cutTo=3.0\n)\n(\"/dev/shm/medialang/online/video_[giphy_UvvK8rOSHPxgjo9ryD]_[728x728].gif\",\n    video=true, slient=true, speed=0.999996,\n    cutFrom=0.0, cutTo=6.0\n)\n(\"/dev/shm/medialang/online/video_[giphy_3o6fJ9cQXux6wfA2BO]_[480x264].gif\",\n    video=true, slient=true, speed=0.987647,\n    cutFrom=0.0, cutTo=3.2\n)\n(\"/dev/shm/medialang/online/video_[giphy_OOTtmh8oXrFK5ccNU7]_[460x460].gif\",",
        "type": "code",
        "location": "/tests/dog_cat_demo_not_for_test.mdl:69-103"
    },
    "2145": {
        "file_id": 216,
        "content": "The code provides a list of video files along with their properties such as file path, speed and duration. The videos are stored in \"/dev/shm/medialang/online\" directory and have the \".gif\" extension. All videos have \"video=true\", indicating they are video files, and \"slient=true\", indicating no audio track is present. The duration of each video is specified using \"cutFrom\" and \"cutTo\".",
        "type": "comment"
    },
    "2146": {
        "file_id": 216,
        "content": "    video=true, slient=true, speed=1.018824,\n    cutFrom=0.0, cutTo=4.004\n)\n(\"/dev/shm/medialang/online/video_[giphy_Dcf2hNSaAiLV6]_[400x300].gif\",\n    video=true, slient=true, speed=0.987007,\n    cutFrom=0.0, cutTo=6.84\n)\n(\"/dev/shm/medialang/online/video_[giphy_yXBqba0Zx8S4]_[480x324].gif\",\n    video=true, slient=true, speed=0.976134,\n    cutFrom=0.0, cutTo=4.5\n)\n(\"/dev/shm/medialang/online/video_[giphy_bhSi84uFsp66s]_[354x306].gif\",\n    video=true, slient=true, speed=1.026876,\n    cutFrom=0.0, cutTo=4.733945\n)\n(\"/dev/shm/medialang/online/video_[giphy_NmGbJwLl7Y4lG]_[480x270].gif\",\n    video=true, slient=true, speed=0.96385,\n    cutFrom=0.0, cutTo=4.0\n)\n(\"/dev/shm/medialang/online/video_[giphy_FOL5mK0tXUmXe]_[450x254].gif\",\n    video=true, slient=true, speed=0.830318,\n    cutFrom=0.0, cutTo=2.3\n)\n(\"/dev/shm/medialang/online/video_[giphy_77vjJEy9IRqJW]_[303x476].gif\",\n    video=true, slient=true, speed=1.192301,\n    cutFrom=0.0, cutTo=4.96\n)\n(\"/dev/shm/medialang/online/video_[giphy_T7nRl5WHw7Yru]_[320x240].gif\",",
        "type": "code",
        "location": "/tests/dog_cat_demo_not_for_test.mdl:104-138"
    },
    "2147": {
        "file_id": 216,
        "content": "This code represents a list of video files along with their properties. Each entry in the list contains the file path, video settings (true/false for video and sound, speed), and cut duration details. The files are stored in \"/dev/shm/medialang/online/\" directory.",
        "type": "comment"
    },
    "2148": {
        "file_id": 216,
        "content": "    video=true, slient=true, speed=0.883147,\n    cutFrom=0.0, cutTo=3.25\n)\n(\"/dev/shm/medialang/online/video_[giphy_37R1oJeXReoJW]_[291x294].gif\",\n    video=true, slient=true, speed=1.010094,\n    cutFrom=0.0, cutTo=7.0\n)\n(\"/dev/shm/medialang/online/video_[giphy_3oz8xEFHNzQE3VIRCE]_[480x490].gif\",\n    video=true, slient=true, speed=1.010619,\n    cutFrom=0.0, cutTo=4.2042\n)\n(\"/dev/shm/medialang/online/video_[giphy_Bkcls2eA8Fc6A]_[480x480].gif\",\n    video=true, slient=true, speed=1.2,\n    cutFrom=0.0, cutTo=10.692054\n)\n(\"/dev/shm/medialang/online/video_[giphy_11kgieHVYW53lC]_[480x360].gif\",\n    video=true, slient=true, speed=1.2,\n    cutFrom=0.0, cutTo=0.564027\n)\n(\"/dev/shm/medialang/online/video_[giphy_Ev17f0KeO9qkE]_[300x169].gif\",\n    video=true, slient=true, speed=0.817758,\n    cutFrom=0.0, cutTo=3.017544\n)\n(\"/dev/shm/medialang/online/video_[giphy_U7969wTwwtn6KBvEdA]_[384x480].gif\",\n    video=true, slient=true, speed=1.009003,\n    cutFrom=0.0, cutTo=3.733333\n)\n(\"/dev/shm/medialang/online/video_[giphy_IPUFTmRYZqG2s]_[480x270].gif\",",
        "type": "code",
        "location": "/tests/dog_cat_demo_not_for_test.mdl:139-173"
    },
    "2149": {
        "file_id": 216,
        "content": "This code contains a list of video file paths along with their properties such as whether they are silent, the playback speed, and the time duration to play.",
        "type": "comment"
    },
    "2150": {
        "file_id": 216,
        "content": "    video=true, slient=true, speed=0.973326,\n    cutFrom=0.0, cutTo=5.84\n)\n(\"/dev/shm/medialang/online/video_[giphy_hNRA4W7qJnbpK]_[389x415].gif\",\n    video=true, slient=true, speed=1.15384,\n    cutFrom=0.0, cutTo=4.8\n)\n(\"/dev/shm/medialang/online/video_[giphy_Ul2rAQJqNXp9S]_[400x225].gif\",\n    video=true, slient=true, speed=0.963845,\n    cutFrom=0.0, cutTo=4.0\n)\n(\"/dev/shm/medialang/online/video_[giphy_4MXO2o9MbPBi6M79G6]_[480x270].gif\",\n    video=true, slient=true, speed=0.99367,\n    cutFrom=0.0, cutTo=3.666667\n)\n(\"/dev/shm/medialang/online/video_[giphy_HC995u2L4I7mg]_[300x169].gif\",\n    video=true, slient=true, speed=0.817758,\n    cutFrom=0.0, cutTo=3.017544\n)\n(\"/dev/shm/medialang/online/video_[giphy_i0lkOcXmpcE92]_[400x225].gif\",\n    video=true, slient=true, speed=1.054048,\n    cutFrom=0.0, cutTo=3.9\n)\n(\"/dev/shm/medialang/online/video_[giphy_QxqqwXQuSWufNazWWU]_[448x450].gif\",\n    video=true, slient=true, speed=0.86666,\n    cutFrom=0.0, cutTo=5.2\n)\n(\"/dev/shm/medialang/online/video_[giphy_XlNkepH9WJO3C]_[245x160].gif\",",
        "type": "code",
        "location": "/tests/dog_cat_demo_not_for_test.mdl:174-208"
    },
    "2151": {
        "file_id": 216,
        "content": "The code contains a list of video files and their respective details, including file path, video settings (true/false), silent status (true/false), playback speed, and cut duration.",
        "type": "comment"
    },
    "2152": {
        "file_id": 216,
        "content": "    video=true, slient=true, speed=0.975598,\n    cutFrom=0.0, cutTo=3.6\n)\n(\"/dev/shm/medialang/online/video_[giphy_cEPFSJokR4hzi]_[480x270].gif\",\n    video=true, slient=true, speed=1.031923,\n    cutFrom=0.0, cutTo=8.08\n)\n(\"/dev/shm/medialang/online/video_[giphy_ghHZVf7kK9379nbcuh]_[442x468].gif\",\n    video=true, slient=true, speed=0.969893,\n    cutFrom=0.0, cutTo=3.578947\n)\n(\"/dev/shm/medialang/online/video_[giphy_5t7AJfJQnmsP5Tm1QS]_[480x480].gif\",\n    video=true, slient=true, speed=1.042304,\n    cutFrom=0.0, cutTo=6.733333\n)\n(\"/dev/shm/medialang/online/video_[giphy_x42zjj678Sr6M]_[420x241].gif\",\n    video=true, slient=true, speed=1.071709,\n    cutFrom=0.0, cutTo=7.92\n)\n(\"/dev/shm/medialang/online/video_[giphy_wBQa0CjlSySUE]_[320x180].gif\",\n    video=true, slient=true, speed=1.005696,\n    cutFrom=0.0, cutTo=8.82\n)\n(\"/dev/shm/medialang/online/video_[giphy_fJdpdS5jaDje8]_[361x194].gif\",\n    video=true, slient=true, speed=0.882244,\n    cutFrom=0.0, cutTo=5.302326\n)\n(\"/dev/shm/medialang/online/video_[giphy_IT4fLZjxyDu24]_[720x540].gif\",",
        "type": "code",
        "location": "/tests/dog_cat_demo_not_for_test.mdl:209-243"
    },
    "2153": {
        "file_id": 216,
        "content": "The code defines a list of video files with their respective parameters such as file path, video status, silent status, speed adjustment, and duration. These videos are stored in the \"/dev/shm/medialang/online\" directory and have different dimensions and durations.",
        "type": "comment"
    },
    "2154": {
        "file_id": 216,
        "content": "    video=true, slient=true, speed=0.83194,\n    cutFrom=0.0, cutTo=5.0\n)\n(\"/dev/shm/medialang/online/video_[giphy_q9ETKoMaBMsNy]_[300x300].gif\",\n    video=true, slient=true, speed=0.956076,\n    cutFrom=0.0, cutTo=6.16\n)\n(\"/dev/shm/medialang/online/video_[giphy_lQI2sf2qserJsrixfw]_[270x480].gif\",\n    video=true, slient=true, speed=0.992241,\n    cutFrom=0.0, cutTo=6.4\n)\n(\"/dev/shm/medialang/online/video_[giphy_MOgAd5Z2LZRHW]_[338x254].gif\",\n    video=true, slient=true, speed=1.2,\n    cutFrom=0.0, cutTo=0.564\n)\n(\"/dev/shm/medialang/online/video_[giphy_GSsTZNQjPvl1m]_[500x377].gif\",\n    video=true, slient=true, speed=1.2,\n    cutFrom=0.0, cutTo=0.564\n)\n(\"/dev/shm/medialang/online/video_[giphy_pCyN4mn4MbGCY]_[306x215].gif\",\n    video=true, slient=true, speed=0.984554,\n    cutFrom=0.0, cutTo=7.266055\n)\n(\"/dev/shm/medialang/online/video_[giphy_czpet1H4pnyAE]_[208x296].gif\",\n    video=true, slient=true, speed=1.074398,\n    cutFrom=0.0, cutTo=7.93985\n)\n(\"/dev/shm/medialang/online/video_[giphy_WhCYptDg5hgIg]_[181x180].gif\",",
        "type": "code",
        "location": "/tests/dog_cat_demo_not_for_test.mdl:244-278"
    },
    "2155": {
        "file_id": 216,
        "content": "The code provides information about different videos, including their file paths and details such as video and silent settings, playback speeds, and specific cut durations.",
        "type": "comment"
    },
    "2156": {
        "file_id": 216,
        "content": "    video=true, slient=true, speed=1.017585,\n    cutFrom=0.0, cutTo=7.52\n)\n(\"/dev/shm/medialang/online/video_[giphy_pytb6SgEJuPGE]_[250x246].gif\",\n    video=true, slient=true, speed=1.2,\n    cutFrom=0.0, cutTo=10.512054\n)\n(\"/dev/shm/medialang/online/video_[giphy_zUdFehNEYEMFi]_[406x293].gif\",\n    video=true, slient=true, speed=1.2,\n    cutFrom=0.0, cutTo=10.500082\n)\n(\"/dev/shm/medialang/online/video_[giphy_1xl9CXjjK64iFItin7]_[480x480].gif\",\n    video=true, slient=true, speed=1.2,\n    cutFrom=0.0, cutTo=0.552\n)\n(\"/dev/shm/medialang/online/video_[giphy_1WbITXJruDYLgYPPgy]_[400x480].gif\",\n    video=true, slient=true, speed=1.174338,\n    cutFrom=0.0, cutTo=8.666667\n)\n(\"/dev/shm/medialang/online/video_[giphy_l1Joh6GmLESwGYjmw]_[480x352].gif\",\n    video=true, slient=true, speed=1.2,\n    cutFrom=0.0, cutTo=0.552\n)\n(\"/dev/shm/medialang/online/video_[giphy_9EcYmq8ofAAkbIlooc]_[480x480].gif\",\n    video=true, slient=true, speed=1.2,\n    cutFrom=0.0, cutTo=0.552\n)\n(\"/dev/shm/medialang/online/video_[giphy_PdSfuPb8ZGV9P2w5IP]_[384x480].gif\",",
        "type": "code",
        "location": "/tests/dog_cat_demo_not_for_test.mdl:279-313"
    },
    "2157": {
        "file_id": 216,
        "content": "The code defines a list of video files along with their properties like video and silent status, speed, and cut duration. Each file is identified by its path and has the extension \".gif\". The video files are stored in the \"/dev/shm/medialang/online/\" directory.",
        "type": "comment"
    },
    "2158": {
        "file_id": 216,
        "content": "    video=true, slient=true, speed=1.2,\n    cutFrom=0.0, cutTo=0.552\n)\n(\"/dev/shm/medialang/online/video_[giphy_JQL87nbjGPYL52tCvF]_[270x480].gif\",\n    video=true, slient=true, speed=1.2,\n    cutFrom=0.0, cutTo=0.54\n)",
        "type": "code",
        "location": "/tests/dog_cat_demo_not_for_test.mdl:314-321"
    },
    "2159": {
        "file_id": 216,
        "content": "The code represents two video configurations with the following attributes:\n1. Both videos are set to play at normal speed (speed=1.2) and silent mode (silent=true).\n2. The first video will be played entirely, while the second video's duration will end at 0.54 seconds from the start (cutFrom=0.0, cutTo=0.54).",
        "type": "comment"
    },
    "2160": {
        "file_id": 217,
        "content": "/tests/check_json_update.py",
        "type": "filepath"
    },
    "2161": {
        "file_id": 217,
        "content": "The code imports necessary modules and defines a dictionary called mdict. It then prints the original dictionary, applies a JSON update operation on the \"b\" key within the \"a\" list, and finally prints the updated result.",
        "type": "summary"
    },
    "2162": {
        "file_id": 217,
        "content": "from test_commons import *\nfrom pyjom.commons import jsonUpdate\nmdict = {\"a\": [1, 2, 3, {\"b\": [4, 5]}]}\nprint(\"ORIGINAL:\", mdict)\njsonUpdate(mdict, [\"a\", 3, \"b\", 0], 2)\nprint(\"RESULT:\", mdict)",
        "type": "code",
        "location": "/tests/check_json_update.py:1-7"
    },
    "2163": {
        "file_id": 217,
        "content": "The code imports necessary modules and defines a dictionary called mdict. It then prints the original dictionary, applies a JSON update operation on the \"b\" key within the \"a\" list, and finally prints the updated result.",
        "type": "comment"
    },
    "2164": {
        "file_id": 218,
        "content": "/tests/apple_prores_encoding_play/test.sh",
        "type": "filepath"
    },
    "2165": {
        "file_id": 218,
        "content": "This script encodes a video file using FFmpeg with the prores_aw encoder and saves it in an Apple ProRes format. The code uses the vulkan hardware acceleration and sets the output container format to .mkv. It also provides alternative options for encoding in ProRes 422 or 4444 HQ, specifying profile, vendor, bits per MB, and pixel format. It mentions allowed container formats for ProRes as .mov, .mkv, and .mxf.",
        "type": "summary"
    },
    "2166": {
        "file_id": 218,
        "content": "videoPath=\"/root/Desktop/works/pyjom/samples/video/cute_cat_gif.mp4\"\n# prores_aw\nffmpeg -hwaccel vulkan -i $videoPath -c:v prores_ks  output.mkv\n# https://ottverse.com/ffmpeg-convert-to-apple-prores-422-4444-hq/#:~:text=FFmpeg%20contains%20two%20ProRes%20encoders%2C%20the%20prores-aw%20and,option%20to%20choose%20the%20ProRes%20profile%20to%20encode.\n# videoPath=\"/Users/jamesbrown/Desktop/works/pyjom_remote/samples/video/cute_cat_gif.mp4\"\n# ffmpeg -hwaccel videotoolbox -i $videoPath -c:v prores_ks  \\\n# -profile:v 4 \\\n# -vendor apl0 \\\n# -bits_per_mb 8000 \\\n# -pix_fmt yuva444p10le \\ \n# output.mov\n# Do remember to store the output in either of these three formats that are allowed as containers for the ProRes format.\n# .mov (QuickTime)\n# .mkv (Matroska)\n# .mxf (Material eXchange Format)",
        "type": "code",
        "location": "/tests/apple_prores_encoding_play/test.sh:1-16"
    },
    "2167": {
        "file_id": 218,
        "content": "This script encodes a video file using FFmpeg with the prores_aw encoder and saves it in an Apple ProRes format. The code uses the vulkan hardware acceleration and sets the output container format to .mkv. It also provides alternative options for encoding in ProRes 422 or 4444 HQ, specifying profile, vendor, bits per MB, and pixel format. It mentions allowed container formats for ProRes as .mov, .mkv, and .mxf.",
        "type": "comment"
    },
    "2168": {
        "file_id": 219,
        "content": "/tests/setu_server_mail_collector_ad_poster_personalization_java/README.md",
        "type": "filepath"
    },
    "2169": {
        "file_id": 219,
        "content": "This Java code sets up a server for Bilibli UIDs and collects personal interests by analyzing images. It requests an email address after some time if not initially provided, then shares tracker links in sent emails as ads.",
        "type": "summary"
    },
    "2170": {
        "file_id": 219,
        "content": "a simple setu server written in java.\nwill ask for bilibili uid\nwill ask for email address after a while (if not provided)\nwill collect personal interest on pictures (planned)\nwill post tracker links on ads in email",
        "type": "code",
        "location": "/tests/setu_server_mail_collector_ad_poster_personalization_java/README.md:1-9"
    },
    "2171": {
        "file_id": 219,
        "content": "This Java code sets up a server for Bilibli UIDs and collects personal interests by analyzing images. It requests an email address after some time if not initially provided, then shares tracker links in sent emails as ads.",
        "type": "comment"
    },
    "2172": {
        "file_id": 220,
        "content": "/tests/chatgpt_multiagent_agent_product_line_multimodal_langchain_experiments/test_chatgpt_cn_api.py",
        "type": "filepath"
    },
    "2173": {
        "file_id": 220,
        "content": "The code offers an online interface for ChatGPT API, streamlining development by loading API key and endpoint from a YAML file, setting environment variables, and using the OpenAI completion API to send messages, receive responses, and return replies.",
        "type": "summary"
    },
    "2174": {
        "file_id": 220,
        "content": "\"\"\"\nInterface for using the chatgpt api online service, without setting up locally.\nThis interface is used for development, not in production.\n\"\"\"\n# Do not treat the machine like people.\n# You need to handle them differently.\nfrom litellm import completion\nimport os\nimport yaml\napi_key_filepath = os.path.join(\n    os.path.expanduser(\"~\"), \".chatgpt_api_key.yaml\")\nif os.path.exists(api_key_filepath):\n    if os.path.isfile(api_key_filepath):\n        # Load YAML file\n        with open(api_key_filepath, 'r') as file:\n            data = yaml.load(file, Loader=yaml.FullLoader)\n            api_key = data['api_key']\n            endpoint = data['endpoint']\n    else:\n        raise Exception(\n            f\"API key path exists but found non-file object at: '{api_key_filepath}'\")\nelse:\n    raise Exception(f\"API key file not found in: '{api_key_filepath}'\")\nos.environ[\"OPENAI_API_KEY\"] = api_key\nos.environ[\"OPENAI_API_BASE\"] = endpoint\nmodel_tag = \"openai/gpt-3.5-turbo\"\ndef get_reply_from_chatgpt(content: str):\n    messages = [{\"content\": content, \"role\": \"user\"}]",
        "type": "code",
        "location": "/tests/chatgpt_multiagent_agent_product_line_multimodal_langchain_experiments/test_chatgpt_cn_api.py:1-37"
    },
    "2175": {
        "file_id": 220,
        "content": "This code provides an interface for using the ChatGPT API online service without setting up locally, specifically designed for development purposes. It handles loading the API key and endpoint from a YAML file, sets environment variables, and defines a function to get a reply from ChatGPT using provided content.",
        "type": "comment"
    },
    "2176": {
        "file_id": 220,
        "content": "    print(\"sending:\")\n    print(messages)\n    # openai call\n    # many info inside. you may want to take a look?\n    response = completion(model_tag, messages)\n    choices = response['choices']\n    reply_content = choices[0]['message']['content']\n    print(\"reply:\")\n    print(reply_content)\n    return reply_content",
        "type": "code",
        "location": "/tests/chatgpt_multiagent_agent_product_line_multimodal_langchain_experiments/test_chatgpt_cn_api.py:38-47"
    },
    "2177": {
        "file_id": 220,
        "content": "This code sends a message and receives a response using OpenAI's completion API. It prints the input messages, processes the response from the API, extracts the reply content, and returns it for further processing.",
        "type": "comment"
    },
    "2178": {
        "file_id": 221,
        "content": "/tests/chatgpt_multiagent_agent_product_line_multimodal_langchain_experiments/test_url_repair_extract_trace_media_source.py",
        "type": "filepath"
    },
    "2179": {
        "file_id": 221,
        "content": "The code defines functions to recover URLs, indexify them, and prompt for YouTube selection with utility functions for repairing content and retrieving selection IDs. It extracts, repairs, and selects YouTube URLs from a list by handling direct/indirect links and improving readability.",
        "type": "summary"
    },
    "2180": {
        "file_id": 221,
        "content": "from typing import Optional\ndef recover_prompt_constructor(info): return f\"\"\"\nPlease recover any URL from the given context. Every URL shall be visitable, starting with \"http://\" or \"https://\".\nContext:\n{info}\nURLs:\n\"\"\"\ndef indexify_string_list(string_list): return [\n    f'[{index}] {url}' for index, url in enumerate(string_list)]\ndef youtube_select_prompt_constructor(url_list): \n    urls_content = '\\n'.join(indexify_string_list(url_list))\n    return f\"\"\"\nPlease select URLs if they are directed to YouTube. I will give you URLs with index in front of them. Give your selection by selected indices in squared brackets separated by space like: [1] [3].\nURLs:\n{urls_content}\nSelected URLs:\n\"\"\"\nfrom test_chatgpt_cn_api import get_reply_from_chatgpt\ndef repair_content_with_url(info):\n    prompt = recover_prompt_constructor(info)\n    content = get_reply_from_chatgpt(prompt)\n    return content\nimport re\ndef get_youtube_selection_ids(urls):\n    prompt = youtube_select_prompt_constructor(urls)\n    response= get_reply_from_chatgpt(prompt)",
        "type": "code",
        "location": "/tests/chatgpt_multiagent_agent_product_line_multimodal_langchain_experiments/test_url_repair_extract_trace_media_source.py:2-42"
    },
    "2181": {
        "file_id": 221,
        "content": "This code defines functions to recover URLs from context, indexify them in a string list, and prompt the user to select YouTube URLs. It also includes utility functions for repairing content with URLs and getting YouTube selection IDs.",
        "type": "comment"
    },
    "2182": {
        "file_id": 221,
        "content": "    numbers = re.findall(r'\\[\\d+\\]', response)\n    indices = []\n    for num in numbers:\n        num = num.strip(\"[\").strip(']').strip()\n        num = int(num)\n        indices.append(num)\n    return indices\ndef select_youtube_urls(url_list, indices):\n    fatal_error:Optional[str]= None\n    selected_urls = []\n    index_errors = 0\n    url_counts = len(url_list)\n    max_index = url_counts-1\n    for index in indices:\n        try:\n            url = url_list[index]\n            print(\"selected:\", url)\n            selected_urls.append(url)\n        except IndexError:\n            index_errors += 1\n            # TODO: handle error by recursively letting the LLM knows the error and querying answer.\n            # TODO: determine if error is fatal (not recoverable in 5 iterations)\n            # TODO: eliminate possibility of external cause of fatal error by inferance\n            print('index not found: %d (max index is %d)' % (index, max_index))\n    print(\"summary\".center(80, \"=\"))\n    print(\"given url counts: %d\" % url_counts)",
        "type": "code",
        "location": "/tests/chatgpt_multiagent_agent_product_line_multimodal_langchain_experiments/test_url_repair_extract_trace_media_source.py:43-69"
    },
    "2183": {
        "file_id": 221,
        "content": "This code defines two functions, `extract_indices` and `select_youtube_urls`. The first function extracts indices from the response string using regular expressions. The second function takes a list of URLs and a list of indices, selects the corresponding URLs based on the provided indices, handles index errors, and returns the selected URLs. It also includes TODO comments for potential error handling and improvement suggestions.",
        "type": "comment"
    },
    "2184": {
        "file_id": 221,
        "content": "    print(\"selected url counts: %d\", len(selected_urls))\n    print(\"index errors: %d\" % index_errors)\n    return selected_urls\nfrom urlextract import URLExtract\nextractor = URLExtract()\ndef extract_url(content):\n    \"\"\"\n    Just extract the url. Do not repair.\n    \"\"\"\n    urls = extractor.find_urls(content)\n    return urls\ndef repair_and_get_repaired_url_list(info):\n    content = repair_content_with_url(info)\n    url_list = extract_url(content)\n    return url_list\nif __name__ == '__main__':\n    info_direct = \"\"\"\nYoutube\n原标题A Thousand Miles-Neco are(FULL VERSION)\nhttps://youtu.be/Ddpx0JLOH6o?si=zZMjAEFj_TOXkQct\n音频下载：\nhttps://wwxa.lanzouj.com/idPN81a5u4ab\n密码:5292\n\"\"\"\n    info_indirect = \"\"\"\n转自Youtube\n/watch?v=mSqRH4WwnnY // By :Encrypted Lobster\n\"\"\"\n    info_list = [info_direct, info_indirect]\n    for i, info in enumerate(info_list):\n        print(f\"processing info #{i}\")\n        print(info)\n        repaired_urls = repair_and_get_repaired_url_list(info)\n        indices = get_youtube_selection_ids(repaired_urls)\n        selected_urls = select_youtube_urls(repaired_urls, indices)",
        "type": "code",
        "location": "/tests/chatgpt_multiagent_agent_product_line_multimodal_langchain_experiments/test_url_repair_extract_trace_media_source.py:70-114"
    },
    "2185": {
        "file_id": 221,
        "content": "This code is extracting and repairing URLs from provided information. It first extracts URLs without repairing them, then repairs the content with any broken URLs and extracts the repaired URLs. The code handles both direct and indirect Youtube links, processes each info in the list, repairs URLs, selects YouTube URLs based on specified selection IDs, and finally returns the selected URLs.",
        "type": "comment"
    },
    "2186": {
        "file_id": 221,
        "content": "        print(\"selected urls:\")\n        for url in selected_urls:\n            print(f'\\t{url}')\n        print()",
        "type": "code",
        "location": "/tests/chatgpt_multiagent_agent_product_line_multimodal_langchain_experiments/test_url_repair_extract_trace_media_source.py:115-118"
    },
    "2187": {
        "file_id": 221,
        "content": "This code segment prints the selected URLs from a list. The 'for' loop iterates through each URL in the list and displays it with a tab character for readability, followed by a newline to separate each URL for better visualization.",
        "type": "comment"
    },
    "2188": {
        "file_id": 222,
        "content": "/tests/chatgpt_multiagent_agent_product_line_multimodal_langchain_experiments/README.md",
        "type": "filepath"
    },
    "2189": {
        "file_id": 222,
        "content": "The code mentions the power of chatgpt-like bots and plans to run one using CPU instead of a powerful GPU. It also suggests utilizing moderation API and openAI API for testing purposes. The bot will start with a simple task involving constructing/extracting URLs from video descriptions.",
        "type": "summary"
    },
    "2190": {
        "file_id": 222,
        "content": "chatgpt-like bots are powerful.\nwe will run one using cpu, since we don't always have a powerful gpu\nwe can also use moderation api & openai api for testing\nfirst we will give the bot a simple task to construct/extract url from video description.",
        "type": "code",
        "location": "/tests/chatgpt_multiagent_agent_product_line_multimodal_langchain_experiments/README.md:1-7"
    },
    "2191": {
        "file_id": 222,
        "content": "The code mentions the power of chatgpt-like bots and plans to run one using CPU instead of a powerful GPU. It also suggests utilizing moderation API and openAI API for testing purposes. The bot will start with a simple task involving constructing/extracting URLs from video descriptions.",
        "type": "comment"
    },
    "2192": {
        "file_id": 223,
        "content": "/tests/adb_phone_control_termux_network_broadcast_scrcpy_appium_airtest/README.md",
        "type": "filepath"
    },
    "2193": {
        "file_id": 223,
        "content": "This code covers device discovery, Termux daemon, remote unlock with ADB and scrcpy client, focused window titles, downloading a macOS keylogger, and executes input tests on the X server.",
        "type": "summary"
    },
    "2194": {
        "file_id": 223,
        "content": "device discovery, termux daemon, remote unlock\nunlock requires screenshot and input events.\nhttps://technastic.com/unlock-android-phone-pin-pattern-adb/\nclick ok after input password:\nhttps://stackoverflow.com/questions/29072501/how-to-unlock-android-phone-through-adb\nscrcpy client\nhttps://github.com/leng-yue/py-scrcpy-client\nhttps://leng-yue.github.io/py-scrcpy-client/guide.html#bind-events\nyou want to use android emulator on macos m1?\nhttps://github.com/google/android-emulator-m1-preview/releases/tag/0.3\ncheck android screen lock/unlock state\nhttps://android.stackexchange.com/questions/191086/adb-commands-to-get-screen-state-and-locked-state\nBonjour/Avahi/Zeroconf\nlogic: if the kill switch is off, when no physical input events happens, or not focused on scrcpy window with keyboard/mouse input events on pc for some time, allow to interact with the phone.\nget physical events:\nwarning: this command could be offline for a short period of time after using the scrcpy. must automatically reconnect if the device is not offline.",
        "type": "code",
        "location": "/tests/adb_phone_control_termux_network_broadcast_scrcpy_appium_airtest/README.md:1-30"
    },
    "2195": {
        "file_id": 223,
        "content": "This code focuses on device discovery, termux daemon, remote unlock, using scrcpy client and android emulator on MacOS M1. It includes links for unlocking Android phone through ADB, checking screen lock/unlock state, utilizing Bonjour/Avahi/Zeroconf logic, handling physical events and reconnecting if necessary.",
        "type": "comment"
    },
    "2196": {
        "file_id": 223,
        "content": "```bash\nadb -s 192.168.10.3:5555 shell getevent\n```\nto get focused window title:\nhint: for headless ssh sessions, must set apropriate xorg environment variables, eg: `env XAUTHORITY=\"/run/user/0/gdm/Xauthority\" DISPLAY=:1 python3`\ngeneral method:\n```python\nimport pywinctl\npywinctl.getActiveWindowTitle()\n```\nfor linux:\n```bash\nwatch -n 2 xdotool getactivewindow getwindowname\n```\nfor macos: (allow permission first, deprecated since it will not get the window title instead of the program name)\nhttps://alvinalexander.com/mac-os-x/applescript-unix-mac-osx-foreground-application-result/\n(where is the window name?)\n```bash\nsleep 3 && osascript -e 'tell application \"System Events\"' -e 'set frontApp to name of first application process whose frontmost is true' -e 'end tell'\n```\nto get input events on macos:\ndownload keylogger here:\nhttps://hackernoon.com/writing-an-keylogger-for-macos-in-python-24adfa22722\nhttps://github.com/beatsbears/pkl?ref=hackernoon.com\n```bash\npython pkl_nowriting.py\n```\ninput events on linux:\n```bash",
        "type": "code",
        "location": "/tests/adb_phone_control_termux_network_broadcast_scrcpy_appium_airtest/README.md:32-68"
    },
    "2197": {
        "file_id": 223,
        "content": "This code provides methods to obtain the focused window title on different operating systems: Bash commands for Android devices and Windows, Python script for Linux, Applescript for macOS. Additionally, it mentions downloading a keylogger for capturing input events on macOS.",
        "type": "comment"
    },
    "2198": {
        "file_id": 223,
        "content": "xinput test-xi2 --root\n```",
        "type": "code",
        "location": "/tests/adb_phone_control_termux_network_broadcast_scrcpy_appium_airtest/README.md:69-70"
    },
    "2199": {
        "file_id": 223,
        "content": "Executes an input test on the X server, affecting all connected devices.",
        "type": "comment"
    }
}