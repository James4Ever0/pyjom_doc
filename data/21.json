{
    "2100": {
        "file_id": 216,
        "content": "from tarot_descriptions import *\n# mdict, smdict2\nimport os\ndef gen_typography_part1(content):\n    with open(\"demo_text.log\",\"w+\",encoding=\"utf8\") as f:\n        f.write(content)\n    os.system(\"xvfb-run -s '-screen 0 1920x1080x24' python3 scriptable_generate_typography_with_voice.py\")\ndef kill_script():\n    os.system(\"bash kill_xb.sh\")\ntyp_0 = \"typo_0\"\ntyp_1 = \"typo_1\"\n# os.system(\"rm -rf {}\".format(typ_0))\n# os.system(\"rm -rf {}\".format(typ_1))\n# os.mkdir(typ_0)\n# os.mkdir(typ_1)\nfrom functional_voice_with_pictures import gen_typography_part2\ninter_text = \"\"\"再抽取一张牌吧~\"\"\"\nbgm_path = \"/root/Desktop/works/bilibili_tarot/tarot_random_shuffle.mp3\"\ntarget_video = \"intermediate_video.mp4\"\nos.system(\"rm {}\".format(target_video))\nkill_script()\n# v = mdict[k]\nv = inter_text\ngen_typography_part1(v)\n# target_video = \"/\".join([typ_0,\"{}.mp4\".format(k)])\ngen_typography_part2(v,bgm_path,target_video)\nkill_script()\nintro_text = \"\"\"塔罗牌，是一种针对人、事、物进行分析、预测和提供建议的工具，被称为“大自然的奥秘库”。\n抽取一张塔罗牌，今天的你会是怎样的呢？\"\"\"\n# intro_text =\n# bgm_path = \"/root/Desktop/works/bilibili_tarot/tarot_random_shuffle.mp3\"",
        "type": "code",
        "location": "/tests/bilibili_practices/bilibili_tarot/all_typography.py:1-46"
    },
    "2101": {
        "file_id": 216,
        "content": "The code imports modules and defines functions for generating typography with voice and video. It creates files, executes scripts, and generates intermediate videos for a tarot reading process. It also generates a final video after killing the script.",
        "type": "comment"
    },
    "2102": {
        "file_id": 216,
        "content": "# target_video = \"intro_video.mp4\"\n# os.system(\"rm {}\".format(target_video))\n# kill_script()\n# # v = mdict[k]\n# v = intro_text\n# gen_typography_part1(v)\n# # target_video = \"/\".join([typ_0,\"{}.mp4\".format(k)])\n# gen_typography_part2(v,bgm_path,target_video)\n# kill_script()\nbgms = [\"you_got_me_acc.wav\", \"tarot_desc_acc.wav\"]\n# outro_text = \"\"\"今天的你运气不错哦～\n# 喜欢的话请分享点赞，一键三联哦～\"\"\"\n# bgm_path = bgms[0]\n# target_video = \"outro_video.mp4\"\n# os.system(\"rm {}\".format(target_video))\n# kill_script()\n# # v = mdict[k]\n# v = outro_text\n# gen_typography_part1(v)\n# # target_video = \"/\".join([typ_0,\"{}.mp4\".format(k)])\n# gen_typography_part2(v,bgm_path,target_video)\n# kill_script()\nimport random\n# for k in mdict.keys():\n#     if k !=16:\n#         continue\n#     kill_script()\n#     v = mdict[k]\n#     gen_typography_part1(v)\n#     target_video = \"/\".join([typ_0,\"{}.mp4\".format(k)])\n#     gen_typography_part2(v,random.choice(bgms),target_video)\n#     kill_script()\n# for k in smdict.keys():\n#     v = smdict[k]\n#     # kill_script()\n#     # v = mdict[k]",
        "type": "code",
        "location": "/tests/bilibili_practices/bilibili_tarot/all_typography.py:48-93"
    },
    "2103": {
        "file_id": 216,
        "content": "The code removes the target video, generates typography for intro and outro text using different background music, and randomly selects a background music from the given list for each card in mdict and smdict.",
        "type": "comment"
    },
    "2104": {
        "file_id": 216,
        "content": "#     gen_typography_part1(v)\n#     target_video = \"/\".join([typ_1,\"{}.mp4\".format(k)])\n#     gen_typography_part2(v,random.choice(bgms),target_video)\n#     kill_script()",
        "type": "code",
        "location": "/tests/bilibili_practices/bilibili_tarot/all_typography.py:94-97"
    },
    "2105": {
        "file_id": 216,
        "content": "This code section generates typography for a video and stores it in a specific format. It first calls a function `gen_typography_part1` passing some parameter v, then combines the typography name with the video number as the file name. The next step is to call another function `gen_typography_part2`, which takes two parameters: v and a randomly chosen bgm (background music) from some list of choices. It also passes the target video file as an argument. Lastly, it calls the `kill_script()` function to terminate the script execution.",
        "type": "comment"
    },
    "2106": {
        "file_id": 217,
        "content": "/tests/bilibili_practices/bilibili_tarot/all_typography_underline_subtitle.py",
        "type": "filepath"
    },
    "2107": {
        "file_id": 217,
        "content": "The code removes files, uses external scripts and programs to generate typography for a bilibili video, and is part of a larger video editing or manipulation process.",
        "type": "summary"
    },
    "2108": {
        "file_id": 217,
        "content": "from tarot_descriptions import *\n# mdict, smdict2\nimport os\ndef gen_typography_part1(content):\n    with open(\"demo_text.log\",\"w+\",encoding=\"utf8\") as f:\n        f.write(content)\n    os.system(\"xvfb-run -s '-screen 0 1920x1080x24' python3 scriptable_generate_typography_with_voice_underline_subtitle.py\")\ndef kill_script():\n    os.system(\"bash kill_xb.sh\")\ntyp_0 = \"typo_0\"\ntyp_1 = \"typo_1\"\n# os.system(\"rm -rf {}\".format(typ_0))\n# os.system(\"rm -rf {}\".format(typ_1))\n# os.mkdir(typ_0)\n# os.mkdir(typ_1)\nfrom functional_voice_with_pictures import gen_typography_part3\n# intro_text = \"\"\"塔罗牌，是一种针对人、事、物进行分析、预测和提供建议的工具，被称为“大自然的奥秘库”。\n# 抽取一张塔罗牌，今天的你会是怎样的呢？\"\"\"\nintro_text = \"\"\"奥拓是只猫～\"\"\"\n# bgm_path = \"/root/Desktop/works/bilibili_tarot/tarot_random_shuffle.mp3\"\ntarget_video = \"cat_intro_video.mp4\"\nos.system(\"rm {}\".format(target_video))\nkill_script()\n# v = mdict[k]\nv = intro_text\ngen_typography_part1(v)\n# target_video = \"/\".join([typ_0,\"{}.mp4\".format(k)])\ngen_typography_part3(v,target_video)\nkill_script()\nintro_text = \"\"\"喜欢本期视频的话 点个关注再走吧～\"\"\"",
        "type": "code",
        "location": "/tests/bilibili_practices/bilibili_tarot/all_typography_underline_subtitle.py:1-43"
    },
    "2109": {
        "file_id": 217,
        "content": "This code generates typography for a bilibili video, involves creating directories and removing files, uses os.system to run external scripts and programs, and has an introductory message followed by an ending message for the video.",
        "type": "comment"
    },
    "2110": {
        "file_id": 217,
        "content": "# bgm_path = \"/root/Desktop/works/bilibili_tarot/tarot_random_shuffle.mp3\"\ntarget_video = \"cat_outro_video.mp4\"\nos.system(\"rm {}\".format(target_video))\nkill_script()\n# v = mdict[k]\nv = intro_text\ngen_typography_part1(v)\n# target_video = \"/\".join([typ_0,\"{}.mp4\".format(k)])\ngen_typography_part3(v,target_video)\nkill_script()",
        "type": "code",
        "location": "/tests/bilibili_practices/bilibili_tarot/all_typography_underline_subtitle.py:45-56"
    },
    "2111": {
        "file_id": 217,
        "content": "This code removes the target video file, terminates a script, generates typography for a specific text using functions gen_typography_part1 and gen_typography_part3, and then terminates another script. It seems to be part of a process involving video editing or manipulation.",
        "type": "comment"
    },
    "2112": {
        "file_id": 218,
        "content": "/tests/bilibili_practices/bilibili_tarot/flipcards.py",
        "type": "filepath"
    },
    "2113": {
        "file_id": 218,
        "content": "This code generates flipcards for Major and Minor Arcana in Tarot. It first clears directories, creates them, and then iterates over dictionaries to generate flipcard videos with specified background music, storing them accordingly.",
        "type": "summary"
    },
    "2114": {
        "file_id": 218,
        "content": "# generate all flipcards.\nfrom tarot_correspondences import *\nfrom functional_generate_demo_tarot import gen_tarot\n# mtarget_0, mtarget_1\ndir_0 = \"major\"\ndir_1 = \"minor\"\nos.system(\"rm -rf {}\".format(dir_0))\nos.system(\"rm -rf {}\".format(dir_1))\nos.mkdir(dir_0)\nos.mkdir(dir_1)\nbgm_path = \"/root/Desktop/works/bilibili_tarot/some_bgm.mp3\"\nfor k in mtarget_0.keys():\n    value = mtarget_0[k]\n    videoPath = \"/\".join([dir_0,\"{}.mp4\".format(k)])\n    picture_path = value\n    gen_tarot(picture_path,bgm_path,videoPath)\nfor k in mtarget_1.keys():\n    value = mtarget_1[k]\n    videoPath = \"/\".join([dir_1,\"{}.mp4\".format(k)])\n    picture_path = value\n    gen_tarot(picture_path,bgm_path,videoPath)",
        "type": "code",
        "location": "/tests/bilibili_practices/bilibili_tarot/flipcards.py:1-27"
    },
    "2115": {
        "file_id": 218,
        "content": "This code generates flipcards for Major and Minor Arcana in Tarot. It first clears directories, creates them, and then iterates over dictionaries to generate flipcard videos with specified background music, storing them accordingly.",
        "type": "comment"
    },
    "2116": {
        "file_id": 219,
        "content": "/tests/bilibili_practices/bilibili_tarot/functional_gen_typo_video_seq.py",
        "type": "filepath"
    },
    "2117": {
        "file_id": 219,
        "content": "This function generates a video sequence with input \"seq\" and duration, applies filters to each clip, uses vidpy library for handling video composition, and saves the final composition as a video file.",
        "type": "summary"
    },
    "2118": {
        "file_id": 219,
        "content": "# seq = [0,1,2,3,4,5,6] # 7\n# duration = 4\nfrom vidpy import Composition, Clip\ndef gen_video(vname, seq, duration):\n    mduration = duration / len(seq)\n    clips = []\n    width,height =1920,1080\n    fps=60\n    orig_fps = 24\n    shift = fps/orig_fps\n    for i,s in enumerate(seq):\n        codec = str(s)\n        codec = \"0\"*(4-len(codec)) + codec\n        path = \"/root/Desktop/works/bilibili_tarot/demo_typography/screenshot{}.png\".format(codec)\n        start = i*mduration\n        end = start + mduration\n        print(start,end)\n        clip = Clip(path,output_fps=fps,start=0,end=mduration*shift,offset = start*shift,profile_override = {\"fps\":60,\"width\": width, \"height\": height})\n        clip.vignette()\n        clip.dust()\n        # clip.charcoal()\n        clip.dither(amount=0.10)\n        # clip.\n        # clip.pixelize()\n        clip.pixelize(width = 0.002,height=0.002)\n        clips.append(clip)\n    # breakpoint()\n    # # maybe some other bgm.\n    # bgm = Clip(bgm_path,start=0)\n    # clips.append(bgm)\n    # breakpoint()",
        "type": "code",
        "location": "/tests/bilibili_practices/bilibili_tarot/functional_gen_typo_video_seq.py:1-39"
    },
    "2119": {
        "file_id": 219,
        "content": "This function generates a video sequence based on input \"seq\" and duration, with each clip corresponding to a number in the sequence. It reads image files from \"/root/Desktop/works/bilibili_tarot/demo_typography/\" and applies various filters (vignette, dust, dithering, pixelize) to each clip before adding it to the list of clips. The function uses vidpy library for handling video composition and Clip class for each image frame.",
        "type": "comment"
    },
    "2120": {
        "file_id": 219,
        "content": "    comp = Composition(clips,duration=duration,fps=fps,width=width,height=height)\n    comp.save(vname,fps=60,duration = duration,width=width,height=height)",
        "type": "code",
        "location": "/tests/bilibili_practices/bilibili_tarot/functional_gen_typo_video_seq.py:40-42"
    },
    "2121": {
        "file_id": 219,
        "content": "The code above creates a Composition object with the specified clips, duration, fps, width, and height. Then, it saves this composition as a video file under the given 'vname' while maintaining the same settings.",
        "type": "comment"
    },
    "2122": {
        "file_id": 220,
        "content": "/tests/bilibili_practices/bilibili_tarot/functional_generate_demo_tarot.py",
        "type": "filepath"
    },
    "2123": {
        "file_id": 220,
        "content": "This code generates a tarot image sequence, applies various filters and effects, resizes videos, pads them if necessary, compresses audio, and merges videos using FFmpeg commands.",
        "type": "summary"
    },
    "2124": {
        "file_id": 220,
        "content": "import os\nfrom vidpy import Clip, Composition  #many shitty things...\n# tarot_target = \"/root/Desktop/works/bilibili_tarot/tarot_pictures/0_THE_FOOL.jpg\"\nimport random\ndef gen_tarot(tarot_target,bgm_path,final_output):\n    os.system(\"rm tarot_demo.mp4\")\n    fps =60\n    # myprofile = {'width': 1320, 'height': 2644} # wtf?\n    # just create profile from it. are you sure?\n    clip = Clip(tarot_target, output_fps=fps,start=0, end=16,override=True)\n    # clip.edgeglow()\n    # clip.crop\n    # 1320x2645 # unbelievable.\n    # clip.fx(\"\",{})\n    # clip.resize(w=1920, h=1080, distort=True)\n    # distort=False\n    c_w = clip.width\n    c_h = clip.height\n    # comp = Composition([clip])\n    clip.dither(amount=0.07) # the greater the better.\n    clip.fadein(0.5)      # fade the clip in over 1 second\n    # clip.fadeout(3.5)   # fade the clip over 0.5 seconds\n    # clip.glow(3.5)         # add a glow effect\n    clip.spin(4, axis=\"z\")\n    clip.vignette()\n    clip.dust()\n    clip.hue(shift = 1-random.random()*0.5)\n    clip.pixelize(width = 0.005,height=0.01)",
        "type": "code",
        "location": "/tests/bilibili_practices/bilibili_tarot/functional_generate_demo_tarot.py:1-30"
    },
    "2125": {
        "file_id": 220,
        "content": "Code snippet imports necessary libraries, defines a function for generating a tarot image sequence, and applies various filters and effects to the input image. The function generates a random hue shift, pixelizes the image, adds a vignette effect, spins the image on the z-axis, and fades the clip in and out. The code uses overridden parameters for output resolution and aspect ratio, potentially causing inconsistencies or errors.",
        "type": "comment"
    },
    "2126": {
        "file_id": 220,
        "content": "    # clip.invert()\n    # clip.luminance\n    # clip.charcoal()\n    # clip.crop(right=c_w,bottom=c_h)\n    clip.save(\"tarot_demo.mp4\", fps=60,duration = 3,width=c_w,height=c_h) # good.\n    # print(c_w,c_h)\n    # 720 576\n    r1 = c_w/c_h\n    target_w, target_h = 1920, 1080\n    r2 = target_w/ target_h\n    if r1 < r2:\n        os.system('ffmpeg -y -i tarot_demo.mp4  -vf \"scale=-1:{},pad={}:ih:(ow-iw)/2\"  tarot_demo2.mp4'.format(target_h,target_w))\n    else:\n        os.system('ffmpeg -y -i tarot_demo.mp4  -vf \"scale={}:-1,pad=iw:{}:0:(oh-ih)/2\"  tarot_demo2.mp4'.format(target_w,target_h))\n    os.system(\"ffmpeg -y -i {} -i {} -c:v copy -c:a aac -map 0:v:0 -map 1:a:0 -shortest {}\".format(\"tarot_demo2.mp4\",bgm_path,final_output))\n    os.system(\"rm -rf tarot_demo2.mp4\")\n    os.system(\"rm -rf tarot_demo.mp4\")",
        "type": "code",
        "location": "/tests/bilibili_practices/bilibili_tarot/functional_generate_demo_tarot.py:31-49"
    },
    "2127": {
        "file_id": 220,
        "content": "The code resizes and pads a video, applies audio compression, then deletes intermediate files. It uses FFmpeg commands to scale the video, pad it if necessary, compress audio, and merge videos.",
        "type": "comment"
    },
    "2128": {
        "file_id": 221,
        "content": "/tests/bilibili_practices/bilibili_tarot/functional_voice_with_pictures.py",
        "type": "filepath"
    },
    "2129": {
        "file_id": 221,
        "content": "This code generates typography for videos using TTS, external tools, and FFMPEG, performing directory operations, merging audio/video, exporting, calculating tempo, and applying it to the audio track.",
        "type": "summary"
    },
    "2130": {
        "file_id": 221,
        "content": "import os\nfrom test_common import *\nimport shutil\ndef split_sentences(sent):\n    spliters = \"\\n，。、？： \"\n    cursent = \"\"\n    results = []\n    for elem in sent:\n        cursent += elem\n        if elem in spliters:\n            results.append(cursent)\n            cursent = \"\"\n    if len(cursent) > 0:\n        results.append(cursent)\n    return results\ndef get_speech(sent,output):\n    assert output.endswith(\".wav\")\n    os.system(\"bash kill_pdspc.sh\")\n    with open(\"temp.txt\", \"w+\",encoding=\"utf-8\") as f:\n        f.write(sent.replace(\"\\n\",\"\")) # important.\n    os.system(\"cat temp.txt | paddlespeech tts --output {}\".format(output))\nfrom pydub import AudioSegment\nfrom functional_gen_typo_video_seq import gen_video\n# import matplotlib # doing this before importing moviepy editor. or we will fail.\n# matplotlib.use(\"TkAgg\")\n# from moviepy.editor import VideoFileClip\n# cannot mix moviepy with vidpy or we get fucked.\nfrom MediaInfo import MediaInfo\ndef merge_audio(asegs):\n    audio_3 = AudioSegment.empty() #shit\n    for seg in asegs:",
        "type": "code",
        "location": "/tests/bilibili_practices/bilibili_tarot/functional_voice_with_pictures.py:1-35"
    },
    "2131": {
        "file_id": 221,
        "content": "The code imports necessary libraries and defines functions for handling sentences, obtaining speech output, and merging audio segments. It also sets up a function that generates a video using the functional_gen_typo_video_seq module. The code uses bash scripts and external tools like PaddleSpeech and MediaInfo to manipulate text-to-speech and audio/video files.",
        "type": "comment"
    },
    "2132": {
        "file_id": 221,
        "content": "        try:\n            audio_3 = audio_3.append(seg,crossfade=100) # also shit.\n        except:\n            audio_3 = audio_3.append(seg,crossfade=0) # also shit.\n    return audio_3\n    # audio_3.export(\"audio_3.wav\", format=\"wav\")\ndef gen_typography_part2(intro_text, bgm_path,target_video):\n    # intro_text = \"\"\"塔罗牌，由“TAROT”一词音译而来，被称为“大自然的奥秘库”。抽取一张塔罗牌，今天的你会是怎样的呢？\"\"\"\n    os.system(\"bash kill_pdspc.sh\")\n    sents = split_sentences(intro_text)\n    # breakpoint()\n    voice_dir = \"voice\"\n    video_dir = \"video\"\n    os.system(\"rm -rf {}\".format(voice_dir))\n    os.system(\"rm -rf {}\".format(video_dir))\n    os.mkdir(\"{}\".format(voice_dir))\n    os.mkdir(\"{}\".format(video_dir))\n    index = 0\n    voice_clips = []\n    video_names = []\n    for i,sent in enumerate(sents):\n        print(\"READING:\",sent)\n        aname = \"{}/{}.wav\".format(voice_dir,i)\n        get_speech(sent,aname)\n        lsent = len(sent)\n        # if no audio then just skip.\n        if not os.path.exists(aname):\n            index += lsent\n            continue",
        "type": "code",
        "location": "/tests/bilibili_practices/bilibili_tarot/functional_voice_with_pictures.py:36-66"
    },
    "2133": {
        "file_id": 221,
        "content": "This code is attempting to generate typography for a video using voice and pictures. It first clears the existing voice and video directories, then creates new ones. It splits the input text into sentences, and for each sentence, it attempts to get speech audio from that sentence and create a corresponding picture. If no audio is found, it skips that sentence. Finally, it returns the generated audio.",
        "type": "comment"
    },
    "2134": {
        "file_id": 221,
        "content": "        seg = AudioSegment.from_wav(aname)\n        duration = seg.duration_seconds\n        voice_clips.append(seg)\n        # get the duration you fuck.\n        # breakpoint()\n        current_indexs = list(range(index,index+lsent))\n        # you can generate video for it.\n        index += lsent\n        vname = \"{}/{}.mp4\".format(video_dir,i)\n        gen_video(vname,current_indexs,duration) # where from?\n        video_names.append(vname)\n    # and finally?\n    final_video = \"{}/final_video.mp4\".format(video_dir)\n    final_audio = \"{}/final_audio.wav\".format(voice_dir)\n    audio_merged = merge_audio(voice_clips)\n    # bgm_path = \"/root/Desktop/works/bilibili_tarot/some_bgm.mp3\"\n    bgm = AudioSegment.from_mp3(bgm_path)\n    # duration2 = audio_merged.duration_seconds\n    # bgm = bgm[:duration2*1000] # really?\n    # breakpoint()\n    # audio_merged = audio_merged.overlay(audio_merged,bgm,loop=True)  #wtf?\n    audio_merged = audio_merged.overlay(bgm,loop=True)\n    # audio_merged = audio_merged.normalize()\n    # is it needed?",
        "type": "code",
        "location": "/tests/bilibili_practices/bilibili_tarot/functional_voice_with_pictures.py:67-91"
    },
    "2135": {
        "file_id": 221,
        "content": "This code generates videos for each segment of audio and appends the video names to a list. It then combines all audio clips into one merged audio file, overlays background music, and saves the final audio and video files. The code also includes debugging tools like breakpoint() to help with troubleshooting.",
        "type": "comment"
    },
    "2136": {
        "file_id": 221,
        "content": "    # shit.\n    audio_merged.export(final_audio, format=\"wav\")\n    final_video2 = \"{}/final_video2.mp4\".format(video_dir)\n    with open(\"mylist.txt\",\"w+\") as f:\n        for n in video_names:\n            f.write(\"file \"+n+\"\\n\")\n    os.system(\"ffmpeg -f concat -safe 0 -i mylist.txt -c copy {}\".format(final_video))\n    # output_length = VideoFileClip(final_video).duration\n    output_length = MediaInfo(filename=final_video).getInfo()[\"videoDuration\"]\n    output_length = float(output_length)\n    input_length = AudioSegment.from_wav(final_audio).duration_seconds\n    tempo = input_length/output_length\n    t_a,t_b = tempo.as_integer_ratio()\n    os.system('ffmpeg -i {} -i {} -c:v copy -c:a aac -filter:a \"atempo={}/{}\" -map 0:v:0 -map 1:a:0 {}'.format(final_video,final_audio,t_a,t_b,final_video2))\n    shutil.move(final_video2,target_video)\ndef gen_typography_part3(intro_text, target_video): #slient\n    # intro_text = \"\"\"塔罗牌，由“TAROT”一词音译而来，被称为“大自然的奥秘库”。抽取一张塔罗牌，今天的你会是怎样的呢？\"\"\"\n    os.system(\"bash kill_pdspc.sh\")\n    sents = split_sentences(intro_text)",
        "type": "code",
        "location": "/tests/bilibili_practices/bilibili_tarot/functional_voice_with_pictures.py:92-114"
    },
    "2137": {
        "file_id": 221,
        "content": "This code performs video and audio processing, using ffmpeg commands to merge and manipulate the files. It exports an audio file in wav format, creates a mylist.txt file with video names, concatenates videos using ffmpeg, calculates the tempo between audio and video duration, applies the tempo to the final audio track, and finally moves the final video to the target location. This function also includes a shell command to kill pdspc process when finished.",
        "type": "comment"
    },
    "2138": {
        "file_id": 221,
        "content": "    # breakpoint()\n    voice_dir = \"voice\"\n    video_dir = \"video\"\n    os.system(\"rm -rf {}\".format(voice_dir))\n    os.system(\"rm -rf {}\".format(video_dir))\n    os.mkdir(\"{}\".format(voice_dir))\n    os.mkdir(\"{}\".format(video_dir))\n    index = 0\n    voice_clips = []\n    video_names = []\n    for i,sent in enumerate(sents):\n        print(\"READING:\",sent)\n        aname = \"{}/{}.wav\".format(voice_dir,i)\n        get_speech(sent,aname)\n        lsent = len(sent)\n        # if no audio then just skip.\n        if not os.path.exists(aname):\n            index += lsent\n            continue\n        seg = AudioSegment.from_wav(aname)\n        duration = seg.duration_seconds\n        voice_clips.append(seg)\n        # get the duration you fuck.\n        # breakpoint()\n        current_indexs = list(range(index,index+lsent))\n        # you can generate video for it.\n        index += lsent\n        vname = \"{}/{}.mp4\".format(video_dir,i)\n        gen_video(vname,current_indexs,duration) # where from?\n        video_names.append(vname)\n    # and finally?",
        "type": "code",
        "location": "/tests/bilibili_practices/bilibili_tarot/functional_voice_with_pictures.py:115-147"
    },
    "2139": {
        "file_id": 221,
        "content": "This code removes existing voice and video directories, creates new ones, reads sentences, saves corresponding audio files for each sentence, checks if audio files are generated correctly, generates videos based on the sentences and their respective positions in the text, and stores the names of generated videos.",
        "type": "comment"
    },
    "2140": {
        "file_id": 221,
        "content": "    final_video = \"{}/final_video.mp4\".format(video_dir)\n    final_audio = \"{}/final_audio.wav\".format(voice_dir)\n    audio_merged = merge_audio(voice_clips)\n    # bgm_path = \"/root/Desktop/works/bilibili_tarot/some_bgm.mp3\"\n    # bgm = AudioSegment.from_mp3(bgm_path)\n    # duration2 = audio_merged.duration_seconds\n    # bgm = bgm[:duration2*1000] # really?\n    # breakpoint()\n    # audio_merged = audio_merged.overlay(audio_merged,bgm,loop=True)  #wtf?\n    # audio_merged = audio_merged.overlay(bgm,loop=True)\n    # audio_merged = audio_merged.normalize()\n    # is it needed?\n    # shit.\n    audio_merged.export(final_audio, format=\"wav\")\n    final_video2 = \"{}/final_video2.mp4\".format(video_dir)\n    with open(\"mylist.txt\",\"w+\") as f:\n        for n in video_names:\n            f.write(\"file \"+n+\"\\n\")\n    os.system(\"ffmpeg -f concat -safe 0 -i mylist.txt -c copy {}\".format(final_video))\n    # output_length = VideoFileClip(final_video).duration\n    output_length = MediaInfo(filename=final_video).getInfo()[\"videoDuration\"]",
        "type": "code",
        "location": "/tests/bilibili_practices/bilibili_tarot/functional_voice_with_pictures.py:148-170"
    },
    "2141": {
        "file_id": 221,
        "content": "This code is performing audio and video merging, exporting the final audio file, creating a mylist.txt file for ffmpeg concatenation, and determining the output length of the final video. The code seems to have undergone revisions as there are comments stating \"wtf?\", \"shit.\", and \"is it needed?\" suggesting possible confusion or uncertainty about certain parts of the code.",
        "type": "comment"
    },
    "2142": {
        "file_id": 221,
        "content": "    output_length = float(output_length)\n    input_length = AudioSegment.from_wav(final_audio).duration_seconds\n    tempo = input_length/output_length\n    t_a,t_b = tempo.as_integer_ratio()\n    os.system('ffmpeg -i {} -i {} -c:v copy -c:a aac -filter:a \"atempo={}/{}\" -map 0:v:0 -map 1:a:0 {}'.format(final_video,final_audio,t_a,t_b,final_video2))\n    shutil.move(final_video2,target_video)",
        "type": "code",
        "location": "/tests/bilibili_practices/bilibili_tarot/functional_voice_with_pictures.py:171-176"
    },
    "2143": {
        "file_id": 221,
        "content": "This code calculates the tempo of an audio file and then applies it to another audio-video file using FFMPEG. It then moves the resulting file to a specified target location.",
        "type": "comment"
    },
    "2144": {
        "file_id": 222,
        "content": "/tests/bilibili_practices/bilibili_tarot/gen_typo_video_seq.py",
        "type": "filepath"
    },
    "2145": {
        "file_id": 222,
        "content": "Generates a video sequence by splitting images into clips with adjusted duration and fps, appends background music clip, composes the clips into a single composition, and saves it as \"typography_demo.mp4\".",
        "type": "summary"
    },
    "2146": {
        "file_id": 222,
        "content": "seq = [0,1,2,3,4,5,6] # 7\nduration = 4\nmduration = duration / len(seq)\nfrom vidpy import Composition, Clip\nclips = []\nwidth,height =1920,1080\nfps=60\norig_fps = 24\nshift = fps/orig_fps\nfor i,s in enumerate(seq):\n    codec = str(s)\n    codec = \"0\"*(4-len(codec)) + codec\n    path = \"/root/Desktop/works/bilibili_tarot/demo_typography/screenshot{}.png\".format(codec)\n    start = i*mduration\n    end = start + mduration\n    print(start,end)\n    clip = Clip(path,output_fps=fps,start=0,end=mduration*shift,offset = start*shift,profile_override = {\"fps\":60,\"width\": width, \"height\": height})\n    clips.append(clip)\n# breakpoint()\nbgm_path = \"/root/Desktop/works/bilibili_tarot/some_bgm.mp3\"\n# maybe some other bgm.\nbgm = Clip(bgm_path,start=0)\nclips.append(bgm)\n# breakpoint()\ncomp = Composition(clips,duration=duration,fps=fps,width=width,height=height)\ncomp.save(\"typography_demo.mp4\",fps=60,duration = duration,width=width,height=height)",
        "type": "code",
        "location": "/tests/bilibili_practices/bilibili_tarot/gen_typo_video_seq.py:1-35"
    },
    "2147": {
        "file_id": 222,
        "content": "Generates a video sequence by splitting images into clips with adjusted duration and fps, appends background music clip, composes the clips into a single composition, and saves it as \"typography_demo.mp4\".",
        "type": "comment"
    },
    "2148": {
        "file_id": 223,
        "content": "/tests/bilibili_practices/bilibili_tarot/generate_demo_tarot.py",
        "type": "filepath"
    },
    "2149": {
        "file_id": 223,
        "content": "The code imports libraries, creates a video clip from an image, applies filters, saves it, and then resizes/pads the file using ffmpeg.",
        "type": "summary"
    },
    "2150": {
        "file_id": 223,
        "content": "import os\nfrom vidpy import Clip, Composition  #many shitty things...\ntarot_target = \"/root/Desktop/works/bilibili_tarot/tarot_pictures/0_THE_FOOL.jpg\"\nos.system(\"rm tarot_demo.mp4\")\nfps =60\nmyprofile = {'width': 1320, 'height': 2644}\n# just create profile from it. are you sure?\nclip = Clip(tarot_target, output_fps=fps,start=0, end=16, profile_override=myprofile,override=False)\n# clip.edgeglow()\n# clip.crop\n# 1320x2645 # unbelievable.\n# clip.fx(\"\",{})\n# clip.resize(w=1920, h=1080, distort=True)\n# distort=False\nc_w = clip.width\nc_h = clip.height\n# comp = Composition([clip])\nclip.dither(amount=0.2) # the greater the better.\nclip.fadein(0.5)      # fade the clip in over 1 second\n# clip.fadeout(3.5)   # fade the clip over 0.5 seconds\n# clip.glow(3.5)         # add a glow effect\nclip.spin(4, axis=\"z\")\n# clip.crop(right=c_w,bottom=c_h)\nclip.save(\"tarot_demo.mp4\", fps=60,duration = 3,width=c_w,height=c_h) # good.\n# print(c_w,c_h)\n# 720 576\nr1 = c_w/c_h\ntarget_w, target_h = 1920, 1080\nr2 = target_w/ target_h\nif r1 < r2:\n  ",
        "type": "code",
        "location": "/tests/bilibili_practices/bilibili_tarot/generate_demo_tarot.py:1-32"
    },
    "2151": {
        "file_id": 223,
        "content": "The code imports necessary libraries, defines a tarot image file path and removes an existing mp4 file. It then creates a video clip object from the image using specific parameters, applies various filters and transformations to the clip, saves the modified clip as \"tarot_demo.mp4\" with specified duration, width, and height.",
        "type": "comment"
    },
    "2152": {
        "file_id": 223,
        "content": "  os.system('ffmpeg -y -i tarot_demo.mp4  -vf \"scale=-1:{},pad={}:ih:(ow-iw)/2\"  tarot_demo2.mp4'.format(target_h,target_w))\nelse:\n    os.system('ffmpeg -y -i tarot_demo.mp4  -vf \"scale={}:-1,pad=iw:{}:0:(oh-ih)/2\"  tarot_demo2.mp4'.format(target_w,target_h))",
        "type": "code",
        "location": "/tests/bilibili_practices/bilibili_tarot/generate_demo_tarot.py:32-34"
    },
    "2153": {
        "file_id": 223,
        "content": "This code uses ffmpeg to resize and pad tarot_demo.mp4 video file into tarot_demo2.mp4, adjusting dimensions based on target_h and target_w variables.",
        "type": "comment"
    },
    "2154": {
        "file_id": 224,
        "content": "/tests/bilibili_practices/bilibili_tarot/generate_typography.py",
        "type": "filepath"
    },
    "2155": {
        "file_id": 224,
        "content": "This code generates typography using Processing library in Python, handling line wrapping and text overflows, with a Chinese SimHei font, adjustable line heights, and separate line storage. It displays the typography on screen and saves screenshots until all elements are processed.",
        "type": "summary"
    },
    "2156": {
        "file_id": 224,
        "content": "from p5 import *\nimport os\nos.system(\"rm screenshot*\")\ntsize = 100\ncounterx = 0\nxcoord = 20\nycoord = 75\nscrwidth = 1920\nscrheight = 1080\nlineNum = 0\n# what fucking ever.\ns = \"[START]\"+\"SOME TEXT\"*500+\"[END]\"\ns0 = [\"\"]\ndef setup():\n    size(scrwidth,scrheight)\n    text_font(create_font('./SimHei.ttf', size=tsize))\ndef draw():\n    global counterx,xcoord,ycoord,s,s0,scrheight,scrwidth,lineNum\n    if len(s0) ==1:\n        if len(s0[0]) == 0:\n            background(0)\n    if counterx > len(s)-1:\n        exit()\n    s1 = s[counterx]\n    stemp0 = s0[-1]+s1\n    tw = text_width(stemp0)\n    th = tsize*(lineNum+1) + tsize*0.2*lineNum\n    # th = tsize*(stemp0.count(\"\\n\")+1)\n    # if (ycoord+th> scrheight):\n    #     s0 = s1\n    # else:\n    if (tw + xcoord+ tsize*0.5> scrwidth):\n        stemp0 = s1\n        s0.append(stemp0)\n        lineNum +=1\n        th = tsize*(lineNum+1) + tsize*0.2*lineNum\n        if (ycoord+th> scrheight):\n            # stemp0 = s1\n            s0 = [stemp0]\n            background(0)\n            lineNum = 0\n    else:\n        s0[-1]= stemp0",
        "type": "code",
        "location": "/tests/bilibili_practices/bilibili_tarot/generate_typography.py:1-48"
    },
    "2157": {
        "file_id": 224,
        "content": "This code generates a typography using Processing (p5.js) library in Python, handling line wrapping and text overflows to fit within the specified screen width and height. It uses a Chinese SimHei font, dynamically adjusts line heights, and stores each line of text separately for easier manipulation.",
        "type": "comment"
    },
    "2158": {
        "file_id": 224,
        "content": "        # no_loop()\n        # clear\n    # s0 = stemp0\n        # end all evil.\n    counterx+=1\n    # load_font(\"SimHei.ttf\")\n    print(\"text w/h:\",tw,th)\n    # for l, text9 in enumerate(s0):\n    text9 = s0[-1][-1]\n    l = len(s0)-1\n    text(text9, (xcoord+text_width(s0[-1][:-1]), ycoord+ l*(tsize*1.2)))  # add str() to key\n    save_frame(\"screenshot.png\")\nrun()\nprint(\"EXITED.\")",
        "type": "code",
        "location": "/tests/bilibili_practices/bilibili_tarot/generate_typography.py:49-64"
    },
    "2159": {
        "file_id": 224,
        "content": "The code snippet seems to be responsible for generating typography using a specific font and displaying it on the screen. It tracks the length of the text being displayed, calculates the position based on that length, and saves a screenshot after each iteration. The loop continues until all elements in 's0' are processed, and then it exits.",
        "type": "comment"
    },
    "2160": {
        "file_id": 225,
        "content": "/tests/bilibili_practices/bilibili_tarot/generate_typography_with_voice.py",
        "type": "filepath"
    },
    "2161": {
        "file_id": 225,
        "content": "This code sets up a drawing environment and generates typography frames by rendering text onto an image, handling wrapping and tracking position on screen. It also initializes new lists, saves screenshots, and handles different scenarios before exiting.",
        "type": "summary"
    },
    "2162": {
        "file_id": 225,
        "content": "from p5 import *\nimport os\nfrom test_common import demo_text\nos.system(\"rm screenshot*\")\ntarget_dir = \"demo_typography\"\nos.system(\"rm -rf {}\".format(target_dir))\nos.system(\"mkdir {}\".format(target_dir))\ntsize = 100\ncounterx = 0\nxcoord = 20\nycoord = 75\nscrwidth = 1920\nscrheight = 1080\nlineNum = 0\n# what fucking ever.\ns = demo_text\ns0 = [\"\"]\ndef setup():\n    size(scrwidth,scrheight)\n    text_font(create_font('./SimHei.ttf', size=tsize))\ndef draw():\n    global counterx,xcoord,ycoord,s,s0,scrheight,scrwidth,lineNum,target_dir\n    if len(s0) ==1:\n        if len(s0[0]) == 0:\n            background(0)\n    if counterx > len(s)-1:\n        exit()\n    s1 = s[counterx]\n    stemp0 = s0[-1]+s1\n    tw = text_width(stemp0)\n    th = tsize*(lineNum+1) + tsize*0.2*lineNum\n    # th = tsize*(stemp0.count(\"\\n\")+1)\n    # if (ycoord+th> scrheight):\n    #     s0 = s1\n    # else:\n    if (tw + xcoord+ tsize*0.5> scrwidth):\n        stemp0 = s1\n        s0.append(stemp0)\n        lineNum +=1\n        th = tsize*(lineNum+1) + tsize*0.2*lineNum\n        if (ycoord+th> scrheight):",
        "type": "code",
        "location": "/tests/bilibili_practices/bilibili_tarot/generate_typography_with_voice.py:1-47"
    },
    "2163": {
        "file_id": 225,
        "content": "This code sets up a drawing environment with a specified size and font, and then generates typography frames by rendering text onto an image. It handles wrapping text to multiple lines if the width is exceeded and keeps track of the number of lines and position on the screen. The code also clears any existing files named \"screenshot*\" and creates a new directory for storing the resulting images.",
        "type": "comment"
    },
    "2164": {
        "file_id": 225,
        "content": "            # stemp0 = s1\n            s0 = [stemp0]\n            background(0)\n            lineNum = 0\n    else:\n        s0[-1]= stemp0\n        # no_loop()\n        # clear\n    # s0 = stemp0\n        # end all evil.\n    counterx+=1\n    # load_font(\"SimHei.ttf\")\n    print(\"text w/h:\",tw,th)\n    # for l, text9 in enumerate(s0):\n    text9 = s0[-1][-1]\n    l = len(s0)-1\n    text(text9, (xcoord+text_width(s0[-1][:-1]), ycoord+ l*(tsize*1.2)))  # add str() to key\n    save_frame(\"{}/screenshot.png\".format(target_dir))\nrun()\nprint(\"EXITED.\")",
        "type": "code",
        "location": "/tests/bilibili_practices/bilibili_tarot/generate_typography_with_voice.py:48-69"
    },
    "2165": {
        "file_id": 225,
        "content": "The code handles different scenarios by either initializing a new list 's0' or updating the last element in 's0'. It uses variables like 'l', 'xcoord', 'ycoord', 'target_dir', 'counterx', and 'text9' to handle text placement, saving screenshots, and maintaining state. The font \"SimHei.ttf\" is loaded, and the width of each line of text is calculated using the 'text_width' function. Finally, a screenshot is saved and the script exits.",
        "type": "comment"
    },
    "2166": {
        "file_id": 226,
        "content": "/tests/bilibili_practices/bilibili_tarot/get_figures.js",
        "type": "filepath"
    },
    "2167": {
        "file_id": 226,
        "content": "This code retrieves all \"figure\" tags from the HTML document, extracts the URLs of the first image in each figure using their \"data-src\" attribute, removes the \"@\" symbol, and replaces \"//\" with \"https://\". Finally, it logs the extracted URLs as a JSON string to the console.",
        "type": "summary"
    },
    "2168": {
        "file_id": 226,
        "content": "var figures = document.getElementsByTagName(\"figure\");\nvar mlinks = []\nfor (var fig of figures) {\n    var link = fig.getElementsByTagName(\"img\")[0].getAttribute(\"data-src\").split(\"@\")[0].replace(\"//\", \"https://\");\n    mlinks.push(link)\n}\nconsole.log(JSON.stringify(mlinks));",
        "type": "code",
        "location": "/tests/bilibili_practices/bilibili_tarot/get_figures.js:1-7"
    },
    "2169": {
        "file_id": 226,
        "content": "This code retrieves all \"figure\" tags from the HTML document, extracts the URLs of the first image in each figure using their \"data-src\" attribute, removes the \"@\" symbol, and replaces \"//\" with \"https://\". Finally, it logs the extracted URLs as a JSON string to the console.",
        "type": "comment"
    },
    "2170": {
        "file_id": 227,
        "content": "/tests/bilibili_practices/bilibili_tarot/get_foreground.py",
        "type": "filepath"
    },
    "2171": {
        "file_id": 227,
        "content": "This code reads two image files, converts them to grayscale, and creates a mask where pixels with absolute difference less than 40 are set to 0 (black) and others are set to 255 (white). The resulting mask is displayed using OpenCV.",
        "type": "summary"
    },
    "2172": {
        "file_id": 227,
        "content": "background = 'tarot_pictures2/BLANK.jpg'\nforeground = 'tarot_pictures2/ACE_OF_SWORDS.jpg'\nimport cv2\nimport numpy as np\npic1 = cv2.imread(background)\npic2 = cv2.imread(foreground)\nh2,w2,c2 = pic2.shape\npic1.resize(h2,w2,c2)\n# print(pic1.shape)\n# print(pic2.shape)\npic1_b = cv2.cvtColor(pic1, cv2.COLOR_BGR2GRAY)\npic2_b = cv2.cvtColor(pic2, cv2.COLOR_BGR2GRAY)\npic3 = np.where(abs(pic1_b-pic2_b)<40, 0,255).astype(np.uint8)\ncv2.imshow(\"mask\",pic3)\ncv2.waitKey(0)\n# print(pic3)\n# print(pic1.dtype)",
        "type": "code",
        "location": "/tests/bilibili_practices/bilibili_tarot/get_foreground.py:1-24"
    },
    "2173": {
        "file_id": 227,
        "content": "This code reads two image files, converts them to grayscale, and creates a mask where pixels with absolute difference less than 40 are set to 0 (black) and others are set to 255 (white). The resulting mask is displayed using OpenCV.",
        "type": "comment"
    },
    "2174": {
        "file_id": 228,
        "content": "/tests/bilibili_practices/bilibili_tarot/get_tarots.py",
        "type": "filepath"
    },
    "2175": {
        "file_id": 228,
        "content": "The code retrieves Tarot card images from \"i0.hdslb.com\" domain, uses PaddleOCR for recognition, saves high certainty recognized files with new names.",
        "type": "summary"
    },
    "2176": {
        "file_id": 228,
        "content": "links = [\"https://i0.hdslb.com/bfs/article/231a2286704d13675c25df228abed3d2ddbf2d00.jpg\",\"https://i0.hdslb.com/bfs/article/c841534b39133e4e96f8bbb19a4471843243c5d4.jpg\",\"https://i0.hdslb.com/bfs/article/7913498bb634b8a13c1b60dbdcaed4463fa17f50.jpg\",\"https://i0.hdslb.com/bfs/article/ec07923700f633578a681c56a008505893cf47a6.jpg\",\"https://i0.hdslb.com/bfs/article/c2691feff128c0b982d9d28ce798b3a3327fd161.jpg\",\"https://i0.hdslb.com/bfs/article/78d92d8abac6fbb8a1a3c9bcf44b76b9e2b709c9.jpg\",\"https://i0.hdslb.com/bfs/article/1d8bc016bd9593a1ffc7c6ace7a0b6e2795ba24a.jpg\",\"https://i0.hdslb.com/bfs/article/e9a3e50378caf80fa7f1584813e7d88ea5f4e4f3.jpg\",\"https://i0.hdslb.com/bfs/article/b73f8a8bc1f215af7e181e1e5f4a682d353dd7f5.jpg\",\"https://i0.hdslb.com/bfs/article/9ebb2bf93fcd4bf0c0dd413c378ebe6b6c4b436a.jpg\",\"https://i0.hdslb.com/bfs/article/063b2dee6bb57a5de4fd518d671e2fc384089705.jpg\",\"https://i0.hdslb.com/bfs/article/9061adbc1f3fe0a6a591e64972feeef126d405bd.jpg\",\"https://i0.hdslb.com/bfs/artic",
        "type": "code",
        "location": "/tests/bilibili_practices/bilibili_tarot/get_tarots.py:1-1"
    },
    "2177": {
        "file_id": 228,
        "content": "The code contains a list of URLs to images.",
        "type": "comment"
    },
    "2178": {
        "file_id": 228,
        "content": "le/16a5af1e204e9d99e29ce567da625fe4cbf97654.jpg\",\"https://i0.hdslb.com/bfs/article/064628af3ba2caad6da4f256c1203a2e5abc84d5.jpg\",\"https://i0.hdslb.com/bfs/article/e91f4d2080851dcd3b7d95b5899c3819379e7419.jpg\",\"https://i0.hdslb.com/bfs/article/ed7503d3465cc98c4f33c7269d4003dff5c0e30e.jpg\",\"https://i0.hdslb.com/bfs/article/30ead312e5de86bab22b1408cfd7e343f7a444ba.jpg\",\"https://i0.hdslb.com/bfs/article/8f099a8a276dcc0304d5ab8032bcca6df92fad45.jpg\",\"https://i0.hdslb.com/bfs/article/d64bde431d4696dc049ccc156689d00f8b56d3e4.jpg\",\"https://i0.hdslb.com/bfs/article/e7b7805ffb07eee969a18b543a342290e847a488.jpg\",\"https://i0.hdslb.com/bfs/article/f6aad92efa9a9db5ab650cc9d958899d3eb0ccc5.jpg\",\"https://i0.hdslb.com/bfs/article/e0ef8a4a11c3451a81e8f8a4aea0460f308aed6d.jpg\",\"https://i0.hdslb.com/bfs/article/7000095230b4d1e4e9c82f596228342a38fceb3b.jpg\"]\n# links = [\"https://i0.hdslb.com/bfs/article/328165fb5c73e4b9a11eb335a6ccbad144606495.jpg\",\"https://i0.hdslb.com/bfs/article/02db465212d3c374a43c60fa26",
        "type": "code",
        "location": "/tests/bilibili_practices/bilibili_tarot/get_tarots.py:1-4"
    },
    "2179": {
        "file_id": 228,
        "content": "Code is listing a series of URLs for images, possibly used for retrieving image resources from the internet.",
        "type": "comment"
    },
    "2180": {
        "file_id": 228,
        "content": "25cc1caeaab796.png\",\"https://i0.hdslb.com/bfs/article/ef99b038b6c254b5ee3c77641a2d24523b2f2549.jpg\",\"https://i0.hdslb.com/bfs/article/6831c04615d8c2656bf9edb260b2692600506b12.jpg\",\"https://i0.hdslb.com/bfs/article/b6e798cc616440a2d8f0e3da08f2e47deb3dea5e.jpg\",\"https://i0.hdslb.com/bfs/article/d6a352ed8ef2662b249b31617d16cb7b49012980.jpg\",\"https://i0.hdslb.com/bfs/article/3ece6a53ffc6d1b934830771861087477def3754.jpg\",\"https://i0.hdslb.com/bfs/article/f0207ebb2a7d120ebd22cec39cf242888747f1aa.jpg\",\"https://i0.hdslb.com/bfs/article/fe80a0fcaecbca438a28dcf6d64b2fdfcf0395dd.jpg\",\"https://i0.hdslb.com/bfs/article/6b60f9321e1c902983020925b9cd77eeb90b0d37.jpg\",\"https://i0.hdslb.com/bfs/article/0e4460990f511fdbdd035872d9e4019d1a91a1c2.jpg\",\"https://i0.hdslb.com/bfs/article/92746eb9f9b399b7f959040e4e108099282c7e78.jpg\",\"https://i0.hdslb.com/bfs/article/41cbd61a4ff091d8a812f2c156b41a42e7cfbcee.jpg\",\"https://i0.hdslb.com/bfs/article/419c0b63e00243fd36a664625528817c5e9b56f9.jpg\",\"https://i0.hdslb.co",
        "type": "code",
        "location": "/tests/bilibili_practices/bilibili_tarot/get_tarots.py:4-4"
    },
    "2181": {
        "file_id": 228,
        "content": "This code contains a list of URLs for images, possibly used to display Tarot card art in an application.",
        "type": "comment"
    },
    "2182": {
        "file_id": 228,
        "content": "m/bfs/article/920f5219d12369d35025f415456a1c8f17af80f0.jpg\",\"https://i0.hdslb.com/bfs/article/f06e85b771817651287a5550a52ab2d407b9bdfd.jpg\",\"https://i0.hdslb.com/bfs/article/4c24e5879af822216e609aa6d7e0aab35fdea868.jpg\",\"https://i0.hdslb.com/bfs/article/3a016ea4f11e086547d5b3cafae7ab4014934415.jpg\",\"https://i0.hdslb.com/bfs/article/57185c84c272c0f9ee70a18a5a969236c43da5d9.jpg\",\"https://i0.hdslb.com/bfs/article/8d2de4ec7b46001041b1b9434f80a4db48cb0182.jpg\",\"https://i0.hdslb.com/bfs/article/780aef80d7246206a5bb4927e2834dc55286fb19.jpg\",\"https://i0.hdslb.com/bfs/article/246967f4d22e55c70666b4ac41205dd2c6cd3cde.jpg\",\"https://i0.hdslb.com/bfs/article/84f521382f7c02e6e4ea0daabb6e93192134372a.jpg\",\"https://i0.hdslb.com/bfs/article/7fd2ad226c81b31d397323891c8194d67f2fdf2b.jpg\",\"https://i0.hdslb.com/bfs/article/eee197d9172b1c38218ab642596b2990afcc383c.jpg\",\"https://i0.hdslb.com/bfs/article/736b5609c526379a8089a7741e19586eebeeb3e2.jpg\",\"https://i0.hdslb.com/bfs/article/93b97faaaa5a14242d21a2e592",
        "type": "code",
        "location": "/tests/bilibili_practices/bilibili_tarot/get_tarots.py:4-4"
    },
    "2183": {
        "file_id": 228,
        "content": "This code is a list of URLs for different images, likely used in a web context. Each URL corresponds to an image file hosted on the \"i0.hdslb.com\" domain. The exact purpose or application context is not clear from this snippet alone.",
        "type": "comment"
    },
    "2184": {
        "file_id": 228,
        "content": "b03b87fa0c5ff3.jpg\",\"https://i0.hdslb.com/bfs/article/ea528dc4bc964eaf9960fdc9d399b03f87db9ddb.jpg\"]\nimport requests\nimport cv2 # will it work?\nimport uuid\nimport shutil\nfrom test_common import *\n# import paddleocr\nfrom paddleocr import PaddleOCR,draw_ocr\nbasepath = \"tarot_pictures\"\n# basepath = \"tarot_pictures2\"\n# Paddleocr supports Chinese, English, French, German, Korean and Japanese.\n# You can set the parameter `lang` as `ch`, `en`, `french`, `german`, `korean`, `japan`\n# to switch the language model in order.\nocr = PaddleOCR(use_angle_cls=True, lang='en') # need to run only once to download and load model into memory\n# img_path = 'PaddleOCR/doc/imgs_en/img_12.jpg'\n# result = ocr.ocr(img_path, cls=True)\n# for line in result:\n#     print(line)\nos.system(\"rm -rf {}\".format(basepath))\nos.system(\"mkdir {}\".format(basepath))\nfor imglink in links:\n    print(\"DOWNLOADING:\",imglink)\n    while True:\n        try:\n            r = requests.get(imglink)\n            break\n        except:\n            continue\n    data = r.content # save as picture.",
        "type": "code",
        "location": "/tests/bilibili_practices/bilibili_tarot/get_tarots.py:4-36"
    },
    "2185": {
        "file_id": 228,
        "content": "The code imports necessary libraries and initializes a PaddleOCR object. It then clears the specified directory and downloads images from provided links, one by one, until successful download is achieved.",
        "type": "comment"
    },
    "2186": {
        "file_id": 228,
        "content": "    tmpname = \"{}.jpg\".format(str(uuid.uuid4()))\n    tmpname = os.path.join(basepath,tmpname)\n    with open(tmpname,\"wb\") as f:\n        f.write(data)\n    new_name = []\n    picture = cv2.imread(tmpname)\n    result = ocr.ocr(picture, cls=True)\n    for line in result:\n        ((x1,y1),(x2,y2),(x3,y3),(x4,y4)), (string,certainty) = line\n        if certainty > 0.7:\n            new_name.append(string)\n    new_name = \"_\".join(new_name)\n    switch = len(new_name)>3\n    if switch:\n        new_name = \"{}.jpg\".format(new_name)\n        new_name = os.path.join(basepath,new_name)\n        print(\"NEWNAME:\",new_name)\n        shutil.move(tmpname,new_name)",
        "type": "code",
        "location": "/tests/bilibili_practices/bilibili_tarot/get_tarots.py:37-54"
    },
    "2187": {
        "file_id": 228,
        "content": "This code generates a temporary file name, reads image data from 'data' variable into the file, and uses OpenCV to read the image. It then performs OCR (optical character recognition) on the image using the 'ocr' function. The recognized text lines are checked for certainty, and if it exceeds 0.7, the string is added to a new_name list. If the length of the new name is greater than 3 characters, it generates a final file name and moves the temporary file to its permanent location using 'shutil.move()'. It also prints \"NEWNAME:\" followed by the new file name to the console.",
        "type": "comment"
    },
    "2188": {
        "file_id": 229,
        "content": "/tests/bilibili_practices/bilibili_tarot/kill_pdspc.sh",
        "type": "filepath"
    },
    "2189": {
        "file_id": 229,
        "content": "This command finds processes named \"paddlespeech\", gets their process IDs, and then kills them using the KILL signal.",
        "type": "summary"
    },
    "2190": {
        "file_id": 229,
        "content": "ps aux | grep -v grep | grep paddlespeech | awk '{print $2}' | xargs -iabc kill -s KILL abc",
        "type": "code",
        "location": "/tests/bilibili_practices/bilibili_tarot/kill_pdspc.sh:1-1"
    },
    "2191": {
        "file_id": 229,
        "content": "This command finds processes named \"paddlespeech\", gets their process IDs, and then kills them using the KILL signal.",
        "type": "comment"
    },
    "2192": {
        "file_id": 230,
        "content": "/tests/bilibili_practices/bilibili_tarot/kill_xb.sh",
        "type": "filepath"
    },
    "2193": {
        "file_id": 230,
        "content": "This script kills processes named \"xvfb\" and \"scriptable_generate_typography\" by first listing all processes, filtering out grep processes, searching for the desired process names, printing their PIDs, and then sending a TERM signal to kill them.",
        "type": "summary"
    },
    "2194": {
        "file_id": 230,
        "content": "ps aux | grep -v grep | grep xvfb | awk '{print $2}' | xargs -iabc kill -s TERM abc\nps aux | grep -v grep | grep scriptable_generate_typography | awk '{print $2}' | xargs -iabc kill -s TERM abc",
        "type": "code",
        "location": "/tests/bilibili_practices/bilibili_tarot/kill_xb.sh:1-2"
    },
    "2195": {
        "file_id": 230,
        "content": "This script kills processes named \"xvfb\" and \"scriptable_generate_typography\" by first listing all processes, filtering out grep processes, searching for the desired process names, printing their PIDs, and then sending a TERM signal to kill them.",
        "type": "comment"
    },
    "2196": {
        "file_id": 231,
        "content": "/tests/bilibili_practices/bilibili_tarot/mylist.txt",
        "type": "filepath"
    },
    "2197": {
        "file_id": 231,
        "content": "This code appears to be a text file listing videos in a specific order, potentially for a media player or organization system. The video files are named \"video/0.mp4\" and \"video/1.mp4\".",
        "type": "summary"
    },
    "2198": {
        "file_id": 231,
        "content": "file video/0.mp4\nfile video/1.mp4",
        "type": "code",
        "location": "/tests/bilibili_practices/bilibili_tarot/mylist.txt:1-2"
    },
    "2199": {
        "file_id": 231,
        "content": "This code appears to be a text file listing videos in a specific order, potentially for a media player or organization system. The video files are named \"video/0.mp4\" and \"video/1.mp4\".",
        "type": "comment"
    }
}