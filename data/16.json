{
    "1600": {
        "file_id": 134,
        "content": "/tasks/qq/qq_red_packet_collect/launch.sh",
        "type": "filepath"
    },
    "1601": {
        "file_id": 134,
        "content": "Starts a new TMUX session, kills the previously running session with the name \"qq_red_packet\", and then loads the red_packet.yaml configuration file to set up the session environment.",
        "type": "summary"
    },
    "1602": {
        "file_id": 134,
        "content": "tmux kill-session -t qq_red_packet\ntmuxp load red_packet.yaml",
        "type": "code",
        "location": "/tasks/qq/qq_red_packet_collect/launch.sh:1-2"
    },
    "1603": {
        "file_id": 134,
        "content": "Starts a new TMUX session, kills the previously running session with the name \"qq_red_packet\", and then loads the red_packet.yaml configuration file to set up the session environment.",
        "type": "comment"
    },
    "1604": {
        "file_id": 135,
        "content": "/tasks/qq/qq_red_packet_collect/paddletts/test.sh",
        "type": "filepath"
    },
    "1605": {
        "file_id": 135,
        "content": "The code uses the PaddleSpeech TTS (Text-to-Speech) model to convert text \"你好\" into speech and saves it as hello.wav using CPU device. The model is located at ~/.paddlespeech in a drive named Toshiba3000, with possible English-Chinese splitting tests. Pyjom is related to these tests and possibly offers other server interactions.",
        "type": "summary"
    },
    "1606": {
        "file_id": 135,
        "content": "paddlespeech tts --input \"你好\" --output hello.wav --voc hifigan_csmsc --device cpu\n# model location ~/.paddlespeech -> /media/root/Toshiba3000/paddlespeech_models\n# check out pyjom about english-chinese spliting tests. we have model server other than cli interactions.",
        "type": "code",
        "location": "/tasks/qq/qq_red_packet_collect/paddletts/test.sh:1-4"
    },
    "1607": {
        "file_id": 135,
        "content": "The code uses the PaddleSpeech TTS (Text-to-Speech) model to convert text \"你好\" into speech and saves it as hello.wav using CPU device. The model is located at ~/.paddlespeech in a drive named Toshiba3000, with possible English-Chinese splitting tests. Pyjom is related to these tests and possibly offers other server interactions.",
        "type": "comment"
    },
    "1608": {
        "file_id": 136,
        "content": "/tasks/qq/qq_red_packet_collect/red_packet.yaml",
        "type": "filepath"
    },
    "1609": {
        "file_id": 136,
        "content": "The code establishes a window with three panes, executes shell commands for server testing, bilibili video recommendation, and xiaoice chat API; requires login and cautions on Gitter token pasting.",
        "type": "summary"
    },
    "1610": {
        "file_id": 136,
        "content": "session_name: qq_red_packet\nwindows:\n  - window_name: qq_red_packet_window\n    layout: tiled\n    shell_command_before:\n      - cd ~/Desktop/works/pyjom # run as a first command in all panes\n      - bash # to ensure we use the right shell\n      - conda deactivate # to disable conda enviorment\n    panes:\n      - shell_command:\n          - cd tests/qq_opqbot\n          - cd opq_arm64\n          - bash launch.sh # will kill all opqbots.\n      - shell_command: # magic from https://www.wikitechy.com/tutorials/linux/how-to-write-stderr-to-a-file-while-using-tee-with-a-pipe\n          - sleep 10\n          - cd tasks/qq/qq_red_packet_collect # run multiple commands in this pane\n          - keepalive python3 botoy_redpacket_collect.py 1>/dev/null 2> >(tee -a logs/redPacketLog_0.log >&2)\n          # - python3 botoy_redpacket_collect.py 1>/dev/null\n        #   - python3 botoy_redpacket_collect.py --log 1 --log_file 0 1>/dev/null 2> >(tee -a redPacketLog_0.log >&2)\n      # it seems we need another github account to have another gitter developer token.",
        "type": "code",
        "location": "/tasks/qq/qq_red_packet_collect/red_packet.yaml:1-20"
    },
    "1611": {
        "file_id": 136,
        "content": "This code is setting up a window with tiled layout and three panes. The first pane runs a command to change the directory, the second pane waits for 10 seconds before changing to another directory, and the third pane runs a Python script called `botoy_redpacket_collect.py`, redirecting both standard output (STDOUT) and standard error (STDERR) to a log file while using `keepalive` to keep the script running indefinitely.",
        "type": "comment"
    },
    "1612": {
        "file_id": 136,
        "content": "      - shell_command:\n          - cd tests/qq_opqbot\n          - cd opq_arm64_another_account\n          - sleep 3\n          - bash launch.sh # port 8784\n      - shell_command:\n          - sleep 10\n          - cd tasks/qq/qq_red_packet_collect # run multiple commands in this pane\n          - keepalive python3 botoy_redpacket_collect.py --qq 917521610 --port 8784 1>/dev/null 2> >(tee -a logs/redPacketLog_1.log >&2)\n          # - python3 botoy_redpacket_collect.py --qq 917521610 --port 8784 1>/dev/null \n        #   - python3 botoy_redpacket_collect.py  --log 1 --log_file 0 --qq 917521610 --port 8784 1>/dev/null 2> >(tee -a redPacketLog_1.log >&2)\n      - shell_command: # GPT2 LOCAL CHATBOT SERVER\n          - cd tests/cpm_chinese_chitchat_model_gpt2/server/\n          - bash launch.sh\n      - shell_command: # text censor api\n          - cd tasks/qq/qq_red_packet_collect/textfilter \n          - bash launch.sh\n      - shell_command: # image dog/cat recognition server\n          - cd tests/bezier_paddlehub_dogcat_detector_serving",
        "type": "code",
        "location": "/tasks/qq/qq_red_packet_collect/red_packet.yaml:21-39"
    },
    "1613": {
        "file_id": 136,
        "content": "This code is setting up and running multiple services for a chatbot application. It changes directories, executes scripts to launch servers, and specifies ports and other configurations for each service. The primary focus appears to be on the \"botoy_redpacket_collect\" application, which requires multiple command line options.",
        "type": "comment"
    },
    "1614": {
        "file_id": 136,
        "content": "          - python3 server.py\n      - shell_command:\n          - cd tests/bilibili_video_recommendation_server\n          - python3 test.py\n      - shell_command: # xiaoice chat api\n          - cd tests/microsoft_xiaobing_conversation_bing\n          # - node chat_with_session_id.js\n          # - bash xiaobing_server_keepalive.sh\n          - keepalive node chat_with_session_id.js # try it. you may want to replace it with python.\n      # login first!\n      # when pasting gitter tokens, be careful.",
        "type": "code",
        "location": "/tasks/qq/qq_red_packet_collect/red_packet.yaml:40-50"
    },
    "1615": {
        "file_id": 136,
        "content": "The code includes three separate shell commands for running different Python and Node.js scripts related to server testing, bilibili video recommendation, and a xiaoice chat API. It also mentions the need to login first and advises being careful when pasting Gitter tokens.",
        "type": "comment"
    },
    "1616": {
        "file_id": 137,
        "content": "/tasks/qq/qq_red_packet_collect/test_ad_generator.py",
        "type": "filepath"
    },
    "1617": {
        "file_id": 137,
        "content": "Iterates through a list of video data, generates Bilibili video ads using provided info, displays the image output on screen and waits for key press.",
        "type": "summary"
    },
    "1618": {
        "file_id": 137,
        "content": "from ad_template_2_functional import generateBilibiliVideoAd, getAdLock\nvideoData = [\n    [\n        \"BV1Qd4y177Tc\",\n        \"bbb\",\n        \"https://i0.hdslb.com/bfs/archive/8a5f0a2bdffc99d33776c9d1f101521c0fc85e31.jpg\",\n    ],\n    [\n        \"BV1FG411K7Cd\",\n        \"aaa\",\n        \"https://i2.hdslb.com/bfs/archive/6423c88a8d3011a6a911627d9100b4cc4f08758d.jpg\",\n    ],\n]\nimport cv2\nfor (bvid, title_text, image_link) in videoData:\n    with getAdLock():\n        output_path, output_standalone, output_masked_path = generateBilibiliVideoAd(\n            bvid, title_text, image_link\n        )\n        img = cv2.imread(output_path)\n        cv2.imshow(\"IMAGE\", img)\n        cv2.waitKey(0)",
        "type": "code",
        "location": "/tasks/qq/qq_red_packet_collect/test_ad_generator.py:1-25"
    },
    "1619": {
        "file_id": 137,
        "content": "Iterates through a list of video data, generates Bilibili video ads using provided info, displays the image output on screen and waits for key press.",
        "type": "comment"
    },
    "1620": {
        "file_id": 138,
        "content": "/tasks/qq/qq_red_packet_collect/test_adtools.sh",
        "type": "filepath"
    },
    "1621": {
        "file_id": 138,
        "content": "This code changes the current directory (CD) and then runs a test script named \"test_make_dog_cat_connection.py\" using the pytest-3 command, specifically focusing on the test function \"test_query\". This might be related to testing connections between dog and cat data.",
        "type": "summary"
    },
    "1622": {
        "file_id": 138,
        "content": "cd . # really sure that is just because of insufficient power supply for external drives?\npytest-3 -s test_make_dog_cat_connection.py::test_query",
        "type": "code",
        "location": "/tasks/qq/qq_red_packet_collect/test_adtools.sh:1-2"
    },
    "1623": {
        "file_id": 138,
        "content": "This code changes the current directory (CD) and then runs a test script named \"test_make_dog_cat_connection.py\" using the pytest-3 command, specifically focusing on the test function \"test_query\". This might be related to testing connections between dog and cat data.",
        "type": "comment"
    },
    "1624": {
        "file_id": 139,
        "content": "/tasks/qq/qq_red_packet_collect/test_cat_dog_info_get.py",
        "type": "filepath"
    },
    "1625": {
        "file_id": 139,
        "content": "The code imports the getCatOrDogAd function from adtools, defines test_init and test_cats_and_dogs_get_video_names functions. test_init randomly selects a response from getCatOrDogAd (20 responses) for 'cat' category and prints the video information. test_cats_and_dogs_get_video_names iterates over 'cat' and 'dog' categories, retrieves videos using getCatOrDogAd with method 'bm25', and prints their titles. The code also checks if the __name__ is '__main__' to execute either test_init or test_cats_and_dogs_get_video_names function.",
        "type": "summary"
    },
    "1626": {
        "file_id": 139,
        "content": "import random\nfrom adtools import getCatOrDogAd\ndef test_init():\n    cat_or_dog='cat'\n    for _ in range(2):\n        responses = getCatOrDogAd(cat_or_dog)\n        videoInfo = random.choice(responses[:20])\n        print(videoInfo)\n        print()\ndef test_cats_and_dogs_get_video_names():\n    for category in ['cat','dog']:\n        print(\"_\"*20)\n        print(\"CATEGORY?\",category)\n        print()\n        responses = getCatOrDogAd(category,method='bm25') # it does not update that often. use online search instead? (fill keywords in description)\n        for info in responses:\n            title = info['title']\n            print(\"VIDEO?\",title)\nif __name__ == '__main__':\n    # test_init()\n    test_cats_and_dogs_get_video_names()",
        "type": "code",
        "location": "/tasks/qq/qq_red_packet_collect/test_cat_dog_info_get.py:1-25"
    },
    "1627": {
        "file_id": 139,
        "content": "The code imports the getCatOrDogAd function from adtools, defines test_init and test_cats_and_dogs_get_video_names functions. test_init randomly selects a response from getCatOrDogAd (20 responses) for 'cat' category and prints the video information. test_cats_and_dogs_get_video_names iterates over 'cat' and 'dog' categories, retrieves videos using getCatOrDogAd with method 'bm25', and prints their titles. The code also checks if the __name__ is '__main__' to execute either test_init or test_cats_and_dogs_get_video_names function.",
        "type": "comment"
    },
    "1628": {
        "file_id": 140,
        "content": "/tasks/qq/qq_red_packet_collect/test_check_dog_cat.py",
        "type": "filepath"
    },
    "1629": {
        "file_id": 140,
        "content": "This code imports a function to check if an image is of a cat or dog. It prints the rate limits and then runs the check function on an image URL three times, displaying the results. If the confidence score for either 'cat' or 'dog' is above 0.4, it returns that species name.",
        "type": "summary"
    },
    "1630": {
        "file_id": 140,
        "content": "from adtools import checkIsCatOrDogImage, rateLimits\nimage_url = \"http://gchat.qpic.cn/gchatpic_new/3318506826/205569604-2534335053-7D3B7BA4B3476AD210837D8C86F2E8DA/0?vuin=917521610&term=255&pictype=0\"\nprint(\"RATE LIMITS?\", rateLimits)\nfor _ in range(3):\n    r= checkIsCatOrDogImage(image_url) # will raise Exception! warning\n    print(\"RESULT?\")\n    import rich\n    rich.print(r)\nthreshold = 0.4\n# for species in r:\n#     name = species['identity']\n#     if name in ['cat','dog']:\n#         conf = species['confidence']\n#         if conf > threshold:\n#             return name",
        "type": "code",
        "location": "/tasks/qq/qq_red_packet_collect/test_check_dog_cat.py:1-20"
    },
    "1631": {
        "file_id": 140,
        "content": "This code imports a function to check if an image is of a cat or dog. It prints the rate limits and then runs the check function on an image URL three times, displaying the results. If the confidence score for either 'cat' or 'dog' is above 0.4, it returns that species name.",
        "type": "comment"
    },
    "1632": {
        "file_id": 141,
        "content": "/tasks/qq/qq_red_packet_collect/test_download_qq_image.sh",
        "type": "filepath"
    },
    "1633": {
        "file_id": 141,
        "content": "This script downloads a QQ image using curl, saves it as \"qq_image_received.image\", and is compatible with OpenCV for processing.",
        "type": "summary"
    },
    "1634": {
        "file_id": 141,
        "content": "# you cannot receive qq voice with opq!\n# but you can download image when it has not expired.\n# what is the type of this image?\ncurl -L -o qq_image_received.image \"http://gchat.qpic.cn/gchatpic_new/3318506826/205569604-2534335053-7D3B7BA4B3476AD210837D8C86F2E8DA/0?vuin=917521610&term=255&pictype=0\"\n# cv2 can handle that.",
        "type": "code",
        "location": "/tasks/qq/qq_red_packet_collect/test_download_qq_image.sh:1-6"
    },
    "1635": {
        "file_id": 141,
        "content": "This script downloads a QQ image using curl, saves it as \"qq_image_received.image\", and is compatible with OpenCV for processing.",
        "type": "comment"
    },
    "1636": {
        "file_id": 142,
        "content": "/tasks/qq/qq_red_packet_collect/test_get_all_my_videos.py",
        "type": "filepath"
    },
    "1637": {
        "file_id": 142,
        "content": "Code makes a POST request to localhost on port 7341, endpoint \"searchUserVideos\", with an empty query and tid 0 for the latest video of own user. Uses requests library, prints data in JSON format using rich library.",
        "type": "summary"
    },
    "1638": {
        "file_id": 142,
        "content": "import requests\nport, endpoint = 7341, \"searchUserVideos\"\npostData = {\"query\":\"\", \"tid\": 0, \"method\": \"online\"} # this is to get latest video of my own. fuck. better turned into registration based method.\n# postData = {'query':\"狗\", \"tid\":0, \"method\":\"bm25\"}\nr = requests.post(f\"http://localhost:{port}/{endpoint}\", json=postData)\ndata = r.json()\nprint(\"data\")\nimport rich\nrich.print(data)",
        "type": "code",
        "location": "/tasks/qq/qq_red_packet_collect/test_get_all_my_videos.py:1-11"
    },
    "1639": {
        "file_id": 142,
        "content": "Code makes a POST request to localhost on port 7341, endpoint \"searchUserVideos\", with an empty query and tid 0 for the latest video of own user. Uses requests library, prints data in JSON format using rich library.",
        "type": "comment"
    },
    "1640": {
        "file_id": 143,
        "content": "/tasks/qq/qq_red_packet_collect/test_make_dog_cat_connection.py",
        "type": "filepath"
    },
    "1641": {
        "file_id": 143,
        "content": "This code imports a function from adtools to test making connections between cats and dogs. It defines three test functions: \"test_main\", \"test_delete\", and \"test_query\". The \"test_query\" function retrieves cat and dog ads. The main code block runs the \"test_query\" function if this script is run directly.",
        "type": "summary"
    },
    "1642": {
        "file_id": 143,
        "content": "from adtools import makeCatOrDogConnections, getCatOrDogAd\ndef test_main():\n    makeCatOrDogConnections(\"123\", \"345\", \"cat\", debug=True)\ndef test_delete():\n    makeCatOrDogConnections(\"123\", \"345\", \"cat\", debug=True, delete=True)\ndef test_query():\n    response = getCatOrDogAd(\"cat\", debug=True)\n    response = getCatOrDogAd(\"dog\", debug=True)\nif __name__ == \"__main__\":\n    test_query()",
        "type": "code",
        "location": "/tasks/qq/qq_red_packet_collect/test_make_dog_cat_connection.py:1-18"
    },
    "1643": {
        "file_id": 143,
        "content": "This code imports a function from adtools to test making connections between cats and dogs. It defines three test functions: \"test_main\", \"test_delete\", and \"test_query\". The \"test_query\" function retrieves cat and dog ads. The main code block runs the \"test_query\" function if this script is run directly.",
        "type": "comment"
    },
    "1644": {
        "file_id": 144,
        "content": "/tasks/qq/qq_red_packet_collect/test_neo4j_creds.py",
        "type": "filepath"
    },
    "1645": {
        "file_id": 144,
        "content": "This code tests Neo4j credentials by iterating through various usernames and passwords, attempting to connect and retrieve a single node result. It prints the retrieved result and the used credentials if successful, or catches any exceptions during the process.",
        "type": "summary"
    },
    "1646": {
        "file_id": 144,
        "content": "from adtools import getNeo4jDriver\ndef test_login():\n    usernames = [\"kali\", \"user\", \"neo4j\", \"admin\", \"parrot\", \"\"]\n    passwords = [\"neo4j\", \"kali\", \"parrot\", \"admin\", \"password\", \"\"]\n    for u in usernames:\n        for p in passwords:\n            try:\n                driver = getNeo4jDriver(username=u, password=p, debug=False)\n                # print('RESPONSE?',r)\n                with driver.session() as session:\n                    result = session.run(\"MATCH (n) RETURN n LIMIT 1\")\n                    print(result.single())\n                    print(\"USING:\", u, p)\n            except:\n                pass\n                # import traceback\n                # traceback.print_exc()",
        "type": "code",
        "location": "/tasks/qq/qq_red_packet_collect/test_neo4j_creds.py:1-19"
    },
    "1647": {
        "file_id": 144,
        "content": "This code tests Neo4j credentials by iterating through various usernames and passwords, attempting to connect and retrieve a single node result. It prints the retrieved result and the used credentials if successful, or catches any exceptions during the process.",
        "type": "comment"
    },
    "1648": {
        "file_id": 145,
        "content": "/tasks/qq/qq_red_packet_collect/test_qrcode_insert_replace.py",
        "type": "filepath"
    },
    "1649": {
        "file_id": 145,
        "content": "This code imports a function to remove and insert QR codes, then tests it with two image inputs and a specific qrcode_path. It displays the output images in a window before exiting.",
        "type": "summary"
    },
    "1650": {
        "file_id": 145,
        "content": "from ad_template_2_functional import removeAndInsertQRCode\nimport cv2\ndef test_main():\n    images = [\n        \"/root/Desktop/works/pyjom/samples/image/qrcode_test/no_qrcode.jpg\",\n        \"/root/Desktop/works/pyjom/samples/image/qrcode_test/with_qrcode.jpg\",\n    ]  # convert to compatible formats first.\n    qrcode_path = \"/root/Desktop/works/pyjom/tests/bilibili_video_recommendation_server/ebegging_template.png\"\n    for img in images:\n        output = removeAndInsertQRCode(img, qrcode_path, None)\n        cv2.imshow(\"IMG\", output)\n        cv2.waitKey(0)\nif __name__ == \"__main__\":\n    test_main()",
        "type": "code",
        "location": "/tasks/qq/qq_red_packet_collect/test_qrcode_insert_replace.py:1-20"
    },
    "1651": {
        "file_id": 145,
        "content": "This code imports a function to remove and insert QR codes, then tests it with two image inputs and a specific qrcode_path. It displays the output images in a window before exiting.",
        "type": "comment"
    },
    "1652": {
        "file_id": 146,
        "content": "/tasks/qq/qq_red_packet_collect/textfilter/filter_py3_fastapi.py",
        "type": "filepath"
    },
    "1653": {
        "file_id": 146,
        "content": "The code offers text filtering through classes like NaiveFilter and BSFilter for keyword removal and regex processing, plus a DFAFilter for performance boost. It checks characters, translates Chinese to Pinyin, and returns moderated text via FastAPI endpoint.",
        "type": "summary"
    },
    "1654": {
        "file_id": 146,
        "content": "#!/usr/bin/env python\n# -*- coding:utf-8 -*-\nfrom collections import defaultdict\nimport re\n__all__ = ['NaiveFilter', 'BSFilter', 'DFAFilter']\n__author__ = 'observer'\n__date__ = '2012.01.05'\nclass NaiveFilter():\n    '''Filter Messages from keywords\n    very simple filter implementation\n    >>> f = NaiveFilter()\n    >>> f.add(\"sexy\")\n    >>> f.filter(\"hello sexy baby\")\n    hello **** baby\n    '''\n    def __init__(self):\n        self.keywords = set([])\n    def parse(self, path):\n        for keyword in open(path):\n            self.keywords.add(keyword.strip().decode('utf-8').lower())\n    def filter(self, message, repl=\"*\"):\n        message = str(message).lower()\n        for kw in self.keywords:\n            message = message.replace(kw, repl)\n        return message\nclass BSFilter:\n    '''Filter Messages from keywords\n    Use Back Sorted Mapping to reduce replacement times\n    >>> f = BSFilter()\n    >>> f.add(\"sexy\")\n    >>> f.filter(\"hello sexy baby\")\n    hello **** baby\n    '''\n    def __init__(self):\n        self.keywords = []",
        "type": "code",
        "location": "/tasks/qq/qq_red_packet_collect/textfilter/filter_py3_fastapi.py:1-48"
    },
    "1655": {
        "file_id": 146,
        "content": "This code is for creating a filter to remove specific keywords from a given message. It provides three classes: NaiveFilter, BSFilter, and DFAFilter. NaiveFilter is the simplest implementation using set data structure, while BSFilter uses Back Sorted Mapping to improve performance by reducing replacement times. The code also includes parsing functionality to add keywords from a file.",
        "type": "comment"
    },
    "1656": {
        "file_id": 146,
        "content": "        self.kwsets = set([])\n        self.bsdict = defaultdict(set)\n        self.pat_en = re.compile(r'^[0-9a-zA-Z]+$')  # english phrase or not\n    def add(self, keyword):\n        if not isinstance(keyword, str):\n            keyword = keyword.decode('utf-8')\n        keyword = keyword.lower()\n        if keyword not in self.kwsets:\n            self.keywords.append(keyword)\n            self.kwsets.add(keyword)\n            index = len(self.keywords) - 1\n            for word in keyword.split():\n                if self.pat_en.search(word):\n                    self.bsdict[word].add(index)\n                else:\n                    for char in word:\n                        self.bsdict[char].add(index)\n    def parse(self, path):\n        with open(path, \"r\") as f:\n            for keyword in f:\n                self.add(keyword.strip())\n    def filter(self, message, repl=\"*\"):\n        if not isinstance(message, str):\n            message = message.decode('utf-8')\n        message = message.lower()\n        for word in message.split():",
        "type": "code",
        "location": "/tasks/qq/qq_red_packet_collect/textfilter/filter_py3_fastapi.py:49-77"
    },
    "1657": {
        "file_id": 146,
        "content": "This code defines a class with methods for adding keywords, parsing from a file, and filtering text. It uses regular expressions to identify English words and stores them in dictionaries based on their characters or full words. The parse method reads a file of keywords and the filter method processes input messages by replacing non-keyword parts with \"*\".",
        "type": "comment"
    },
    "1658": {
        "file_id": 146,
        "content": "            if self.pat_en.search(word):\n                for index in self.bsdict[word]:\n                    message = message.replace(self.keywords[index], repl)\n            else:\n                for char in word:\n                    for index in self.bsdict[char]:\n                        message = message.replace(self.keywords[index], repl)\n        return message\nclass DFAFilter():\n    '''Filter Messages from keywords\n    Use DFA to keep algorithm perform constantly\n    >>> f = DFAFilter()\n    >>> f.add(\"sexy\")\n    >>> f.filter(\"hello sexy baby\")\n    hello **** baby\n    '''\n    def __init__(self):\n        self.keyword_chains = {}\n        self.delimit = '\\x00'\n    def add(self, keyword):\n        if not isinstance(keyword, str):\n            keyword = keyword.decode('utf-8')\n        keyword = keyword.lower()\n        chars = keyword.strip()\n        if not chars:\n            return\n        level = self.keyword_chains\n        for i in range(len(chars)):\n            if chars[i] in level:\n                level = level[chars[i]]",
        "type": "code",
        "location": "/tasks/qq/qq_red_packet_collect/textfilter/filter_py3_fastapi.py:78-113"
    },
    "1659": {
        "file_id": 146,
        "content": "This code defines a DFAFilter class to filter messages from keywords. It uses DFA (Deterministic Finite Automaton) to improve algorithm performance. The add method adds a keyword and the filter method replaces keywords with asterisks (*). If the keyword is already in the DFA, it updates the level of the DFA accordingly.",
        "type": "comment"
    },
    "1660": {
        "file_id": 146,
        "content": "            else:\n                if not isinstance(level, dict):\n                    break\n                for j in range(i, len(chars)):\n                    level[chars[j]] = {}\n                    last_level, last_char = level, chars[j]\n                    level = level[chars[j]]\n                last_level[last_char] = {self.delimit: 0}\n                break\n        if i == len(chars) - 1:\n            level[self.delimit] = 0\n    def parse(self, path):\n        with open(path) as f:\n            for keyword in f:\n                self.add(keyword.strip())\n    def filter(self, message, repl=\"*\"):  # what is this repl?\n        if not isinstance(message, str):\n            message = message.decode('utf-8')\n        message = message.lower()\n        ret = []\n        start = 0\n        while start < len(message):\n            level = self.keyword_chains\n            step_ins = 0\n            for char in message[start:]:\n                if char in level:\n                    step_ins += 1\n                    if self.delimit not in level[char]:",
        "type": "code",
        "location": "/tasks/qq/qq_red_packet_collect/textfilter/filter_py3_fastapi.py:114-143"
    },
    "1661": {
        "file_id": 146,
        "content": "This code is parsing a text file of keywords and their corresponding chains. It then filters a given message by replacing instances of the keyword chains with a placeholder (\"*\"). The \"repl\" argument in filter() function seems to be optional and represents the placeholder character used for replacement. If the input message is not a string, it's decoded from its original format (like bytes) to a string. The code maintains a nested dictionary structure representing keyword chains, and if a delimiter is found missing in a chain, it's set to 0.",
        "type": "comment"
    },
    "1662": {
        "file_id": 146,
        "content": "                        level = level[char]\n                    else:\n                        # print(\"STEPINS\", step_ins)\n                        # print(\"CHAR\", char)\n                        # print(level[char])\n                        ret.append(repl * step_ins)\n                        start += step_ins - 1\n                        break\n                else:\n                    ret.append(message[start])\n                    break\n            else:\n                ret.append(message[start])\n            start += 1\n        return ''.join(ret)\ndef test_first_character():\n    gfw = DFAFilter()\n    gfw.add(\"1989年\")\n    assert gfw.filter(\"1989\", \"*\") == \"1989\"\ngfw = DFAFilter()\ngfw.parse(\"keywords\")\nfrom typing import Union\nfrom fastapi import FastAPI\napp = FastAPI()\nfrom snownlp import SnowNLP\nfrom snownlp.normal import pin, re_zh\n# import re\ndef getPinyin(originalText,\n              filteredText,\n              whitelistChars=[\"的\"],\n              whitelistNonChinese=True):  # any repl will do.\n    blocks = [x for x in re_zh.split(originalText) if len(x) > 0]",
        "type": "code",
        "location": "/tasks/qq/qq_red_packet_collect/textfilter/filter_py3_fastapi.py:144-186"
    },
    "1663": {
        "file_id": 146,
        "content": "This function takes a message and filters it based on a DFA (Deterministic Finite Automaton) filter. It checks each character in the message, appending replacements if necessary or keeping the original character if not. If a keyword is found, it replaces it with '*'. The function returns the filtered text as a string.\n\nThe code also includes a test case for checking if the first character of the filter result matches the expected output for the given input. Additionally, there are import statements and function definitions for other functionalities like getting pinyin and handling Chinese text.",
        "type": "comment"
    },
    "1664": {
        "file_id": 146,
        "content": "    # words = result.words\n    translate_list = []\n    for block in blocks:\n        if re_zh.match(block):\n            block_pinyin = pin.get(block)\n            for index, pinyin in enumerate(block_pinyin):\n                character = block[index]\n                translate_list.append((character, pinyin[0]))\n        else:\n            for index, character in enumerate(block):\n                translate_list.append((character, character))\n    moderatedText = \"\"\n    for index, (originalCharacter, pinyin) in enumerate(translate_list):\n        filteredCharacter = filteredText[index]\n        if filteredCharacter == originalCharacter or originalCharacter in whitelistChars or (\n                whitelistNonChinese and (not re_zh.match(originalCharacter))): # changed the moderator logic.\n            moderatedText += originalCharacter\n        elif pinyin != originalCharacter:\n            moderatedText += pinyin\n        else:\n            moderatedText += filteredCharacter\n    return moderatedText\n@app.get(\"/\")\ndef read_root():",
        "type": "code",
        "location": "/tasks/qq/qq_red_packet_collect/textfilter/filter_py3_fastapi.py:187-213"
    },
    "1665": {
        "file_id": 146,
        "content": "This code filters text by translating Chinese characters into their corresponding Pinyin while preserving non-Chinese characters or whitelisted characters. It creates a list of translated characters and applies the filter logic to generate a moderated text output, which is returned as the result. Additionally, there's an API endpoint (\"/\") defined for accessing this functionality through a FastAPI server.",
        "type": "comment"
    },
    "1666": {
        "file_id": 146,
        "content": "    return {\"response\": \"DFAFilter based Chinese text filter(censor)\"}\n@app.get(\"/filter\")\ndef read_item(text: Union[str, None] = None, moderate: bool = True):\n    originalText = text\n    filteredText = gfw.filter(text, \"*\")\n    if moderate:\n        moderatedText = getPinyin(originalText, filteredText)\n        return {\"response\": moderatedText}\n    else:\n        return {\"response\": filteredText}",
        "type": "code",
        "location": "/tasks/qq/qq_red_packet_collect/textfilter/filter_py3_fastapi.py:214-225"
    },
    "1667": {
        "file_id": 146,
        "content": "This code defines a FastAPI route (\"/filter\") that takes in a text input and applies GFW filtering. If the \"moderate\" parameter is True, it generates a moderated text by replacing Chinese characters with their corresponding pinyin. Otherwise, it returns the filtered text.",
        "type": "comment"
    },
    "1668": {
        "file_id": 147,
        "content": "/tasks/qq/qq_red_packet_collect/textfilter/launch.sh",
        "type": "filepath"
    },
    "1669": {
        "file_id": 147,
        "content": "Launches the FastAPI application using uvicorn, listens on port 8932, and provides an option for auto-reloading with --reload. However, the comment suggests not to use the reload feature.",
        "type": "summary"
    },
    "1670": {
        "file_id": 147,
        "content": "python3 -m uvicorn filter_py3_fastapi:app --port 8932 \n# python3 -m uvicorn filter_py3_fastapi:app --reload --port 8932 \n# do not use reload!",
        "type": "code",
        "location": "/tasks/qq/qq_red_packet_collect/textfilter/launch.sh:1-3"
    },
    "1671": {
        "file_id": 147,
        "content": "Launches the FastAPI application using uvicorn, listens on port 8932, and provides an option for auto-reloading with --reload. However, the comment suggests not to use the reload feature.",
        "type": "comment"
    },
    "1672": {
        "file_id": 148,
        "content": "/tests/README.md",
        "type": "filepath"
    },
    "1673": {
        "file_id": 148,
        "content": "This code snippet aims to integrate a recommendation system into the existing LLM (Large Language Model) and scrapers. By doing so, it intends to enhance the overall performance and efficiency of the language model and web scraping processes.",
        "type": "summary"
    },
    "1674": {
        "file_id": 148,
        "content": "use recommendation system to enhance our LLM/scrapers",
        "type": "code",
        "location": "/tests/README.md:1-1"
    },
    "1675": {
        "file_id": 148,
        "content": "This code snippet aims to integrate a recommendation system into the existing LLM (Large Language Model) and scrapers. By doing so, it intends to enhance the overall performance and efficiency of the language model and web scraping processes.",
        "type": "comment"
    },
    "1676": {
        "file_id": 149,
        "content": "/tests/adb_phone_control_termux_network_broadcast_scrcpy_appium_airtest/README.md",
        "type": "filepath"
    },
    "1677": {
        "file_id": 149,
        "content": "This code covers device discovery, Termux daemon, remote unlock with ADB and scrcpy client, focused window titles, downloading a macOS keylogger, and executes input tests on the X server.",
        "type": "summary"
    },
    "1678": {
        "file_id": 149,
        "content": "device discovery, termux daemon, remote unlock\nunlock requires screenshot and input events.\nhttps://technastic.com/unlock-android-phone-pin-pattern-adb/\nclick ok after input password:\nhttps://stackoverflow.com/questions/29072501/how-to-unlock-android-phone-through-adb\nscrcpy client\nhttps://github.com/leng-yue/py-scrcpy-client\nhttps://leng-yue.github.io/py-scrcpy-client/guide.html#bind-events\nyou want to use android emulator on macos m1?\nhttps://github.com/google/android-emulator-m1-preview/releases/tag/0.3\ncheck android screen lock/unlock state\nhttps://android.stackexchange.com/questions/191086/adb-commands-to-get-screen-state-and-locked-state\nBonjour/Avahi/Zeroconf\nlogic: if the kill switch is off, when no physical input events happens, or not focused on scrcpy window with keyboard/mouse input events on pc for some time, allow to interact with the phone.\nget physical events:\nwarning: this command could be offline for a short period of time after using the scrcpy. must automatically reconnect if the device is not offline.",
        "type": "code",
        "location": "/tests/adb_phone_control_termux_network_broadcast_scrcpy_appium_airtest/README.md:1-30"
    },
    "1679": {
        "file_id": 149,
        "content": "This code focuses on device discovery, termux daemon, remote unlock, using scrcpy client and android emulator on MacOS M1. It includes links for unlocking Android phone through ADB, checking screen lock/unlock state, utilizing Bonjour/Avahi/Zeroconf logic, handling physical events and reconnecting if necessary.",
        "type": "comment"
    },
    "1680": {
        "file_id": 149,
        "content": "```bash\nadb -s 192.168.10.3:5555 shell getevent\n```\nto get focused window title:\nhint: for headless ssh sessions, must set apropriate xorg environment variables, eg: `env XAUTHORITY=\"/run/user/0/gdm/Xauthority\" DISPLAY=:1 python3`\ngeneral method:\n```python\nimport pywinctl\npywinctl.getActiveWindowTitle()\n```\nfor linux:\n```bash\nwatch -n 2 xdotool getactivewindow getwindowname\n```\nfor macos: (allow permission first, deprecated since it will not get the window title instead of the program name)\nhttps://alvinalexander.com/mac-os-x/applescript-unix-mac-osx-foreground-application-result/\n(where is the window name?)\n```bash\nsleep 3 && osascript -e 'tell application \"System Events\"' -e 'set frontApp to name of first application process whose frontmost is true' -e 'end tell'\n```\nto get input events on macos:\ndownload keylogger here:\nhttps://hackernoon.com/writing-an-keylogger-for-macos-in-python-24adfa22722\nhttps://github.com/beatsbears/pkl?ref=hackernoon.com\n```bash\npython pkl_nowriting.py\n```\ninput events on linux:\n```bash",
        "type": "code",
        "location": "/tests/adb_phone_control_termux_network_broadcast_scrcpy_appium_airtest/README.md:32-68"
    },
    "1681": {
        "file_id": 149,
        "content": "This code provides methods to obtain the focused window title on different operating systems: Bash commands for Android devices and Windows, Python script for Linux, Applescript for macOS. Additionally, it mentions downloading a keylogger for capturing input events on macOS.",
        "type": "comment"
    },
    "1682": {
        "file_id": 149,
        "content": "xinput test-xi2 --root\n```",
        "type": "code",
        "location": "/tests/adb_phone_control_termux_network_broadcast_scrcpy_appium_airtest/README.md:69-70"
    },
    "1683": {
        "file_id": 149,
        "content": "Executes an input test on the X server, affecting all connected devices.",
        "type": "comment"
    },
    "1684": {
        "file_id": 150,
        "content": "/tests/adb_phone_control_termux_network_broadcast_scrcpy_appium_airtest/get_modifier.sh",
        "type": "filepath"
    },
    "1685": {
        "file_id": 150,
        "content": "This line establishes a TCP/IP connection on port 5555 for ADB, ensuring the device is reachable over the network.",
        "type": "summary"
    },
    "1686": {
        "file_id": 150,
        "content": "adb tcpip 5555 # will not restart if already in tcpip mode\\",
        "type": "code",
        "location": "/tests/adb_phone_control_termux_network_broadcast_scrcpy_appium_airtest/get_modifier.sh:1-1"
    },
    "1687": {
        "file_id": 150,
        "content": "This line establishes a TCP/IP connection on port 5555 for ADB, ensuring the device is reachable over the network.",
        "type": "comment"
    },
    "1688": {
        "file_id": 151,
        "content": "/tests/adb_phone_control_termux_network_broadcast_scrcpy_appium_airtest/get_modifier_with_masscan_scapy.py",
        "type": "filepath"
    },
    "1689": {
        "file_id": 151,
        "content": "This code uses Masscan to scan for open ports, connects to the desired port with AdbWrapper, and stores connected addresses in a list. It is part of a script for controlling devices over the network.",
        "type": "summary"
    },
    "1690": {
        "file_id": 151,
        "content": "# strange.\nfrom __future__ import absolute_import, division, print_function\nimport logging\nimport scapy.config\nimport scapy.layers.l2\nimport scapy.route\nimport socket\nimport math\nimport errno\nimport os\nimport getopt\nimport sys\nmyPort = 5555\nmyInterface = \"wlan0\"\n# list avaliable devices.\nfrom adb_wrapper import AdbWrapper\na = AdbWrapper()\ndevices = a.devices()\nprint(devices)\n# exit()\nconnected_addresses = []\nfor key, value in devices.items():\n    address = key\n    connected_addresses.append(address)\n    deviceType = value\n# not working.\nif os.geteuid() != 0:\n        print('You need to be root to run this script', file=sys.stderr)\n        sys.exit(1)\nscanAddress = None\nfor network, netmask, _, interface, address, _ in scapy.config.conf.route.routes:\n    # print(interface, address)\n    if interface == myInterface:\n        myAddress = address.split(\".\")\n        myAddress[3] = \"0/24\"\n        scanAddress = \".\".join(myAddress)\n        print(scanAddress, interface)\n        break\nif scanAddress is not None:\n    # now scan this interface with masscan.",
        "type": "code",
        "location": "/tests/adb_phone_control_termux_network_broadcast_scrcpy_appium_airtest/get_modifier_with_masscan_scapy.py:1-42"
    },
    "1691": {
        "file_id": 151,
        "content": "The code imports necessary libraries, initializes variables, and connects with available devices using AdbWrapper. It then checks if the user is root before attempting to scan a specific network interface using masscan.",
        "type": "comment"
    },
    "1692": {
        "file_id": 151,
        "content": "    import masscan\n    mas = masscan.PortScanner()\n    mas.scan(scanAddress, ports=str(myPort), arguments='--max-rate 1000')\n    result = mas.scan_result\n    # usually it only show opens.\n    import json\n    scanResultDict = json.loads(result)['scan']\n    for key, value in scanResultDict.items():\n        address = key\n        for port in value:\n            if port['port'] == myPort and port['status'] =='open':\n                # print(address, myPort)\n                # we need to connect to it!\n                connect_address = \"{}:{}\".format(address,myPort)\n                print(connect_address)\n                if not connect_address in connected_addresses:\n                    print(\"connecting device:\", connect_address)\n                    # command1 = \"adb tcpip 5555\"\n                    # no need to restart?\n                    command2 = \"adb connect {}\".format(connect_address)\n                    # os.system(command1)\n                    os.system(command2)",
        "type": "code",
        "location": "/tests/adb_phone_control_termux_network_broadcast_scrcpy_appium_airtest/get_modifier_with_masscan_scapy.py:43-64"
    },
    "1693": {
        "file_id": 151,
        "content": "This code is using the Masscan library to scan for open ports on a specified address. It then checks if the desired port is open, and if so, connects to it by running \"adb connect\" command. The connected addresses are stored in the connected_addresses list. This code is part of a broader script for controlling devices over network.",
        "type": "comment"
    },
    "1694": {
        "file_id": 152,
        "content": "/tests/adb_phone_control_termux_network_broadcast_scrcpy_appium_airtest/pkl_nowriting.py",
        "type": "filepath"
    },
    "1695": {
        "file_id": 152,
        "content": "This Python script logs keystrokes and mouse events via Cocoa, for educational purposes, requires privilege settings adjustment, and has an event loop with interrupt handling.",
        "type": "summary"
    },
    "1696": {
        "file_id": 152,
        "content": "#!/usr/bin/env python\n\"\"\"\npkl.py\n:author: Andrew Scott\n:date: 9-3-2018\nIf executed successfully this script will log key strokes until the process is killed.\nThis script is for EDUCATIONAL PURPOSES ONLY. \n\"\"\"\n# can be run without root, but must enable the privilege in privacy settings\nimport os, sys\nsys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))\nfrom AppKit import NSApplication, NSApp\nfrom Foundation import NSObject\nfrom Cocoa import (\n    NSEvent,\n    NSKeyDownMask, # keyboard\n    NSLeftMouseUpMask, # mouse\n    NSLeftMouseDownMask,\n    NSLeftMouseDraggedMask,\n    NSRightMouseDownMask,\n    NSRightMouseDraggedMask,\n    NSRightMouseUpMask,\n    NSMouseMovedMask,\n)\nfrom PyObjCTools import AppHelper\n# NSLeftMouseUpMask, NSLeftMouseDownMask, NSLeftMouseDraggedMask, NSRightMouseDownMask, NSRightMouseDraggedMask, NSRightMouseUpMask, NSMouseMovedMask\nclass AppDelegate(NSObject):\n    \"\"\"\n    The App Delegate creates a mask to detect the key being pressed and adds\n    a global monitor for this mask.",
        "type": "code",
        "location": "/tests/adb_phone_control_termux_network_broadcast_scrcpy_appium_airtest/pkl_nowriting.py:1-38"
    },
    "1697": {
        "file_id": 152,
        "content": "This Python script logs key strokes until the process is killed, intended for educational purposes only. It uses AppKit and Foundation modules from Cocoa and PyObjCTools to create an app delegate that detects keyboard and mouse events without root access, but requires enabling privilege in privacy settings.",
        "type": "comment"
    },
    "1698": {
        "file_id": 152,
        "content": "    \"\"\"\n    def applicationDidFinishLaunching_(self, notification):\n        mask_down = NSKeyDownMask\n        mouse_masks = [\n            NSLeftMouseUpMask,\n            NSLeftMouseDownMask,\n            NSLeftMouseDraggedMask,\n            NSRightMouseDownMask,\n            NSRightMouseDraggedMask,\n            NSRightMouseUpMask,\n            NSMouseMovedMask,\n        ]\n        NSEvent.addGlobalMonitorForEventsMatchingMask_handler_(mask_down, key_handler)\n        for mouse_mask in mouse_masks:\n            NSEvent.addGlobalMonitorForEventsMatchingMask_handler_(\n                mouse_mask, mouse_handler\n            )\n# w = Writer()\ndef mouse_handler(event):\n    import time\n    print(\"mouse have actions\", time.time())\ndef key_handler(event):\n    \"\"\"\n    Translates the key press events into readable characters if one exists\n    the key code is also recorded for non-character input.\n    \"\"\"\n    try:\n        capture_char = event.characters()\n        capture_raw = event.keyCode()\n        print(capture_char, capture_raw)\n        # w.write_to_log(capture_char, capture_raw)",
        "type": "code",
        "location": "/tests/adb_phone_control_termux_network_broadcast_scrcpy_appium_airtest/pkl_nowriting.py:39-74"
    },
    "1699": {
        "file_id": 152,
        "content": "The code sets up event handlers for various mouse actions and keyboard events. It adds a global monitor to track these events, and when an event occurs, it logs the characters (if any) and keyCode. The code also includes functions for handling the mouse and key events, but they do not appear to perform any specific actions beyond logging.",
        "type": "comment"
    }
}