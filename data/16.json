{
    "1600": {
        "file_id": 144,
        "content": "            },\n            User.dedeuserid == credential.dedeuserid,\n        )\n        if returnName:\n            return name\n        else:\n            return True\n    except:\n        import traceback\n        traceback.print_exc()\n        print(\"invalid credential:\", credential)\n        return False\ndef removeCredentialByDedeUserId(dedeuserid: str):\n    try:\n        db.remove(User.dedeuserid == dedeuserid)\n        return True\n    except:\n        import traceback\n        traceback.print_exc()\n        print(\n            \"error when removing credential from database for dedeuserid:\", dedeuserid\n        )\n        return False\n# from lazero.program.functools import skipException\nfrom lazero.program.functools import suppressException\n# @skipException(defaultReturn = None, breakpoint_flag=True, debug_flag=True, global_variables=globals(), local_variables=locals()) # send_sms is not definded here. WTF?\n@suppressException(defaultReturn=None, showException=True)  # trycatch based.\ndef getCredentialViaSMS():\n    phone = input(\"请输入手机号：\")",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/credentials.py:39-74"
    },
    "1601": {
        "file_id": 144,
        "content": "The code is a Python implementation for managing bilibili credentials. The `getCredentialViaSMS` function allows users to input their phone number and retrieves the corresponding credential via SMS verification. The `removeCredentialByDedeUserId` function removes a credential from the database based on the provided dedeuserid. Both functions handle exceptions using try-except blocks, providing error messages and returning False if any errors occur during execution.",
        "type": "comment"
    },
    "1602": {
        "file_id": 144,
        "content": "    print(\"正在登录。\")\n    send_sms(PhoneNumber(phone, country=\"+86\"))  # 默认设置地区为中国大陆\n    code = input(\"请输入验证码：\")\n    c = login_with_sms(PhoneNumber(phone, country=\"+86\"), code)\n    credential = c\n    # first, check if this is a valid credential.\n    name = verifyCredential(credential)\n    return credential, name\ndef getCredentialByDedeUserId(dedeuserid: str = \"397424026\"):\n    dataList = db.search(User.dedeuserid == dedeuserid)\n    if len(dataList) != 1:\n        if len(dataList) != 0:\n            # remove all related records.\n            print(\"multiple credentials found for dedeuserid:\", dedeuserid)\n            removeCredentialByDedeUserId(dedeuserid)\n        else:\n            print(\"no credential found for dedeuserid:\", dedeuserid)\n    else:\n        # check validity.\n        data = dataList[0].copy()\n        print(\"try to login credential fetched from db:\", data)\n        oldName = data.pop(\"name\")\n        print(\"previous name:\", oldName)\n        credential = Credential(**data)\n        name = verifyCredential(credential)",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/credentials.py:75-101"
    },
    "1603": {
        "file_id": 144,
        "content": "The code is responsible for logging in to a Bilibili account and retrieving the user's credentials. It first attempts to log in using an SMS verification code, then checks if the provided credential is valid by verifying it with the database. The function `getCredentialByDedeUserId` allows fetching credentials based on the given dedeuserid. If multiple or no credentials are found for the specified id, appropriate error messages are printed and potentially irrelevant records are removed from the database.",
        "type": "comment"
    },
    "1604": {
        "file_id": 144,
        "content": "        if name != False:\n            print(\"login successful:\", name)\n            return credential\n        else:\n            print(\"login failed with existing credential for user:\", oldName)\n            removeCredentialByDedeUserId(\n                dedeuserid\n            )  # warning. my credential has been removed because of that async problem. please relogin.\n    # anyway if you are here, nothing in database related to this dedeuserid now.\n    # you choose to login via SMS.\n    while True:\n        # could be troublesome.\n        result = getCredentialViaSMS()\n        if result != None:  # has type check here?\n            credential, name = result\n            if name != False:\n                print(\"登录成功\")\n                # update with this credential!\n                # next, check if this is the credential we need.\n                if credential.dedeuserid == dedeuserid:\n                    return credential\n                else:\n                    print(\"dedeuserid not right.\")\n                    print(",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/credentials.py:102-125"
    },
    "1605": {
        "file_id": 144,
        "content": "The code checks if the provided name is not False and prints \"login successful\" along with the name. If the name is False, it prints a failed login message and removes the existing credential associated with the user. The code then allows the user to log in via SMS. It retrieves the credential from SMS and checks if the dedeuserid matches the desired value. If it does, the credential is returned; otherwise, a message is printed indicating that the dedeuserid is incorrect.",
        "type": "comment"
    },
    "1606": {
        "file_id": 144,
        "content": "                        \"user %s (dedeuserid: %s) does not have dedeuserid: %s\"\n                        % (name, credential.dedeuserid, dedeuserid)\n                    )\n        else:\n            print(\"登陆失败\")\ndef bilibiliCredential(func):\n    def wrapper(*args, dedeuserid=\"397424026\", **kwargs):\n        credential = getCredentialByDedeUserId(dedeuserid)\n        if type(kwargs) != dict:\n            kwargs = {}\n        return func(*args, **(kwargs | {'credential': credential}))\n    return wrapper",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/credentials.py:126-140"
    },
    "1607": {
        "file_id": 144,
        "content": "The code defines a decorator called `bilibiliCredential` that takes a function as input and returns a new function wrapper. The wrapper retrieves the credentials for a specific `dedeuserid`, and if the user exists, it passes the function call with the credential as an argument. If the keyword arguments are not of type dictionary, it converts them into an empty dictionary.",
        "type": "comment"
    },
    "1608": {
        "file_id": 145,
        "content": "/pyjom/platforms/bilibili/uploader.py",
        "type": "filepath"
    },
    "1609": {
        "file_id": 145,
        "content": "This code uses bilibili_api module to create an asynchronous function and class for uploading videos to Bilibili platform. It supports multithreading, retry mechanisms, and profile settings, with exception handling and result validation.",
        "type": "summary"
    },
    "1610": {
        "file_id": 145,
        "content": "from bilibili_api import video_uploader, Credential\nfrom pyjom.platforms.bilibili.credentials import bilibiliCredential\nimport os\nfrom pyjom.platforms.bilibili.utils import bilibiliSync\n# you may use the 'sync' method elsewhere.\n# damn. out of sync.\n# recall the order of applying decorators\n# WTF is the order?\n@bilibiliSync\nasync def asyncVideoUploader(\n    videoPath, title, description, meta, credential, cover_path\n):\n    page = video_uploader.VideoUploaderPage(\n        path=videoPath,\n        title=title,\n        description=description,\n    )  # are you sure?\n    uploader = video_uploader.VideoUploader(\n        [page], meta, credential, cover_path=cover_path\n    )\n    # will this work as expected?\n    # @uploader.on(\"__ALL__\")\n    # async def ev(data):\n    #     print(data)\n    result = await uploader.start()  # with bvid, aid as key.\n    # please tell me where the fuck you upload my video upto?\n    # print(\"upload video result:\", result)\n    return result # there's no upload_id. but you can do it in other way, with methods inside the class.",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/uploader.py:1-34"
    },
    "1611": {
        "file_id": 145,
        "content": "This code defines an asynchronous function for uploading videos to Bilibili using the video_uploader module from bilibili_api. It takes videoPath, title, description, meta, credential, and cover_path as parameters, and uses the VideoUploaderPage and VideoUploader classes from the video_uploader module to initiate the upload process. The function is decorated with @bilibiliSync for synchronization purposes.",
        "type": "comment"
    },
    "1612": {
        "file_id": 145,
        "content": "    # if possible please return something like upload_id?\n    # upload video result: {'aid': 901508571, 'bvid': 'BV1MN4y1P7mq'}\n    # breakpoint()  # comment it out later? or we will check why this upload fails. maybe it is because we have duplicated name/cover.\n    # return result[\"bvid\"]  # choose to be in this way?\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\nimport os\nimport re\nimport sys\nimport math\nimport base64\nimport requests\nfrom requests.adapters import HTTPAdapter\nimport threading\nfrom threading import Event\nimport copy\nimport traceback\n# you better embed it inside your function? what a creep?\n# but that will make it impossible to test against other shits.\nclass MultithreadUploader(object):\n    ## what is the cookie string look like?\n    def __init__(self, cookie_string):\n        # TODO: 增加登录接口使用账号密码登陆\n        #  get all related shits?\n        cookie = cookie_string\n        self.MAX_RETRYS = 5\n        self.profile = \"ugcupos/yb\"\n        self.cdn = \"ws\"\n        self.csrf = re.search(\"bili_jct=(.*?);\", cookie + \";\").group(1)",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/uploader.py:35-67"
    },
    "1613": {
        "file_id": 145,
        "content": "Class \"MultithreadUploader\" is a custom class for uploading videos to Bilibili platform using multiple threads. It takes a cookie string as input and has features like retry mechanism and profile settings for caching, CDN, etc.",
        "type": "comment"
    },
    "1614": {
        "file_id": 145,
        "content": "        self.mid = re.search(\"DedeUserID=(.*?);\", cookie + \";\").group(1)\n        self.session = requests.session()\n        self.session.mount(\"https://\", HTTPAdapter(max_retries=self.MAX_RETRYS))\n        self.session.headers[\"cookie\"] = cookie\n        self.session.headers[\n            \"Accept\"\n        ] = \"application/json, text/javascript, */*; q=0.01\"\n        self.session.headers[\n            \"User-Agent\"\n        ] = \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36\"\n        self.session.headers[\"Referer\"] = \"https://space.bilibili.com/{mid}/#!/\".format(\n            mid=self.mid\n        )\n        self.upload_id = None\n    def _preupload(self, filename, filesize):\n        # 1.获取本次上传所需信息\n        preupload_url = \"https://member.bilibili.com/preupload\"\n        params = {\n            \"os\": \"upos\",\n            \"r\": \"upos\",\n            \"ssl\": \"0\",\n            \"name\": filename,\n            \"size\": filesize,\n            \"upcdn\": self.cdn,\n            \"profile\": self.profile,",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/uploader.py:68-94"
    },
    "1615": {
        "file_id": 145,
        "content": "The code sets up the necessary headers and session parameters for interacting with Bilibili's API, then defines a function _preupload that makes a request to \"https://member.bilibili.com/preupload\" to obtain pre-upload information. The parameters for this request include filename, file size, cdn, and profile.",
        "type": "comment"
    },
    "1616": {
        "file_id": 145,
        "content": "        }\n        response = self.session.get(preupload_url, params=params)\n        upload_info = response.json()\n        # 本次上传bilibili端文件名\n        upload_info[\"bili_filename\"] = (\n            upload_info[\"upos_uri\"].split(\"/\")[-1].split(\".\")[0]\n        )\n        # 本次上传url\n        endpoint = \"http:%s/\" % upload_info[\"endpoint\"]\n        upload_url = re.sub(r\"^upos://\", endpoint, upload_info[\"upos_uri\"])\n        print(\"UPLOAD URL:\", upload_url, file=sys.stderr)\n        # 本次上传session\n        upload_session = requests.session()\n        upload_session.mount(\"http://\", HTTPAdapter(max_retries=self.MAX_RETRYS))\n        upload_session.headers[\"X-Upos-Auth\"] = upload_info[\"auth\"]\n        # 2.获取本次上传的upload_id\n        response = upload_session.post(upload_url + \"?uploads&output=json\")\n        upload_info[\"upload_id\"] = response.json()[\n            \"upload_id\"\n        ]  # here you have upload_id\n        self.upload_id = upload_info[\"upload_id\"]\n        print(\"UPLOAD INFO:\", upload_info, file=sys.stderr)\n        return upload_url, upload_info, upload_session",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/uploader.py:95-120"
    },
    "1617": {
        "file_id": 145,
        "content": "This code snippet handles the process of uploading a file to Bilibili. It first fetches pre-upload information, extracts relevant details like filename and endpoint URL. Then it generates an upload URL using this information and creates a session for the upload. The function returns the upload URL, upload info, and the upload session.",
        "type": "comment"
    },
    "1618": {
        "file_id": 145,
        "content": "    def _multithread_upload(\n        self, filepath, filesize, upload_url, upload_info, upload_session\n    ):\n        # 3.分块上传文件\n        CHUNK_SIZE = 4 * 1024 * 1024\n        total_chunks = math.ceil(filesize * 1.0 / CHUNK_SIZE)\n        offset = 0\n        chunk = 0\n        parts_info = {\"parts\": []}\n        with open(filepath, \"rb\") as fp:\n            events = []\n            while True:\n                blob = fp.read(CHUNK_SIZE)\n                if not blob:\n                    break\n                params = {\n                    \"partNumber\": chunk + 1,\n                    \"uploadId\": upload_info[\"upload_id\"],\n                    \"chunk\": chunk,\n                    \"chunks\": total_chunks,\n                    \"size\": len(blob),\n                    \"start\": offset,\n                    \"end\": offset + len(blob),\n                    \"total\": filesize,\n                }\n                # here we go?\n                def multiparts():\n                    blob0 = copy.deepcopy(blob)\n                    chunk0 = chunk\n                    thisevent = Event()",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/uploader.py:122-151"
    },
    "1619": {
        "file_id": 145,
        "content": "The code reads a file in chunks of 4MB (CHUNK_SIZE) and calculates the total number of chunks required to complete the upload. It then starts a loop where it reads each chunk, creates a dictionary with parameters including partNumber, uploadId, chunk number, total chunks, size of the blob, start and end offsets of the blob, and file's total size. The function seems to be preparing to call another function \"multiparts\" which is defined later in the code block.",
        "type": "comment"
    },
    "1620": {
        "file_id": 145,
        "content": "                    events.append(thisevent)\n                    offset0 = offset\n                    while True:\n                        try:\n                            response = upload_session.put(\n                                upload_url, params=params, data=blob0\n                            )\n                            print(\n                                \"Uploading...\",\n                                math.floor(chunk0 / total_chunks * 100),\n                                \"%  UPLOAD CHUNK\",\n                                chunk0,\n                                \":\",\n                                response.text,\n                                file=sys.stderr,\n                            )\n                            print(\"done for {}\".format(offset0))\n                            thisevent.set()\n                            break\n                        except:\n                            print(\"error in chunk {}\".format(offset0))\n                            traceback.print_exc()\n                threading.Thread(target=multiparts, args=(), daemon=True).start()",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/uploader.py:152-175"
    },
    "1621": {
        "file_id": 145,
        "content": "This code is handling the upload of a chunk of data to Bilibili using a session with retry on error. It creates an event and appends it to a list, initializes the offset, and then enters a while loop to attempt uploading the chunk. If successful, it sets the event to complete, otherwise it prints an error message. A new thread is created to execute a function called multiparts.",
        "type": "comment"
    },
    "1622": {
        "file_id": 145,
        "content": "                parts_info[\"parts\"].append({\"partNumber\": chunk + 1, \"eTag\": \"etag\"})\n                chunk += 1\n                offset += len(blob)\n            for event in events:\n                event.wait()\n            print(\"finished waiting.\")\n        return parts_info\n    def _upload(self, filepath):\n        \"\"\"执行上传文件操作\"\"\"\n        if not os.path.isfile(filepath):\n            print(\"FILE NOT EXISTS:\", filepath, file=sys.stderr)\n            return\n        filename = os.path.basename(filepath)\n        filesize = os.path.getsize(filepath)\n        upload_url, upload_info, upload_session = self._preupload(filename, filesize)\n        # 4.标记本次上传完成\n        parts_info = self._multithread_upload(\n            filepath, filesize, upload_url, upload_info, upload_session\n        )\n        params = {\n            \"output\": \"json\",\n            \"name\": filename,\n            \"profile\": self.profile,\n            \"uploadId\": upload_info[\"upload_id\"],\n            \"biz_id\": upload_info[\"biz_id\"],\n        }\n        response = upload_session.post(upload_url, params=params, data=parts_info)",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/uploader.py:177-205"
    },
    "1623": {
        "file_id": 145,
        "content": "The code uploads a file to Bilibili using multipart upload. It first checks if the file exists, then retrieves the upload URL and necessary information through `_preupload` function. The actual multipart upload is performed in `_multithread_upload`, with progress events handled concurrently. Finally, it posts the parts information to the upload URL along with other parameters to complete the upload.",
        "type": "comment"
    },
    "1624": {
        "file_id": 145,
        "content": "        print(\n            \"UPLOAD RESULT:\",\n            response.text,\n            file=sys.stderr,  # but till then we can use the upload_id.\n        )  # here we do not have the result.\n        return upload_info  # still, not the bvid thing we want.\n    def _cover_up(self, image_path):\n        \"\"\"上传图片并获取图片链接\"\"\"\n        if not os.path.isfile(image_path):\n            return \"\"\n        import tempfile\n        import cv2\n        with tempfile.NamedTemporaryFile(suffix=\".jpg\") as f:\n            jpeg_image_path = f.name\n            image = cv2.imread(image_path)\n            cv2.imwrite(jpeg_image_path, image)\n            fp = open(jpeg_image_path, \"rb\")\n            encode_data = base64.b64encode(fp.read())\n            # warning. forced to use jpeg.\n            url = \"https://member.bilibili.com/x/vu/web/cover/up\"\n            data = {\n                \"cover\": b\"data:image/jpeg;base64,\" + encode_data,\n                \"csrf\": self.csrf,\n            }\n            response = self.session.post(url, data=data)\n            return response.json()[\"data\"][\"url\"]",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/uploader.py:206-234"
    },
    "1625": {
        "file_id": 145,
        "content": "This function uploads an image to Bilibili and returns the image URL. It first checks if the input file exists, then converts the image to JPEG format using OpenCV. The converted image is encoded as base64 and sent in a POST request to Bilibili's cover upload endpoint. Finally, it retrieves and returns the image URL from the response.",
        "type": "comment"
    },
    "1626": {
        "file_id": 145,
        "content": "    def upload_video_and_cover(self, filepath, cover_path):\n        # 上传文件, 获取上传信息\n        upload_info = self._upload(filepath)\n        if not upload_info:\n            ## fuck?\n            print(\"upload failed?\")\n            return {}, \"\"\n        # 获取图片链接\n        cover_url = self._cover_up(cover_path) if cover_path else \"\"\n        return upload_info, \"\"\n    def postupload(self, upload_info, cover_url, metadata):\n        title = \"\"\n        tid = 0\n        tag = \"\"\n        desc = \"\"\n        source = \"\"\n        # cover_path=\"\",\n        dynamic = \"\"\n        # mission_id = None\n        no_reprint = 1\n        \"\"\"视频投稿\n        Args:\n            filepath   : 视频文件路径\n            title      : 投稿标题\n            tid        : 投稿频道id,详见https://member.bilibili.com/x/web/archive/pre\n            tag        : 视频标签，多标签使用','号分隔\n            desc       : 视频描述信息\n            source     : 转载视频出处url\n            cover_path : 封面图片路径\n            dynamic    : 分享动态, 比如：\"#周五##放假# 劳资明天不上班\"\n            no_reprint : 1表示不允许转载,0表示允许\n        \"\"\"\n        # TODO:",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/uploader.py:236-270"
    },
    "1627": {
        "file_id": 145,
        "content": "This function `upload_video_and_cover` uploads a video file and optional cover image, returning the upload information. It first calls the `_upload` method to upload the video and checks if it was successful. If not, it prints an error message and returns empty information. Then it retrieves the cover URL using the `_cover_up` method, if a cover path is provided. The function returns the upload information and an empty string.",
        "type": "comment"
    },
    "1628": {
        "file_id": 145,
        "content": "        # 1.增加多P上传\n        # 2.对已投稿视频进行删改, 包括删除投稿，修改信息，加P删P等\n        # 设置视频基本信息\n        params = {\n            \"source\": source,\n            \"title\": title,\n            \"tid\": tid,\n            \"tag\": tag,\n            \"no_reprint\": no_reprint,\n            \"desc\": desc,\n            # \"mission_id\": mission_id,\n            \"desc_format_id\": 0,\n            \"dynamic\": dynamic,\n            \"cover\": cover_url,\n            \"videos\": [\n                {\n                    \"filename\": upload_info[\"bili_filename\"],\n                    \"title\": title,\n                    \"desc\": \"\",\n                }\n            ],\n        }\n        params.update(metadata)\n        # 版权判断, 转载无版权\n        params[\"copyright\"] = 2 if params.get(\"source\") else 1\n        if source:\n            del params[\"no_reprint\"]\n        # tag设置\n        mtag = params.get(\"tag\")\n        if isinstance(mtag, list):\n            params[\"tag\"] = \",\".join(mtag)\n        # if mission_id is None:\n        #     del params[\"mission_id\"]\n        url = \"https://member.bilibili.com/x/vu/web/add?csrf=\" + self.csrf",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/uploader.py:271-305"
    },
    "1629": {
        "file_id": 145,
        "content": "Sets video basic information, including source, title, TID, tag, no_reprint status, description, dynamic, cover URL, and video file details for upload. Updates parameters if necessary, checks copyright based on source flag, handles tag format, and sets URL with CSRF token.",
        "type": "comment"
    },
    "1630": {
        "file_id": 145,
        "content": "        response = self.session.post(url, json=params)\n        print(\"SET VIDEO INFO:\", response.text, file=sys.stderr)\n        return response.json() # {\"code\":0,\"message\":\"0\",\"ttl\":1,\"data\":{\"aid\":604946025,\"bvid\":\"BV1y84y1v7tM\"}}\n        # seriously, it is a ugc platform.\n        ## what is this fucking json?\n    def upload(\n        self,\n        filepath: str,\n        cover_path: str,\n        metadata: dict,\n    ):\n        upload_info, cover_url = self.upload_video_and_cover(filepath, cover_path)\n        if upload_info == {}:\n            # something went wrong.\n            return\n        response_json = self.postupload(upload_info, cover_url, metadata)\n        return response_json\ndef getCookieStringFromCookieDict(cookies_dict, mustcook=[\"DedeUserID\", \"bili_jct\"]):\n    cookies = cookies_dict\n    cookie_string = \"\"\n    for x in mustcook:\n        assert x in cookies.keys()\n    # ckeys = mustcook + [x for x in cookies.keys() if x not in mustcook]\n    # assert \"bili_jct\" in cookies.keys()\n    for key in mustcook:",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/uploader.py:306-333"
    },
    "1631": {
        "file_id": 145,
        "content": "Code snippet is performing the following tasks:\n1. Posting video info to server and returning response as JSON format.\n2. Uploading video and cover, then posting video information with cover URL to the server using a predefined function `postupload`.\n3. Converting cookies dictionary into a string with mandatory cookies \"DedeUserID\", \"bili_jct\".",
        "type": "comment"
    },
    "1632": {
        "file_id": 145,
        "content": "        assert key in cookies.keys()\n    # breakpoint()\n    for key, value in cookies.items():  # oh shit maybe i know it.\n        if key is not None and value is not None:\n            cookie_string += key + \"=\" + value + \"; \"\n    cookie_string = cookie_string[:-2]\n    return cookie_string\n##############################################################\ndef videoMultithreadUploader(\n    cookies_dict: dict = ...,\n    filepath: str = ...,\n    coverpath: str = ...,\n    metadata: dict = ...,\n):\n    # append new events?\n    # planning using two jsons. one for credential, one for video details.\n    # get picture.\n    cookie_string = getCookieStringFromCookieDict(cookies_dict)\n    # while True:\n    try:\n        uper = MultithreadUploader(cookie_string)\n        data = uper.upload(filepath, coverpath, metadata)\n        return True, data\n    except:\n        print(\"Exception found when uploading video.\")\n        traceback.print_exc()\n        return False, {}\n##############################################################\n# @bilibiliSync",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/uploader.py:334-367"
    },
    "1633": {
        "file_id": 145,
        "content": "The code defines a function `videoMultithreadUploader` that uploads a video using multithreading and returns True if successful or False otherwise. It first extracts cookies from the input dictionary and then uses the `MultithreadUploader` class to perform the actual upload. The uploaded data is returned as a tuple with the status and data. In case of an exception, it prints the traceback and returns (False, {}).",
        "type": "comment"
    },
    "1634": {
        "file_id": 145,
        "content": "# no need to be sync. really?\n@bilibiliCredential  # keyword 'dedeuserid' with default value.\ndef uploadVideo(\n    credential: Credential = ...,\n    # sessdata=\"\",\n    # bili_jct=\"\",\n    # buvid3=\"\", # credentials.\n    # dedeuserid: str = \"397424026\",\n    description: str = \"\",\n    dynamic: str = \"\",\n    tagString: str = \"\",\n    tagId: int = 21,  # what is 21? -> 日常\n    title: str = \"\",\n    close_danmaku: bool = False,\n    close_reply: bool = False,\n    videoPath: str = \"\",\n    cover_path: str = \"\",\n    multithread: bool = True,\n    # threads=3,\n):\n    # title='abdefg'\n    assert os.path.exists(videoPath)\n    assert os.path.exists(cover_path)\n    cookie_dict = {\n        key: credential.__dict__[key.lower()]\n        for key in [\"buvid3\", \"DedeUserID\", \"bili_jct\", \"SESSDATA\"]\n    }\n    # videoExtension = videoPath.split(\".\")[-1].lower()\n    # credential = Credential(sessdata=sessdata, bili_jct=bili_jct, buvid3=buvid3)\n    # you can pass it from somewhere else.\n    # 具体请查阅相关文档\n    meta = {\n        \"copyright\": 1,\n        \"source\": \"\",  # no source?",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/uploader.py:368-401"
    },
    "1635": {
        "file_id": 145,
        "content": "This function uploads a video to Bilibili and requires credentials, metadata such as title, description, and tags, and file paths for the video and cover image. The function uses assertions to ensure the file paths exist and creates a dictionary of required cookie values from the provided credential object. It also allows passing some parameters externally.",
        "type": "comment"
    },
    "1636": {
        "file_id": 145,
        "content": "        \"desc\": description,\n        \"desc_format_id\": 0,\n        \"dynamic\": dynamic,  # could be the same as desc.\n        \"interactive\": 0,\n        \"open_elec\": 1,\n        \"no_reprint\": 1,\n        \"subtitles\": {\"lan\": \"\", \"open\": 0},\n        \"tag\": tagString,\n        \"tid\": tagId,  # original is 21. what is it?\n        \"title\": title,\n        \"up_close_danmaku\": close_danmaku,\n        \"up_close_reply\": close_reply,\n    }\n    if multithread:\n        no_exception, mresult = videoMultithreadUploader(cookie_dict, videoPath, cover_path, meta)\n        if not no_exception:\n            raise Exception('videoMultithreadUploader error')\n        try:\n            code, message = mresult.get('code'), mresult.get('message')\n            assert code == 0  # 为什么分区暂时不可用？\n            assert message == '0'\n        except:\n            print(\"Uploading to bilibili failed\")\n            breakpoint()\n            print()\n            raise Exception('videoMultithreadUploader error: invalid response:', mresult)\n        result = mresult.get('data',{})",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/uploader.py:402-428"
    },
    "1637": {
        "file_id": 145,
        "content": "This code is creating a dictionary with metadata for uploading a video to Bilibili. It includes various parameters like description, interactive setting, and tags. The code also implements multithreading for the upload process, handling exceptions and checking for valid response codes from the API. If there's an error or invalid response, it raises an exception and prints a failure message.",
        "type": "comment"
    },
    "1638": {
        "file_id": 145,
        "content": "    else:\n        result = asyncVideoUploader(\n            videoPath, title, description, meta, credential, cover_path\n        )\n    print(\"multithread?\", multithread)\n    print(\"upload video result:\", result)\n    try:\n        assert 'aid' in result.keys()\n        assert 'bvid' in result.keys()\n    except:\n        raise Exception(\"error: no valid upload result obtained:\", result)\n        # {'aid': 817422346, 'bvid': 'BV1NG4y1t7zk'}\n        # in this format.\n    return result\n# host your web application online, then make money through it!",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/uploader.py:429-445"
    },
    "1639": {
        "file_id": 145,
        "content": "This code checks if the uploader is not async, then calls `asyncVideoUploader` with provided parameters. It then asserts that the result contains 'aid' and 'bvid' keys before returning the result. The print statements are for debugging purposes.",
        "type": "comment"
    },
    "1640": {
        "file_id": 146,
        "content": "/pyjom/platforms/bilibili/searchDataParser.py",
        "type": "filepath"
    },
    "1641": {
        "file_id": 146,
        "content": "This function parses Bilibili video data, enabling metadata extraction and error handling. It retrieves bvid, pubdate, author name, tags, title, duration, play count, cover image, and description, while disabling specified author-related tags.",
        "type": "summary"
    },
    "1642": {
        "file_id": 146,
        "content": "import json\n# from bs4 import BeautifulSoup\nfrom lazero.utils.logger import sprint\nfrom pyjom.platforms.bilibili.utils import (\n    # generatorToList,\n    linkFixer,\n    traceError,\n    extractLinks,\n    videoDurationStringToSeconds,\n    getAuthorKeywords,\n    clearHtmlTags,\n    splitTitleTags,\n    removeAuthorRelatedTags,\n)\ndef parseVideoSearchItem(video, disableList: list = [], debug=False):\n    from pyjom.platforms.bilibili.utils import detectAuthorRelatedKeywords\n    bvid = video[\"bvid\"]\n    pubdate = video[\"pubdate\"]\n    if \"author\" not in disableList:\n        author = video[\"author\"]\n        author_id = video[\n            \"mid\"\n        ]  # this is important. may let us able to find out the fans count.\n    else:\n        author = \"\"\n        author_id = -1\n    author_keywords = getAuthorKeywords(author)\n    if \"tag\" not in disableList:\n        tag = video[\"tag\"]\n        tags = tag.split(\",\")\n        tags = [\n            tag for tag in tags if not detectAuthorRelatedKeywords(tag, author_keywords)\n        ]\n    else:",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/searchDataParser.py:1-37"
    },
    "1643": {
        "file_id": 146,
        "content": "Function to parse video search item data from Bilibili platform, takes a video object and an optional list of keywords to disable (author and tag). Extracts bvid, pubdate, author name, author ID, tags, and filters out author-related tags if specified.",
        "type": "comment"
    },
    "1644": {
        "file_id": 146,
        "content": "        tags = []\n    if \"typeid\" not in disableList and \"typename\" not in disableList:\n        categoryId = int(video.get(\"typeid\", video.get(\"type_id\")))\n        categoryName = video.get(\"typename\", video.get(\"type_name\"))\n    else:\n        categoryId = 0\n        categoryName = \"\"\n    title = video[\"title\"]  # remove those markers, please?\n    title = clearHtmlTags(title)\n    title = removeAuthorRelatedTags(title, author)\n    title, title_tags = splitTitleTags(\n        title, author_keywords\n    )  # use author for filtering unwanted title tags.\n    duration = video[\"duration\"]  # this is not recommended. we need seconds.\n    play = video.get(\"play\", video.get(\"view\"))  # select some hot videos.\n    cover = video[\"pic\"]\n    cover = linkFixer(cover)\n    if \"description\" not in disableList:\n        description = video.get(\"description\", video.get(\"desc\"))\n        description = clearHtmlTags(description)\n        description = removeAuthorRelatedTags(description, author)\n    else:\n        description = \"\"\n    links_in_description, bgms, description = extractLinks(description)",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/searchDataParser.py:38-61"
    },
    "1645": {
        "file_id": 146,
        "content": "The code checks for certain video types and disables them if present in the disable list. It retrieves category ID, category name, title, duration, play count, cover image, and description from the video data. The title is cleaned by removing markers, clearing HTML tags, and filtering unwanted tags using author keywords. Duration and play count are retrieved with fallback options. Cover image is fixed for links. If description is not disabled, it's also cleaned of HTML tags and filtered for author-related tags, and links in the description, background music, and modified description are extracted.",
        "type": "comment"
    },
    "1646": {
        "file_id": 146,
        "content": "    duration_seconds = videoDurationStringToSeconds(duration)\n    resultTuple = (\n        author,\n        author_id,\n        bvid,\n        tags,\n        categoryId,\n        categoryName,\n        title,\n        duration_seconds,\n        play,\n        cover,\n        description,\n        links_in_description,\n        bgms,\n        title_tags,\n        pubdate,\n    )\n    if debug:\n        for metadata in resultTuple:\n            print(metadata)\n    from lazero.utils.logger import sprint\n    if debug:\n        sprint()\n    return resultTuple\n# you might want the creater's name, to filter out unwanted parts.\ndef iterateResultList(resultList, debug=False):\n    for video in resultList:\n        # be warned cause all these things might fail.\n        try:\n            if video[\"type\"] == \"video\":\n                yield parseVideoSearchItem(video, debug=debug)\n        except:\n            traceError(\"error iterating video metadata\")\n            continue\ndef parseSearchAllResult(data, debug=False):\n    # if not generator:\n    #     return generatorToList(parseSearchAllResult(data, debug=debug,generator=True))",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/searchDataParser.py:62-106"
    },
    "1647": {
        "file_id": 146,
        "content": "The code defines functions for parsing and iterating through search results from a specific platform, bilibili. It converts video duration strings to seconds, extracts relevant metadata, and handles potential errors during iteration.",
        "type": "comment"
    },
    "1648": {
        "file_id": 146,
        "content": "    results = data[\"result\"]\n    for elem in results:\n        try:\n            if elem[\"result_type\"] == \"video\":\n                resultList = elem[\"data\"]\n                for videoMetadata in iterateResultList(resultList, debug=debug):\n                    yield videoMetadata\n        except:\n            traceError(\"error iterating data results\")\ndef parseSearchVideoResult(data, debug=False):\n    # if not generator:\n    #     return generatorToList(parseSearchVideoResult(data, debug=debug,generator=True))\n    try:\n        resultList = data[\"result\"]\n        try:\n            for videoMetadata in iterateResultList(resultList, debug=debug):\n                try:\n                    yield videoMetadata\n                except:\n                    traceError(\"error iterating video metadata\")\n        except:\n            traceError(\"error iterating result list\")\n    except:\n        traceError(\"error parsing search video result\")\ndef parseVideoInfo(videoInfo, debug=False):\n    data = videoInfo\n    # no tag out here.\n    secondaryVideoInfoList = []",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/searchDataParser.py:107-138"
    },
    "1649": {
        "file_id": 146,
        "content": "The code defines functions for parsing search video results and video information from data. It iterates through the results, extracting relevant metadata, and handles potential errors during the process. The parsed results are then yielded or converted to a list if necessary.",
        "type": "comment"
    },
    "1650": {
        "file_id": 146,
        "content": "    data_copy = data.copy()\n    data_copy.update({\"author\": data[\"owner\"][\"name\"], \"mid\": data[\"owner\"][\"mid\"]})\n    data_copy.update(data[\"stat\"])\n    primaryVideoInfo = parseVideoSearchItem(\n        data_copy, disableList=[\"tag\", \"typeid\", \"typename\"], debug=debug\n    )\n    # videoInfoList.append(primaryVideoInfo)\n    season = data.get(\"ugc_season\", {})  # we only care about this thing.\n    season_cover = season.get(\"cover\", None)  # it could be noting.\n    sections = season.get(\"sections\", [])\n    for section in sections:\n        for episode in section[\"episodes\"]:\n            # print(episode.keys())\n            # breakpoint()\n            arc = episode[\"arc\"]\n            stat = arc[\"stat\"]\n            videoInfo = episode.copy()\n            videoInfo.update(stat)\n            videoInfo.update(arc)\n            authorRelatedVideoInfo = parseVideoSearchItem(\n                videoInfo,\n                disableList=[\"tag\", \"typeid\", \"typename\", \"description\", \"author\"],\n                debug=debug,\n            )  # author is the same as the original video.",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/searchDataParser.py:139-162"
    },
    "1651": {
        "file_id": 146,
        "content": "This code parses bilibili search data and extracts relevant information. It creates a primary video info, updates it with necessary attributes, handles seasonal content, and iterates through episodes to create individual video infos for each episode. This is done by updating video stats and arc attributes, then calling parseVideoSearchItem function. The author remains the same as the original video.",
        "type": "comment"
    },
    "1652": {
        "file_id": 146,
        "content": "            secondaryVideoInfoList.append(authorRelatedVideoInfo)\n            # BV1Cb4y1s7em\n            # []\n            # 0\n            # 这次真的燃起来了！！！\n            # 217\n            # 27911\n            # http://i2.hdslb.com/bfs/archive/c5a0d18ee077fb6a4ac0970ccb0a3788e137d14f.jpg\n    return primaryVideoInfo, secondaryVideoInfoList\ndef parseVideoRelated(videoRelatedData, debug=False):\n    data = videoRelatedData\n    # if not generator:\n    #     return generatorToList(parseVideoRelated(data, debug=debug,generator=True))\n    try:\n        for videoInfo in data:\n            try:\n                videoInfo2 = videoInfo.copy()\n                videoInfo2.update({\"author\": videoInfo[\"owner\"][\"name\"]})\n                videoInfo2.update({\"mid\": videoInfo[\"owner\"][\"mid\"]})\n                # also update the stat.\n                videoInfo2.update(videoInfo[\"stat\"])\n                try:\n                    yield parseVideoSearchItem(\n                        videoInfo2,\n                        disableList=[\"tag\", \"typeid\", \"typename\"],",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/searchDataParser.py:163-190"
    },
    "1653": {
        "file_id": 146,
        "content": "This function parses video-related data and returns the primary video information and a list of secondary video information. It updates the video information with the author's name, ID, and statistics before yielding the result.",
        "type": "comment"
    },
    "1654": {
        "file_id": 146,
        "content": "                        debug=debug,\n                    )\n                    # print(videoMetadata)\n                except:\n                    traceError()\n            except:\n                traceError()\n    except:\n        traceError()\nif __name__ == \"__main__\":\n    # fake tests.\n    # test_subject = \"search_video\"\n    # test_subject = \"search_all\"\n    # test_subject = 'video_related'\n    test_subject = \"video_info\"\n    # test_subject = 'extract_links'\n    if test_subject == \"search_all\":\n        with open(\"search_result_all.json\", \"r\") as f:\n            data = f.read()\n            data = json.loads(data)\n        for mresult in parseSearchAllResult(data):\n            print(\"RESULT:\")\n            sprint(mresult)\n    elif test_subject == \"search_video\":\n        with open(\"search_by_type_result_video.json\", \"r\") as f:\n            data = f.read()\n            data = json.loads(data)\n        for mresult in parseSearchVideoResult(data):\n            print(\"VIDEO SEARCH RESULT:\")\n            sprint(mresult)\n    elif test_subject == \"video_info\":",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/searchDataParser.py:191-223"
    },
    "1655": {
        "file_id": 146,
        "content": "The code is running tests on a Python module for parsing search results and video information from Bilibili. It executes the main function with different test subjects, such as \"search_all\", \"search_video\", \"video_info\", and \"extract_links\". If an error occurs during execution, it calls a \"traceError\" function to log the exception.",
        "type": "comment"
    },
    "1656": {
        "file_id": 146,
        "content": "        with open(\"video_info.json\", \"r\") as f:\n            data = f.read()\n            data = json.loads(data)\n        primaryVideoInfo, secondaryVideoInfoList = parseVideoInfo(data)\n        videoInfoList = [primaryVideoInfo] + secondaryVideoInfoList\n        for mVideoInfo in videoInfoList:\n            print(mVideoInfo)\n            sprint()\n    elif test_subject == \"video_related\":\n        with open(\"video_related.json\", \"r\") as f:\n            data = f.read()\n            data = json.loads(data)\n        for videoMetadata in parseVideoRelated(data):\n            print(videoMetadata)\n            sprint()\n    elif test_subject == \"extract_links\":\n        description = (\n            \"http://www.toutiao.com/a6347649852365897986/ 男子送走从小养大的狗，狗狗用泪汪汪的眼神看着他\\n\"\n            + \"https://www.youtube.com/watch?v=r724w57oXyU\"\n            + \" https://www.youtube.com/shorts/UYCy8HD1C7o\"\n        )\n        links, desc = extractLinks(description)\n        print(links)\n        print(desc)\n    else:\n        raise Exception(\"unknown test_subject:\", test_subject)",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/searchDataParser.py:224-249"
    },
    "1657": {
        "file_id": 146,
        "content": "This code block handles different cases for parsing data from JSON files and extracting links from descriptions. It loads data from \"video_info.json\" or \"video_related.json\", processes it using parseVideoInfo or parseVideoRelated functions, then prints the results. If test_subject is \"extract_links\", it extracts links from a given description using extractLinks function and prints them. For any other test_subject, an Exception is raised.",
        "type": "comment"
    },
    "1658": {
        "file_id": 147,
        "content": "/pyjom/platforms/bilibili/utils.py",
        "type": "filepath"
    },
    "1659": {
        "file_id": 147,
        "content": "The code uses functions for API synchronization, error handling, and list conversions to parse BGM information and durations. It also defines cleaning functions like `clearHtmlTags` and `detectAuthorRelatedKeywords` to remove unwanted characters and author-related keywords from video titles and tags.",
        "type": "summary"
    },
    "1660": {
        "file_id": 147,
        "content": "import types\nfrom bilibili_api import sync\n# import json\nfrom bs4 import BeautifulSoup\nfrom lazero.utils.logger import sprint\n# wtf is async generator type?\ndef bilibiliSync(func):\n    def wrapper(*args, **kwargs):\n        coroutineMaybe = func(*args, **kwargs)\n        if type(coroutineMaybe) == types.CoroutineType:\n            return sync(coroutineMaybe)\n        else:\n            return coroutineMaybe\n    return wrapper\n######## import all below functions to searchDataParser.\n# from pyjom.platforms.bilibili.utils import generatorToList, linkFixer,traceError, extractLinks,videoDurationStringToSeconds,getAuthorKeywords,clearHtmlTags,splitTitleTags,removeAuthorRelatedTags\ndef generatorToList(generator):\n    return [x for x in generator]\ndef linkFixer(link, prefix=\"http:\"):\n    if link.startswith(\"//\"):\n        return prefix + link\n    return link\ndef traceError(errorMsg: str = \"error!\", _breakpoint: bool = False):\n    import traceback\n    traceback.print_exc()\n    sprint(errorMsg)\n    if _breakpoint:\n        return breakpoint()",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/utils.py:1-41"
    },
    "1661": {
        "file_id": 147,
        "content": "This code is related to the bilibili platform and contains functions for synchronizing API calls, converting generator to list, fixing links, handling errors with traceback, and more. It's likely part of a larger project focused on working with the bilibili API.",
        "type": "comment"
    },
    "1662": {
        "file_id": 147,
        "content": "def extractLinks(description, extract_bgm=True):\n    \"\"\"Extract and remove links in description\"\"\"\n    import re\n    # notice, we don't need to go wild here. we just want the title and the cover, and the tags.\n    expression = r\"http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\\(\\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+\"\n    # expr = re.compile(expression)\n    links = re.findall(expression, description)\n    # if links == None:\n    #     links = []\n    desc_without_link = re.sub(expression, \"\", description)\n    desc_without_link_per_line = [\n        x.replace(\"\\n\", \"\").strip() for x in desc_without_link.split(\"\\n\")\n    ]\n    desc_without_link_per_line = [x for x in desc_without_link_per_line if len(x) > 0]\n    bgms = []\n    final_desc_list = []\n    if not extract_bgm:\n        final_desc_list = desc_without_link_per_line\n    else:\n        for line in desc_without_link_per_line:\n            bgmCandidateTemplates = [\"{}：\", \"{}:\", \"{} \"]\n            fixers = [x.format(\"\") for x in bgmCandidateTemplates]\n            bgmCandidates = [x.format(\"bgm\") + \"(.+)\" for x in bgmCandidateTemplates]",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/utils.py:44-67"
    },
    "1663": {
        "file_id": 147,
        "content": "The code defines a function `extractLinks` that takes in a description and optionally extracts background music (BGM) links. It uses regular expressions to find and remove links from the description, then splits the description into lines. If BGM extraction is enabled, it searches for BGM candidates using templates and formats them correctly. The final result is a list of non-empty lines without links or potential BGM information if BGM extraction is disabled.",
        "type": "comment"
    },
    "1664": {
        "file_id": 147,
        "content": "            has_bgm = False\n            for candidate in bgmCandidates:\n                bgm_parse_result = re.findall(candidate, line.lower())\n                if len(bgm_parse_result) > 0:\n                    has_bgm = True\n                    # bgm = line[len(bgmCandidates) :]\n                    bgm = bgm_parse_result[0]\n                    bgm = bgm.strip()\n                    for fixer in fixers:\n                        bgm = bgm.strip(fixer)\n                    if len(bgm) > 0:\n                        bgms.append(bgm)\n                    break\n            if not has_bgm:\n                final_desc_list.append(line)\n    desc_without_link = \"\\n\".join(final_desc_list)\n    return links, bgms, desc_without_link\nfrom typing import Literal\nimport re\nfrom typing import Union\ndef videoDurationStringToSeconds(\n    durationString:Union[str, None], method: Literal[\"vtc\", \"basic\"] = \"vtc\"\n):\n    if durationString in [\"-\", None]:\n        return None\n    if type(durationString) != str:\n        return None\n    if re.findall(r\"\\d\", durationString) == []:",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/utils.py:68-99"
    },
    "1665": {
        "file_id": 147,
        "content": "The code is parsing a line for background music (BGM) information using regular expressions. If BGM is found, it appends to bgms list; if not, the line is added to final_desc_list. The function videoDurationStringToSeconds converts video duration string to seconds based on given method (vtc or basic). It checks for invalid input (empty string or None) and returns None in those cases.",
        "type": "comment"
    },
    "1666": {
        "file_id": 147,
        "content": "        return None\n    try:\n        if method == \"vtc\":\n            import vtc\n            timecode = \"{}:0\".format(durationString)\n            decimal_seconds = vtc.Timecode(timecode, rate=1).seconds\n            seconds = round(decimal_seconds)\n            return seconds\n        elif method == \"basic\":\n            if type(durationString) == int:\n                return durationString  # not string at all.\n            if type(durationString) != str:\n                print(\"unknown durationString type: %s\" % type(durationString))\n                return None\n            durationString = durationString.strip()\n            mList = durationString.split(\":\")[::-1]\n            if len(mList) > 3:\n                print(\"DURATION STRING TOO LONG\")\n                return None\n            seconds = 0\n            for index, elem in enumerate(mList):\n                elem = int(elem)\n                seconds += (60**index) * elem\n            return seconds\n        else:\n            raise Exception(\"method %s does not exist\" % method)",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/utils.py:100-126"
    },
    "1667": {
        "file_id": 147,
        "content": "This function converts a duration string, either in basic format or \"vtc\" method, into seconds. It checks the input type and handles invalid formats, returning None for errors or the converted duration in seconds if successful.",
        "type": "comment"
    },
    "1668": {
        "file_id": 147,
        "content": "    except:\n        import traceback\n        traceback.print_exc()\n        print(\"exception durion video duration string conversion\")\ndef clearHtmlTags(htmlObject):\n    a = BeautifulSoup(htmlObject, features=\"lxml\")\n    return a.text\ndef detectAuthorRelatedKeywords(title_tag, author_keywords):\n    abandon = False\n    for keyword in author_keywords:\n        if len(keyword) > 1:\n            if keyword in title_tag:\n                abandon = True  # detected this thing.\n                break\n    return abandon\ndef getAuthorKeywords(author):\n    author = author.strip()\n    import jieba\n    author_keywords = jieba.lcut(author)\n    author_keywords = [x.strip() for x in author_keywords]\n    author_keywords = [x for x in author_keywords if len(x) > 0]\n    return author_keywords\ndef removeAuthorRelatedTags(description_or_title, author):\n    templates = [\"【{}】\", \"@{}\", \"{}\"]\n    tags = [template.format(author) for template in templates]\n    for tag in tags:\n        description_or_title = description_or_title.replace(tag, \"\")",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/utils.py:127-163"
    },
    "1669": {
        "file_id": 147,
        "content": "The code defines several functions:\n1. `clearHtmlTags` removes HTML tags from an object using BeautifulSoup and returns the text content.\n2. `detectAuthorRelatedKeywords` checks if a given title contains any keywords from a list of author-related keywords, returning True if detected.\n3. `getAuthorKeywords` takes an author's name, tokenizes it with Jieba, filters out empty strings and returns a list of non-empty tokens.\n4. `removeAuthorRelatedTags` replaces specific author-related tags in the description or title with an empty string.",
        "type": "comment"
    },
    "1670": {
        "file_id": 147,
        "content": "    return description_or_title\ndef splitTitleTags(title, author_keywords):\n    import re\n    pattern = r\"【.+】\"\n    title_tags = re.findall(pattern, title)\n    title = re.sub(pattern, \"\", title)\n    title_tags = [x.lstrip(\"【\").rstrip(\"】\").strip() for x in title_tags]\n    title_tags = [x for x in title_tags if len(x) > 0]\n    final_title_tags = []\n    for title_tag in title_tags:\n        detected = detectAuthorRelatedKeywords(title_tag, author_keywords)\n        if not detected:\n            final_title_tags.append(title_tag)\n    return title, title_tags",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/utils.py:164-181"
    },
    "1671": {
        "file_id": 147,
        "content": "This function splits the title and tags in a video using regular expressions, removes unnecessary characters, filters out empty strings, and detects author-related keywords. It returns the cleaned title and a list of remaining title tags.",
        "type": "comment"
    },
    "1672": {
        "file_id": 148,
        "content": "/tests/test_remerge_demanded_cut_spans.py",
        "type": "filepath"
    },
    "1673": {
        "file_id": 148,
        "content": "This code defines cut_spans as ranges for processing and creates a test function to check if the list of spans has consistent order, duration, and is remerged correctly.",
        "type": "summary"
    },
    "1674": {
        "file_id": 148,
        "content": "cut_spans = [(0, 1), (1, 2), (2, 9), (9, 100), (100, 101), (101, 102)]\n# cut_spans=[(0, 2.43475), (2.43475, 4.3458125), (4.3458125, 7.543145833333333), (7.543145833333333, 10.7313125), (10.7313125, 13.928645833333333), (13.928645833333333, 16.492041666666665), (16.492041666666665, 22.216020833333335), (22.216020833333335, 25.4225625), (25.4225625, 30.530958333333334), (30.530958333333334, 33.709916666666665), (33.709916666666665, 36.907270833333335), (36.907270833333335, 39.46145833333333), (39.46145833333333, 42.649625), (42.649625, 46.499291666666664), (46.499291666666664, 49.0443125), (49.0443125, 52.54485416666667), (52.54485416666667, 55.10825), (55.10825, 57.65325), (57.65325, 61.806125), (61.806125, 64.99429166666667), (64.99429166666667, 67.55766666666666), (67.55766666666666, 70.1026875), (70.1026875, 73.28164583333333), (73.28164583333333, 76.16660416666667), (76.16660416666667, 79.99791666666667), (79.99791666666667, 82.23054166666667), (82.23054166666667, 85.1063125), (85.10",
        "type": "code",
        "location": "/tests/test_remerge_demanded_cut_spans.py:1-2"
    },
    "1675": {
        "file_id": 148,
        "content": "Code defines a list of cut_spans, where each span represents a range of values for further processing or analysis.",
        "type": "comment"
    },
    "1676": {
        "file_id": 148,
        "content": "63125, 87.97289583333334), (87.97289583333334, 91.1610625), (91.1610625, 93.09047916666667), (93.09047916666667, 96.26945833333333), (96.26945833333333, 100.42233333333333), (100.42233333333333, 102.97652083333334), (102.97652083333334, 106.80783333333333), (106.80783333333333, 111.27308333333333), (111.27308333333333, 117.33702083333333), (117.33702083333333, 119.57883333333334), (119.57883333333334, 123.0701875), (123.0701875, 127.250625), (127.250625, 129.7864375), (129.7864375, 134.57327083333334), (134.57327083333334, 137.7614375), (137.7614375, 140.95877083333335), (140.95877083333335, 146.06716666666668), (146.06716666666668, 150.5324375), (150.5324375, 153.72058333333334), (153.72058333333334, 157.55189583333333), (157.55189583333333, 160.74922916666668), (160.74922916666668, 163.3034375), (163.3034375, 164.25895833333334), (164.25895833333334, 164.89291666666668), (164.89291666666668, 171.576)]\nfrom test_commons import *\nfrom pyjom.lyrictoolbox import remergeDemandedCutSpans\ndef test_cut_spans_valid(list_of_spans, min_span=1.5, max_span=10, no_range_test=False):",
        "type": "code",
        "location": "/tests/test_remerge_demanded_cut_spans.py:2-7"
    },
    "1677": {
        "file_id": 148,
        "content": "This code defines a function `test_cut_spans_valid` that takes a list of spans and optional arguments for minimum and maximum span duration. It calls the `remergeDemandedCutSpans` function from `pyjom.lyrictoolbox`. The code also imports functions from `test_commons` module and defines some variables.",
        "type": "comment"
    },
    "1678": {
        "file_id": 148,
        "content": "    start = list_of_spans[0][0]\n    init_end = list_of_spans[0][1]\n    minit_duration = list_of_spans[0][1] - start\n    if not no_range_test:\n        assert start < list_of_spans[0][1]\n        assert minit_duration >= min_span and minit_duration <= max_span\n    # end = list_of_spans[-1][1]\n    for i, span in enumerate(list_of_spans[1:]):\n        mstart, mend = span\n        try:\n            assert mstart == init_end\n        except:\n            print(mstart, mend, init_end, i + 1)\n            print(list_of_spans[max(0, i - 2) : min(len(list_of_spans), i + 2)])\n            breakpoint()\n        assert mstart < mend\n        duration = mend - mstart\n        if not no_range_test:\n            assert duration >= min_span and duration <= max_span\n        init_end = mend\ntest_cut_spans_valid(cut_spans, no_range_test=True)\nnew_spans = remergeDemandedCutSpans(cut_spans)\nprint(\"new spans?\", new_spans)\ntest_cut_spans_valid(new_spans)\nassert cut_spans[0][0] == new_spans[0][0]\nassert cut_spans[-1][1] == new_spans[-1][1]",
        "type": "code",
        "location": "/tests/test_remerge_demanded_cut_spans.py:8-35"
    },
    "1679": {
        "file_id": 148,
        "content": "This code checks if the list of spans has a consistent order and duration. It asserts that the start of each span is less than its end, and the duration (end - start) adheres to specified minimum and maximum span values. If any assertion fails, it prints the offending span and surrounding spans for debugging. The code then tests if the list of spans has been remerged correctly using the remergeDemandedCutSpans function, ensuring that the first and last spans remain unchanged.",
        "type": "comment"
    },
    "1680": {
        "file_id": 149,
        "content": "/tests/test_manual_censorInterface.py",
        "type": "filepath"
    },
    "1681": {
        "file_id": 149,
        "content": "The code imports necessary modules, defines lists of tags, shuffles them, and uses the censorInterface function to perform content censorship on a title and content with specified tags. It then prints the result.",
        "type": "summary"
    },
    "1682": {
        "file_id": 149,
        "content": "from test_commons import *\nfrom pyjom.modules.contentCensoring.core import censorInterface\nmcounter = 20\nmtags0 = [\"superLongtag{}\".format(x) for x in range(mcounter)]  # must be differet.\nmtags1 = [\"tag{}\".format(x) for x in range(mcounter)]\nmtags = mtags0 + mtags1\nimport random\nrandom.shuffle(mtags)\nresult = censorInterface(\n    \"title\", [\"mytopic\", \"another topic\"], \"mycontent\", mtags=mtags\n)\nprint(result)",
        "type": "code",
        "location": "/tests/test_manual_censorInterface.py:1-18"
    },
    "1683": {
        "file_id": 149,
        "content": "The code imports necessary modules, defines lists of tags, shuffles them, and uses the censorInterface function to perform content censorship on a title and content with specified tags. It then prints the result.",
        "type": "comment"
    },
    "1684": {
        "file_id": 150,
        "content": "/tests/test_local_reviewer.py",
        "type": "filepath"
    },
    "1685": {
        "file_id": 150,
        "content": "This code imports necessary modules, initializes a FilesystemContentReviewer object with a directory path, and calls its main() method to perform content review on the specified directory.",
        "type": "summary"
    },
    "1686": {
        "file_id": 150,
        "content": "from test_commons import *\nfrom pyjom.primitives import *  # this is capitalized.\nwbRev = FilesystemContentReviewer(dirpath=\"./samples/video/\")\nwbRev.main()",
        "type": "code",
        "location": "/tests/test_local_reviewer.py:1-5"
    },
    "1687": {
        "file_id": 150,
        "content": "This code imports necessary modules, initializes a FilesystemContentReviewer object with a directory path, and calls its main() method to perform content review on the specified directory.",
        "type": "comment"
    },
    "1688": {
        "file_id": 151,
        "content": "/tests/test_iterator_generator_wrapper_lazero_utils.py",
        "type": "filepath"
    },
    "1689": {
        "file_id": 151,
        "content": "This code tests the functionality of lazero's iteratorWrapper with different parameters such as init_repeat, repeat, and max_iter. It compares the generated results to predefined objective lists for validation.",
        "type": "summary"
    },
    "1690": {
        "file_id": 151,
        "content": "from lazero.utils.tools import iteratorWrapper, flattenUnhashableList\nsequence = [i for i in range(10)]\nINIT_REPEAT = 3\nobjective_init_repeat = [sequence[0]] * INIT_REPEAT + sequence\nREPEAT = 2\nobjective_repeat = [sequence[0]] * INIT_REPEAT + flattenUnhashableList(\n    list(zip(*([sequence] * (1 + REPEAT))))\n)\nMAX_ITER = 4\nobjective_max_iter = [sequence[0]] * INIT_REPEAT + flattenUnhashableList(\n    list(zip(*([sequence[:MAX_ITER]] * (1 + REPEAT))))\n)\ndef test_init_repeat():\n    result = list(iteratorWrapper((s for s in sequence), init_repeat=INIT_REPEAT))\n    assert result == objective_init_repeat\ndef test_repeat():\n    result = list(\n        iteratorWrapper((s for s in sequence), init_repeat=INIT_REPEAT, repeat=REPEAT)\n    )\n    assert result == objective_repeat\ndef test_max_iter():\n    result = list(\n        iteratorWrapper(\n            (s for s in sequence),\n            init_repeat=INIT_REPEAT,\n            repeat=REPEAT,\n            max_iter=MAX_ITER,\n        )\n    )\n    assert result == objective_max_iter",
        "type": "code",
        "location": "/tests/test_iterator_generator_wrapper_lazero_utils.py:1-42"
    },
    "1691": {
        "file_id": 151,
        "content": "This code tests the functionality of lazero's iteratorWrapper with different parameters such as init_repeat, repeat, and max_iter. It compares the generated results to predefined objective lists for validation.",
        "type": "comment"
    },
    "1692": {
        "file_id": 152,
        "content": "/tests/test_medialang.py",
        "type": "filepath"
    },
    "1693": {
        "file_id": 152,
        "content": "This code imports necessary modules, defines test paths, and iterates through each path. It creates a Medialang object with the specified script path and prettifies it in-place.",
        "type": "summary"
    },
    "1694": {
        "file_id": 152,
        "content": "from test_commons import *\nfrom pyjom.medialang.core import *\nimport os\ntestpaths = [\n    \"processor_demo.mdl\",\n    \"processor_multi.mdl\",\n    \"recipe.mdl\",\n    \"audiolang.mdl\",\n    \"videolang.mdl\",\n]\n# testcontent = open(testpath,\"r\").read()\nfor path in testpaths:\n    testpath = os.path.join(\"/root/Desktop/works/pyjom/test/\", path)\n    mdl = Medialang(script_path=testpath)  # will be parsed.\n    mdl.prettify(inplace=True)",
        "type": "code",
        "location": "/tests/test_medialang.py:1-18"
    },
    "1695": {
        "file_id": 152,
        "content": "This code imports necessary modules, defines test paths, and iterates through each path. It creates a Medialang object with the specified script path and prettifies it in-place.",
        "type": "comment"
    },
    "1696": {
        "file_id": 153,
        "content": "/tests/test_dummy.sh",
        "type": "filepath"
    },
    "1697": {
        "file_id": 153,
        "content": "This code is executing a Python script named \"test_dummy.py\" using the default installed Python3 interpreter. It's likely being run in a Unix-like environment as it uses \"python3\" instead of \"python\". The purpose of running this script might be for testing, debugging or execution of the code within \"test_dummy.py\".",
        "type": "summary"
    },
    "1698": {
        "file_id": 153,
        "content": "python3 test_dummy.py",
        "type": "code",
        "location": "/tests/test_dummy.sh:1-1"
    },
    "1699": {
        "file_id": 153,
        "content": "This code is executing a Python script named \"test_dummy.py\" using the default installed Python3 interpreter. It's likely being run in a Unix-like environment as it uses \"python3\" instead of \"python\". The purpose of running this script might be for testing, debugging or execution of the code within \"test_dummy.py\".",
        "type": "comment"
    }
}