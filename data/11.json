{
    "1100": {
        "file_id": 95,
        "content": "/pyjom/platforms/bilibili/database.py",
        "type": "filepath"
    },
    "1101": {
        "file_id": 95,
        "content": "The code is for a video recommendation program that uses text processing, SQLite database, BM25 algorithm, and hybrid search algorithms to retrieve Bilibili user videos, handle pagination, and update databases. It defines functions for video searching and refreshing status, interacts with a database, initializes a scheduler, creates tables, sets up FastAPI application, contains video search endpoints, retrieves video info from generators, schedules tasks, handles forms, registers videos on Bilibili platform, uses Uvicorn server, and runs bilibiliRecommendationServer function.",
        "type": "summary"
    },
    "1102": {
        "file_id": 95,
        "content": "from lazero.utils.json import jsonify\n# ellipsis = type(...)\n# serve my video, serve my cat video, dog video, set priority, serve others video\n# by means of query? or just directly ask me for it.\n# you'd better mimic the video that you have never recommend, and these audience have never seen before.\nimport time\n# utils.\ndef default(value, default_, isInstance=lambda v: v in [..., None]):\n    if isInstance(value):\n        return default_\n    return value\nimport datetime\nfrom typing import Union, Literal\nfrom functools import lru_cache\nimport random\n# you might want to add this to bilibili platform api, if there's no use of pyjom.commons\nfrom pyjom.platforms.bilibili.credentials import getCredentialByDedeUserId\nfrom pyjom.platforms.bilibili.utils import (\n    linkFixer,\n    videoDurationStringToSeconds,\n    clearHtmlTags,\n)\nfrom lazero.search.preprocessing import getFourVersionsOfProcessedLine\nimport jieba\nimport opencc\nimport jieba.analyse as ana\nimport progressbar\nimport pydantic\n@lru_cache(maxsize=4)\ndef getOpenCCConverter(converter_type: str = \"t2s\"):",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:1-43"
    },
    "1103": {
        "file_id": 95,
        "content": "This code appears to be a part of a larger program that deals with video recommendations and retrieval on the bilibili platform. It imports various libraries and functions, such as jieba for text processing, opencc for Chinese-to-simplified Chinese conversion, and pydantic for data validation. The getOpenCCConverter function is a memoized function that converts text using OpenCC's \"t2s\" type.",
        "type": "comment"
    },
    "1104": {
        "file_id": 95,
        "content": "    converter = opencc.OpenCC(converter_type)\n    return converter\ndef isChineseCharacter(char):\n    assert len(char) == 1\n    return char >= \"\\u4e00\" and char <= \"\\u9fff\"\ndef containChineseCharacters(text):\n    for char in text:\n        if isChineseCharacter(char):\n            return True\n    return False\nfrom lazero.utils.mathlib import extract_span\ndef textPreprocessing(text):\n    converter = getOpenCCConverter()\n    text = converter.convert(text)\n    (\n        final_line,\n        final_cutted_line,\n        final_stemmed_line,\n        final_cutted_stemmed_line,\n    ) = getFourVersionsOfProcessedLine(text)\n    # breakpoint()\n    wordlist = jieba.lcut(final_cutted_line)\n    final_wordlist = []\n    for w in wordlist:\n        word = w.strip()\n        if len(word) > 0:\n            final_wordlist.append(word)\n    flags = [int(containChineseCharacters(word)) for word in final_wordlist]\n    chineseSpans = extract_span(flags, target=1)\n    nonChineseSpans = extract_span(flags, target=0)\n    finalSpans = [(span, True) for span in chineseSpans] + [",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:44-82"
    },
    "1105": {
        "file_id": 95,
        "content": "This code snippet performs text preprocessing on a given text. It uses the OpenCC library to convert the text to simplified Chinese if needed, and then applies Jieba's jieba.lcut method for word segmentation. The resulting words are checked for their presence in the Chinese character range (u4e00-u9fff). Flags are created based on whether each word contains a Chinese character or not. The extract_span function is then used to identify spans of consecutive words with similar flags, which are assumed to be either Chinese or non-Chinese text.",
        "type": "comment"
    },
    "1106": {
        "file_id": 95,
        "content": "        (span, False) for span in nonChineseSpans\n    ]\n    finalSpans.sort(key=lambda span: span[0])\n    finalWordList = []\n    for span, isChineseSpan in finalSpans:\n        subWordList = final_wordlist[span[0] : span[1]]\n        subChars = \"\".join(subWordList)\n        subCharList = [c for c in subChars]  # 直接给你逐字切割了 说不定就有用了\n        if isChineseSpan:\n            subWordList = jieba.lcut_for_search(subChars)\n        finalWordList.extend(subWordList)\n        finalWordList.extend(subCharList)\n    return \" \".join(finalWordList)\nfrom nltk.corpus import stopwords\n@lru_cache(maxsize=1)\ndef getStopwords(languages: tuple = (\"chinese\", \"english\")):\n    stopword_list = []\n    for lang in languages:\n        stopword_list.extend(stopwords.words(lang))\n    return stopword_list\ndef keywordExtracting(\n    text,\n    method: Literal[\"tfidf\", \"random\"] = \"tfidf\",\n    languages: tuple = (\"chinese\", \"english\"),\n    topK: int = 5,\n):\n    # remove all stopwords.\n    keyword_list = textPreprocessing(text).split(\" \")\n    stopword_list = getStopwords(languages=languages)",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:83-117"
    },
    "1107": {
        "file_id": 95,
        "content": "This code performs text preprocessing and keyword extraction. It removes stopwords, utilizes a custom function for Chinese word segmentation, and implements TF-IDF or random selection of top keywords from the preprocessed text. It also stores commonly used stopwords in memory using LRU cache.",
        "type": "comment"
    },
    "1108": {
        "file_id": 95,
        "content": "    results = []\n    for k in keyword_list:\n        if k.lower() not in stopword_list:\n            results.append(k)\n    if method == \"random\":\n        random.shuffle(results)\n        return results[:topK]\n    elif method == \"tfidf\":\n        myText = \" \".join(results)\n        tags = ana.extract_tags(myText, topK=topK)\n        return tags\n    else:\n        raise Exception(\"Unknown keyword extraction method: %s\" % method)\n################################BILIBILI QUERY DATA MODELS######################\n# @reloading\nclass queryForm(pydantic.BaseModel):\n    query: str  # required?\n    page_size: Union[int, None] = None\n    page_num: int = 1\n    query_for_search_cached: Union[str, None] = None\n    # you are going to inherit this.\n    @property\n    def query_for_search(\n        self,\n    ):  # make sure the preprocessing is only called once. really?\n        if self.query_for_search_cached is None:\n            query = self.query\n            self.query_for_search_cached = textPreprocessing(query)\n        return self.query_for_search_cached",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:118-151"
    },
    "1109": {
        "file_id": 95,
        "content": "This code performs keyword extraction based on the provided method. It filters out stopwords, shuffles results if using the \"random\" method, and uses TF-IDF for the \"tfidf\" method. The `queryForm` class is a Pydantic model for BiliBili query data models with properties for query, page size, page number, and cached preprocessed search query.",
        "type": "comment"
    },
    "1110": {
        "file_id": 95,
        "content": "# @reloading\nclass searchVideoForm(queryForm):\n    iterate: bool = False\n    params: dict = {}  # let's just see what you've got here.\nfrom bilibili_api.user import VideoOrder\n# @reloading\nclass searchRegisteredVideoForm(queryForm):\n    tid: int = 0\n    dedeuserid: Union[list[str], str, None] = None\n    videoOrder: VideoOrder = VideoOrder.PUBDATE\n# @reloading\nclass searchUserVideoForm(searchRegisteredVideoForm):\n    dedeuserid: str = \"397424026\"\n    method: Literal[\"online\", \"bm25\"] = \"online\"\n    use_credential: bool = False\n# @reloading\nclass registerUserVideoForm(pydantic.BaseModel):\n    bvid: str\n    dedeuserid: str\n    is_mine: bool = False\n    visible: bool = False\n################################BILIBILI QUERY DATA MODELS######################\n# from pyjom.platforms.bilibili.searchDataParser import parseSearchVideoResult # but you never use this shit.\n# will it load the overheads of pyjom.commons?\n# updated anyio. does that work? will it break dependencies?\nimport pyjq\nfrom bilibili_api import sync, search, user, video",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:154-195"
    },
    "1111": {
        "file_id": 95,
        "content": "The code defines four classes: `searchVideoForm`, `searchRegisteredVideoForm`, `searchUserVideoForm`, and `registerUserVideoForm`. These classes inherit from `queryForm` and are used for querying video data on Bilibili. The classes have different parameters, such as `tid`, `dedeuserid`, `videoOrder`, `method`, and `use_credential`, to specify the desired search criteria. The code also imports necessary modules and functions from `bilibili_api` for performing operations on videos, users, and searches.",
        "type": "comment"
    },
    "1112": {
        "file_id": 95,
        "content": "from peewee import *\nfrom playhouse.sqlite_ext import SqliteExtDatabase, FTSModel, SearchField, RowIDField\nBSP = search.bilibiliSearchParams\n# you can query for the server status.\n# make it into a dashboard like thing.\n@lru_cache(maxsize=1)\ndef getMajorMinorTopicMappings(debug: bool = False):\n    majorMinorMappings = {}\n    for key, value in BSP.all.tids.__dict__.items():\n        try:\n            major_tid = value.tid\n            if debug:\n                print(\"MAJOR\", key, major_tid)\n            content = {\"major\": {\"tid\": major_tid, \"name\": key}}\n            majorMinorMappings.update(\n                {major_tid: content, key: content, str(major_tid): content}\n            )\n            for subkey, subvalue in value.__dict__.items():\n                if subkey != \"tid\" and type(subvalue) == int:\n                    if debug:\n                        print(\"MINOR\", subkey, subvalue)\n                    content = {\n                        \"major\": {\"tid\": major_tid, \"name\": key},\n                        \"minor\": {\"tid\": subvalue, \"name\": subkey},",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:197-223"
    },
    "1113": {
        "file_id": 95,
        "content": "This code retrieves major and minor topic mappings from the bilibiliSearchParams database table and stores them in a dictionary called 'majorMinorMappings'. The function is memoized using @lru_cache decorator to avoid redundant queries. The debug parameter, if set to True, will print the major and minor topics during execution.",
        "type": "comment"
    },
    "1114": {
        "file_id": 95,
        "content": "                    }\n                    majorMinorMappings.update(\n                        {subvalue: content, subkey: content, str(subvalue): content}\n                    )\n        except:\n            pass\n    return majorMinorMappings\ndef getTagStringFromTid(tid):\n    majorMinorTopicMappings = getMajorMinorTopicMappings()\n    topic = majorMinorTopicMappings.get(tid, None)\n    tags = []\n    if topic:\n        majorTopic = topic.get(\"major\", {}).get(\"name\", None)\n        minorTopic = topic.get(\"minor\", {}).get(\"name\", None)\n        if majorTopic:\n            tags.append(majorTopic)\n            if minorTopic:\n                tags.append(minorTopic)\n    return \",\".join(tags)\n# also make a decorator for refreshing status, add it to every function.\n# thie refresher is scheduled.\n# you may want to run this beforehand...\nimport schedule\n# do we really need credential for checking our video? you can try.\n@lru_cache(maxsize=3)  # could be bigger.\ndef getUserObject(dedeuserid: str = \"397424026\", use_credential: bool = False):",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:224-257"
    },
    "1115": {
        "file_id": 95,
        "content": "This code defines a function `getTagStringFromTid(tid)` that retrieves topic details from a topic ID (tid) and returns a comma-separated list of major and minor topics. It also uses a decorator to refresh the status, scheduled by calling `schedule()`, and a cached version of `getUserObject()` function with an optional dedeuserid and use_credential parameters.",
        "type": "comment"
    },
    "1116": {
        "file_id": 95,
        "content": "    dedeuserid_int = int(dedeuserid)\n    if use_credential:\n        credential = getCredentialByDedeUserId(\n            dedeuserid\n        )  # this will cache the cookies. so it allows multiple accounts.\n    else:\n        credential = None\n    u = user.User(dedeuserid_int, credential=credential)\n    return u\nfrom lazero.filesystem.env import getHomeDirectory\nfrom pathlib import Path\nimport os\nfrom peewee import *\nclass BilibiliUser(Model):\n    username = CharField()  # can be updated later.\n    user_id = IntegerField(unique=True)  # this is integer.\n    is_mine = BooleanField(default=False)\n    followers = IntegerField(\n        null=True\n    )  # how to get that? every time you get some video you do this shit? will get you blocked.\n    # well you can check it later.\n    avatar = CharField(null=True)  # warning! charfield max length is 255\n    def userInfoExtracter(self, blacklist=[\"id\"]):\n        info = {\n            key: value for key, value in self.__data__.items() if key not in blacklist\n        }\n        return info",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:258-290"
    },
    "1117": {
        "file_id": 95,
        "content": "The code defines a class called BilibiliUser, which inherits from the peewee.Model class. The class has fields for username, user_id (which is unique), is_mine flag, followers count, and avatar URL. A method, userInfoExtracter, is also defined to extract information from the model instance excluding specified keys. Additionally, a function exists to create a new User instance based on the provided dedeuserid and credential.",
        "type": "comment"
    },
    "1118": {
        "file_id": 95,
        "content": "class BilibiliVideo(Model):\n    bvid = CharField(unique=True)\n    typeid = IntegerField(null=True)  # string? wtf?\n    visible = BooleanField(null=True)  # are you sure?\n    last_check = DateTimeField(\n        default=datetime.datetime.now\n    )  # well this is not tested. test it!\n    register_date = DateTimeField(default=datetime.datetime.now)\n    poster = ForeignKeyField(\n        BilibiliUser, field=BilibiliUser.user_id\n    )  # is it my account anyway?\n    play = IntegerField(null=True)\n    pic = CharField(null=True)\n    length = IntegerField(null=True)\n    pubdate = IntegerField(default=0, null=True)\n    review = IntegerField(null=True)  # you want to update? according to this?\n    favorites = IntegerField(default=0, null=True)\n    title = CharField(null=True)\n    tag = CharField(null=True)\n    description = CharField(null=True)\n    def videoInfoExtractor(\n        self, blacklist=[\"id\", \"last_check\", \"register_date\", \"poster\"]\n    ):\n        info = {\n            key: value for key, value in self.__data__.items() if key not in blacklist",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:293-318"
    },
    "1119": {
        "file_id": 95,
        "content": "This code defines a BilibiliVideo class that inherits from Model and includes various fields such as bvid, typeid, visible, last_check, register_date, poster, play, pic, length, pubdate, review, favorites, title, and tag. The videoInfoExtractor method takes a blacklist parameter and returns information excluding the specified fields.",
        "type": "comment"
    },
    "1120": {
        "file_id": 95,
        "content": "        }\n        poster = self.poster\n        try:\n            info[\n                \"poster\"\n            ] = (\n                poster.userInfoExtracter()\n            )  # well it will return as always. no live fetching! it is stored in database.\n        except:\n            import traceback\n            traceback.print_exc()\n            print(\"userinfo might be missing from videoinfo.\")\n        try:\n            info[\"typeid\"] = int(info[\"typeid\"])\n        except:\n            pass\n        return info\nclass BilibiliVideoIndex(FTSModel):\n    rowid = RowIDField()\n    # these three must be preprocessed before put into the search engine, or we cannot retrieve the data correctly.\n    title = SearchField()\n    tag = (\n        SearchField()\n    )  # also what the fuck is going on with the tag? why we cannot get the tag/topic name?\n    description = SearchField()\n    class Meta:\n        database = None  # that's good.\n        options = {\"tokenize\": \"porter\"}  # you need manually separate some\n@lru_cache(maxsize=1)\ndef getBilibiliVideoDatabase():",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:319-354"
    },
    "1121": {
        "file_id": 95,
        "content": "This code is initializing a BilibiliVideoIndex model, which extends FTSModel and has three SearchField properties (title, tag, description). It also contains a RowIDField (rowid). The function getBilibiliVideoDatabase() is a cache-friendly function to access the database.",
        "type": "comment"
    },
    "1122": {
        "file_id": 95,
        "content": "    db_dir = Path(getHomeDirectory()) / \".bilibili_video\"\n    if not os.path.exists(db_dir):\n        os.mkdir(db_dir)\n    db_path = db_dir / \"database.db\"  # sure this works?\n    # db = SqliteDatabase(db_path)\n    db = SqliteExtDatabase(\n        db_path, pragmas={\"journal_mode\": \"wal\", \"cache_size\": -1024 * 64}\n    )\n    # test the full text search function elsewhere. please?\n    return db\ndef getBilibiliVideoDatabaseAndCreateTables():\n    db = getBilibiliVideoDatabase()\n    db.create_tables([BilibiliUser, BilibiliVideo, BilibiliVideoIndex])\n    return db\n# no need to decorate this thing. only put some 'unchecked' video into array.\ndef registerUser(dedeuserid: str, is_mine: Union[bool, None] = None):\n    user_id = int(dedeuserid)\n    u = BilibiliUser.get_or_none(user_id=user_id)\n    if u is None:  # this is to create.\n        if is_mine is None:\n            is_mine = False\n        userObject = user.User(user_id)\n        userInfo = sync(userObject.get_user_info())\n        # print(userInfo)\n        # print(dir(userInfo))",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:355-383"
    },
    "1123": {
        "file_id": 95,
        "content": "The code sets up a SQLite database for the Bilibili video platform. It creates a directory if it doesn't exist, defines the database path, and initializes an SqliteExtDatabase object with specified pragmas. The getBilibiliVideoDatabaseAndCreateTables function creates necessary tables using the defined database, and registerUser function retrieves or creates a BilibiliUser based on the provided dedeuserid.\n\nThe code sets up a SQLite database for the Bilibili video platform by initializing an SqliteExtDatabase object with specified pragmas and creating required tables. The getBilibiliVideoDatabaseAndCreateTables function utilizes this setup, while the registerUser function handles user retrieval or creation based on dedeuserid.",
        "type": "comment"
    },
    "1124": {
        "file_id": 95,
        "content": "        # breakpoint()\n        # dict_keys(['list', 're_version', 'total'])\n        # in the 'list' we've got a few recent followers.\n        followersInfo = sync(userObject.get_followers())\n        username = userInfo[\"name\"]\n        followers = followersInfo[\"total\"]\n        avatar = userInfo[\"face\"]\n        (\n            u,\n            _,\n        ) = BilibiliUser.get_and_update_or_create(  # this is wrong. maybe the username is updated.\n            user_id=user_id,\n            username=username,\n            is_mine=is_mine,\n            followers=followers,\n            avatar=avatar,\n        )\n        # when to update? maybe later.\n    elif is_mine is not None and u.is_mine != is_mine:\n        u.is_mine = is_mine\n        u.save()\n    return u\n# @refresh_status_decorator\ndef searchVideos(\n    query: str,\n    iterate: bool = False,\n    page_start: int = 1,\n    params={\"duration\": BSP.all.duration._10分钟以下},  # is that right? maybe?\n    page_size: int = ...,\n):  # what do you expect? you want the xml object let's get it!",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:384-415"
    },
    "1125": {
        "file_id": 95,
        "content": "The code appears to be fetching user and video information from the Bilibili platform, handling updates for user profiles, and searching for videos based on a given query. It utilizes functions like `get_followers()`, `BilibiliUser.get_and_update_or_create()`, and `searchVideos()`. The code also includes a refresh status decorator, and handles user profile updates if the 'is_mine' flag changes.",
        "type": "comment"
    },
    "1126": {
        "file_id": 95,
        "content": "    # search the thing directly? or you distill keywords from it?\n    search_type = search.SearchObjectType.VIDEO\n    # or you use some baidu magic?\n    # anyway, let's begin.\n    # warning: this is coroutine.\n    # you might want some magic. with 'suppressException' and pickledFunction?\n    def getResultParsed(result):\n        mresult = pyjq.all(\n            \".result[] | {mid, author, pic, play, is_pay, duration, bvid, description, title, pubdate, tag, typename, typeid, review, favorites, danmaku, rank_score, like, upic} | select (.title != null and .bvid != null)\",\n            result,\n        )\n        return mresult\n    def getResult(page):\n        result = sync(\n            search.search_by_type(\n                query,\n                search_type,\n                params=params,\n                page=page,\n                **jsonify(dict(page_size=page_size)),\n            )\n        )\n        return result\n    result = getResult(page_start)\n    numPages = result[\"numPages\"]  # usually we select the topmost candidates.",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:416-442"
    },
    "1127": {
        "file_id": 95,
        "content": "This code searches for results on Bilibili using the search_type parameter and query. It uses coroutines to get the result, then extracts and returns parsed data from the result. The function gets the result by calling a search API with specified parameters and retrieves the number of pages from the returned result.",
        "type": "comment"
    },
    "1128": {
        "file_id": 95,
        "content": "    # print(result)\n    if numPages < page_start:\n        page_start_current = 1\n    else:\n        page_start_current = page_start\n        mresult = getResultParsed(result)\n        for v in mresult:\n            yield v\n    if not iterate:\n        page_range = range(page_start_current, page_start_current + 1)\n    else:\n        import progressbar\n        print(f\"iterating page range: {page_start_current}-{numPages}\")\n        page_range = progressbar.progressbar(range(page_start_current, numPages + 1))\n    for page in page_range:\n        if page != page_start:\n            result = getResult(page)\n            mresult = getResultParsed(result)\n            for v in mresult:\n                yield v\n    # you can use the upic to render some deceptive ads, but better not?\n    # so you want to persist these results or not?\n    # better persist so we can reuse.\n    # no persistance?\n    # check some interesting result.\n    # no selection?\n    # you should use the parser found elsewhere. or not?\n    # breakpoint()\n    # remove keyword highlight from title. will you?",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:443-474"
    },
    "1129": {
        "file_id": 95,
        "content": "The code is responsible for iterating through a range of pages, fetching data from each page, and processing the results. It also includes checks to see if persistence is required or if any selections need to be made. Additionally, it considers whether to remove keyword highlights from titles. The code may also handle potential errors or breakpoints with a `breakpoint()` statement.",
        "type": "comment"
    },
    "1130": {
        "file_id": 95,
        "content": "    # result['result'][0].keys()\n    # keys = [\n    #     \"type\",\n    #     \"id\",\n    #     \"author\",\n    #     \"mid\",\n    #     \"typeid\",\n    #     \"typename\",\n    #     \"arcurl\",\n    #     \"aid\",\n    #     \"bvid\",\n    #     \"title\",\n    #     \"description\",\n    #     \"arcrank\",\n    #     \"pic\",\n    #     \"play\",\n    #     \"video_review\",\n    #     \"favorites\",\n    #     \"tag\",\n    #     \"review\",\n    #     \"pubdate\",\n    #     \"senddate\",\n    #     \"duration\",\n    #     \"badgepay\",\n    #     \"hit_columns\",\n    #     \"view_type\",\n    #     \"is_pay\",\n    #     \"is_union_video\",\n    #     \"rec_tags\",\n    #     \"new_rec_tags\",\n    #     \"rank_score\",\n    #     \"like\",\n    #     \"upic\",\n    #     \"corner\",\n    #     \"cover\",\n    #     \"desc\",\n    #     \"url\",\n    #     \"rec_reason\",\n    #     \"danmaku\",\n    # ]\n    # rank score is important!\n# you need my credential!\n# better reuse the code.\ndef checkVideoInDatabase(bvid: str):\n    # we use peewee (of course our modified version)\n    db = getBilibiliVideoDatabase()\n    db.create_tables([BilibiliVideo, BilibiliUser])",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:475-525"
    },
    "1131": {
        "file_id": 95,
        "content": "This code is defining a function `checkVideoInDatabase` that takes a video bvid as input, initializes a Peewee database, creates tables for BilibiliVideo and BilibiliUser, and checks if the video already exists in the database. It returns True if the video is found, otherwise False.",
        "type": "comment"
    },
    "1132": {
        "file_id": 95,
        "content": "    result = BilibiliVideo.get_or_none(BilibiliVideo.bvid == bvid)\n    return result  # check it elsewhere?\n# get my videos first!\nimport math\n# @refresh_status_decorator\nfrom bilibili_api.user import VideoOrder\ndef indexAndGetVideoObject(\n    v, bilibiliUser\n):  # let's wrap this shit. eliminate those 'erroneous' display.\n    try:\n        v[\"typeid\"] = int(v[\"typeid\"])\n    except:\n        pass\n    favdict = {}\n    favorites = v.get(\"favorites\", None)\n    if favorites is not None:\n        favdict[\"favorites\"] = favorites\n    bilibiliVideo, flag = BilibiliVideo.get_and_update_or_create(\n        bvid=v[\"bvid\"],\n        typeid=v[\"typeid\"],\n        visible=True,  # are you sure?\n        last_check=datetime.datetime.now(),  # well this is not tested. test it!\n        poster=bilibiliUser,  # is it my account anyway?\n        play=v[\"play\"],\n        pic=linkFixer(v[\"pic\"]),\n        length=videoDurationStringToSeconds(v.get(\"length\", v.get(\"duration\"))),\n        review=v.get(\"comment\", v.get(\"review\")),\n        pubdate=v.get(\"created\", v.get(\"pubdate\")),",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:526-558"
    },
    "1133": {
        "file_id": 95,
        "content": "This code retrieves a BilibiliVideo object based on the provided bvid and typeid, updates or creates it if necessary, and fills in various attributes from the given video dictionary. The poster attribute is set to bilibiliUser, assuming it belongs to that user's account. The visible attribute is set to True by default, but this may need verification. The last_check timestamp is set to the current datetime, and the code attempts to fix the pic URL with a linkFixer function call.",
        "type": "comment"
    },
    "1134": {
        "file_id": 95,
        "content": "        description=v[\"description\"],\n        title=clearHtmlTags(v[\"title\"]),  # it may contain highlights. be warned\n        tag=v[\"tag\"],\n        **favdict,\n        # _debug=True\n    )\n    # print(\"f\", flag)\n    # print(v)\n    # print(bilibiliUser)\n    # breakpoint()\n    bilibiliVideoIndex, _ = BilibiliVideoIndex.get_and_update_or_create(\n        rowid=bilibiliVideo.id,\n        description=textPreprocessing(bilibiliVideo.description),\n        tag=textPreprocessing(bilibiliVideo.tag),\n        title=textPreprocessing(bilibiliVideo.title),\n    )\n    return bilibiliVideo\ndef getUserVideos(\n    tid=0,\n    keyword=\"\",\n    order=VideoOrder.PUBDATE,\n    dedeuserid: str = \"397424026\",\n    use_credential: bool = False,\n    stop_on_duplicate: bool = True,\n    sleep: int = 2,\n    page_num: int = 1,\n    page_size: int = 30,\n):  # all videos? just at init.\n    pn = page_num\n    # some stop condition for early termination.\n    # if any of the video exists in the database, we stop this shit.\n    bilibiliUser = registerUser(\n        dedeuserid,",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:559-593"
    },
    "1135": {
        "file_id": 95,
        "content": "The code retrieves a user's videos from Bilibili and processes them, updating the database with the video information. It also provides options for filtering and pagination.",
        "type": "comment"
    },
    "1136": {
        "file_id": 95,
        "content": "    )\n    u = getUserObject(dedeuserid=dedeuserid, use_credential=use_credential)\n    # tid\tint, optional\t分区 ID. Defaults to 0（全部）\n    # pn\tint, optional\t页码，从 1 开始. Defaults to 1.\n    # ps\t(int, optional)\t每一页的视频数. Defaults to 30.\n    # keyword\tstr, optional\t搜索关键词. Defaults to \"\".\n    # order\tVideoOrder, optional\t排序方式. Defaults to VideoOrder.PUBDATE\n    # this is async. use sync.\n    stopped = False\n    while not stopped:\n        videos = sync(\n            u.get_videos(pn=pn, keyword=keyword, tid=tid, order=order, ps=page_size)\n        )\n        # print(videos)\n        # dict_keys(['list', 'page', 'episodic_button', 'is_risk', 'gaia_res_type', 'gaia_data'])\n        page = videos[\"page\"]  # pagination options\n        numPages = math.ceil(page[\"count\"] / page[\"ps\"])\n        # print('NUM PAGES',numPages)\n        # topicDict = videos[\"list\"][\"tlist\"]\n        # {'1': {'tid': 1, 'count': 13, 'name': '动画'}, '160': {'tid': 160, 'count': 257, 'name': '生活'}, '181': {'tid': 181, 'count': 2, 'name': '影视'}, '188': {'t",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:594-613"
    },
    "1137": {
        "file_id": 95,
        "content": "This code is retrieving videos from the Bilibili platform, using a specific user object and various parameters such as pagination and keyword. It fetches data in pages and calculates the number of pages based on the total count of videos. The code handles pagination and possibly retrieves topic information based on different categories (tid).",
        "type": "comment"
    },
    "1138": {
        "file_id": 95,
        "content": "id': 188, 'count': 4, 'name': '科技'}, '217': {'tid': 217, 'count': 4, 'name': '动物圈'}, '234': {'tid': 234, 'count': 1, 'name': '运动'}, '3': {'tid': 3, 'count': 9, 'name': '音乐'}, '36': {'tid': 36, 'count': 30, 'name': '知识'}, '4': {'tid': 4, 'count': 67, 'name': '游戏'}}\n        # breakpoint()\n        video_list = videos[\"list\"][\"vlist\"]\n        # breakpoint()\n        if video_list == []:\n            break\n        for v in video_list:\n            bvid = v[\"bvid\"]\n            subTypeId = v[\"typeid\"]\n            tagString = getTagStringFromTid(subTypeId)\n            v.update({\"tag\": tagString})\n            result = checkVideoInDatabase(bvid)\n            if result and stop_on_duplicate:\n                stopped = True\n                break\n            # print(v)\n            # dict_keys(['comment', 'typeid', 'play', 'pic', 'subtitle', 'description', 'copyright', 'title', 'review', 'author', 'mid', 'created', 'length', 'video_review', 'aid', 'bvid', 'hide_click', 'is_pay', 'is_union_video', 'is_steins_gate', 'is_live_playback'])",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:613-629"
    },
    "1139": {
        "file_id": 95,
        "content": "The code is iterating through a list of videos and for each video, it updates the tag string using getTagStringFromTid function. Then, it checks if the video already exists in the database using checkVideoInDatabase function. If the video is found and stop_on_duplicate is True, the loop breaks and stopped is set to True.",
        "type": "comment"
    },
    "1140": {
        "file_id": 95,
        "content": "            # breakpoint()\n            # bad idea. you should get the bilibiliUser before you do this.\n            bilibiliVideo = indexAndGetVideoObject(v, bilibiliUser)\n            yield bilibiliVideo\n        # videos['list']['vlist'][0].keys()\n        # dict_keys(['comment', 'typeid', 'play', 'pic', 'subtitle', 'description', 'copyright', 'title', 'review', 'author', 'mid', 'created', 'length', 'video_review', 'aid', 'bvid', 'hide_click', 'is_pay', 'is_union_video', 'is_steins_gate', 'is_live_playback'])\n        if pn >= numPages:\n            break\n        elif not stop_on_duplicate:\n            break  # this is the hint of merely using this as a search tool\n        time.sleep(sleep)\n        pn += 1\n# cannot resolve 217?\ndef resolveSubTidsFromTid(tid: int):\n    if type(tid) != int:\n        tid = int(tid)\n    MMTM = getMajorMinorTopicMappings()\n    allTids = [t for t in MMTM.keys() if type(t) == int]\n    if tid == 0:\n        return allTids\n    elif tid not in allTids:\n        raise Exception(\"Invalid tid: %d\" % tid)",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:630-653"
    },
    "1141": {
        "file_id": 95,
        "content": "This code appears to be part of a larger program responsible for interacting with the Bilibili platform's database. It utilizes functions like `indexAndGetVideoObject`, `getMajorMinorTopicMappings`, and `resolveSubTidsFromTid`. The main functionality seems to involve looping through pages of videos, obtaining video objects, and resolving subtopic IDs from a given topic ID. There is also a mechanism for handling duplicate or redundant data and an optional sleep function to control the speed at which the program retrieves information.",
        "type": "comment"
    },
    "1142": {
        "file_id": 95,
        "content": "    else:\n        myTids = set()\n        myTids.add(tid)\n        # print(\"ALL TIDS?\")\n        # import rich\n        # rich.print(allTids)\n        # rich.print(MMTM)\n        myTopic = MMTM[tid]\n        # myTopic = allTids[tid]\n        if myTopic.get(\"minor\", None) == None:\n            # this is a major topic\n            for t in allTids:\n                subTopic = MMTM[t]\n                if subTopic.get(\"major\", {}).get(\"tid\", None) == tid:\n                    subTid = subTopic.get(\"minor\", {}).get(\"tid\", tid)\n                    myTids.add(subTid)\n        return list(myTids)\ndef searchRegisteredVideosAndGetResultList(\n    keyword: str,\n    tid: int = 0,\n    dedeuserid: Union[str, None, list[str]] = \"397424026\",\n    videoOrder=VideoOrder.PUBDATE,  # FAVOURITE, VIEW\n    page_num: int = 1,\n    page_size: int = 10,\n):\n    resultList = []\n    resolvedTids = resolveSubTidsFromTid(tid)\n    condition = (BilibiliVideo.typeid in resolvedTids) & (BilibiliVideo.visible == True)\n    if dedeuserid is not None:\n        if type(dedeuserid) == str:",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:654-686"
    },
    "1143": {
        "file_id": 95,
        "content": "Code resolves subtopics from a given topic ID and returns a list of associated topic IDs. It checks if the topic is major or minor, then searches for subtopics related to the main topic. Finally, it adds the subtopic's minor topic IDs to the list. This function can be used to find videos related to specific keywords within registered topics and return a result list based on video order preference.",
        "type": "comment"
    },
    "1144": {
        "file_id": 95,
        "content": "            dedeuserids = [dedeuserid]\n        else:\n            dedeuserids = dedeuserid\n        dedeuserids = [int(d) for d in dedeuserids]\n    else:\n        dedeuserids = None\n        # print(\"DEDEUSERIDS:\", dedeuserids)\n    # vlist = [v for v in (BilibiliVideo.select().where(condition) or [])]\n    # http://docs.peewee-orm.com/en/latest/peewee/relationships.html#relationships\n    def getVgen(selector, videoOrder):\n        nonlocal condition, dedeuserids\n        vgen = selector\n        # breakpoint()\n        if dedeuserids:\n            from functools import reduce\n            condition &= reduce(\n                lambda a, b: a | b,\n                [BilibiliUser.user_id == int(userid) for userid in dedeuserids],\n            )\n            vgen = vgen.join(BilibiliUser).where(\n                condition\n            )  # this statement does not work.\n        else:\n            vgen = vgen.where(condition)\n        favorites = BilibiliVideo.favorites\n        pubdate = BilibiliVideo.pubdate\n        view = BilibiliVideo.play",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:687-716"
    },
    "1145": {
        "file_id": 95,
        "content": "This code retrieves bilibili videos based on a given condition. It takes into account dedeuserids, which are either provided as a list or None. If dedeuserids is not None, it applies the condition to filter the videos by specific users. Finally, it sorts and selects the videos based on favorites, pubdate, and view count.",
        "type": "comment"
    },
    "1146": {
        "file_id": 95,
        "content": "        if videoOrder == VideoOrder.FAVORITE:  # this is fake ordering.\n            order = favorites.desc()  # desc\n        elif videoOrder == VideoOrder.VIEW:\n            order = view.desc()  # desc\n        elif videoOrder == VideoOrder.PUBDATE:  # also desc.\n            order = pubdate.desc()  # most recent video.\n        else:\n            order = None\n        if order is not None:\n            vgen = vgen.order_by(order)\n        return vgen\n    # user_video_ids = [v.id for v in vgen or []]\n    # print('user of videos',set([v.poster.user_id for v in vgen or []]))\n    # breakpoint()\n    results = getVgen(\n        BilibiliVideoIndex.search_bm25(keyword).join(\n            BilibiliVideo, on=(BilibiliVideoIndex.rowid == BilibiliVideo.id)\n        ),\n        videoOrder,\n    ).paginate(  # again this is wrong.\n        page_num, page_size\n    )\n    for index, video_index in enumerate(results):\n        bilibiliVideo = BilibiliVideo.get(id=video_index.rowid)  # this shall be fast.\n        # what is the count? you need to reorder?",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:717-742"
    },
    "1147": {
        "file_id": 95,
        "content": "The code retrieves videos based on a specified ordering (favorites, view count, or publication date) and performs a search using the BM25 algorithm. It then paginates the results and retrieves additional information for each video by calling `BilibiliVideo.get()`. The code also includes a comment indicating that reordering might be necessary in the future.",
        "type": "comment"
    },
    "1148": {
        "file_id": 95,
        "content": "        # bvid = bilibiliVideo.bvid\n        # cover = bilibiliVideo.pic\n        order = None\n        # you should return the video_index.\n        resultList.append((bilibiliVideo, order))\n    # resultList.sort(key=lambda x: x[1])\n    return resultList\ndef searchRegisteredVideos(\n    keyword: str,\n    tid: int = 0,\n    dedeuserid: Union[list[str], str, None] = \"397424026\",\n    videoOrder=VideoOrder.PUBDATE,  # FAVOURITE, VIEW\n    page_num: int = 1,\n    page_size: int = 30,\n):\n    resultList = searchRegisteredVideosAndGetResultList(\n        tid=tid,\n        dedeuserid=dedeuserid,\n        videoOrder=videoOrder,\n        page_num=page_num,\n        page_size=page_size,\n        keyword=keyword,\n    )\n    for v, _ in resultList:\n        yield v  # this is bilibiliVideoIndex, but you also needs the bvid.\ndef searchUserVideos(\n    keyword: str,\n    tid: int = 0,\n    dedeuserid: str = \"397424026\",\n    method: Literal[\"online\", \"bm25\"] = \"online\",\n    use_credential: bool = False,\n    videoOrder=VideoOrder.PUBDATE,  # FAVOURITE, VIEW",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:743-778"
    },
    "1149": {
        "file_id": 95,
        "content": "This code defines functions for searching registered and user videos on Bilibili. The functions take a keyword, video order, tid, dedeuserid, page number, and page size as parameters. It searches for videos based on the provided parameters and returns a list of bilibiliVideoIndex objects along with their orders.",
        "type": "comment"
    },
    "1150": {
        "file_id": 95,
        "content": "    page_num: int = 1,\n    page_size: int = 30,\n):  # you can support this in database?\n    # you want keyword search or not? it's better than searching in database. i think.\n    # but database search saves bandwidth.\n    # better use semantic search. but now we use hybrid search instead.\n    # hybrid search: metatopic plus bm25\n    # or not?\n    # just dump that shit.\n    # check if keyword overlaps.\n    # how to search my video? and how to measure relevance?\n    if method == \"online\":\n        resultList = []\n        order = None\n        for v in getUserVideos(\n            tid=tid,\n            order=videoOrder,\n            keyword=keyword,\n            dedeuserid=dedeuserid,\n            use_credential=use_credential,\n            stop_on_duplicate=False,\n            page_num=page_num,\n            page_size=page_size,\n        ):\n            # what is the content? plan to update?\n            # print(\"SEARCHED USER VIDEO ID:\", v_id)\n            resultList.append((v, order))\n        # info = u.get_videos(keyword=keyword,order=videoOrder)",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:779-806"
    },
    "1151": {
        "file_id": 95,
        "content": "The code performs a hybrid search for videos, combining metatopic and BM25 search algorithms, to find the most relevant results based on a given keyword. It also retrieves video information and stores it in a list for further processing or display.",
        "type": "comment"
    },
    "1152": {
        "file_id": 95,
        "content": "    elif method == \"bm25\":\n        # export all video? shit?\n        # you should tokenize the thing.\n        # but this search does not have limitations!\n        resultList = searchRegisteredVideosAndGetResultList(\n            tid=tid,\n            dedeuserid=dedeuserid,\n            videoOrder=videoOrder,\n            page_num=page_num,\n            page_size=page_size,\n            keyword=keyword,\n        )\n    for v, _ in resultList:\n        yield v  # this is bilibiliVideoIndex, but you also needs the bvid.\n# you can make excerpt from video to lure people into viewing your video.\ndef getVideoInfo(bvid: str):\n    v = video.Video(bvid=bvid)\n    info = sync(v.get_info())\n    return info\ndef registerUserVideo(\n    bvid: str,\n    dedeuserid: str,\n    is_mine: bool = False,\n    visible: bool = False,  # no checking on video visibility? maybe we need to do this after search.\n):  # this is the video i just post. must be regularly checked then add to candidate list. you can check it when another call for my videos has been issued.",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:807-837"
    },
    "1153": {
        "file_id": 95,
        "content": "The code is performing a search for registered videos on Bilibili platform, utilizing the BM25 search algorithm. It returns the video results without any limitations and allows for further processing like excerpt generation to attract viewers. The code also includes functions for getting video information and registering user videos with optional visibility settings.",
        "type": "comment"
    },
    "1154": {
        "file_id": 95,
        "content": "    # register user first, then register the video.\n    # you will store it to database.\n    u = registerUser(dedeuserid, is_mine)\n    # check if exists.\n    v = BilibiliVideo.get_or_none(BilibiliVideo.bvid == bvid)\n    new = v is None\n    if new:\n        BilibiliVideo.create(bvid=bvid, visible=visible, poster=u)  # it must be new.\n    return new\n# grace period to be one day. that's long enough. or not?\n# we still need some more experiment.\ndef checkVideoVisibility(bvid: str, debug: bool = False):\n    visible = False  # you might want some 'err' parameter. but that only indicates inavalibility of certain video, not video flagged as permanently invisible.\n    try:\n        info = getVideoInfo(bvid)  # getting shit? we need some normal video for test.\n        state = info[\"state\"]\n        visible = state == 0\n    except:\n        if debug:\n            import traceback\n            traceback.print_exc()\n            print(\"error when checking video status: %s\" % bvid)\n    return visible\n# check api doc for hint.\ndef checkRegisteredVideo(",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:838-869"
    },
    "1155": {
        "file_id": 95,
        "content": "This code is responsible for checking the visibility of a bilibili video. It first checks if the user and video are registered in the database, and then fetches the video information to determine its state. If the state is 0, the video is considered visible; otherwise, it's invisible. In case of an error during the process, the debug parameter can be used to print the exception for further investigation. The code also includes a function to register user and video in the database, and another function for checking if a video has been registered before. The grace period for checking video visibility is set to one day, but it suggests that more experimentation might be needed to optimize this duration.",
        "type": "comment"
    },
    "1156": {
        "file_id": 95,
        "content": "    bvid: str,\n    grace_period=datetime.timedelta(days=1),\n    check_interval=datetime.timedelta(hours=1),\n):  # maybe the video is not immediately visible after registration.\n    # check if they are published or not.\n    # ____CI____CI____CI____ (before check video info. decide to check or not.)\n    # __________GP__________ (after check video info. decide to delete or not.)\n    published = False\n    bilibiliVideo = BilibiliVideo.get_or_none(bvid=bvid)\n    now = datetime.datetime.now()\n    needCheck = False\n    if bilibiliVideo:\n        visible = bilibiliVideo.visible\n        needCheck = now - bilibiliVideo.last_check >= check_interval\n        needRemove = now - bilibiliVideo.register_date >= grace_period\n        if (\n            visible and needRemove\n        ):  # do not remove. it just need to be check again, when using checkPublishedVideo. this value is used for double check.\n            published = True\n        else:\n            if needCheck:\n                visible = checkVideoVisibility(bvid)\n                if visible:",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:870-892"
    },
    "1157": {
        "file_id": 95,
        "content": "Checks if a video is published or not by comparing its registration date and last check time with the given grace period and check interval. If needed, it calls `checkVideoVisibility` function to verify visibility.",
        "type": "comment"
    },
    "1158": {
        "file_id": 95,
        "content": "                    published = True\n                elif needRemove:\n                    bilibiliVideo.delete_instance()\n    # you update that 'last_check' and compare it with 'checkin_date'\n    # you can schedule check every hour. not all the time.\n    # basically the same thing. but we do not delete these video till the time is too late, after check.\n    return published, not needCheck\n# seems bilibili can automatically categorize video.\n# we just need to find out how?\ndef checkPublishedVideo(bvid: str):  # this is only done during retrieval.\n    # if published, the video is taken down afterwards, we will delete it.\n    # check if video is still visible or taken down.\n    # if video is not visible then we delete this video from database.\n    # v = video.Video(bvid=bvid)\n    # print(info)\n    # dict_keys(['bvid', 'aid', 'videos', 'tid', 'tname', 'copyright', 'pic', 'title', 'pubdate', 'ctime', 'desc', 'desc_v2', 'state', 'duration', 'forward', 'rights', 'owner', 'stat', 'dynamic', 'dimension', 'pre",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:893-910"
    },
    "1159": {
        "file_id": 95,
        "content": "This code is for a database platform, specifically Bilibili. It checks if videos are still visible or taken down and deletes them if not. The code updates 'last_check' and compares it with 'checkin_date', scheduling check every hour. It also mentions that Bilibili automatically categorizes videos, and this function is used during retrieval to find out how it does so.",
        "type": "comment"
    },
    "1160": {
        "file_id": 95,
        "content": "miere', 'teenage_mode', 'is_chargeable_season', 'is_story', 'no_cache', 'subtitle', 'is_season_display', 'user_garb', 'honor_reply', 'like_icon'])\n    #  'state': -4,\n    # bad state! what is the meaning of this state?\n    # normal; state -> 0\n    avaliable = False\n    bilibiliVideo = BilibiliVideo.get_or_none(bvid=bvid)\n    if (\n        bilibiliVideo is not None\n    ):  # might be our 'registered' video but not yet been published.\n        published, needCheckAgain = checkRegisteredVideo(bvid)\n        if published:\n            if not needCheckAgain:\n                published = True\n            else:\n                visible = checkVideoVisibility(bvid)\n                avaliable = visible\n                if not visible:\n                    # remove that thing.\n                    bilibiliVideoIndex = BilibiliVideo.get_or_none(\n                        rowid=bilibiliVideo.id\n                    )\n                    bilibiliVideo.delete_instance()\n                    if bilibiliVideoIndex is not None:\n                        # remove that thing.",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:910-933"
    },
    "1161": {
        "file_id": 95,
        "content": "Checking if a Bilibili video with the given bvid exists and is available. If it exists, checks if it has been published or needs further checking. If unpublished or visibility issues, deletes the entry in the database.",
        "type": "comment"
    },
    "1162": {
        "file_id": 95,
        "content": "                        bilibiliVideoIndex.delete_instance()\n                else:\n                    bilibiliVideo.last_check = datetime.datetime.now()\n                    bilibiliVideo.visible = True\n                    bilibiliVideo.save()\n    else:\n        print(\"video %s is not registered.\" % bvid)\n    # info['stat'].keys()\n    # dict_keys(['aid', 'view', 'danmaku', 'reply', 'favorite', 'coin', 'share', 'now_rank', 'his_rank', 'like', 'dislike', 'evaluation', 'argue_msg'])\n    # breakpoint()\n    # if anything goes wrong, do not return the state.\n    # if you want update, better do it here. we are checking and updating the video.\n    # we use some random video for test.\n    return avaliable\n# i suggest you to use sqlalchemy. since this is no ordinary task.\n# you cannot just check every video of your own in the past.\n## following code is for test purpose.\n# shall write some server.\n# not fastapi!\ndef searchAndRegisterVideos(\n    query: str,\n    iterate: bool = False,\n    page_start: int = 1,\n    params={\"duration\": BSP.all.duration._10分钟以下},",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:934-963"
    },
    "1163": {
        "file_id": 95,
        "content": "This code deletes a bilibiliVideoInstance if it's not registered, otherwise updates the last_check and makes it visible. If something goes wrong, it doesn't return state, and suggests using SQLAlchemy for more complex tasks. The function allows searching and registering videos, with optional parameters like query, iterate, page_start, and params. It mentions testing the code with a random video and recommends writing a server (not FastAPI).",
        "type": "comment"
    },
    "1164": {
        "file_id": 95,
        "content": "    # 'order': BSP.all.order.综合排序\n    # # you can add this parameter later on.\n    page_size: int = ...,\n):\n    results = searchVideos(\n        query,\n        iterate=iterate,\n        page_start=page_start,\n        params=params,\n        page_size=page_size,\n    )\n    # db = getBilibiliVideoDatabaseAndCreateTables()\n    # this database connection will be established elsewhere.\n    for v in results:  # shall you called them 'tags' instead of 'tag'.\n        # print(v)\n        # breakpoint()\n        mid, author, upic = v[\"mid\"], v[\"author\"], v[\"upic\"]\n        bilibiliUser, _ = BilibiliUser.get_and_update_or_create(\n            username=author, user_id=mid, avatar=linkFixer(upic)\n        )\n        # v.update({'comment':v['review'],'created':v['pubdate']})\n        bilibiliVideo = indexAndGetVideoObject(v, bilibiliUser)\n        # bilibiliVideo, _ = BilibiliVideo.get_and_update_or_create(\n        #     bvid=v[\"bvid\"],\n        #     typeid=v[\"typeid\"],\n        #     visible=True,  # are you sure?\n        #     last_check=datetime.datetime.now(),  # well this is not tested. test it!",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:964-990"
    },
    "1165": {
        "file_id": 95,
        "content": "This code searches videos based on a query and iterate parameter, retrieves results, and establishes a database connection elsewhere. It then iterates through the results, gets or creates BilibiliUser objects, indexes and retrieves video objects for each result, and potentially updates or creates BilibiliVideo objects.",
        "type": "comment"
    },
    "1166": {
        "file_id": 95,
        "content": "        #     poster=bilibiliUser,  # is it my account anyway?\n        #     play=v[\"play\"],\n        #     pic=linkFixer(v[\"pic\"]),\n        #     length=videoDurationStringToSeconds(v[\"duration\"]),\n        #     review=v[\"review\"],\n        #     pubdate=v[\"pubdate\"],\n        #     favorites=v[\"favorites\"],\n        #     description=v[\"description\"],\n        #     title=v[\"title\"],\n        #     tag=v[\"tag\"],\n        # )\n        # bilibiliVideoIndex, _ = BilibiliVideoIndex.get_and_update_or_create(\n        #     rowid=bilibiliVideo.id,\n        #     description=textPreprocessing(bilibiliVideo.description),\n        #     tag=textPreprocessing(bilibiliVideo.tag),\n        #     title=textPreprocessing(bilibiliVideo.title),\n        # )\n        yield bilibiliVideo\n# @reloading\ndef getVideoInfosFromVideoGenerator(vgen):\n    vlist = []\n    for v in vgen:\n        if type(v) == BilibiliVideo:\n            vlist.append(v.videoInfoExtractor())\n    return vlist\ndef searchVideosByForm(form:searchUserVideoForm, default_page_size:int=30):",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:991-1019"
    },
    "1167": {
        "file_id": 95,
        "content": "This code is retrieving video information from a generator and creating a list of BilibiliVideo objects. It then returns this list after extracting video information from each object in the generator. The get_and_update_or_create function updates or creates a new BilibiliVideoIndex record based on the description, tag, and title fields. The searchVideosByForm function searches for videos using a provided form and a default page size of 30.",
        "type": "comment"
    },
    "1168": {
        "file_id": 95,
        "content": "    vgen = searchUserVideos(\n        form.query_for_search,\n        form.tid,\n        form.dedeuserid,\n        form.method,\n        form.use_credential,\n        form.videoOrder,\n        form.page_num,\n        default(form.page_size, default_page_size),\n    )\n    videoInfos = getVideoInfosFromVideoGenerator(vgen)\n    return videoInfos\ndef refresh_latest_video_of_user(uid: int):  # must be online.\n    form = searchUserVideoForm(method=\"online\", tid=0, query=\"\", dedeuserid=str(uid))\n    videoInfos = searchVideosByForm(form)\ndef refresh_status(\n    grace_period=datetime.timedelta(days=1),\n    check_interval=datetime.timedelta(hours=1),\n    sleep: int = 2,\n    target_user_uids: list[int] = [397424026],\n):\n    for uid in target_user_uids:\n        try:\n            refresh_latest_video_of_user(uid)\n            time.sleep(sleep)\n        except:\n            import traceback\n            traceback.print_exc()\n            print(f\"Failed to refresh latest video status of user {uid}\")\n    # what to do? just select and update?\n    # but you need the database object. it is loop dependency!",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:1020-1053"
    },
    "1169": {
        "file_id": 95,
        "content": "This code defines functions for searching videos and refreshing the latest video status of a user. The 'searchVideosByForm' function takes search parameters and returns a list of video information. 'refresh_latest_video_of_user' searches for the latest online video of a specified user. In 'refresh_status', the code loops through a list of target users, refreshes their latest video status, and handles exceptions with sleep and error printing. The code seems to be part of a larger system that requires database interaction to select and update records.",
        "type": "comment"
    },
    "1170": {
        "file_id": 95,
        "content": "    # well we can split the function.\n    # just for initialization?\n    now_minus_check_interval = datetime.datetime.now() - check_interval\n    selector = BilibiliVideo.select(BilibiliVideo.bvid).where(\n        (BilibiliVideo.last_check < now_minus_check_interval)\n        & (\n            BilibiliVideo.visible == False\n        )  # only check invisible videos. invisible videos will be removed after 1 day of inavaliability.\n    )  # need check or not?\n    print(\"refreshing video status\")\n    for bvid in progressbar.progressbar(selector):\n        checkRegisteredVideo(\n            bvid, grace_period=grace_period, check_interval=check_interval\n        )\n        time.sleep(sleep)\n    return\ndef refresh_status_decorator(func):\n    def wrapper(*args, **kwargs):\n        schedule.run_pending()\n        return func(*args, **kwargs)\n    return wrapper\n@refresh_status_decorator  # this might prevent you adding the decorator everywhere?\ndef getBilibiliVideoDatabaseCreateTablesAndRefreshStatus():\n    db = getBilibiliVideoDatabaseAndCreateTables()",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:1054-1082"
    },
    "1171": {
        "file_id": 95,
        "content": "This function initializes a database and checks for invisible Bilibili videos, updating their status after a day of invisibility. It uses progressbar to track progress and sleep for a brief period between iterations. The getBilibiliVideoDatabaseCreateTablesAndRefreshStatus function creates tables and calls the refresh_status decorator on another function.",
        "type": "comment"
    },
    "1172": {
        "file_id": 95,
        "content": "    return db\n# somewhere here:\n# https://fastapi.tiangolo.com/es/tutorial/debugging/\n@lru_cache(maxsize=1)\ndef bootstrap():\n    db = getBilibiliVideoDatabaseAndCreateTables()\n    refresh_status()  # ensure the database is connected.\n    schedule.every(20).minutes.do(refresh_status)\ndef bilibiliRecommendationServer(\n    welcome_message=\"bilibili recommendation server\", port=7341\n):\n    bootstrap()\n    from fastapi import FastAPI\n    import uvicorn\n    import pydantic\n    app = FastAPI()\n    @app.get(\"/\")\n    # #@reloading\n    def server_hello():\n        schedule.run_pending()\n        return welcome_message\n    # just asking. post or get?\n    @app.post(\"/searchVideos\")  # what do you want to have? all fields?\n    # #@reloading\n    def search_videos(form: searchVideoForm):\n        # print('received params:',params) # it is str.\n        # breakpoint()\n        schedule.run_pending()\n        params = {\n            \"duration\": BSP.all.duration._10分钟以下\n        } | form.params  # this is default parameter.\n        # breakpoint()",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:1083-1123"
    },
    "1173": {
        "file_id": 95,
        "content": "The code initializes the Bilibili video database, sets up a scheduler to refresh the status periodically, and creates a FastAPI application for serving a recommendation server with a welcome message route (\"/\") and a search route (\"/searchVideos\"). The search route accepts a POST request with parameters.",
        "type": "comment"
    },
    "1174": {
        "file_id": 95,
        "content": "        vgen = searchAndRegisterVideos(\n            form.query_for_search,\n            iterate=form.iterate,\n            page_start=form.page_num,\n            params=params,\n            page_size=default(form.page_size, ...),\n        )\n        videoInfos = getVideoInfosFromVideoGenerator(vgen)\n        return videoInfos\n    @app.post(\"/searchRegisteredVideos\")\n    # #@reloading\n    def search_registered_videos(form: searchRegisteredVideoForm):\n        schedule.run_pending()\n        vgen = searchRegisteredVideos(\n            form.query_for_search,\n            form.tid,\n            form.dedeuserid,\n            form.videoOrder,\n            form.page_num,\n            default(form.page_size, 30),\n        )\n        videoInfos = getVideoInfosFromVideoGenerator(vgen)\n        return videoInfos\n    @app.post(\"/searchUserVideos\")\n    # #@reloading\n    def search_user_videos(form: searchUserVideoForm):\n        schedule.run_pending()\n        videoInfos = searchVideosByForm(form)\n        return videoInfos\n    @app.post(\"/registerUserVideo\")",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:1124-1157"
    },
    "1175": {
        "file_id": 95,
        "content": "This code appears to contain various endpoints for searching and registering videos on a platform. It utilizes form data to query for specific search results, and then retrieves the video information from the generated video generators. It also schedules tasks and handles different types of video forms.",
        "type": "comment"
    },
    "1176": {
        "file_id": 95,
        "content": "    # #@reloading\n    def register_user_video(form: registerUserVideoForm):\n        schedule.run_pending()\n        new = registerUserVideo(form.bvid, form.dedeuserid, form.is_mine, form.visible)\n        if new:\n            print(\"----\")\n            print(\"registered user video:\", form.bvid)\n            print(\"user:\", form.dedeuserid)\n            print(\"is_mine:\", form.is_mine)\n            print(\"visible:\", form.visible)\n            print(\"----\")\n        else:\n            print(\"video already registered.\")\n        return {\"is_new\": new}\n    uvicorn.run(app, host=\"0.0.0.0\", port=port)\nif __name__ == \"__main__\":\n    bilibiliRecommendationServer()",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:1158-1178"
    },
    "1177": {
        "file_id": 95,
        "content": "This code registers a user video on Bilibili platform. It utilizes the registerUserVideoForm to store necessary information, schedules pending tasks for execution, and prints details if the registration is successful or not. The code also runs the Uvicorn server for the application, specifying the host and port. If this file is executed directly, it calls bilibiliRecommendationServer() function.",
        "type": "comment"
    },
    "1178": {
        "file_id": 96,
        "content": "/pyjom/platforms/bilibili/postMetadata.py",
        "type": "filepath"
    },
    "1179": {
        "file_id": 96,
        "content": "The code filters videos, generates Bilibili post metadata, supports language selection and error handling, extracts video metadata, fetches related videos, applies limits, and generates covers and descriptions for dog or cat topics.",
        "type": "summary"
    },
    "1180": {
        "file_id": 96,
        "content": "from pyjom.commons import *\nimport cv2\nfrom pyjom.modules.topicGenerator.onlineTopicGenerator import getMetaTopicString\nfrom bilibili_api import sync, search\nfrom lazero.utils.tools import flattenUnhashableList  # one of my classic methods\nfrom lazero.utils.logger import sprint\n# TODO: you know the drill. if it really contains nonacceptable characters (currently, must be some rule changes), you use Notofu font for rendering and OCR for recognition.\n# well you might want tesseract.\n# i suspect this change is due to language models used in bilibili's system\nfrom pyjom.languagetoolbox import filterNonChineseOrEnglishOrJapaneseCharacters\ndef filterTitleWithCoreTopicSet(title, core_topic_set, debug=False):\n    value = False\n    for core_topic in core_topic_set:\n        if core_topic in title:\n            value = True\n            break\n    if debug:\n        print(\"TITLE:\", title)\n        print(\"CORE TOPIC SET:\", core_topic_set)\n        print(\"VALUE:\", value)\n        breakpoint()\n    return value\ndef filterTitleListWithCoreTopicSet(titleList, core_topic_set, debug=False):",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/postMetadata.py:1-27"
    },
    "1181": {
        "file_id": 96,
        "content": "This code filters titles for a video platform, checking if they contain specific core topics. It utilizes existing modules and tools for this purpose. The function filterTitleListWithCoreTopicSet takes in a list of titles and a set of core topics, returning true if any title contains a core topic. The function filterTitleWithCoreTopicSet checks individual titles for a single core topic. Both functions have optional debug parameter to print information about the process.",
        "type": "comment"
    },
    "1182": {
        "file_id": 96,
        "content": "    newTitleList = []\n    for title in titleList:\n        result = filterTitleWithCoreTopicSet(title, core_topic_set)\n        if result:\n            newTitleList.append(title)\n    if debug:\n        print(\"TITLE LIST:\", titleList)\n        print(\"CORE TOPIC SET:\", core_topic_set)\n        sprint(\"NEW TITLE LIST:\", newTitleList)\n    return newTitleList\ndef randomChoiceTagList(\n    tag_list, selected_tag_groups=3, selected_tag_per_group=2, pop=True\n):\n    import random\n    if not pop:\n        selected_tags = random.sample(tag_list, selected_tag_groups)\n    else:\n        selected_tags = [\n            shuffleAndPopFromList(tag_list) for _ in range(selected_tag_groups)\n        ]\n    selected_tags = [\n        random.sample(tags, min(len(tags), selected_tag_per_group))\n        for tags in selected_tags\n    ]\n    # flatten this thing.\n    selected_tags = flattenUnhashableList(selected_tags)\n    return list(set(selected_tags))\nfrom typing import Literal\nfrom pyjom.imagetoolbox import resizeImageWithPadding\ndef getCoverTargetFromCoverListDefault(",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/postMetadata.py:28-64"
    },
    "1183": {
        "file_id": 96,
        "content": "This function takes a list of titles, applies a filter based on a core topic set, and creates a new title list. It also generates random tag groups and flattens them to create a final list of unique tags. The function is part of a larger codebase for processing data related to the Bilibili platform.",
        "type": "comment"
    },
    "1184": {
        "file_id": 96,
        "content": "    cover_list,\n    dog_or_cat_original,\n    input_width: int = 1200,\n    output_width: int = 1920,\n    filter_function=lambda image: image,\n    histogramMatch=True,\n    delta=0.2,\n    flip: Literal[True, False, \"random\"] = True,\n):  # default function does not process this tag.\n    import random\n    if flip == \"random\":\n        flip = random.choice([True, False])\n    # random.shuffle(cover_list)\n    # reference_histogram_cover = random.choice(cover_list)\n    reference_histogram_cover = shuffleAndPopFromList(cover_list)\n    cover_target = None\n    # for cover in cover_list:\n    while len(cover_list) > 0:\n        cover = shuffleAndPopFromList(cover_list)\n        import os\n        os.environ[\"http\"] = \"\"\n        os.environ[\"https\"] = \"\"\n        from pyjom.imagetoolbox import (\n            imageLoader,\n            # imageDogCatCoverCropAdvanced,\n            imageHistogramMatch,\n        )\n        image = imageLoader(cover)\n        # downscale this image first.\n        image = resizeImageWithPadding(\n            image, input_width, None, border_type=\"replicate\"",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/postMetadata.py:65-100"
    },
    "1185": {
        "file_id": 96,
        "content": "The code takes a list of image covers, randomly selects one as the reference histogram cover, and iterates over the remaining covers. It prepares for image processing by setting environment variables, loading images, downscaling if necessary, and possibly flipping the image based on a random choice.",
        "type": "comment"
    },
    "1186": {
        "file_id": 96,
        "content": "        )  # are you sure? it is just a cover image.\n        cropped_image = filter_function(\n            image\n        )  # we should do something to the filter function!\n        if cropped_image is not None:\n            if histogramMatch:\n                cropped_image = imageHistogramMatch(\n                    cropped_image, reference_histogram_cover, delta=delta\n                )\n            if flip:\n                cropped_image = cv2.flip(cropped_image, 1)\n            cover_target = cropped_image\n            break\n    if cover_target is not None:\n        cover_target = resizeImageWithPadding(\n            cover_target, output_width, None, border_type=\"replicate\"\n        )  # this is strange.\n    return cover_target\ndef getCoverTargetFromCoverListForDogCat(cover_list, dog_or_cat_original):\n    from pyjom.imagetoolbox import (\n        # imageLoader,\n        imageDogCatCoverCropAdvanced,\n        # imageHistogramMatch,\n    )\n    return getCoverTargetFromCoverListDefault(\n        cover_list,\n        dog_or_cat_original,",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/postMetadata.py:101-130"
    },
    "1187": {
        "file_id": 96,
        "content": "The code applies advanced image cropping and processing for a dog or cat cover image. It checks the cover list, performs histogram matching if necessary, and flips the image if required. Finally, it resizes the image with padding using replicate border type. The function \"imageLoader\" and \"imageHistogramMatch\" are imported but not used in this specific code.",
        "type": "comment"
    },
    "1188": {
        "file_id": 96,
        "content": "        filter_function=lambda image: imageDogCatCoverCropAdvanced(\n            image,\n            yolov5_confidence_threshold=0.27,  # you made it smaller.\n            dog_or_cat=dog_or_cat_original,  # already configured. no need to do shit.\n            area_threshold=0.30,  # 0.7 # could be smaller.\n            corner=False,\n        ),\n    )\nBSP = search.bilibiliSearchParams()\nimport random\nfrom typing import Callable\ndef getBilibiliPostMetadata(\n    sleepTime=2,\n    customParaphraser:Union[Callable,None]=None,\n    getMetatopic={},\n    bgmCacheSetName: Union[str, None] = \"bilibili_cached_bgm_set\",\n    getTids={},  # these two are not specified here.\n    genericTids:list[int]=[],\n    orders=[\n        BSP.all.order.最多点击,\n        BSP.all.order.最多收藏,\n        BSP.all.order.最新发布,\n        BSP.all.order.最多弹幕,\n        BSP.all.order.综合排序,\n    ],\n    pageIndexRange=(1, 5),\n    duration=BSP.all.duration._10分钟以下,\n    lang=\"zh\",\n    duration_limit={\"min\": 70, \"max\": 5 * 60},\n    play_limit={\"min\": 10000},\n    titleLengthLimit={\"min\": 7, \"max\": 17},",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/postMetadata.py:131-165"
    },
    "1189": {
        "file_id": 96,
        "content": "This function generates Bilibili post metadata by specifying parameters like search type, video duration, order of sorting, and title length limits. It also allows for custom paraphrasing, language selection, and optional background music caching.",
        "type": "comment"
    },
    "1190": {
        "file_id": 96,
        "content": "    getCoverTargetFromCoverList=getCoverTargetFromCoverListDefault,  # what is the default process?\n    bgmCacheAutoPurge=False,\n):\n    if bgmCacheSetName and bgmCacheAutoPurge:\n        removeRedisValueByKey(bgmCacheSetName)\n    selected_topic_list_dict = {key: [] for key in getMetatopic.keys()}\n    randomTarget = lambda: random.choice(list(selected_topic_list_dict.keys()))\n    dog_or_cat = randomTarget()\n    description_list = []\n    bgm_list = []\n    title_list = []\n    tag_list = []\n    cover_list = []\n    bvid_list = []\n    def clearMyLists():\n        nonlocal bvid_list, bgm_list, title_list, tag_list, cover_list, bvid_list, description_list\n        description_list = []\n        bgm_list = []\n        title_list = []\n        tag_list = []\n        cover_list = []\n        bvid_list = []\n    getKeywords = {\n        key: lambda: getMetaTopicString(value) for key, value in getMetatopic.items()\n    }\n    # getDogTid = lambda: random.choice([BSP.all.tids.动物圈.tid, BSP.all.tids.动物圈.汪星人])\n    # getCatTid = lambda: random.choice([BSP.all.tids.动物圈.tid, BSP.all.tids.动物圈.喵星人])",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/postMetadata.py:166-196"
    },
    "1191": {
        "file_id": 96,
        "content": "This code retrieves metadata from a bilibili platform, filters and selects topics, randomly chooses between dog or cat content, and initializes lists for BGM, title, tag, cover, and video ID. It also defines functions to clear lists and retrieve keywords. The code does not contain a default process for `getCoverTargetFromCoverList`.",
        "type": "comment"
    },
    "1192": {
        "file_id": 96,
        "content": "    # getTid = {\"dog\": getDogTid, \"cat\": getCatTid}\n    getTid = {key: lambda: random.choice(value) for key, value in getTids.items()}\n    getTargetTid = {key: lambda: random.choice([v for v in value if v not in genericTids]) for key, value in getTids.items()}\n    getRandomPage = lambda: random.randint(*pageIndexRange)  # not so broad.\n    # getRandomPage = lambda: random.randint(1, 50)  # broad range!\n    randomOrder = lambda: random.choice(orders)\n    while True:\n        try:\n            core_topic_set = {\n                *flattenUnhashableList(\n                    [value for key, value in getMetatopic[dog_or_cat].items()]\n                )\n            }\n            static_core_topic_list = flattenUnhashableList(\n                getMetatopic[dog_or_cat][\"static\"]\n            )\n            metatopicString = getKeywords[dog_or_cat]()\n            print(\"METATOPIC STRING:\", metatopicString)\n            # we use video only search.\n            search_tid = getTid[dog_or_cat]()\n            target_tid = getTargetTid[dog_or_cat]()",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/postMetadata.py:197-223"
    },
    "1193": {
        "file_id": 96,
        "content": "This code dynamically generates a set of core topics, static core topic list, and metatopic string for the bilibili platform. It uses lambda functions to generate random values for TIDs, page index, and order. The code ensures that the selected TID is not present in genericTids. Finally, it prints the metatopic string and assigns a search TID and target TID for further processing.",
        "type": "comment"
    },
    "1194": {
        "file_id": 96,
        "content": "            result = sync(\n                search.search_by_type(\n                    keyword=metatopicString,\n                    params={\n                        \"tids\": search_tid,\n                        \"duration\": duration,\n                        \"order\": randomOrder(),\n                    },\n                    page=getRandomPage(),\n                    search_type=search.SearchObjectType.VIDEO,\n                )\n            )\n            # print(result)\n            # breakpoint()\n            from pyjom.platforms.bilibili.searchDataParser import parseSearchVideoResult\n            from pyjom.mathlib import checkMinMaxDict\n            def updateMyLists(\n                videoMetadata,\n                duration_limit={\"min\": 70, \"max\": 5 * 60},\n                titleLengthLimit={\"min\": 7, \"max\": 17},\n                play_limit={\"min\": 10000},\n                debugTag=\"debug\",\n            ):\n                nonlocal bvid_list, bgm_list, title_list, tag_list, cover_list, bvid_list, description_list, static_core_topic_list  # use nonlocal instead in nested functions.",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/postMetadata.py:225-252"
    },
    "1195": {
        "file_id": 96,
        "content": "The code searches for video results on Bilibili based on specified criteria and uses the search result to update local lists of videos, titles, tags, covers, descriptions, and static core topics. It checks duration limits, title length limits, play counts, and debugs if needed.",
        "type": "comment"
    },
    "1196": {
        "file_id": 96,
        "content": "                (\n                    author,\n                    author_id,\n                    bvid,\n                    tags,\n                    categoryId,\n                    categoryName,\n                    title,\n                    duration_seconds,\n                    play,\n                    cover,\n                    description,\n                    links_in_description,\n                    bgms,\n                    title_tags,\n                    pubdate,\n                ) = videoMetadata\n                # print(\"VIDEO_METADATA\",videoMetadata)\n                # breakpoint()\n                if not checkMinMaxDict(len(title), titleLengthLimit):\n                    return\n                if not filterTitleWithCoreTopicSet(title, static_core_topic_list):\n                    return\n                if len(tags) > 0:\n                    tagContainStaticCoreTopicFlags = [\n                        int(filterTitleWithCoreTopicSet(tag, static_core_topic_list))\n                        for tag in tags\n                    ]",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/postMetadata.py:253-280"
    },
    "1197": {
        "file_id": 96,
        "content": "This code extracts video metadata such as author, duration, title, and tags. It checks the length of the title against a limit and filters it for any static core topic. If the tag contains a static core topic, it creates a boolean flag for each tag. The function then returns the extracted metadata and flag list.",
        "type": "comment"
    },
    "1198": {
        "file_id": 96,
        "content": "                    mTagFlag = sum(tagContainStaticCoreTopicFlags) > 0\n                    if not mTagFlag:\n                        return\n                else:\n                    return\n                if duration_seconds == None:\n                    print(debugTag, \"VIDEO_METADATA\", videoMetadata)\n                    breakpoint()\n                elif play == None:\n                    print(debugTag, \"VIDEO_METADATA\", videoMetadata)\n                    breakpoint()\n                if len(bgms) > 0:\n                    bgm_list += bgms\n                try:\n                    if checkMinMaxDict(duration_seconds, duration_limit):\n                        if checkMinMaxDict(play, play_limit):\n                            bvid_list += [bvid]\n                            cover_list += [cover]\n                            title_list += [title]  # this for topic modeling?\n                            if description not in [\"\", None]:\n                                description_list += [description]\n                            if len(tags) > 0:",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/postMetadata.py:281-302"
    },
    "1199": {
        "file_id": 96,
        "content": "This code checks if a video's metadata contains certain elements and whether they meet specific duration and play limits. If the video meets these criteria, it adds it to a list of bvids for further processing. It also handles potential errors by printing a debug message and breaking the execution. The title is added to a list for topic modeling purposes.",
        "type": "comment"
    }
}