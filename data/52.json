{
    "5200": {
        "file_id": 678,
        "content": "/tests/skipexception_code_and_continue_resurrection_time_travel_debugging/test_code/pyjom_recover_and_rewrite.py",
        "type": "filepath"
    },
    "5201": {
        "file_id": 678,
        "content": "This code utilizes modules to change files at specified paths, walks through directories to collect .py files, applies changes using a progress bar, and stops after processing every 100 files.",
        "type": "summary"
    },
    "5202": {
        "file_id": 678,
        "content": "import sys\nsys.path.append(\"/root/Desktop/works/pyjom/tests/skipexception_code_and_continue_resurrection_time_travel_debugging/codemod_redbaron\")\nfrom pasta_test import recover_and_rewrite as rar1\nfrom recover_and_rewrite import recover_and_rewrite as rar2\nif __name__ == \"__main__\":\n    import os\n    # from comby import Comby\n    # comby = Comby()\n    dirpath = \"/root/Desktop/works/pyjom/pyjom\"\n    def change_file_at_path(path,no_rewrite=False):\n        with open(path, \"r\") as f:\n            source_old = f.read()\n            if len(source_old) < 20 or \"\\ndef \" not in source_old:\n                return\n            try:\n                source_new = rar1(source_old,no_rewrite=no_rewrite)\n            except:\n                import traceback\n                traceback.print_exc()\n                print('pasta failed to process the code at path: %s' % path)\n                source_new = rar2(source_old,no_rewrite=no_rewrite)\n        with open(path, \"w+\") as f:\n            f.write(source_new)\n    pyfiles = []\n    import progressbar",
        "type": "code",
        "location": "/tests/skipexception_code_and_continue_resurrection_time_travel_debugging/test_code/pyjom_recover_and_rewrite.py:1-30"
    },
    "5203": {
        "file_id": 678,
        "content": "Imports necessary modules and defines a function to change files at specified paths by reading the file, passing the content to two recovery functions (rar1 and rar2), and rewriting the file with the new content.",
        "type": "comment"
    },
    "5204": {
        "file_id": 678,
        "content": "    for basedir, dirs, files in os.walk(dirpath):\n        for fname in files:\n            fpath = os.path.join(basedir, fname)\n            if fname.endswith(\".py\"):\n                pyfiles.append(fpath)\n                # print(fpath)\n    mod = 100\n    for pyfile in progressbar.progressbar(pyfiles):\n        # if index % mod == 0:\n        print(\"processing file at path: %s\" % pyfile)\n        change_file_at_path(pyfile,no_rewrite=True)",
        "type": "code",
        "location": "/tests/skipexception_code_and_continue_resurrection_time_travel_debugging/test_code/pyjom_recover_and_rewrite.py:32-42"
    },
    "5205": {
        "file_id": 678,
        "content": "This code walks through a directory, collects .py files, and applies a change to each file using a progress bar. It stops processing after every 100 files.",
        "type": "comment"
    },
    "5206": {
        "file_id": 679,
        "content": "/tests/skipexception_code_and_continue_resurrection_time_travel_debugging/test_code/new_test2.py",
        "type": "filepath"
    },
    "5207": {
        "file_id": 679,
        "content": "The code is a Python function with decorators and an asynchronous function, using the 'reloading' module for reloadable functions. The main function takes multiple arguments and returns its value, while the asynchronous function remains undefined.",
        "type": "summary"
    },
    "5208": {
        "file_id": 679,
        "content": "from reloading import reloading\n# decorate here!\n# @dec # won't fix here.\n# @someRandomDecorator\n@reloading # it won't help with everything.\ndef someFunction (a,b,c,d=1,f=2\n):\n    # not touching this function!\n    # @decorator\n    # def inner_function (h,i,j,\n    # k):\n    abcdefg=1234\n    #     return hjkl\n    return abcdefg # I need you to decorate this thing.\nasync def shitfunction():\n    return shit\nif __name__ == \"__main__\":\n    someFunction(1,2,3)",
        "type": "code",
        "location": "/tests/skipexception_code_and_continue_resurrection_time_travel_debugging/test_code/new_test2.py:1-21"
    },
    "5209": {
        "file_id": 679,
        "content": "The code is a Python function with decorators and an asynchronous function, using the 'reloading' module for reloadable functions. The main function takes multiple arguments and returns its value, while the asynchronous function remains undefined.",
        "type": "comment"
    },
    "5210": {
        "file_id": 680,
        "content": "/tests/skipexception_code_and_continue_resurrection_time_travel_debugging/test_code/new_test.py",
        "type": "filepath"
    },
    "5211": {
        "file_id": 680,
        "content": "Code snippet with a function `someFunction` decorated by `@reloading`, indicating the code is using the 'reloading' module to automatically reload any changes made during runtime. The code also has an undefined variable \"shit\" in the async function, which could cause an error when executed. The main part of the script executes `someFunction(1,2,3)` when run directly.",
        "type": "summary"
    },
    "5212": {
        "file_id": 680,
        "content": "from reloading import reloading\n# decorate here!\n# @dec # won't fix here.\n# @someRandomDecorator\n@reloading # it won't help with everything. be cautious.\ndef someFunction (a,b,c,d=1,f=2\n):\n    # not touching this function!\n    # @decorator\n    # def inner_function (h,i,j,\n    # k):\n    abcdefg=1234\n    #     return hjkl\n    return abcdefg # I need you to decorate this thing.\nasync def shitfunction():\n    return shit\nif __name__ == \"__main__\":\n    someFunction(1,2,3)",
        "type": "code",
        "location": "/tests/skipexception_code_and_continue_resurrection_time_travel_debugging/test_code/new_test.py:1-21"
    },
    "5213": {
        "file_id": 680,
        "content": "Code snippet with a function `someFunction` decorated by `@reloading`, indicating the code is using the 'reloading' module to automatically reload any changes made during runtime. The code also has an undefined variable \"shit\" in the async function, which could cause an error when executed. The main part of the script executes `someFunction(1,2,3)` when run directly.",
        "type": "comment"
    },
    "5214": {
        "file_id": 681,
        "content": "/tests/skipexception_code_and_continue_resurrection_time_travel_debugging/test_code/bowler_test.py",
        "type": "filepath"
    },
    "5215": {
        "file_id": 681,
        "content": "The code is importing the bowler library and defining a pattern for identifying function definitions in a source file. It then creates a Query object with the source file, selects elements matching the pattern, and prints the selected elements along with their attributes.",
        "type": "summary"
    },
    "5216": {
        "file_id": 681,
        "content": "import bowler\nsrc ='test2.py'\npattern=\"\"\"(\n    decorated=decorated<\n        decorators=decorators\n        function_def=funcdef<\n            'def' function_name=any\n            function_parameters=parameters< '(' function_arguments=any* ')' >\n            any*\n        >\n    >\n|\n    function_def=funcdef<\n        'def' function_name=any\n        function_parameters=parameters< '(' function_arguments=any* ')' >\n        any*\n    >\n)\"\"\"\nq = bowler.Query(src)\nf = q.select(pattern).is_def()\nprint(f, dir(f))\n# for x in f:\n#     print(x)",
        "type": "code",
        "location": "/tests/skipexception_code_and_continue_resurrection_time_travel_debugging/test_code/bowler_test.py:1-26"
    },
    "5217": {
        "file_id": 681,
        "content": "The code is importing the bowler library and defining a pattern for identifying function definitions in a source file. It then creates a Query object with the source file, selects elements matching the pattern, and prints the selected elements along with their attributes.",
        "type": "comment"
    },
    "5218": {
        "file_id": 682,
        "content": "/tests/skipexception_code_and_continue_resurrection_time_travel_debugging/test_code/test2.py",
        "type": "filepath"
    },
    "5219": {
        "file_id": 682,
        "content": "The code contains a function \"a()\" which returns value \"b\". It also has a function \"g()\" that returns value \"c\". However, the actual logic and purpose of these functions are unclear. There is an attempt to use decorators on some functions, but they seem to be improperly applied due to missing decorator names. Additionally, there is a confusing comment and import statement which may not serve any functional purpose.",
        "type": "summary"
    },
    "5220": {
        "file_id": 682,
        "content": "# # decorate here!\n# @dec\n# @someRandomDecorator\n# def someFunction (a,b,c,d=1,f=2\n# ):\n#     # not touching this function!\n#     @decorator\n#     def inner_function (h,i,j,\n#     k):\n#         return hjkl\n#     return abcdefg # I need you to decorate this thing.\nimport shit # just a shitty import. it won't decorate.\n@k\n# i am a fucking comment.\ndef a():\n    return b\ndef g():\n    return c",
        "type": "code",
        "location": "/tests/skipexception_code_and_continue_resurrection_time_travel_debugging/test_code/test2.py:2-23"
    },
    "5221": {
        "file_id": 682,
        "content": "The code contains a function \"a()\" which returns value \"b\". It also has a function \"g()\" that returns value \"c\". However, the actual logic and purpose of these functions are unclear. There is an attempt to use decorators on some functions, but they seem to be improperly applied due to missing decorator names. Additionally, there is a confusing comment and import statement which may not serve any functional purpose.",
        "type": "comment"
    },
    "5222": {
        "file_id": 683,
        "content": "/tests/skipexception_code_and_continue_resurrection_time_travel_debugging/test_code/test.sh",
        "type": "filepath"
    },
    "5223": {
        "file_id": 683,
        "content": "This code is replacing the existing code with a modified version that uses the \"reloading\" module for dynamic code reloading. It first selects a new code block and replaces the existing one, then applies additional modifications to ensure proper function decorators are applied using regular expressions. Finally, it applies these changes to a specific Python file.",
        "type": "summary"
    },
    "5224": {
        "file_id": 683,
        "content": "# are you sensitive to return?\n# you can first replace the code with the selected \n# cat new_test.py | comby ':[prefix~@reloading.*$]def :[functionName](:[args]):'  'def :[functionName](:[args]):' -stdin -stdout -matcher .py |  comby \"from reloading import reloading\"  '' -stdin -stdout -matcher .py \n# cat test.py | comby ':[prefix~(@.+)*$]def :[functionName](:[args]):'  ':[prefix] @reloading def :[functionName](:[args]):' -rule 'where match :[prefix] { | :[_@someRandomDecorator.*] -> true | :[_] -> false } ' -stdin -stdout -matcher .py -match-only\ncat /root/Desktop/works/pyjom/pyjom/platforms/bilibili/utils.py | comby ':[prefix~(@.+)*$]def :[functionName](:[args]):'  ':[prefix] @reloading def :[functionName](:[args]):' -stdin -stdout -matcher .py -match-only",
        "type": "code",
        "location": "/tests/skipexception_code_and_continue_resurrection_time_travel_debugging/test_code/test.sh:1-9"
    },
    "5225": {
        "file_id": 683,
        "content": "This code is replacing the existing code with a modified version that uses the \"reloading\" module for dynamic code reloading. It first selects a new code block and replaces the existing one, then applies additional modifications to ensure proper function decorators are applied using regular expressions. Finally, it applies these changes to a specific Python file.",
        "type": "comment"
    },
    "5226": {
        "file_id": 684,
        "content": "/tests/skipexception_code_and_continue_resurrection_time_travel_debugging/test_code/test.py",
        "type": "filepath"
    },
    "5227": {
        "file_id": 684,
        "content": "The code defines a function, someFunction, with optional parameters 'a', 'b', 'c', and default values for 'd' and 'f'. It also includes an inner_function nested within it, which takes parameters 'h', 'i', 'j', and 'k', and returns the concatenation of these parameters. The code is decorated with multiple decorators and requires further decoration to be applied.",
        "type": "summary"
    },
    "5228": {
        "file_id": 684,
        "content": "# decorate here!\n@dec\n@someRandomDecorator\ndef someFunction (a,b,c,d=1,f=2\n):\n    # not touching this function!\n    @decorator\n    def inner_function (h,i,j,\n    k):\n        return hjkl\n    return abcdefg # I need you to decorate this thing.",
        "type": "code",
        "location": "/tests/skipexception_code_and_continue_resurrection_time_travel_debugging/test_code/test.py:2-12"
    },
    "5229": {
        "file_id": 684,
        "content": "The code defines a function, someFunction, with optional parameters 'a', 'b', 'c', and default values for 'd' and 'f'. It also includes an inner_function nested within it, which takes parameters 'h', 'i', 'j', and 'k', and returns the concatenation of these parameters. The code is decorated with multiple decorators and requires further decoration to be applied.",
        "type": "comment"
    },
    "5230": {
        "file_id": 685,
        "content": "/tests/skipexception_code_and_continue_resurrection_time_travel_debugging/test_code/rewrite.py",
        "type": "filepath"
    },
    "5231": {
        "file_id": 685,
        "content": "This code rewrites a Python source file by adding the `@reloading` decorator to functions using the Comby library. It reads the old source, replaces the function definitions with the decorated versions, and optionally adds an import statement for reloading if changes are made.",
        "type": "summary"
    },
    "5232": {
        "file_id": 685,
        "content": "from comby import Comby\ncomby = Comby()\n# better not to use this!\ndef rewrite(source_old):\n    # match = ':[prefix~$]def :[functionName](:[args]):'\n    match = ':[prefix~$]def :[functionName](:[args]):'\n    # match = ':[prefix~\\n$]def :[functionName](:[args]):'\n    rewrite = ':[prefix]\\n@reloading\\ndef :[functionName](:[args]):'\n    source_new = comby.rewrite(source_old, match, rewrite,language='.py')\n    if source_new !=source_old:\n        source_new = 'from reloading import reloading\\n'+source_new\n    return source_new\nif __name__ == \"__main__\":\n    source_old = open('test2.py','r').read()\n    # source_old = open('/root/Desktop/works/pyjom/pyjom/platforms/bilibili/uploader.py','r').read()\n    # source_old = open('/root/Desktop/works/pyjom/pyjom/platforms/bilibili/uploader.py','r').read()\n    # comby = Comby()\n    source_new = rewrite(source_old)\n    print(source_new)",
        "type": "code",
        "location": "/tests/skipexception_code_and_continue_resurrection_time_travel_debugging/test_code/rewrite.py:1-25"
    },
    "5233": {
        "file_id": 685,
        "content": "This code rewrites a Python source file by adding the `@reloading` decorator to functions using the Comby library. It reads the old source, replaces the function definitions with the decorated versions, and optionally adds an import statement for reloading if changes are made.",
        "type": "comment"
    },
    "5234": {
        "file_id": 686,
        "content": "/tests/skipexception_code_and_continue_resurrection_time_travel_debugging/codemod_redbaron/test2.py",
        "type": "filepath"
    },
    "5235": {
        "file_id": 686,
        "content": "This code contains various profanity and seems to have been written in a rushed or unprofessional manner. It defines two functions, `a()` and `b()`, with the latter containing an async function `shit()`. There's also a nested function `c()`. The code might be related to testing or debugging as it mentions \"redbaron\" and \"pasta\", possibly referring to frameworks or processes. However, it appears unsupported in this context.",
        "type": "summary"
    },
    "5236": {
        "file_id": 686,
        "content": "#fuck\n@shit #and fuck\n#shit\n@reloading\n@fuck(shit)\n#oh shit\ndef a():\n    #fuck\n#fuck\n    return shit # oh fuck\n#hell no\ndef b():\n    def c():\n        fuck\nasync def shit():\n    ...\n# not supported anywhere. not redbaron, not pasta.\n# with (re() as a, re2() as b):\n#     print(fuck)",
        "type": "code",
        "location": "/tests/skipexception_code_and_continue_resurrection_time_travel_debugging/codemod_redbaron/test2.py:2-23"
    },
    "5237": {
        "file_id": 686,
        "content": "This code contains various profanity and seems to have been written in a rushed or unprofessional manner. It defines two functions, `a()` and `b()`, with the latter containing an async function `shit()`. There's also a nested function `c()`. The code might be related to testing or debugging as it mentions \"redbaron\" and \"pasta\", possibly referring to frameworks or processes. However, it appears unsupported in this context.",
        "type": "comment"
    },
    "5238": {
        "file_id": 687,
        "content": "/tests/skipexception_code_and_continue_resurrection_time_travel_debugging/codemod_redbaron/redbaron_test.py",
        "type": "filepath"
    },
    "5239": {
        "file_id": 687,
        "content": "The code reads a file, creates a RedBaron instance, and iterates over each node in the instance. It checks if a node is a function definition (DefNode) and if it's asynchronous. If it's a DefNode and not async, it appends a decorator to it. Finally, it prints various information about each node and dumps the RedBaron instance.",
        "type": "summary"
    },
    "5240": {
        "file_id": 687,
        "content": "t=open(\"/root/Desktop/works/pyjom/pyjom/platforms/bilibili/postMetadata.py\",\"r\").read()\nimport redbaron\nfrom create_decnode import getd\nr=redbaron.RedBaron(t)\nfor n in r:\n    print(\"name\",n.name)\n    n.help()\n    flag=type(n)==redbaron.DefNode\n    print(\"is defnode?\",flag)\n    if flag:\n        print(\"is async?\",n.async_)\n        #print(\"is async?\",n.__dict__[\"async\"])\n        print(\"decorators\")\n        print(type(n.decorators))\n        #n.decorators.append(getd())\n        # use official method instead.\n        n.decorators.append(\"@offdec\")\n        for d in n.decorators:\n            dt=type(d)\n            isdt = dt == redbaron.DecoratorNode\n            print(\"is decorator?\",isdt)\n    print(\"node\")\n    print(n)\n    print(dir(n))\nprint(\"----\")\nprint(r.dumps())",
        "type": "code",
        "location": "/tests/skipexception_code_and_continue_resurrection_time_travel_debugging/codemod_redbaron/redbaron_test.py:1-30"
    },
    "5241": {
        "file_id": 687,
        "content": "The code reads a file, creates a RedBaron instance, and iterates over each node in the instance. It checks if a node is a function definition (DefNode) and if it's asynchronous. If it's a DefNode and not async, it appends a decorator to it. Finally, it prints various information about each node and dumps the RedBaron instance.",
        "type": "comment"
    },
    "5242": {
        "file_id": 688,
        "content": "/tests/skipexception_code_and_continue_resurrection_time_travel_debugging/codemod_redbaron/recover_source.py",
        "type": "filepath"
    },
    "5243": {
        "file_id": 688,
        "content": "This code reads the content of \"test2.py\", parses it using the PASTA library, stores the result in a tree structure, then dumps and prints the tree representation.",
        "type": "summary"
    },
    "5244": {
        "file_id": 688,
        "content": "c=open(\"test2.py\",\"r\").read()\nimport pasta\ntree=pasta.parse(c)\nc0=pasta.dump(tree)\nprint(c0)",
        "type": "code",
        "location": "/tests/skipexception_code_and_continue_resurrection_time_travel_debugging/codemod_redbaron/recover_source.py:1-8"
    },
    "5245": {
        "file_id": 688,
        "content": "This code reads the content of \"test2.py\", parses it using the PASTA library, stores the result in a tree structure, then dumps and prints the tree representation.",
        "type": "comment"
    },
    "5246": {
        "file_id": 689,
        "content": "/tests/skipexception_code_and_continue_resurrection_time_travel_debugging/codemod_redbaron/pasta_test.py",
        "type": "filepath"
    },
    "5247": {
        "file_id": 689,
        "content": "This function removes 'reloading' decorators from code, adds if missing, and preserves 'lru_cache'. It differentiates between FunctionDef and AsyncFunctionDef. The modified tree is dumped and the input code is recovered and rewritten before printing.",
        "type": "summary"
    },
    "5248": {
        "file_id": 689,
        "content": "import pasta\nimport ast\ndef recover_and_rewrite(c,no_rewrite=False):\n    c = c.replace(\"from reloading import reloading\\n\", \"\")\n    if not no_rewrite:\n        c = \"from reloading import reloading\\n\" + c\n    tree = pasta.parse(c)\n    # print(dir(tree))\n    for i in range(len(tree.body)):\n        f = tree.body[i]\n        if type(f) == ast.FunctionDef:\n            cached = False\n            removeList = []\n            for index, elem in enumerate(f.decorator_list):\n                if type(elem) == ast.Name:\n                    if elem.id == \"reloading\":\n                        removeList.append(index)\n                    elif \"lru_cache\" in elem.id: # are you sure you won't call that again?\n                        cached = True\n                elif type(elem) == ast.Call:\n                    # breakpoint()\n                    if type(elem.func) == ast.Name:\n                        if \"lru_cache\" in elem.func.id:\n                            cached = True\n            for index in removeList:\n                del f.decorator_list[index]",
        "type": "code",
        "location": "/tests/skipexception_code_and_continue_resurrection_time_travel_debugging/codemod_redbaron/pasta_test.py:1-28"
    },
    "5249": {
        "file_id": 689,
        "content": "This function removes 'reloading' decorators from function definitions within the given code and retains 'lru_cache' decorators. It also adds a 'reloading' import if it was not present initially, unless specified otherwise.",
        "type": "comment"
    },
    "5250": {
        "file_id": 689,
        "content": "            # if len(f.decorator_list) == 0: # are you sure this will be ok?\n            if not no_rewrite:\n                if not cached:\n                    f.decorator_list.append(ast.Name(\"reloading\"))  # seems good?\n        # ast.FunctionDef and ast.AsyncFunctionDef are different.\n    c0 = pasta.dump(tree)\n    return c0\nif __name__ == \"__main__\":\n    c = open(\"test2.py\", \"r\").read()\n    c0 = recover_and_rewrite(c)\n    print(c0)",
        "type": "code",
        "location": "/tests/skipexception_code_and_continue_resurrection_time_travel_debugging/codemod_redbaron/pasta_test.py:29-41"
    },
    "5251": {
        "file_id": 689,
        "content": "The code checks if the decorator list is empty and if not, adds a \"reloading\" decorator. It differentiates between FunctionDef and AsyncFunctionDef. It then dumps the modified tree, recovers, and rewrites the input code before printing it.",
        "type": "comment"
    },
    "5252": {
        "file_id": 690,
        "content": "/tests/skipexception_code_and_continue_resurrection_time_travel_debugging/codemod_redbaron/create_decnode.py",
        "type": "filepath"
    },
    "5253": {
        "file_id": 690,
        "content": "This code imports the RedBaron library and defines a function `getd()` that generates a decorator by passing a string of Python code to RedBaron, extracting the first decorator from the returned object, and then returning it.",
        "type": "summary"
    },
    "5254": {
        "file_id": 690,
        "content": "import redbaron\ndef getd():\n    code=\"\"\"@abcd\n    def shit(): pass\"\"\"\n    d=redbaron.RedBaron(code)[0].decorators[0]\n    #print(d,type(d))\n    return d",
        "type": "code",
        "location": "/tests/skipexception_code_and_continue_resurrection_time_travel_debugging/codemod_redbaron/create_decnode.py:1-8"
    },
    "5255": {
        "file_id": 690,
        "content": "This code imports the RedBaron library and defines a function `getd()` that generates a decorator by passing a string of Python code to RedBaron, extracting the first decorator from the returned object, and then returning it.",
        "type": "comment"
    },
    "5256": {
        "file_id": 691,
        "content": "/tests/tencent_video_recommendation_extraction/requests_html_test.py",
        "type": "filepath"
    },
    "5257": {
        "file_id": 691,
        "content": "Imports pyppeteer and initializes an HTMLSession object, sets the URL to a QQ video page, uses session.get() to fetch the page's content, then iterates through all absolute links in the fetched HTML using r.html.absolute_links. Prints each link.",
        "type": "summary"
    },
    "5258": {
        "file_id": 691,
        "content": "from requests_html import HTMLSession # use pyppeteer.\nsession = HTMLSession()\n# url='https://www.baidu.com/'\nurl = 'http://v.qq.com/x/page/m0847y71q98.html'\nr = session.get(url)\nfor link in r.html.absolute_links:\n    print(link)",
        "type": "code",
        "location": "/tests/tencent_video_recommendation_extraction/requests_html_test.py:1-8"
    },
    "5259": {
        "file_id": 691,
        "content": "Imports pyppeteer and initializes an HTMLSession object, sets the URL to a QQ video page, uses session.get() to fetch the page's content, then iterates through all absolute links in the fetched HTML using r.html.absolute_links. Prints each link.",
        "type": "comment"
    },
    "5260": {
        "file_id": 692,
        "content": "/tests/tencent_video_recommendation_extraction/playwright_with_elinks.sh",
        "type": "filepath"
    },
    "5261": {
        "file_id": 692,
        "content": "This code executes a Python script and an elinks command to extract recommended video IDs from a webpage, searching for them in specific HTML elements.",
        "type": "summary"
    },
    "5262": {
        "file_id": 692,
        "content": "python3 dump_page.py\nelinks -dump dump.html > dump.log\n# please find recommended video id in <div data-vid=\"<vid>\">\n# or in <img src=\"//puui.qpic.cn/vpic_cover/<vid>/<vid>_old_ori.jpg/s640x360?max_age=7776000\">",
        "type": "code",
        "location": "/tests/tencent_video_recommendation_extraction/playwright_with_elinks.sh:1-5"
    },
    "5263": {
        "file_id": 692,
        "content": "This code executes a Python script and an elinks command to extract recommended video IDs from a webpage, searching for them in specific HTML elements.",
        "type": "comment"
    },
    "5264": {
        "file_id": 693,
        "content": "/tests/tencent_video_recommendation_extraction/phantomjs_test.js",
        "type": "filepath"
    },
    "5265": {
        "file_id": 693,
        "content": "This code uses PhantomJS and creates a new page. It opens the specified URL, checks if the status is \"success\", then retrieves the HTML of the page using evaluate() and outputs it to the console before exiting.",
        "type": "summary"
    },
    "5266": {
        "file_id": 693,
        "content": "var page = require('webpage').create();\npage.open('http://v.qq.com/x/page/m0847y71q98.html', function(status) {\n    //console.log(\"Status: \" + status);\n    if (status === \"success\") {\n        //\tpage.render('example.png');\n        result = page.evaluate(() => document.body.innerHTML);\n        console.log(result)\n    }\n    phantom.exit();\n});",
        "type": "code",
        "location": "/tests/tencent_video_recommendation_extraction/phantomjs_test.js:1-10"
    },
    "5267": {
        "file_id": 693,
        "content": "This code uses PhantomJS and creates a new page. It opens the specified URL, checks if the status is \"success\", then retrieves the HTML of the page using evaluate() and outputs it to the console before exiting.",
        "type": "comment"
    },
    "5268": {
        "file_id": 694,
        "content": "/tests/tencent_video_recommendation_extraction/loop_all_tags.py",
        "type": "filepath"
    },
    "5269": {
        "file_id": 694,
        "content": "This code reads the \"dump.html\" file, parses it with BeautifulSoup, and then iterates over all elements to check if their attributes include 'src' or 'href'. If so, it prints the key-value pair for further examination.",
        "type": "summary"
    },
    "5270": {
        "file_id": 694,
        "content": "from bs4 import BeautifulSoup\ndata = open(\"dump.html\",'r').read()\nsoup = BeautifulSoup(data)\nfor elem in soup.find_all():\n    # print(elem.attrs)\n    # for further examination\n    attrs = elem.attrs\n    for key in ['src', 'href']:\n        if key in attrs.keys():\n            print(key, attrs[key])",
        "type": "code",
        "location": "/tests/tencent_video_recommendation_extraction/loop_all_tags.py:1-14"
    },
    "5271": {
        "file_id": 694,
        "content": "This code reads the \"dump.html\" file, parses it with BeautifulSoup, and then iterates over all elements to check if their attributes include 'src' or 'href'. If so, it prints the key-value pair for further examination.",
        "type": "comment"
    },
    "5272": {
        "file_id": 695,
        "content": "/tests/tencent_video_recommendation_extraction/dump_page.py",
        "type": "filepath"
    },
    "5273": {
        "file_id": 695,
        "content": "This code uses Playwright library to launch a headless Chromium browser, navigates to a QQ video page, waits for the DOM content loaded state, retrieves the HTML content, writes it to a \"dump.html\" file, and then closes the browser.",
        "type": "summary"
    },
    "5274": {
        "file_id": 695,
        "content": "from playwright.sync_api import sync_playwright\ndef run(playwright):\n    webkit = playwright.chromium\n    browser = webkit.launch(headless=True)\n    context = browser.new_context()\n    page = context.new_page()\n    page.goto(\"https://v.qq.com/x/page/m0847y71q98.html\")\n    page.wait_for_load_state(\"domcontentloaded\")\n    content = page.content()\n    with open(\"dump.html\", 'w+') as f: f.write(content)\n    print(\"content write to dump.html\")\n    browser.close()\nwith sync_playwright() as playwright:\n    run(playwright)",
        "type": "code",
        "location": "/tests/tencent_video_recommendation_extraction/dump_page.py:1-16"
    },
    "5275": {
        "file_id": 695,
        "content": "This code uses Playwright library to launch a headless Chromium browser, navigates to a QQ video page, waits for the DOM content loaded state, retrieves the HTML content, writes it to a \"dump.html\" file, and then closes the browser.",
        "type": "comment"
    },
    "5276": {
        "file_id": 696,
        "content": "/tests/video_detector_tests/frameDifference.py",
        "type": "filepath"
    },
    "5277": {
        "file_id": 696,
        "content": "This function detects motion in a video by comparing frames, calculating differences, applying thresholding and morphology operations, and identifying contours. The code displays two consecutive frames side-by-side using OpenCV and stops when 'Esc' is pressed.",
        "type": "summary"
    },
    "5278": {
        "file_id": 696,
        "content": "import cv2 as cv\nimport numpy as np\nfrom matplotlib import pyplot as plt\ndef motionDetection(videoPath):\n    cap = cv.VideoCapture(videoPath)\n    ret, frame1 = cap.read()\n    ret, frame2 = cap.read()\n    while cap.isOpened():\n        if frame1 is not None and frame2 is not None:\n            pass\n        else:\n            break\n        diff = cv.absdiff(frame1, frame2)\n        diff_gray = cv.cvtColor(diff, cv.COLOR_BGR2GRAY)\n        blur = cv.GaussianBlur(diff_gray, (5, 5), 0)\n        _, thresh = cv.threshold(blur, 20, 255, cv.THRESH_BINARY)\n        dilated = cv.dilate(thresh, None, iterations=3)\n        contours, _ = cv.findContours(\n            dilated, cv.RETR_TREE, cv.CHAIN_APPROX_SIMPLE)\n        for contour in contours:\n            (x, y, w, h) = cv.boundingRect(contour)\n            if cv.contourArea(contour) < 900:\n                continue\n            cv.rectangle(frame1, (x, y), (x+w, y+h), (0, 255, 0), 2)\n            cv.putText(frame1, \"Status: {}\".format('Movement'), (10, 20), cv.FONT_HERSHEY_SIMPLEX,\n                        1, (255, 0, 0), 3)",
        "type": "code",
        "location": "/tests/video_detector_tests/frameDifference.py:1-30"
    },
    "5279": {
        "file_id": 696,
        "content": "This function performs motion detection by comparing successive frames in a video, calculates the difference, applies thresholding and morphology operations, and finally detects contours to identify areas with significant changes.",
        "type": "comment"
    },
    "5280": {
        "file_id": 696,
        "content": "        # cv.drawContours(frame1, contours, -1, (0, 255, 0), 2)\n        cv.imshow(\"Video\", frame1)\n        frame1 = frame2\n        ret, frame2 = cap.read()\n        if cv.waitKey(50) == 27:\n            break\n    cap.release()\n    cv.destroyAllWindows()\nif __name__ == \"__main__\":\n    motionDetection(\"../../samples/video/LiEIfnsvn.mp4\")",
        "type": "code",
        "location": "/tests/video_detector_tests/frameDifference.py:32-46"
    },
    "5281": {
        "file_id": 696,
        "content": "This code displays two consecutive frames of a video side by side, highlighting the difference between them using OpenCV. It reads frames from a video file and continuously checks for user input to break the loop when key 'Esc' is pressed.",
        "type": "comment"
    },
    "5282": {
        "file_id": 697,
        "content": "/tests/video_detector_tests/detectron2_norfair.py",
        "type": "filepath"
    },
    "5283": {
        "file_id": 697,
        "content": "The code uses Detectron2 for object detection, tracks \"person\" or \"dog\", updates tracked_objects, and displays bounding boxes. It utilizes OpenCV for video display and waits for 'q' to terminate, closing windows upon exiting.",
        "type": "summary"
    },
    "5284": {
        "file_id": 697,
        "content": "import cv2\nimport numpy as np\nfrom detectron2.config import get_cfg\nfrom detectron2.engine import DefaultPredictor\nfrom cocoNames import cocoRealName\nfrom norfair import Detection, Tracker, Video, draw_tracked_objects\ndef euclidean_distance(detection, tracked_object):\n    return np.linalg.norm(detection.points - tracked_object.estimate)\n# Set up Detectron2 object detector\ncfg = get_cfg()\ncfg.merge_from_file(\"norfair/demos/faster_rcnn_R_50_FPN_3x.yaml\")\ncfg.MODEL.ROI_HEADS.SCORE_THRESH_TEST = 0.5 # looks like it does not recognize dog.\n# cfg.MODEL.WEIGHTS = \"detectron2://COCO-InstanceSegmentation/mask_rcnn_R_50_FPN_3x/137849600/model_final_f10217.pkl\"\ncfg.MODEL.WEIGHTS = \"/root/Desktop/works/pyjom/tests/video_detector_tests/detectron2_models/model_final_f10217.pkl\"\n# it is stored in s3\n# https://dl.fbaipublicfiles.com/detectron2/COCO-InstanceSegmentation/mask_rcnn_R_50_FPN_3x/137849600/model_final_f10217.pkl\n# download cache: /root/.torch/iopath_cache/detectron2/COCO-InstanceSegmentation/mask_rcnn_R_50_FPN_3x/137849600/model_final_f10217.pkl",
        "type": "code",
        "location": "/tests/video_detector_tests/detectron2_norfair.py:1-21"
    },
    "5285": {
        "file_id": 697,
        "content": "The code imports necessary libraries and sets up a Detectron2 object detector using pre-trained weights for instance segmentation. It also defines a function to calculate Euclidean distance between detection and tracked objects. The configuration file specifies the model architecture, which is R_50_FPN with three stages and the specific weights (model_final_f10217.pkl) to be used for detection. The weights can either be downloaded from a public S3 storage or retrieved from the local cache if already downloaded.",
        "type": "comment"
    },
    "5286": {
        "file_id": 697,
        "content": "detector = DefaultPredictor(cfg)\n# what are the classes output by the model?\n# Norfair\nvideo_path = \"/root/Desktop/works/pyjom/samples/video/dog_with_text.mp4\"\n# video_path = \"/root/Desktop/works/pyjom/samples/video/LlfeL29BP.mp4\"\nvideo = Video(input_path=video_path)\ntracker = Tracker(distance_function=euclidean_distance, distance_threshold=400,hit_inertia_min=2,hit_inertia_max=20,initialization_delay=1) # what the heck?\ntracked_objects = None\ndisplay=True\nfor index, frame in enumerate(video): # we need to speed up.\n    if index%10 == 0:\n        detections = detector(cv2.cvtColor(frame, cv2.COLOR_BGR2RGB))\n        print(\"original detections:\",detections)\n        instances = detections[\"instances\"]\n        print(\"instances:\",instances)\n        # breakpoint()\n        pred_classes = instances.pred_classes\n        if len(pred_classes) == 0:\n            continue\n        detections2=[]\n        for index,class_ in enumerate(pred_classes):\n            print(\"index:\",index)\n            class_ = int(class_.cpu().numpy().tolist())",
        "type": "code",
        "location": "/tests/video_detector_tests/detectron2_norfair.py:23-48"
    },
    "5287": {
        "file_id": 697,
        "content": "The code initializes a video detector using Detector class and then processes each frame of the video. It predicts instances in each frame, prints detected classes and instances, and continues only if there are predictions. The tracker is used to track objects over frames, but its parameters might need clarification. Speedup is mentioned as needed, which implies potential optimizations.",
        "type": "comment"
    },
    "5288": {
        "file_id": 697,
        "content": "            print(\"class:\",class_)\n            box = instances.pred_boxes.tensor[index].cpu().numpy().tolist()\n            box = [int(x) for x in box]\n            score = float(instances.scores[index].cpu().numpy().tolist())\n            print('box:',box)\n            print('score:',score)\n            className = cocoRealName[class_]\n            # we filter our targets.\n            if className not in [\"person\",\"dog\"]:\n                continue\n            mdata = {\"box\":box,\"class\":{\"id\":class_,\"name\":className}}\n            det = Detection(instances.pred_boxes.get_centers()[index].cpu().numpy(),scores=np.array([score]),data=mdata)\n            detections2.append(det)\n            # breakpoint()\n        # detections = [Detection(p) for p in instances.pred_boxes.get_centers().cpu().numpy()] # what is this instance anyway?\n        # you would lost data you dick!\n        print(\"detections2\",detections2)\n        tracked_objects = tracker.update(detections=detections2)\n        # print(detections)\n        print(\"tracked objects:\",tracked_objects) # you don't track shit?",
        "type": "code",
        "location": "/tests/video_detector_tests/detectron2_norfair.py:49-68"
    },
    "5289": {
        "file_id": 697,
        "content": "This code is filtering and creating detection objects for \"person\" or \"dog\" instances from a given dataset. It prints the box coordinates, score, and class name before adding it to the detections2 list. The code then updates tracked_objects using the tracker function with the detections2 list.",
        "type": "comment"
    },
    "5290": {
        "file_id": 697,
        "content": "    if tracked_objects is not None:\n        if tracked_objects!=[]:\n            # there is no bounding box avaliable?\n            for obj in tracked_objects:\n                point = obj.estimate[0]\n                position = tuple(point.astype(int))\n                color = (255,0,0)\n                # breakpoint()\n                name = obj.last_detection.data[\"class\"][\"name\"]\n                cv2.circle(\n                        frame,\n                        position,\n                        radius=100,\n                        color=color,\n                        thickness=2,\n                    )\n                cv2.putText(\n                    frame,\n                    \"[{}][{}]\".format(str(obj.id),name),\n                    (position[0]-100,position[1]),\n                    cv2.FONT_HERSHEY_SIMPLEX,\n                    2,\n                    (0,255,0),\n                    3,\n                    cv2.LINE_AA,\n                )\n            # breakpoint()\n        # i want to draw you in a different way.\n        # draw_tracked_objects(frame, tracked_objects,color=(255,0,0))",
        "type": "code",
        "location": "/tests/video_detector_tests/detectron2_norfair.py:69-97"
    },
    "5291": {
        "file_id": 697,
        "content": "The code checks if there are any tracked objects and then proceeds to draw bounding boxes around them, add labels for the objects' class names, and display their IDs on the frame using OpenCV functions. Additionally, it offers an alternative way to draw the objects in a different color.",
        "type": "comment"
    },
    "5292": {
        "file_id": 697,
        "content": "    if display:\n        cv2.imshow(\"window\",frame)\n        key  =  cv2.waitKey(1) & 0xff\n        if key == ord('q'):\n            break\n        # maybe we shall print this shit somehow.\n    # video.write(frame) # you write what?\nif display:\n    cv2.destroyAllWindows()",
        "type": "code",
        "location": "/tests/video_detector_tests/detectron2_norfair.py:98-106"
    },
    "5293": {
        "file_id": 697,
        "content": "The code displays a frame from a video using OpenCV's imshow function and waits for a user input (key) to terminate. The key input is checked if it matches the character 'q', which signals a break in the loop. OpenCV's destroyAllWindows() is called to close the window when display is enabled.",
        "type": "comment"
    },
    "5294": {
        "file_id": 698,
        "content": "/tests/video_detector_tests/detectron2_model_zoo_url.py",
        "type": "filepath"
    },
    "5295": {
        "file_id": 698,
        "content": "This code maps Detectron2 COCO model names to checkpoint files, defining configurations for trained parameters and providing pretrained model URLs and checkpoints.",
        "type": "summary"
    },
    "5296": {
        "file_id": 698,
        "content": "from typing import Optional\nclass _ModelZooUrls(object):\n    \"\"\"\n    Mapping from names to officially released Detectron2 pre-trained models.\n    \"\"\"\n    S3_PREFIX = \"https://dl.fbaipublicfiles.com/detectron2/\"\n    # format: {config_path.yaml} -> model_id/model_final_{commit}.pkl\n    CONFIG_PATH_TO_URL_SUFFIX = {\n        # COCO Detection with Faster R-CNN\n        \"COCO-Detection/faster_rcnn_R_50_C4_1x\": \"137257644/model_final_721ade.pkl\",\n        \"COCO-Detection/faster_rcnn_R_50_DC5_1x\": \"137847829/model_final_51d356.pkl\",\n        \"COCO-Detection/faster_rcnn_R_50_FPN_1x\": \"137257794/model_final_b275ba.pkl\",\n        \"COCO-Detection/faster_rcnn_R_50_C4_3x\": \"137849393/model_final_f97cb7.pkl\",\n        \"COCO-Detection/faster_rcnn_R_50_DC5_3x\": \"137849425/model_final_68d202.pkl\",\n        \"COCO-Detection/faster_rcnn_R_50_FPN_3x\": \"137849458/model_final_280758.pkl\",\n        \"COCO-Detection/faster_rcnn_R_101_C4_3x\": \"138204752/model_final_298dad.pkl\",\n        \"COCO-Detection/faster_rcnn_R_101_DC5_3x\": \"138204841/model_final_3e0943.pkl\",",
        "type": "code",
        "location": "/tests/video_detector_tests/detectron2_model_zoo_url.py:2-20"
    },
    "5297": {
        "file_id": 698,
        "content": "The code defines a class \"_ModelZooUrls\" that provides a mapping between Detectron2 pre-trained model names and their respective URLs. It uses the \"S3_PREFIX\" to specify the base URL for downloading models and stores each model's path in the \"CONFIG_PATH_TO_URL_SUFFIX\" dictionary. The code includes various pre-trained COCO Detection models, such as Faster R-CNN with different architectures and scales.",
        "type": "comment"
    },
    "5298": {
        "file_id": 698,
        "content": "        \"COCO-Detection/faster_rcnn_R_101_FPN_3x\": \"137851257/model_final_f6e8b1.pkl\",\n        \"COCO-Detection/faster_rcnn_X_101_32x8d_FPN_3x\": \"139173657/model_final_68b088.pkl\",\n        # COCO Detection with RetinaNet\n        \"COCO-Detection/retinanet_R_50_FPN_1x\": \"190397773/model_final_bfca0b.pkl\",\n        \"COCO-Detection/retinanet_R_50_FPN_3x\": \"190397829/model_final_5bd44e.pkl\",\n        \"COCO-Detection/retinanet_R_101_FPN_3x\": \"190397697/model_final_971ab9.pkl\",\n        # COCO Detection with RPN and Fast R-CNN\n        \"COCO-Detection/rpn_R_50_C4_1x\": \"137258005/model_final_450694.pkl\",\n        \"COCO-Detection/rpn_R_50_FPN_1x\": \"137258492/model_final_02ce48.pkl\",\n        \"COCO-Detection/fast_rcnn_R_50_FPN_1x\": \"137635226/model_final_e5f7ce.pkl\",\n        # COCO Instance Segmentation Baselines with Mask R-CNN\n        \"COCO-InstanceSegmentation/mask_rcnn_R_50_C4_1x\": \"137259246/model_final_9243eb.pkl\",\n        \"COCO-InstanceSegmentation/mask_rcnn_R_50_DC5_1x\": \"137260150/model_final_4f86c3.pkl\",\n        \"COCO-InstanceSegmentation/mask_rcnn_R_50_FPN_1x\": \"137260431/model_final_a54504.pkl\",",
        "type": "code",
        "location": "/tests/video_detector_tests/detectron2_model_zoo_url.py:21-34"
    },
    "5299": {
        "file_id": 698,
        "content": "This code maps various Detectron2 models (e.g., faster_rcnn, retinanet, mask_rcnn) to their corresponding pre-trained model files stored in specific URLs or locations. These models are used for tasks like instance segmentation and detection on the COCO dataset.",
        "type": "comment"
    }
}