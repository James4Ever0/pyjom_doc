{
    "700": {
        "file_id": 49,
        "content": "    # the 'mean' is still not correctified.\n    # ERROR STATUS: False\n    # video codec we use 'copy' if the extension name is the same.\n    outputPathExtension = outputPath.lower().split(\".\")[-1]\n    mediaPathExtension = mediaPath.lower().split(\".\")[-1]\n    outputMediaType = determineMediaTypeByExtension(outputPathExtension)\n    # treat this as a common repository.\n    if outputPathExtension == mediaPathExtension and outputMediaType == \"video\":\n        commandline += [\"-c:v\", \"copy\"]\n    # problem is, the container must be video compabible.\n    # list the thing here?\n    if outputPathExtension == \"mp4\":\n        commandline += [\"-c:a\", \"aac\"]\n    if target_level:\n        commandline += [\"-t\", str(target_level)]\n    if true_peak:\n        commandline += [\"-tp\", str(true_peak)]\n    if overwrite_output:\n        commandline += [\"-f\"]\n    commandline += [mediaPath]\n    status = subprocess.run(commandline)  # is it even successful?\n    returncode = status.returncode\n    try:\n        assert returncode == 0\n        print(\"VOLUME NORMALIZATION SUCCESSFUL\")",
        "type": "code",
        "location": "/pyjom/audiotoolbox.py:98-122"
    },
    "701": {
        "file_id": 49,
        "content": "This code is normalizing the volume of a video file and correcting its container type if necessary. It checks the input and output extensions, sets the video and audio codecs, handles target level, true peak, and overwrite settings, and runs subprocess command to execute FFmpeg for processing. The script prints \"VOLUME NORMALIZATION SUCCESSFUL\" if returncode is 0, indicating successful volume normalization.",
        "type": "comment"
    },
    "702": {
        "file_id": 49,
        "content": "        return outputPath\n    except:\n        import traceback\n        traceback.print_exc()\n        print(\"error when normalizing audio for media: %s\" % mediaPath)\n    # media = ffmpeg.input(videoPath)\n    # audio = media.audio\n    # video = media.video\n    # audio = audio.filter()",
        "type": "code",
        "location": "/pyjom/audiotoolbox.py:123-132"
    },
    "703": {
        "file_id": 49,
        "content": "This code snippet is responsible for normalizing audio for a given media file. If an error occurs during the process, it prints the error message and stack trace using the traceback module.",
        "type": "comment"
    },
    "704": {
        "file_id": 50,
        "content": "/pyjom/modules/__init__.py",
        "type": "filepath"
    },
    "705": {
        "file_id": 50,
        "content": "Importing various modules for different functionalities in the pyjom framework.",
        "type": "summary"
    },
    "706": {
        "file_id": 50,
        "content": "from pyjom.modules.methodIdentifier import *\nfrom pyjom.modules.topicGenerator import *\nfrom pyjom.modules.informationGathering import *\nfrom pyjom.modules.informationProcessing import *\nfrom pyjom.modules.contentProducing import *\nfrom pyjom.modules.contentPosting import *\nfrom pyjom.modules.feedbackCollecting import *\nfrom pyjom.modules.globalOptimizer import *\nfrom pyjom.modules.globalUpdator import *\nfrom pyjom.modules.contentReviewer import *\nfrom pyjom.modules.contentCensoring import *",
        "type": "code",
        "location": "/pyjom/modules/__init__.py:1-11"
    },
    "707": {
        "file_id": 50,
        "content": "Importing various modules for different functionalities in the pyjom framework.",
        "type": "comment"
    },
    "708": {
        "file_id": 51,
        "content": "/pyjom/modules/contentCensoring/core.py",
        "type": "filepath"
    },
    "709": {
        "file_id": 51,
        "content": "This code creates a media downloader GUI with library integration, progress updates, customizable appearance, and tabular post topics. It uses decorator function `keywordDecorator` to censor media based on input parameters and handles unknown content types with exceptions.",
        "type": "summary"
    },
    "710": {
        "file_id": 51,
        "content": "from tkinter import *\nfrom pyjom.commons import *\nfrom pyjom.modules.contentCensoring.autoCensor import *\n# import tkinter.font\nimport requests\nimport traceback\nimport os\nimport command_spawner\nfrom progressbar import *\n# add progressbar\ndef mediaDownloader(url, mblogid, basedir=None, index=None):\n    try:\n        with requests.get(url) as r: # what is the media file suffix?\n            suffix = url.split(\"?\")[0].split(\".\")[-1]\n            mid = mblogid if index is None else \"{}[{}]\".format(mblogid, index)\n            fname = \"{}.{}\".format(mid, suffix)\n            if not os.path.exists(basedir):\n                os.mkdir(basedir)\n            fpath = os.path.join(basedir, fname)\n            size = int(r.headers[\"Content-Length\"].strip())\n            mbytes = 0\n            widgets = [\n                fpath,\n                \": \",\n                Bar(marker=\"|\", left=\"[\", right=\" \"),\n                Percentage(),\n                \" \",\n                FileTransferSpeed(),\n                \"] \",\n                \" of {0}MB\".format(str(round(size / 1024 / 1024, 2))[:4]),",
        "type": "code",
        "location": "/pyjom/modules/contentCensoring/core.py:1-32"
    },
    "711": {
        "file_id": 51,
        "content": "This code snippet is for a media downloader function that uses the requests library to download a file from a given URL. It also includes functionality for handling progress updates using the progressbar module, and it creates a folder to store the downloaded files if one does not already exist. The function takes in parameters such as the URL of the file to be downloaded, an optional mblog ID (and index) for creating a unique file name based on this ID, and an optional base directory where the files will be stored. If no base directory is provided, it will create one automatically with the specified name. The function determines the file's suffix by parsing the URL and extracting the last part of the string after any query parameters. Once the download starts, it tracks progress using a widget that displays a bar indicating the percentage completed, along with other information like the current file transfer speed. It also calculates and displays the size of the file in MB as it downloads.",
        "type": "comment"
    },
    "712": {
        "file_id": 51,
        "content": "            ]\n            pbar = ProgressBar(widgets=widgets, maxval=size).start()\n            mfile = []\n            for buf in r.iter_content(1024):\n                if buf:\n                    mfile.append(buf)\n                    mbytes += len(buf)\n                    pbar.update(mbytes)\n            pbar.finish()\n            print(\"saved to {}\".format(fpath))\n            with open(fpath, \"wb\") as f:\n                for byteContent in mfile:\n                    f.write(byteContent)\n            return fpath\n    except:\n        traceback.print_exc()\n        print(\"error in mediaDownloader:\\n\", url)\n    return None\nx_buffer = None\ntag_x_offset =None\ntag_y_counter =None\ndef censorInterface(\n    mtitle, mtopic, mcontent,mtags=[], local=False\n):  # this could be a standard template.\n    global x_buffer,tag_x_offset,tag_y_counter\n    assert type(mtopic) == list\n    assert type(mtags) == list\n    is_on = {key:False for key in mtags}\n    def switch(key, buttons, index, is_on):\n        button = buttons[index]\n        if is_on[key]:",
        "type": "code",
        "location": "/pyjom/modules/contentCensoring/core.py:33-65"
    },
    "713": {
        "file_id": 51,
        "content": "The code downloads media content from a URL and saves it to the specified file path. It also includes error handling using try-except block and traceback. The function censorInterface seems to be an interface for switching between tags, where the user can toggle the visibility of different tags on or off.",
        "type": "comment"
    },
    "714": {
        "file_id": 51,
        "content": "            button.config(text=key ,bg = \"grey\",fg=\"black\")\n            is_on[key] = False\n        else:\n            button.config(text = key,bg = \"green\",fg=\"white\")\n            is_on[key] = True\n    def getSwitchLambda(text, on_buttons, index, is_on):\n        return lambda:switch(text, on_buttons, index, is_on)\n    on_buttons = []\n    mfunctions = []\n    mdata = {\"labels\": [], \"comment\": None, \"discard\": False}\n    left, top = 1500, 500\n    parent = Tk()\n    parent.geometry(\"+{}+{}\".format(left, top))\n    # parent\n    default_window_size =(460,400)\n    parent.geometry(\"{0}x{1}\".format(*default_window_size))\n    themepath = joinScriptFileBaseDir(__file__, \"Forest-ttk-theme/forest-dark.tcl\")\n    parent.tk.call(\"source\", themepath)\n    parent.attributes(\"-topmost\", True)\n    if not local:\n        title = Label(\n            parent,\n            text=\"Title:\" + \"\\n\" * 4,\n            fg=\"white\",\n        )\n        title.grid(row=0, column=0, sticky=\"e\")\n        text0 = Text(fg=\"aqua\", height=5, width=24)\n        text0.grid(row=0, column=1)",
        "type": "code",
        "location": "/pyjom/modules/contentCensoring/core.py:66-98"
    },
    "715": {
        "file_id": 51,
        "content": "This code sets up a window with buttons, configures their appearance and state based on the given 'is_on' variable, and provides functions for handling button clicks. It also handles window geometry and theme customization.",
        "type": "comment"
    },
    "716": {
        "file_id": 51,
        "content": "        text0.insert(END, mtitle)\n        # print(mtopic)\n        mlabel = (  # not designed for sina topic format.\n            \"None\" if mtopic == None else \" \".join([\"[{}]\".format(x) for x in mtopic])\n        )\n        label = Label(\n            parent,\n            text=\"Topics:\" + \"\\n\" * 4,\n            fg=\"aqua\",\n        )\n        label.grid(row=1, column=0, sticky=\"e\")\n        text1 = Text(fg=\"aqua\", height=5, width=24)\n        text1.grid(row=1, column=1)\n        text1.insert(END, mlabel)\n        content = Label(\n            parent,\n            text=\"Content:\" + \"\\n\" * 4,\n            fg=\"white\",\n        )\n        content.grid(row=2, column=0, sticky=\"e\")\n        text2 = Text(fg=\"aqua\", height=5, width=24)\n        text2.grid(row=2, column=1)\n        text2.insert(END, mcontent)\n        conrow = 3\n    else:\n        conrow = 0\n    redbutton = Entry(parent, fg=\"red\")\n    redbutton.grid(row=0 + conrow, column=1, sticky=\"ew\")\n    # button_height = 32 # default height?\n    x_buffer = 10\n    tag_x_offset = 0\n    tag_y_counter = 0",
        "type": "code",
        "location": "/pyjom/modules/contentCensoring/core.py:99-134"
    },
    "717": {
        "file_id": 51,
        "content": "This code snippet creates a GUI for displaying post topics and content in a tabular format. It includes labels, text boxes, and a red button. The code handles the case where a topic is given or not, and adjusts the positioning accordingly. The variable \"conrow\" keeps track of the row position for the red button. Variables like \"x_buffer\", \"tag_x_offset\", and \"tag_y_counter\" are used for positioning elements on the screen.",
        "type": "comment"
    },
    "718": {
        "file_id": 51,
        "content": "    # print(\"TEXT:\", text)\n    def placeTagButtons(index, text,tag_x_offset, tag_y_counter, x_buffer, on=False):\n        # global\n        if not on:\n            mButton = Button(parent, text=text, bd = 0,bg=\"grey\",fg=\"black\")\n        else:\n            mButton = Button(parent, text=text, bd = 0,bg=\"green\",fg=\"white\")\n        button_width = mButton.winfo_reqwidth()\n        # 65\n        button_height = mButton.winfo_reqheight()\n        # print(button_width, button_height)\n        # breakpoint()\n        on_buttons.append(mButton)\n        mfunctions.append(getSwitchLambda(text, on_buttons, index, is_on))\n        on_buttons[index].config(command=mfunctions[index])\n        # on_buttons[index].grid_forget()\n        estimate_x_size = tag_x_offset+x_buffer+button_width\n        estimated_y_size = default_window_size[1]+ button_width*1.3*(tag_y_counter+1)\n        if estimate_x_size > default_window_size[0]:\n            tag_x_offset = 0\n            tag_y_counter+=1\n            # change window geometry\n            parent",
        "type": "code",
        "location": "/pyjom/modules/contentCensoring/core.py:135-158"
    },
    "719": {
        "file_id": 51,
        "content": "This code defines a function `placeTagButtons` which creates buttons with specified text and positions them in a window, adjusting the position based on available space. The button color depends on its 'on' parameter, and it stores the button and associated command for later use.",
        "type": "comment"
    },
    "720": {
        "file_id": 51,
        "content": ".geometry(\"{0}x{1}\".format(default_window_size[0], int(default_window_size[1]+ button_height*0.1+(tag_y_counter+1)*button_height*1.2)))\n        elif estimated_y_size > default_window_size[1]:\n            parent.geometry(\"{0}x{1}\".format(default_window_size[0], int(default_window_size[1]+ button_height*0.1+(tag_y_counter+1)*button_height*1.2)))\n        on_buttons[index].place(x=tag_x_offset+x_buffer, y=default_window_size[1]+ button_height*0.1+tag_y_counter*button_height*1.2)\n        tag_x_offset+= button_width\n        return tag_x_offset,tag_y_counter\n        # print(dir(mButton))\n    for index, text in enumerate(is_on.keys()):\n        tag_x_offset,tag_y_counter = placeTagButtons(index, text, tag_x_offset,tag_y_counter, x_buffer)\n        # 32\n        # breakpoint()\n    def add_tag():\n        global tag_x_offset, tag_y_counter, x_buffer\n        mtext = redbutton.get()\n        mtext = mtext.strip()\n        if mtext != \"\": # that is the base line\n            redbutton.delete(0, END)\n            # change this shit.",
        "type": "code",
        "location": "/pyjom/modules/contentCensoring/core.py:158-176"
    },
    "721": {
        "file_id": 51,
        "content": "The code is setting the window geometry and placing button elements on the screen based on certain conditions. It calculates the dimensions and positions of buttons to fit within the available window space, while keeping track of the x-offset and y-counter for future button placement. The code also includes a function called \"add_tag\" that takes user input and checks if it's not empty before making further actions.",
        "type": "comment"
    },
    "722": {
        "file_id": 51,
        "content": "            # mdata[\"labels\"].append(mtext)\n            if mtext not in is_on.keys():\n                is_on.update({mtext:True}) # enable this tag anyway.\n                # and we do some append task here.\n                tag_x_offset, tag_y_counter=placeTagButtons(len(on_buttons), mtext,tag_x_offset, tag_y_counter, x_buffer, on=True)\n    bluebutton = Button(parent, text=\"ADD TAG\", fg=\"aqua\", command=add_tag)\n    bluebutton.grid(row=0 + conrow, column=0, sticky=\"e\")\n    redbutton3 = Label(parent, text=\"Comment:\", fg=\"red\")\n    redbutton3.grid(row=1 + conrow, column=0, sticky=\"e\")\n    redbutton2 = Entry(parent, fg=\"red\")\n    def add_comment():\n        comment = redbutton2.get()\n        if comment != \"\":\n            mdata[\"comment\"] = comment\n    redbutton2.grid(row=1 + conrow, column=1, sticky=\"ew\")\n    def mdestroy():\n        add_tag()\n        add_comment()\n        parent.destroy()\n    def mdestroy2():\n        mdata[\"discard\"] = True\n        parent.destroy()\n    blackbutton = Button(parent, text=\"SUBMIT\", fg=\"red\", command=mdestroy)",
        "type": "code",
        "location": "/pyjom/modules/contentCensoring/core.py:177-206"
    },
    "723": {
        "file_id": 51,
        "content": "This code creates a GUI window for adding tags and comments to content. It enables any previously unused tag, places tag buttons, adds an \"ADD TAG\" button, sets up a comment input field with a \"SUBMIT\" button, and defines functions for adding tags and comments and closing the window.",
        "type": "comment"
    },
    "724": {
        "file_id": 51,
        "content": "    blackbutton.grid(row=1 + conrow, column=2, sticky=\"e\")\n    blackbutton2 = Button(parent, text=\"KILL\", fg=\"yellow\", command=mdestroy2)\n    blackbutton2.grid(row=0 + conrow, column=2, sticky=\"ew\")\n    parent.bind(\"<Return>\", lambda event=None: bluebutton.invoke())\n    parent.bind(\"<Control-Return>\", lambda event=None: mdestroy())\n    # this is for updating the order of tags.\n    parent.bind(\"<KeyRelease>\", lambda event=None: print(\"KEY RELEASED! PLEASE CONSIDER TO BIND THIS EVENT TO UPDATING TAGS ORDER BY INPUT\"))\n    # this is for updating the order of tags.\n    parent.mainloop()\n    mdata[\"labels\"] = [x for x in is_on.keys() if is_on[x]]\n    mdata[\"total_labels\"] = [x for x in is_on.keys()]\n    return mdata\ndef playMedia(mediaPath):\n    cmdline = \"ffplay -alwaysontop -loop 0 -top 0 -left 0 {}\".format(mediaPath)\n    cs = command_spawner.CommandSpawner(command=cmdline, daemon=True)\n    cs.run()\n    return cs\ndef coreMediaCensor(\n    mediaPath,\n    meta,\n    play=True,\n    auto=False,\n    semiauto=True,\n    local=False,",
        "type": "code",
        "location": "/pyjom/modules/contentCensoring/core.py:207-234"
    },
    "725": {
        "file_id": 51,
        "content": "This code includes functions for playing media, core media censoring functionality, and interacting with a GUI. It spawns a command to play media in the background, binds keyboard events, and updates labels' order when a key is released.",
        "type": "comment"
    },
    "726": {
        "file_id": 51,
        "content": "    dummy_auto=True,\n    args={},\n    template_names=[],\n):\n    assert type(local) == bool\n    mtitle, mtopic, mcontent = meta\n    censor_method = (\n        keywordDecorator(autoCensor, args=args, template_names=template_names)\n        if not dummy_auto\n        else dummyAutoCensor\n    )\n    if ((not auto) or semiauto) and play:\n        cs = playMedia(mediaPath)  # siderun.\n        if not auto:\n            mdata = censorInterface(mtitle, mtopic, mcontent, local=local)\n        else:\n            nextData = censor_method(\n                mediaPath, meta, semiauto=semiauto\n            )  # this will not approve the thing. only generate tags and metadata.\n            mdata = censorInterface(mtitle, mtopic, mcontent, local=True)\n            mdata.update(nextData)\n    else:\n        mdata = censor_method(mediaPath, meta, semiauto=semiauto)\n    if ((not auto) or semiauto) and play:\n        cs.kill()\n        os.system(\"killall ffplay\")\n    return mdata\n@decorator\ndef weiboCensor(\n    content,\n    basedir=None,\n    auto=False,\n    semiauto=True,",
        "type": "code",
        "location": "/pyjom/modules/contentCensoring/core.py:235-269"
    },
    "727": {
        "file_id": 51,
        "content": "This code uses a decorator function, `keywordDecorator`, to apply different censoring methods based on the input parameters. If `auto` is False or `semiauto` is True and `play` is True, it calls `playMedia` and applies censoring using the `censor_method`. If `auto` is True, it only generates tags and metadata without approving the content. It also kills any running ffplay instances after playback if necessary.",
        "type": "comment"
    },
    "728": {
        "file_id": 51,
        "content": "    dummy_auto=True,\n    args={},\n    template_names=[],\n):\n    groupArgs = {\n        \"template_names\": template_names,\n        \"auto\": auto,\n        \"semiauto\": semiauto,\n        \"dummy_auto\": dummy_auto,\n        \"args\": args,\n    }\n    if (not auto) or semiauto:\n        os.system(\"killall ffplay\")\n    # we only need video.\n    data = {\"type\": \"text\", \"review\": None}\n    mtitle = content[\"title\"]\n    mtopic = (\n        None if content[\"topic\"] is None else [x[0] for x in content[\"topic\"]]\n    )  # excerpt the topic name only\n    mcontent = content[\"text\"][\"raw\"]\n    meta = (mtitle, mtopic, mcontent)\n    if content[\"video\"] is not None:\n        data[\"type\"] = \"video\"\n        videoUrl = content[\"video\"][\"download_link\"]\n        mblogid = content[\"meta\"][\"mblogid\"]\n        videoPath = mediaDownloader(videoUrl, mblogid, basedir=basedir)\n        mdata = coreMediaCensor(videoPath, meta, **groupArgs)\n        data[\"review\"] = (videoPath, mdata)\n        # return mdata\n    elif content[\"picture\"] is not None and content[\"picture\"] is not []:",
        "type": "code",
        "location": "/pyjom/modules/contentCensoring/core.py:270-299"
    },
    "729": {
        "file_id": 51,
        "content": "This code is creating a dictionary called \"groupArgs\" that holds various parameters. It then checks if the \"auto\" parameter is False or if \"semiauto\" is set, in which case it kills a process named \"ffplay\". Next, it sets the data type to \"text\" and initializes variables for title, topic, and content. If there's a video available, it updates the data type to \"video\", downloads the video, and calls a function \"coreMediaCensor\" with additional parameters. Finally, if there is a picture available but no video, it continues execution.",
        "type": "comment"
    },
    "730": {
        "file_id": 51,
        "content": "        data[\"type\"] = \"picture\"\n        data[\"review\"] = []\n        for index, pictureUrl in enumerate(content[\"picture\"]):\n            picturePath = mediaDownloader(\n                pictureUrl, mblogid, basedir=basedir, index=index\n            )\n            mdata = coreMediaCensor(picturePath, meta, **groupArgs)\n            data[\"review\"].append((picturePath, mdata))\n    else:\n        # just display the raw content.\n        mdata = coreMediaCensor(\n            None, meta, play=False, **groupArgs\n        )  # how to automate this shit?\n        data[\"review\"] = mdata\n    return data\n@decorator\ndef localCensor(\n    content, auto=False, semiauto=True, dummy_auto=True, args={}, template_names=[]\n):\n    # examine local files.\n    # first determine the content type.\n    groupArgs = {\n        \"auto\": auto,\n        \"semiauto\": semiauto,\n        \"dummy_auto\": dummy_auto,\n        \"template_names\": template_names,\n        \"args\": args,\n    }\n    if (not auto) or semiauto:\n        os.system(\"killall ffplay\")\n    # you may play the media as well.",
        "type": "code",
        "location": "/pyjom/modules/contentCensoring/core.py:300-332"
    },
    "731": {
        "file_id": 51,
        "content": "The code checks if the content is a picture and downloads it using mediaDownloader function. Then, it censors the picture using coreMediaCensor function and adds the path and censoring data to the review list. If the content is not a picture, it directly censors the content without displaying raw content using coreMediaCensor function with appropriate arguments. Finally, it returns the censored content as 'data'.",
        "type": "comment"
    },
    "732": {
        "file_id": 51,
        "content": "    data = {\"type\": None, \"review\": None}\n    mediaTypes = [\"image\", \"video\"]\n    # mediaTypes = [\"picture\", \"video\"]\n    if content[\"type\"] in mediaTypes:\n        data[\"type\"] = content[\"type\"]\n        mediaPath = content[\"path\"]\n        mdata = coreMediaCensor(mediaPath, (None, None, None), local=True, **groupArgs)\n        # review as video.\n        data[\"review\"] = (mediaPath, mdata)\n    else:\n        raise Exception(\"Unknown Content Type: {}\\n{}\".format(content[\"type\"], content))\n    return data",
        "type": "code",
        "location": "/pyjom/modules/contentCensoring/core.py:333-344"
    },
    "733": {
        "file_id": 51,
        "content": "This code checks the content type, if it's an image or video, then it censor the media using `coreMediaCensor` function and returns the data. If the content type is unknown, it raises an exception.",
        "type": "comment"
    },
    "734": {
        "file_id": 52,
        "content": "/pyjom/modules/contentCensoring/autoCensor.py",
        "type": "filepath"
    },
    "735": {
        "file_id": 52,
        "content": "This code provides content censoring functionality for media processing software using Tkinter and optional parameters, as well as a semi-auto blacklist feature. It removes specified key-value pairs from the dictionary.",
        "type": "summary"
    },
    "736": {
        "file_id": 52,
        "content": "from tkinter import *\nfrom pyjom.commons import *\nfrom pyjom.medialang.core import *\ndef dummyAutoCensor(contentPath, meta, semiauto=False):\n    mdata = {\n        \"dummyAutoCensor\": {\n            \"input\": {\"path\": contentPath, \"meta\": meta},\n            \"result\": \"some content here!\",\n        }\n    }\n    return mdata\ndef autoCensor(contentPath, meta, template_names=[], semiauto=False, args={}):\n    from pyjom.medialang.core import Medialang\n    mdata = {}\n    template_dirs = [\"medialang\", \"autoCensor\"]\n    medialang_template_paths = template_names  # not always need all templates.\n    semiauto_key_blacklist = []\n    semiauto_template_path_blacklist = []\n    if semiauto:\n        medialang_template_paths = [\n            x\n            for x in medialang_template_paths\n            if x not in semiauto_template_path_blacklist\n        ]\n    for template_name in medialang_template_paths:\n        name = template_name.split(\".\")[0]  # check if starts with meta.\n        template_path = getTemplatePath(template_dirs, template_name)",
        "type": "code",
        "location": "/pyjom/modules/contentCensoring/autoCensor.py:1-31"
    },
    "737": {
        "file_id": 52,
        "content": "This code is for content censoring in a media processing software. It utilizes Tkinter and other modules for functionality, provides a dummy auto-censorship function, and an actual auto-censorship function with optional parameters like template names and semi-auto mode. It also includes a list of blacklisted templates if semi-auto mode is enabled.",
        "type": "comment"
    },
    "738": {
        "file_id": 52,
        "content": "        template_args = {} if name not in args.keys() else args[name]\n        assert type(template_args) == dict\n        if name.startswith(\"meta_\"):\n            template_args.update({\"meta\": meta})  # you can access it by keys.\n        template_args.update({\"mediafile\": contentPath})\n        # print(\"template_args\")\n        # breakpoint()\n        medialang = Medialang(\n            script_path=template_path,\n            template=True,\n            template_args=template_args,  # config inside the template args. None to use the default.\n        )\n        script = medialang.prettify()\n        print(script)\n        # breakpoint()\n        data = medialang.execute()\n        # print(\"DATA\",data)\n        # breakpoint()\n        # # try:\n        data = data[0][0]  # language feature.\n        # what the fuck is wrong?\n        mdata.update({name: data})  # this is not so good, though.\n        # except:\n            # print('skipping marking data')\n    if semiauto:  # need some modification.\n        for key in semiauto_key_blacklist:",
        "type": "code",
        "location": "/pyjom/modules/contentCensoring/autoCensor.py:32-57"
    },
    "739": {
        "file_id": 52,
        "content": "This code takes a name and dictionary of arguments, checks if the name matches a specific key in the arguments dictionary. If it does, it adds \"meta\" and \"mediafile\" keys to the template_args dictionary, then creates an instance of Medialang with the script path, template set to True, and template_args. The script is prettified, executed, and the data returned. Lastly, the data is added to the mdata dictionary under the given name, unless there was an issue where it prints \"skipping marking data\". If semiauto is set, it goes through a loop for each key in semiauto_key_blacklist.",
        "type": "comment"
    },
    "740": {
        "file_id": 52,
        "content": "            mdata.pop(key)\n    return mdata",
        "type": "code",
        "location": "/pyjom/modules/contentCensoring/autoCensor.py:58-59"
    },
    "741": {
        "file_id": 52,
        "content": "Removing specified key-value pair from the dictionary and returning the updated dictionary.",
        "type": "comment"
    },
    "742": {
        "file_id": 53,
        "content": "/pyjom/modules/contentCensoring/__init__.py",
        "type": "filepath"
    },
    "743": {
        "file_id": 53,
        "content": "This code imports two parts, label and filter, from the contentCensoring module's core and autoCensor submodules in the pyjom library.",
        "type": "summary"
    },
    "744": {
        "file_id": 53,
        "content": "# two parts: label and filter\nfrom pyjom.modules.contentCensoring.core import *\nfrom pyjom.modules.contentCensoring.autoCensor import *",
        "type": "code",
        "location": "/pyjom/modules/contentCensoring/__init__.py:1-3"
    },
    "745": {
        "file_id": 53,
        "content": "This code imports two parts, label and filter, from the contentCensoring module's core and autoCensor submodules in the pyjom library.",
        "type": "comment"
    },
    "746": {
        "file_id": 54,
        "content": "/pyjom/modules/topicGenerator/weiboTopicGenerator.py",
        "type": "filepath"
    },
    "747": {
        "file_id": 54,
        "content": "This code imports necessary modules and defines a topic generator function for pets. It returns a fixed topic in both Chinese and English languages, demonstrating simple multilingual support.",
        "type": "summary"
    },
    "748": {
        "file_id": 54,
        "content": "from pyjom.commons import *\n@decorator\ndef petsTopicGenerator():\n    # this is just some primitive topic, always return the same thing.\n    # topics cannot be multilingual.\n    return {\"entities\": [{\"chinese\": \"搞笑 宠物\", \"english\": \"funny pets\"}]}",
        "type": "code",
        "location": "/pyjom/modules/topicGenerator/weiboTopicGenerator.py:1-8"
    },
    "749": {
        "file_id": 54,
        "content": "This code imports necessary modules and defines a topic generator function for pets. It returns a fixed topic in both Chinese and English languages, demonstrating simple multilingual support.",
        "type": "comment"
    },
    "750": {
        "file_id": 55,
        "content": "/pyjom/modules/topicGenerator/onlineTopicGenerator.py",
        "type": "filepath"
    },
    "751": {
        "file_id": 55,
        "content": "The code imports functions for keyword removal and topic modeling in English/Chinese, selects words by shuffling topics, fetches random keywords to request gifs/videos from a local server, and retrieves a random picture with related words using keyword and topic modeling.",
        "type": "summary"
    },
    "752": {
        "file_id": 55,
        "content": "from pyjom.commons import *\nfrom pyjom.languagetoolbox import englishTopicModeling, chineseTopicModeling\nfrom lazero.utils.tools import flattenUnhashableList  # one of my classic methods\nimport requests\n# import jieba\nfrom typing import Literal\ndef removeKeywordDuplicates(keywords):\n    keywordsType = type(keywords)\n    inputFuncs = {\n        str: lambda x: x.split(\" \"),\n        list: lambda x: x,\n        tuple: lambda x: list(x),\n    }\n    outputFuncs = {\n        str: lambda x: \" \".join(x),\n        list: lambda x: x,\n        tuple: lambda x: tuple(x),\n    }\n    if keywordsType in inputFuncs.keys():\n        keywordsList = inputFuncs[keywordsType](keywords)\n    else:\n        raise Exception(\"Unknown keywords type: %s\" % type(keywords))\n    keywordsSet = set(keywordsList)\n    keywordsSetList = list(keywordsSet)\n    return outputFuncs[keywordsType](keywordsSetList)\ndef topicModeling(sentences: list[str], lang=\"en\"):  # specify language please?\n    # python does not enforce type checking. use third party tool such as linter instead.",
        "type": "code",
        "location": "/pyjom/modules/topicGenerator/onlineTopicGenerator.py:1-33"
    },
    "753": {
        "file_id": 55,
        "content": "This code imports necessary modules and defines two functions: `removeKeywordDuplicates` for removing duplicate keywords in a list or string, and `topicModeling` for topic modeling with specified language (English or Chinese). It also includes an exception handling for unknown keyword types.",
        "type": "comment"
    },
    "754": {
        "file_id": 55,
        "content": "    if lang == \"en\":\n        topics = englishTopicModeling(sentences)\n        return topics\n    elif lang == \"zh\":\n        topics = chineseTopicModeling(sentences)\n        return topics\n    else:\n        raise Exception(\"Unknown language: %s\" % lang)\ndef topicWordSelection(\n    topics,\n    core_topic_set: set,\n    selected_topic_list: list,\n    mode: Literal[\"combined\", \"separate\"] = \"combined\",\n    threshold=10,\n):\n    if len(selected_topic_list) > threshold:\n        for _ in range(len(selected_topic_list) - threshold):\n            selected_topic_list.pop(0)  # right way to remove elem from original list.\n    selected_topic_set = set(list(core_topic_set) + selected_topic_list)\n    import random\n    mTopics = topics.copy()\n    random.shuffle(mTopics)\n    for topic in mTopics:\n        words = topic[mode]\n        words = [x for x in words if x not in selected_topic_set]\n        if len(words) > 0:\n            word = random.choice(words)\n            selected_topic_list.append(word)  # no need to go elsewhere.\n            return word",
        "type": "code",
        "location": "/pyjom/modules/topicGenerator/onlineTopicGenerator.py:34-65"
    },
    "755": {
        "file_id": 55,
        "content": "The code checks the language input and applies the appropriate topic modeling function. It then performs word selection by removing words already in the list, shuffling the remaining topics, and randomly choosing a new word to append to the selected_topic_list until it reaches a specified threshold.",
        "type": "comment"
    },
    "756": {
        "file_id": 55,
        "content": "    print(\"no topic word this time\")\n    return None\ndef getMetaTopicString(metaTopic):\n    staticCandidates = [random.choice(x) for x in metaTopic.get(\"static\", [])]\n    optionalCandidates = [random.choice(x) for x in metaTopic.get(\"optional\", [])]\n    if len(optionalCandidates) > 0:\n        optionalCandidates = random.choice(optionalCandidates)\n    if type(optionalCandidates) != list:\n        optionalCandidates = [optionalCandidates]\n    dynamicCandidates = [random.choice(x) for x in metaTopic.get(\"dynamic\", [])]\n    samples = random.sample(\n        dynamicCandidates, random.randint(0, len(dynamicCandidates))\n    )\n    # print(staticCandidates)\n    # print(optionalCandidates)\n    # print(samples)\n    # breakpoint()\n    return \" \".join(staticCandidates + optionalCandidates + samples)\n@decorator\ndef OnlineTopicGenerator(\n    source=\"giphy\",\n    metaTopic={\n        \"static\": [[\"dog\", \"cat\"], [\"funny\", \"cute\"]],\n        \"dynamic\": [[\"samoyed\", \"husky\", \"teddy\", \"chiwawa\"]],\n    },  # this is not a matrix.\n    # sample_size = 10 # per search.",
        "type": "code",
        "location": "/pyjom/modules/topicGenerator/onlineTopicGenerator.py:66-95"
    },
    "757": {
        "file_id": 55,
        "content": "The code defines a function called `getMetaTopicString` which takes a metaTopic dictionary as input and returns a string of topic words. It first generates static, optional, and dynamic candidates from the provided metaTopic dictionary. Then, it selects one candidate from each category and combines them into a final string. The code also includes a print statement and a breakpoint for debugging purposes. Finally, the decorator `@decorator` is used to apply some functionality to the `OnlineTopicGenerator` function.",
        "type": "comment"
    },
    "758": {
        "file_id": 55,
        "content": "    timeout:float=20\n):\n    getKeywords = lambda: getMetaTopicString(metaTopic)\n    core_topic_set = {\n        *flattenUnhashableList([value for key, value in metaTopic.items()])\n    }  # common way to initialize a set.\n    selected_topic_list = []\n    if source == \"giphy\":\n        waitForServerUp(8902, \"nodejs giphy server\")\n        keywords = getKeywords()\n        while True:\n            import time\n            time.sleep(0.5)\n            harvestedData = []\n            try:\n                source_type = random.choice([\"videos\", \"gifs\"])\n                # source_type = 'videos' # for debugging\n                if random.random() > 0.5:\n                    with requests.get(\n                        \"http://127.0.0.1:8902/random\",\n                        params={\"q\": keywords, \"rating\": \"g\", \"type\": source_type},\n                        verify=False,\n                        proxies=None,\n                        timeout=timeout\n                    ) as mRandomPicture:  # may you get stickers?\n                        mRandomPictureJson = mRandomPicture.json()",
        "type": "code",
        "location": "/pyjom/modules/topicGenerator/onlineTopicGenerator.py:96-122"
    },
    "759": {
        "file_id": 55,
        "content": "Code fetches random keywords from a metaTopic string and sends GET requests to a local server (running on 127.0.0.1:8902) for gifs or videos related to these keywords. If the keyword-related request is successful, it stores the result in mRandomPictureJson variable. This process continues until a timeout occurs or until another condition breaks the loop. The code also has debugging support by allowing the source_type to be hardcoded as 'videos'.",
        "type": "comment"
    },
    "760": {
        "file_id": 55,
        "content": "                        harvestedData += mRandomPictureJson[\"data\"]\n                        randomPictureId = mRandomPictureJson[\"data\"][0][\"id\"]\n                else:\n                    with requests.get(\n                        \"http://127.0.0.1:8902/search\",\n                        params={\"q\": keywords, \"rating\": \"g\", \"type\": source_type},\n                        verify=False,\n                        proxies=None,\n                        timeout=timeout\n                    ) as mSearchPictures:\n                        mSearchPicturesJson = mSearchPictures.json()\n                        harvestedData += mSearchPicturesJson[\"data\"]\n                        randomPictureId = random.choice(mSearchPicturesJson[\"data\"])[\n                            \"id\"\n                        ]\n                selectedWord = None\n                with requests.get(\n                    \"http://127.0.0.1:8902/related\",\n                    params={\n                        \"q\": randomPictureId,\n                        \"type\": source_type,",
        "type": "code",
        "location": "/pyjom/modules/topicGenerator/onlineTopicGenerator.py:123-143"
    },
    "761": {
        "file_id": 55,
        "content": "This code is making a request to an API, harvesting data based on keywords and type, and selecting a random picture. It also retrieves related words for the selected picture.",
        "type": "comment"
    },
    "762": {
        "file_id": 55,
        "content": "                    },\n                    verify=False,\n                    proxies=None,  # seems not working? wtf?\n                ) as mRelatedPictures:\n                    mRelatedPicturesJson = mRelatedPictures.json()\n                    harvestedData += mRelatedPicturesJson[\"data\"]\n                    sentences = [x[\"title\"] for x in mRelatedPicturesJson[\"data\"]]\n                    topics = topicModeling(sentences)\n                    selectedWord = topicWordSelection(\n                        topics, core_topic_set, selected_topic_list\n                    )\n                if not selectedWord is None:\n                    keywords = \" \".join(\n                        [getKeywords(), selectedWord]\n                    )  # for next iteration.\n                    print(\"REFRESHING KEYWORDS:\", keywords)\n                else:\n                    keywords = getKeywords()\n                # recheck keywords!\n                keywords = removeKeywordDuplicates(keywords)\n            except:\n                import traceback",
        "type": "code",
        "location": "/pyjom/modules/topicGenerator/onlineTopicGenerator.py:144-165"
    },
    "763": {
        "file_id": 55,
        "content": "This code segment fetches related pictures from a URL, performs topic modeling on the titles of these images, selects a word from the core topic set for further keyword generation, and handles potential exceptions.",
        "type": "comment"
    },
    "764": {
        "file_id": 55,
        "content": "                traceback.print_exc()\n                print(\"ERROR WHEN FETCHING GIPHY TOPIC\")\n            for elem in harvestedData:\n                yield elem[\"id\"], json_auto_float_int(elem[\"media\"])",
        "type": "code",
        "location": "/pyjom/modules/topicGenerator/onlineTopicGenerator.py:167-170"
    },
    "765": {
        "file_id": 55,
        "content": "This code block catches exceptions that may occur while fetching GIPHY topics. It prints the error trace and a descriptive message, then proceeds to iterate through the harvested data, yielding each entry's ID and media value after converting it using json_auto_float_int function.",
        "type": "comment"
    },
    "766": {
        "file_id": 56,
        "content": "/pyjom/modules/topicGenerator/localTopicGenerator.py",
        "type": "filepath"
    },
    "767": {
        "file_id": 56,
        "content": "The filesystemTopicGenerator function generates topics from file/directory paths, checking their validity and appending to a list of file names. It returns a dictionary with protocol, path, and content (filepaths).",
        "type": "summary"
    },
    "768": {
        "file_id": 56,
        "content": "from pyjom.commons import *\nimport os\n@decorator\ndef filesystemTopicGenerator(filepath=None, dirpath=None, recursive=False):\n    mfilelist = []\n    protocol = None\n    path = getHostname() + \"@\"\n    if filepath is not None:\n        assert os.path.isfile(filepath)\n        mpath = os.path.abspath(filepath)\n        protocol = \"file\"\n        path += mpath\n        mfilelist.append(mpath)\n    else:\n        assert dirpath is not None\n        assert os.path.isdir(dirpath)\n        dirpath = os.path.abspath(dirpath)\n        path += dirpath\n        if recursive:\n            protocol = \"dir_recursive\"\n            for _, _, files in os.walk(dirpath):\n                for fname in files:\n                    fpath = os.path.join(dirpath, fname)\n                    if os.path.isfile(fpath):\n                        # mpath = os.path.abspath(fpath)\n                        mfilelist.append(fpath)\n        else:\n            protocol = \"dir\"\n            mfiles = os.listdir(dirpath)\n            for fname in mfiles:\n                fpath = os.path.join(dirpath, fname)",
        "type": "code",
        "location": "/pyjom/modules/topicGenerator/localTopicGenerator.py:1-33"
    },
    "769": {
        "file_id": 56,
        "content": "The code defines a filesystemTopicGenerator function that generates topics from file or directory paths. It takes filepath and dirpath as input parameters, with optional recursive flag for directories. It checks if the given filepath exists or if the dirpath is a valid directory. If so, it appends the file/directory path to a list of file names. The protocol is set based on whether a file or directory was provided and used in generating topics.",
        "type": "comment"
    },
    "770": {
        "file_id": 56,
        "content": "                if os.path.isfile(fpath):\n                    # mpath = os.path.abspath(fpath)\n                    mfilelist.append(fpath)\n    return {\"protocol\": protocol, \"path\": path, \"content\": mfilelist}",
        "type": "code",
        "location": "/pyjom/modules/topicGenerator/localTopicGenerator.py:34-37"
    },
    "771": {
        "file_id": 56,
        "content": "Checks if a file exists at the specified path, appends absolute file paths to list, and returns a dictionary containing protocol, path, and content (filepaths).",
        "type": "comment"
    },
    "772": {
        "file_id": 57,
        "content": "/pyjom/modules/topicGenerator/dummyTopicGenerator.py",
        "type": "filepath"
    },
    "773": {
        "file_id": 57,
        "content": "The code imports the \"decorator\" function from the \"pyjom.commons\" module and defines two functions: \"dummyTopic()\" that returns the string \"pets\", and \"metaTopic(selected_source)\" which returns a list of titles based on the selected source. These functions are likely used for generating topic ideas or names.",
        "type": "summary"
    },
    "774": {
        "file_id": 57,
        "content": "from pyjom.commons import *\n@decorator\ndef dummyTopic():\n    return \"pets\"\n@decorator\ndef metaTopic(selected_source):\n    sources = {\n        \"baidu_baijiahao\": [\"shitty title1\"],\n        \"bilibili_trending\": [\"boy with women's clothes\"],\n    }\n    return sources[selected_source]",
        "type": "code",
        "location": "/pyjom/modules/topicGenerator/dummyTopicGenerator.py:1-15"
    },
    "775": {
        "file_id": 57,
        "content": "The code imports the \"decorator\" function from the \"pyjom.commons\" module and defines two functions: \"dummyTopic()\" that returns the string \"pets\", and \"metaTopic(selected_source)\" which returns a list of titles based on the selected source. These functions are likely used for generating topic ideas or names.",
        "type": "comment"
    },
    "776": {
        "file_id": 58,
        "content": "/pyjom/modules/topicGenerator/__init__.py",
        "type": "filepath"
    },
    "777": {
        "file_id": 58,
        "content": "This code imports modules from various topic generators (dummy, weibo, local, online) within the pyjom project. It appears to be related to generating topics or data for a specific purpose.",
        "type": "summary"
    },
    "778": {
        "file_id": 58,
        "content": "from pyjom.modules.topicGenerator.dummyTopicGenerator import *\nfrom pyjom.modules.topicGenerator.weiboTopicGenerator import *\nfrom pyjom.modules.topicGenerator.localTopicGenerator import *\nfrom pyjom.modules.topicGenerator.onlineTopicGenerator import *",
        "type": "code",
        "location": "/pyjom/modules/topicGenerator/__init__.py:1-4"
    },
    "779": {
        "file_id": 58,
        "content": "This code imports modules from various topic generators (dummy, weibo, local, online) within the pyjom project. It appears to be related to generating topics or data for a specific purpose.",
        "type": "comment"
    },
    "780": {
        "file_id": 59,
        "content": "/pyjom/modules/methodIdentifier/dummyIdentifier.py",
        "type": "filepath"
    },
    "781": {
        "file_id": 59,
        "content": "The code defines a function `dummyId()` that generates a unique UUID and a class `dummyIdentifier` with instance variables and methods to store fix information related to various components of a system.",
        "type": "summary"
    },
    "782": {
        "file_id": 59,
        "content": "def dummyId():\n    import uuid\n    return uuid.uuid4()\nclass dummyIdentifier:\n    def __init__(self, uuid):\n        self.uuid = uuid\n        self.data = {}\n    def typeFix(self, typeFix):\n        self.data[\"typeFix\"] = typeFix\n    def topicFix(self, topicFix):\n        self.data[\"topicFix\"] = topicFix\n    def infoFix(self, infoFix):\n        self.data[\"infoFix\"] = infoFix\n    def producerFix(self, producerFix):\n        self.data[\"producerFix\"] = producerFix\n    def posterFix(self, posterFix):\n        self.data[\"posterFix\"] = posterFix\n    def feedbackFix(self, feedbackFix):\n        self.data[\"feedbackFix\"] = feedbackFix\n    def updatorFix(self, updatorFix):\n        self.data[\"updatorFix\"] = updatorFix\n    def fetcherFix(self, fetcherFix):\n        self.data[\"fetcherFix\"] = fetcherFix\n    def processorFix(self, processorFix):\n        self.data[\"processorFix\"] = processorFix\n    def optimizerFix(self, optimizerFix):\n        self.data[\"optimizerFix\"] = optimizerFix\n    def reviewerFix(self, reviewerFix):\n        self.data[\"reviewerFix\"] = reviewerFix",
        "type": "code",
        "location": "/pyjom/modules/methodIdentifier/dummyIdentifier.py:1-43"
    },
    "783": {
        "file_id": 59,
        "content": "The code defines a function `dummyId()` that generates a unique UUID and a class `dummyIdentifier` with instance variables and methods to store fix information related to various components of a system.",
        "type": "comment"
    },
    "784": {
        "file_id": 60,
        "content": "/pyjom/modules/methodIdentifier/__init__.py",
        "type": "filepath"
    },
    "785": {
        "file_id": 60,
        "content": "This code imports all the contents from the \"dummyIdentifier\" module in the \"pyjom.modules.methodIdentifier\" package.",
        "type": "summary"
    },
    "786": {
        "file_id": 60,
        "content": "from pyjom.modules.methodIdentifier.dummyIdentifier import *",
        "type": "code",
        "location": "/pyjom/modules/methodIdentifier/__init__.py:1-1"
    },
    "787": {
        "file_id": 60,
        "content": "This code imports all the contents from the \"dummyIdentifier\" module in the \"pyjom.modules.methodIdentifier\" package.",
        "type": "comment"
    },
    "788": {
        "file_id": 61,
        "content": "/pyjom/modules/contentReviewer/weiboSearchReviewer.py",
        "type": "filepath"
    },
    "789": {
        "file_id": 61,
        "content": "This code snippet defines a function called weiboSearchReviewer that reviews content for keywords and censors elements using the weiboCensor function. It prints details, appends reviews to a dictionary, and returns mreview.",
        "type": "summary"
    },
    "790": {
        "file_id": 61,
        "content": "from pyjom.commons import *\nfrom pyjom.modules.contentCensoring.core import weiboCensor\nimport json\n@decorator\ndef weiboSearchReviewer(content, basedir=None, auto=False, semiauto=True,dummy_auto=True,template_names=[], args={}):\n    mreview = {}\n    for key in content.keys():\n        print(\"keyword:\", key)\n        print(\"_\" * 20)\n        mreview[key] = []\n        mcontent = content[key]\n        for elem in mcontent:\n            print(\"element inside:\")\n            print(\"_\" * 20)\n            meta = elem[\"meta\"]\n            feedback = elem[\"feedback\"]\n            _, pretty_printed = jsonPrettyPrint(elem)\n            print(pretty_printed)\n            review, source = weiboCensor(\n                elem, basedir=basedir, semiauto=semiauto, auto=auto, dummy_auto=dummy_auto,template_names=template_names ,args=args\n            )  # unnoticed source.\n            review[\"meta\"] = meta\n            review[\"feedback\"] = feedback\n            print(\"review:\", review)\n            mreview[key].append({\"review\": review, \"source\": source})",
        "type": "code",
        "location": "/pyjom/modules/contentReviewer/weiboSearchReviewer.py:1-27"
    },
    "791": {
        "file_id": 61,
        "content": "This function, weiboSearchReviewer, reviews content for various keywords and calls the weiboCensor function to censor elements. It prints each keyword and element, and then appends the review and source of the review to a dictionary with the corresponding keyword as key. The reviewed content is stored in mreview.",
        "type": "comment"
    },
    "792": {
        "file_id": 61,
        "content": "    return mreview",
        "type": "code",
        "location": "/pyjom/modules/contentReviewer/weiboSearchReviewer.py:28-28"
    },
    "793": {
        "file_id": 61,
        "content": "This code snippet is returning the variable \"mreview\" after performing some operation.",
        "type": "comment"
    },
    "794": {
        "file_id": 62,
        "content": "/pyjom/modules/contentReviewer/localReviewer.py",
        "type": "filepath"
    },
    "795": {
        "file_id": 62,
        "content": "This code defines `filesystemReviewer` for content review, including `filesystemReviewerCoreAnalyzer` and `filesystemReviewerNoGenerator`. It handles analysis, censoring, and returns results. `localReviewer` is created for local processing with arguments args, template_names, and debug.",
        "type": "summary"
    },
    "796": {
        "file_id": 62,
        "content": "from pyjom.commons import jsonPrettyPrint,decorator\nfrom pyjom.modules.contentCensoring.core import localCensor\nimport json\ndef filesystemReviewerCoreAnalyzer(\n    elem, auto=False, semiauto=True, dummy_auto=True, args={}, template_names=[], debug=True\n):\n    if debug:\n        print(\"element inside:\")\n        print(\"_\" * 20)\n        _, pretty_printed = jsonPrettyPrint(elem)\n        print(pretty_printed)\n    # print(\"ELEMENT\", elem)\n    # breakpoint()\n    review, source = localCensor(\n        elem,\n        auto=auto,\n        semiauto=semiauto,\n        dummy_auto=dummy_auto,\n        args=args,\n        template_names=template_names,\n    )  # unnoticed source.\n    if debug:\n        print(\"review:\")\n        # breakpoint()\n        print(json.dumps(review, indent=4))\n    reviewResult = {\"review\": review, \"source\": source}\n    return reviewResult\ndef filesystemReviewerNoGenerator(\n    content,**kwargs\n):\n    mreview = []\n    for elem in content:\n        reviewResult = filesystemReviewerCoreAnalyzer(\n            elem,**kwargs\n        )",
        "type": "code",
        "location": "/pyjom/modules/contentReviewer/localReviewer.py:1-39"
    },
    "797": {
        "file_id": 62,
        "content": "This code defines two functions for content reviewing: `filesystemReviewerCoreAnalyzer` and `filesystemReviewerNoGenerator`. The `filesystemReviewerCoreAnalyzer` function analyzes an element, applies content censoring with optional automation settings, and returns a review result containing the review and source. The `filesystemReviewerNoGenerator` function iterates over content elements, using `filesystemReviewerCoreAnalyzer` to analyze each element and return a list of review results.",
        "type": "comment"
    },
    "798": {
        "file_id": 62,
        "content": "        mreview.append(reviewResult)\n    return mreview\ndef filesystemReviewerGenerator(\n    content, **kwargs\n):\n    # mreview = []\n    for elem in content:\n        reviewResult = filesystemReviewerCoreAnalyzer(\n            elem,**kwargs\n        )\n        yield reviewResult\n    #     mreview.append(reviewResult)\n    # return mreview\n@decorator\ndef filesystemReviewer(\n    content,\n    auto=False,\n    semiauto=True,\n    dummy_auto=True,\n    args={},\n    template_names=[],\n    generator: bool = False,\n    debug=True\n):\n    # print(content)\n    # print('generator flag', generator)\n    # link = content[\"link\"]\n    if not generator:\n        return filesystemReviewerNoGenerator(\n            content,\n            auto=auto,\n            semiauto=semiauto,\n            dummy_auto=dummy_auto,\n            args=args,\n            template_names=template_names,\n            debug=debug\n        )\n    else:\n        return filesystemReviewerGenerator(\n            content,\n            auto=auto,\n            semiauto=semiauto,\n            dummy_auto=dummy_auto,",
        "type": "code",
        "location": "/pyjom/modules/contentReviewer/localReviewer.py:40-86"
    },
    "799": {
        "file_id": 62,
        "content": "This code defines a function `filesystemReviewer` which, depending on the generator flag parameter, returns either the result of `filesystemReviewerNoGenerator` or a review generator using the `filesystemReviewerGenerator` function. The review generator iterates over content elements and yields the results from each call to the `filesystemReviewerCoreAnalyzer`.",
        "type": "comment"
    }
}