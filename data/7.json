{
    "700": {
        "file_id": 50,
        "content": "        print(\"media type:\",mediatype)\n    # handle to ffmpeg.\n    mediaFunctions = {\"video\":videoFsProcessor,\"audio\":audioFsProcessor,\"image\":imageFsProcessor}\n    data = mediaFunctions[mediatype](path,args=args,previous=previous, medialangTmpDir = medialangTmpDir)\n    return data",
        "type": "code",
        "location": "/pyjom/medialang/processors/mediaProcessor/filesystemProcessor.py:29-33"
    },
    "701": {
        "file_id": 50,
        "content": "This code segment handles media processing based on the type. It prints the media type, creates a dictionary of function handlers for video, audio, and image, processes the media using the corresponding function, and returns the result.",
        "type": "comment"
    },
    "702": {
        "file_id": 51,
        "content": "/pyjom/modify_package.sh",
        "type": "filepath"
    },
    "703": {
        "file_id": 51,
        "content": "This script searches for Python files (.py), then replaces specific module imports (\"from modules\", \"from main\", etc.) with their new corresponding pyjom paths using sed command.",
        "type": "summary"
    },
    "704": {
        "file_id": 51,
        "content": "find | grep -E \".py\\$\" | xargs -iabc sed -i \"s/from modules/from pyjom.modules/g\" abc\nfind | grep -E \".py\\$\" | xargs -iabc sed -i \"s/from main/from pyjom.main/g\" abc \nfind | grep -E \".py\\$\" | xargs -iabc sed -i \"s/from commons/from pyjom.commons/g\" abc\nfind | grep -E \".py\\$\" | xargs -iabc sed -i \"s/from config/from pyjom.config/g\" abc\nfind | grep -E \".py\\$\" | xargs -iabc sed -i \"s/from medialang/from pyjom.medialang/g\" abc\nfind | grep -E \".py\\$\" | xargs -iabc sed -i \"s/from primitives/from pyjom.primitives/g\" abc",
        "type": "code",
        "location": "/pyjom/modify_package.sh:1-6"
    },
    "705": {
        "file_id": 51,
        "content": "This script searches for Python files (.py), then replaces specific module imports (\"from modules\", \"from main\", etc.) with their new corresponding pyjom paths using sed command.",
        "type": "comment"
    },
    "706": {
        "file_id": 52,
        "content": "/pyjom/modules/__init__.py",
        "type": "filepath"
    },
    "707": {
        "file_id": 52,
        "content": "Importing various modules for different functionalities in the pyjom framework.",
        "type": "summary"
    },
    "708": {
        "file_id": 52,
        "content": "from pyjom.modules.methodIdentifier import *\nfrom pyjom.modules.topicGenerator import *\nfrom pyjom.modules.informationGathering import *\nfrom pyjom.modules.informationProcessing import *\nfrom pyjom.modules.contentProducing import *\nfrom pyjom.modules.contentPosting import *\nfrom pyjom.modules.feedbackCollecting import *\nfrom pyjom.modules.globalOptimizer import *\nfrom pyjom.modules.globalUpdator import *\nfrom pyjom.modules.contentReviewer import *\nfrom pyjom.modules.contentCensoring import *",
        "type": "code",
        "location": "/pyjom/modules/__init__.py:1-11"
    },
    "709": {
        "file_id": 52,
        "content": "Importing various modules for different functionalities in the pyjom framework.",
        "type": "comment"
    },
    "710": {
        "file_id": 53,
        "content": "/pyjom/modules/contentCensoring/__init__.py",
        "type": "filepath"
    },
    "711": {
        "file_id": 53,
        "content": "This code imports two parts, label and filter, from the contentCensoring module's core and autoCensor submodules in the pyjom library.",
        "type": "summary"
    },
    "712": {
        "file_id": 53,
        "content": "# two parts: label and filter\nfrom pyjom.modules.contentCensoring.core import *\nfrom pyjom.modules.contentCensoring.autoCensor import *",
        "type": "code",
        "location": "/pyjom/modules/contentCensoring/__init__.py:1-3"
    },
    "713": {
        "file_id": 53,
        "content": "This code imports two parts, label and filter, from the contentCensoring module's core and autoCensor submodules in the pyjom library.",
        "type": "comment"
    },
    "714": {
        "file_id": 54,
        "content": "/pyjom/modules/contentCensoring/autoCensor.py",
        "type": "filepath"
    },
    "715": {
        "file_id": 54,
        "content": "This code provides content censoring functionality for media processing software using Tkinter and optional parameters, as well as a semi-auto blacklist feature. It removes specified key-value pairs from the dictionary.",
        "type": "summary"
    },
    "716": {
        "file_id": 54,
        "content": "from tkinter import *\nfrom pyjom.commons import *\nfrom pyjom.medialang.core import *\ndef dummyAutoCensor(contentPath, meta, semiauto=False):\n    mdata = {\n        \"dummyAutoCensor\": {\n            \"input\": {\"path\": contentPath, \"meta\": meta},\n            \"result\": \"some content here!\",\n        }\n    }\n    return mdata\ndef autoCensor(contentPath, meta, template_names=[], semiauto=False, args={}):\n    from pyjom.medialang.core import Medialang\n    mdata = {}\n    template_dirs = [\"medialang\", \"autoCensor\"]\n    medialang_template_paths = template_names  # not always need all templates.\n    semiauto_key_blacklist = []\n    semiauto_template_path_blacklist = []\n    if semiauto:\n        medialang_template_paths = [\n            x\n            for x in medialang_template_paths\n            if x not in semiauto_template_path_blacklist\n        ]\n    for template_name in medialang_template_paths:\n        name = template_name.split(\".\")[0]  # check if starts with meta.\n        template_path = getTemplatePath(template_dirs, template_name)",
        "type": "code",
        "location": "/pyjom/modules/contentCensoring/autoCensor.py:1-31"
    },
    "717": {
        "file_id": 54,
        "content": "This code is for content censoring in a media processing software. It utilizes Tkinter and other modules for functionality, provides a dummy auto-censorship function, and an actual auto-censorship function with optional parameters like template names and semi-auto mode. It also includes a list of blacklisted templates if semi-auto mode is enabled.",
        "type": "comment"
    },
    "718": {
        "file_id": 54,
        "content": "        template_args = {} if name not in args.keys() else args[name]\n        assert type(template_args) == dict\n        if name.startswith(\"meta_\"):\n            template_args.update({\"meta\": meta})  # you can access it by keys.\n        template_args.update({\"mediafile\": contentPath})\n        # print(\"template_args\")\n        # breakpoint()\n        medialang = Medialang(\n            script_path=template_path,\n            template=True,\n            template_args=template_args,  # config inside the template args. None to use the default.\n        )\n        script = medialang.prettify()\n        print(script)\n        # breakpoint()\n        data = medialang.execute()\n        # print(\"DATA\",data)\n        # breakpoint()\n        # # try:\n        data = data[0][0]  # language feature.\n        # what the fuck is wrong?\n        mdata.update({name: data})  # this is not so good, though.\n        # except:\n            # print('skipping marking data')\n    if semiauto:  # need some modification.\n        for key in semiauto_key_blacklist:",
        "type": "code",
        "location": "/pyjom/modules/contentCensoring/autoCensor.py:32-57"
    },
    "719": {
        "file_id": 54,
        "content": "This code takes a name and dictionary of arguments, checks if the name matches a specific key in the arguments dictionary. If it does, it adds \"meta\" and \"mediafile\" keys to the template_args dictionary, then creates an instance of Medialang with the script path, template set to True, and template_args. The script is prettified, executed, and the data returned. Lastly, the data is added to the mdata dictionary under the given name, unless there was an issue where it prints \"skipping marking data\". If semiauto is set, it goes through a loop for each key in semiauto_key_blacklist.",
        "type": "comment"
    },
    "720": {
        "file_id": 54,
        "content": "            mdata.pop(key)\n    return mdata",
        "type": "code",
        "location": "/pyjom/modules/contentCensoring/autoCensor.py:58-59"
    },
    "721": {
        "file_id": 54,
        "content": "Removing specified key-value pair from the dictionary and returning the updated dictionary.",
        "type": "comment"
    },
    "722": {
        "file_id": 55,
        "content": "/pyjom/modules/contentCensoring/core.py",
        "type": "filepath"
    },
    "723": {
        "file_id": 55,
        "content": "This code creates a media downloader GUI with library integration, progress updates, customizable appearance, and tabular post topics. It uses decorator function `keywordDecorator` to censor media based on input parameters and handles unknown content types with exceptions.",
        "type": "summary"
    },
    "724": {
        "file_id": 55,
        "content": "from tkinter import *\nfrom pyjom.commons import *\nfrom pyjom.modules.contentCensoring.autoCensor import *\n# import tkinter.font\nimport requests\nimport traceback\nimport os\nimport command_spawner\nfrom progressbar import *\n# add progressbar\ndef mediaDownloader(url, mblogid, basedir=None, index=None):\n    try:\n        with requests.get(url) as r: # what is the media file suffix?\n            suffix = url.split(\"?\")[0].split(\".\")[-1]\n            mid = mblogid if index is None else \"{}[{}]\".format(mblogid, index)\n            fname = \"{}.{}\".format(mid, suffix)\n            if not os.path.exists(basedir):\n                os.mkdir(basedir)\n            fpath = os.path.join(basedir, fname)\n            size = int(r.headers[\"Content-Length\"].strip())\n            mbytes = 0\n            widgets = [\n                fpath,\n                \": \",\n                Bar(marker=\"|\", left=\"[\", right=\" \"),\n                Percentage(),\n                \" \",\n                FileTransferSpeed(),\n                \"] \",\n                \" of {0}MB\".format(str(round(size / 1024 / 1024, 2))[:4]),",
        "type": "code",
        "location": "/pyjom/modules/contentCensoring/core.py:1-32"
    },
    "725": {
        "file_id": 55,
        "content": "This code snippet is for a media downloader function that uses the requests library to download a file from a given URL. It also includes functionality for handling progress updates using the progressbar module, and it creates a folder to store the downloaded files if one does not already exist. The function takes in parameters such as the URL of the file to be downloaded, an optional mblog ID (and index) for creating a unique file name based on this ID, and an optional base directory where the files will be stored. If no base directory is provided, it will create one automatically with the specified name. The function determines the file's suffix by parsing the URL and extracting the last part of the string after any query parameters. Once the download starts, it tracks progress using a widget that displays a bar indicating the percentage completed, along with other information like the current file transfer speed. It also calculates and displays the size of the file in MB as it downloads.",
        "type": "comment"
    },
    "726": {
        "file_id": 55,
        "content": "            ]\n            pbar = ProgressBar(widgets=widgets, maxval=size).start()\n            mfile = []\n            for buf in r.iter_content(1024):\n                if buf:\n                    mfile.append(buf)\n                    mbytes += len(buf)\n                    pbar.update(mbytes)\n            pbar.finish()\n            print(\"saved to {}\".format(fpath))\n            with open(fpath, \"wb\") as f:\n                for byteContent in mfile:\n                    f.write(byteContent)\n            return fpath\n    except:\n        traceback.print_exc()\n        print(\"error in mediaDownloader:\\n\", url)\n    return None\nx_buffer = None\ntag_x_offset =None\ntag_y_counter =None\ndef censorInterface(\n    mtitle, mtopic, mcontent,mtags=[], local=False\n):  # this could be a standard template.\n    global x_buffer,tag_x_offset,tag_y_counter\n    assert type(mtopic) == list\n    assert type(mtags) == list\n    is_on = {key:False for key in mtags}\n    def switch(key, buttons, index, is_on):\n        button = buttons[index]\n        if is_on[key]:",
        "type": "code",
        "location": "/pyjom/modules/contentCensoring/core.py:33-65"
    },
    "727": {
        "file_id": 55,
        "content": "The code downloads media content from a URL and saves it to the specified file path. It also includes error handling using try-except block and traceback. The function censorInterface seems to be an interface for switching between tags, where the user can toggle the visibility of different tags on or off.",
        "type": "comment"
    },
    "728": {
        "file_id": 55,
        "content": "            button.config(text=key ,bg = \"grey\",fg=\"black\")\n            is_on[key] = False\n        else:\n            button.config(text = key,bg = \"green\",fg=\"white\")\n            is_on[key] = True\n    def getSwitchLambda(text, on_buttons, index, is_on):\n        return lambda:switch(text, on_buttons, index, is_on)\n    on_buttons = []\n    mfunctions = []\n    mdata = {\"labels\": [], \"comment\": None, \"discard\": False}\n    left, top = 1500, 500\n    parent = Tk()\n    parent.geometry(\"+{}+{}\".format(left, top))\n    # parent\n    default_window_size =(460,400)\n    parent.geometry(\"{0}x{1}\".format(*default_window_size))\n    themepath = joinScriptFileBaseDir(__file__, \"Forest-ttk-theme/forest-dark.tcl\")\n    parent.tk.call(\"source\", themepath)\n    parent.attributes(\"-topmost\", True)\n    if not local:\n        title = Label(\n            parent,\n            text=\"Title:\" + \"\\n\" * 4,\n            fg=\"white\",\n        )\n        title.grid(row=0, column=0, sticky=\"e\")\n        text0 = Text(fg=\"aqua\", height=5, width=24)\n        text0.grid(row=0, column=1)",
        "type": "code",
        "location": "/pyjom/modules/contentCensoring/core.py:66-98"
    },
    "729": {
        "file_id": 55,
        "content": "This code sets up a window with buttons, configures their appearance and state based on the given 'is_on' variable, and provides functions for handling button clicks. It also handles window geometry and theme customization.",
        "type": "comment"
    },
    "730": {
        "file_id": 55,
        "content": "        text0.insert(END, mtitle)\n        # print(mtopic)\n        mlabel = (  # not designed for sina topic format.\n            \"None\" if mtopic == None else \" \".join([\"[{}]\".format(x) for x in mtopic])\n        )\n        label = Label(\n            parent,\n            text=\"Topics:\" + \"\\n\" * 4,\n            fg=\"aqua\",\n        )\n        label.grid(row=1, column=0, sticky=\"e\")\n        text1 = Text(fg=\"aqua\", height=5, width=24)\n        text1.grid(row=1, column=1)\n        text1.insert(END, mlabel)\n        content = Label(\n            parent,\n            text=\"Content:\" + \"\\n\" * 4,\n            fg=\"white\",\n        )\n        content.grid(row=2, column=0, sticky=\"e\")\n        text2 = Text(fg=\"aqua\", height=5, width=24)\n        text2.grid(row=2, column=1)\n        text2.insert(END, mcontent)\n        conrow = 3\n    else:\n        conrow = 0\n    redbutton = Entry(parent, fg=\"red\")\n    redbutton.grid(row=0 + conrow, column=1, sticky=\"ew\")\n    # button_height = 32 # default height?\n    x_buffer = 10\n    tag_x_offset = 0\n    tag_y_counter = 0",
        "type": "code",
        "location": "/pyjom/modules/contentCensoring/core.py:99-134"
    },
    "731": {
        "file_id": 55,
        "content": "This code snippet creates a GUI for displaying post topics and content in a tabular format. It includes labels, text boxes, and a red button. The code handles the case where a topic is given or not, and adjusts the positioning accordingly. The variable \"conrow\" keeps track of the row position for the red button. Variables like \"x_buffer\", \"tag_x_offset\", and \"tag_y_counter\" are used for positioning elements on the screen.",
        "type": "comment"
    },
    "732": {
        "file_id": 55,
        "content": "    # print(\"TEXT:\", text)\n    def placeTagButtons(index, text,tag_x_offset, tag_y_counter, x_buffer, on=False):\n        # global\n        if not on:\n            mButton = Button(parent, text=text, bd = 0,bg=\"grey\",fg=\"black\")\n        else:\n            mButton = Button(parent, text=text, bd = 0,bg=\"green\",fg=\"white\")\n        button_width = mButton.winfo_reqwidth()\n        # 65\n        button_height = mButton.winfo_reqheight()\n        # print(button_width, button_height)\n        # breakpoint()\n        on_buttons.append(mButton)\n        mfunctions.append(getSwitchLambda(text, on_buttons, index, is_on))\n        on_buttons[index].config(command=mfunctions[index])\n        # on_buttons[index].grid_forget()\n        estimate_x_size = tag_x_offset+x_buffer+button_width\n        estimated_y_size = default_window_size[1]+ button_width*1.3*(tag_y_counter+1)\n        if estimate_x_size > default_window_size[0]:\n            tag_x_offset = 0\n            tag_y_counter+=1\n            # change window geometry\n            parent",
        "type": "code",
        "location": "/pyjom/modules/contentCensoring/core.py:135-158"
    },
    "733": {
        "file_id": 55,
        "content": "This code defines a function `placeTagButtons` which creates buttons with specified text and positions them in a window, adjusting the position based on available space. The button color depends on its 'on' parameter, and it stores the button and associated command for later use.",
        "type": "comment"
    },
    "734": {
        "file_id": 55,
        "content": ".geometry(\"{0}x{1}\".format(default_window_size[0], int(default_window_size[1]+ button_height*0.1+(tag_y_counter+1)*button_height*1.2)))\n        elif estimated_y_size > default_window_size[1]:\n            parent.geometry(\"{0}x{1}\".format(default_window_size[0], int(default_window_size[1]+ button_height*0.1+(tag_y_counter+1)*button_height*1.2)))\n        on_buttons[index].place(x=tag_x_offset+x_buffer, y=default_window_size[1]+ button_height*0.1+tag_y_counter*button_height*1.2)\n        tag_x_offset+= button_width\n        return tag_x_offset,tag_y_counter\n        # print(dir(mButton))\n    for index, text in enumerate(is_on.keys()):\n        tag_x_offset,tag_y_counter = placeTagButtons(index, text, tag_x_offset,tag_y_counter, x_buffer)\n        # 32\n        # breakpoint()\n    def add_tag():\n        global tag_x_offset, tag_y_counter, x_buffer\n        mtext = redbutton.get()\n        mtext = mtext.strip()\n        if mtext != \"\": # that is the base line\n            redbutton.delete(0, END)\n            # change this shit.",
        "type": "code",
        "location": "/pyjom/modules/contentCensoring/core.py:158-176"
    },
    "735": {
        "file_id": 55,
        "content": "The code is setting the window geometry and placing button elements on the screen based on certain conditions. It calculates the dimensions and positions of buttons to fit within the available window space, while keeping track of the x-offset and y-counter for future button placement. The code also includes a function called \"add_tag\" that takes user input and checks if it's not empty before making further actions.",
        "type": "comment"
    },
    "736": {
        "file_id": 55,
        "content": "            # mdata[\"labels\"].append(mtext)\n            if mtext not in is_on.keys():\n                is_on.update({mtext:True}) # enable this tag anyway.\n                # and we do some append task here.\n                tag_x_offset, tag_y_counter=placeTagButtons(len(on_buttons), mtext,tag_x_offset, tag_y_counter, x_buffer, on=True)\n    bluebutton = Button(parent, text=\"ADD TAG\", fg=\"aqua\", command=add_tag)\n    bluebutton.grid(row=0 + conrow, column=0, sticky=\"e\")\n    redbutton3 = Label(parent, text=\"Comment:\", fg=\"red\")\n    redbutton3.grid(row=1 + conrow, column=0, sticky=\"e\")\n    redbutton2 = Entry(parent, fg=\"red\")\n    def add_comment():\n        comment = redbutton2.get()\n        if comment != \"\":\n            mdata[\"comment\"] = comment\n    redbutton2.grid(row=1 + conrow, column=1, sticky=\"ew\")\n    def mdestroy():\n        add_tag()\n        add_comment()\n        parent.destroy()\n    def mdestroy2():\n        mdata[\"discard\"] = True\n        parent.destroy()\n    blackbutton = Button(parent, text=\"SUBMIT\", fg=\"red\", command=mdestroy)",
        "type": "code",
        "location": "/pyjom/modules/contentCensoring/core.py:177-206"
    },
    "737": {
        "file_id": 55,
        "content": "This code creates a GUI window for adding tags and comments to content. It enables any previously unused tag, places tag buttons, adds an \"ADD TAG\" button, sets up a comment input field with a \"SUBMIT\" button, and defines functions for adding tags and comments and closing the window.",
        "type": "comment"
    },
    "738": {
        "file_id": 55,
        "content": "    blackbutton.grid(row=1 + conrow, column=2, sticky=\"e\")\n    blackbutton2 = Button(parent, text=\"KILL\", fg=\"yellow\", command=mdestroy2)\n    blackbutton2.grid(row=0 + conrow, column=2, sticky=\"ew\")\n    parent.bind(\"<Return>\", lambda event=None: bluebutton.invoke())\n    parent.bind(\"<Control-Return>\", lambda event=None: mdestroy())\n    # this is for updating the order of tags.\n    parent.bind(\"<KeyRelease>\", lambda event=None: print(\"KEY RELEASED! PLEASE CONSIDER TO BIND THIS EVENT TO UPDATING TAGS ORDER BY INPUT\"))\n    # this is for updating the order of tags.\n    parent.mainloop()\n    mdata[\"labels\"] = [x for x in is_on.keys() if is_on[x]]\n    mdata[\"total_labels\"] = [x for x in is_on.keys()]\n    return mdata\ndef playMedia(mediaPath):\n    cmdline = \"ffplay -alwaysontop -loop 0 -top 0 -left 0 {}\".format(mediaPath)\n    cs = command_spawner.CommandSpawner(command=cmdline, daemon=True)\n    cs.run()\n    return cs\ndef coreMediaCensor(\n    mediaPath,\n    meta,\n    play=True,\n    auto=False,\n    semiauto=True,\n    local=False,",
        "type": "code",
        "location": "/pyjom/modules/contentCensoring/core.py:207-234"
    },
    "739": {
        "file_id": 55,
        "content": "This code includes functions for playing media, core media censoring functionality, and interacting with a GUI. It spawns a command to play media in the background, binds keyboard events, and updates labels' order when a key is released.",
        "type": "comment"
    },
    "740": {
        "file_id": 55,
        "content": "    dummy_auto=True,\n    args={},\n    template_names=[],\n):\n    assert type(local) == bool\n    mtitle, mtopic, mcontent = meta\n    censor_method = (\n        keywordDecorator(autoCensor, args=args, template_names=template_names)\n        if not dummy_auto\n        else dummyAutoCensor\n    )\n    if ((not auto) or semiauto) and play:\n        cs = playMedia(mediaPath)  # siderun.\n        if not auto:\n            mdata = censorInterface(mtitle, mtopic, mcontent, local=local)\n        else:\n            nextData = censor_method(\n                mediaPath, meta, semiauto=semiauto\n            )  # this will not approve the thing. only generate tags and metadata.\n            mdata = censorInterface(mtitle, mtopic, mcontent, local=True)\n            mdata.update(nextData)\n    else:\n        mdata = censor_method(mediaPath, meta, semiauto=semiauto)\n    if ((not auto) or semiauto) and play:\n        cs.kill()\n        os.system(\"killall ffplay\")\n    return mdata\n@decorator\ndef weiboCensor(\n    content,\n    basedir=None,\n    auto=False,\n    semiauto=True,",
        "type": "code",
        "location": "/pyjom/modules/contentCensoring/core.py:235-269"
    },
    "741": {
        "file_id": 55,
        "content": "This code uses a decorator function, `keywordDecorator`, to apply different censoring methods based on the input parameters. If `auto` is False or `semiauto` is True and `play` is True, it calls `playMedia` and applies censoring using the `censor_method`. If `auto` is True, it only generates tags and metadata without approving the content. It also kills any running ffplay instances after playback if necessary.",
        "type": "comment"
    },
    "742": {
        "file_id": 55,
        "content": "    dummy_auto=True,\n    args={},\n    template_names=[],\n):\n    groupArgs = {\n        \"template_names\": template_names,\n        \"auto\": auto,\n        \"semiauto\": semiauto,\n        \"dummy_auto\": dummy_auto,\n        \"args\": args,\n    }\n    if (not auto) or semiauto:\n        os.system(\"killall ffplay\")\n    # we only need video.\n    data = {\"type\": \"text\", \"review\": None}\n    mtitle = content[\"title\"]\n    mtopic = (\n        None if content[\"topic\"] is None else [x[0] for x in content[\"topic\"]]\n    )  # excerpt the topic name only\n    mcontent = content[\"text\"][\"raw\"]\n    meta = (mtitle, mtopic, mcontent)\n    if content[\"video\"] is not None:\n        data[\"type\"] = \"video\"\n        videoUrl = content[\"video\"][\"download_link\"]\n        mblogid = content[\"meta\"][\"mblogid\"]\n        videoPath = mediaDownloader(videoUrl, mblogid, basedir=basedir)\n        mdata = coreMediaCensor(videoPath, meta, **groupArgs)\n        data[\"review\"] = (videoPath, mdata)\n        # return mdata\n    elif content[\"picture\"] is not None and content[\"picture\"] is not []:",
        "type": "code",
        "location": "/pyjom/modules/contentCensoring/core.py:270-299"
    },
    "743": {
        "file_id": 55,
        "content": "This code is creating a dictionary called \"groupArgs\" that holds various parameters. It then checks if the \"auto\" parameter is False or if \"semiauto\" is set, in which case it kills a process named \"ffplay\". Next, it sets the data type to \"text\" and initializes variables for title, topic, and content. If there's a video available, it updates the data type to \"video\", downloads the video, and calls a function \"coreMediaCensor\" with additional parameters. Finally, if there is a picture available but no video, it continues execution.",
        "type": "comment"
    },
    "744": {
        "file_id": 55,
        "content": "        data[\"type\"] = \"picture\"\n        data[\"review\"] = []\n        for index, pictureUrl in enumerate(content[\"picture\"]):\n            picturePath = mediaDownloader(\n                pictureUrl, mblogid, basedir=basedir, index=index\n            )\n            mdata = coreMediaCensor(picturePath, meta, **groupArgs)\n            data[\"review\"].append((picturePath, mdata))\n    else:\n        # just display the raw content.\n        mdata = coreMediaCensor(\n            None, meta, play=False, **groupArgs\n        )  # how to automate this shit?\n        data[\"review\"] = mdata\n    return data\n@decorator\ndef localCensor(\n    content, auto=False, semiauto=True, dummy_auto=True, args={}, template_names=[]\n):\n    # examine local files.\n    # first determine the content type.\n    groupArgs = {\n        \"auto\": auto,\n        \"semiauto\": semiauto,\n        \"dummy_auto\": dummy_auto,\n        \"template_names\": template_names,\n        \"args\": args,\n    }\n    if (not auto) or semiauto:\n        os.system(\"killall ffplay\")\n    # you may play the media as well.",
        "type": "code",
        "location": "/pyjom/modules/contentCensoring/core.py:300-332"
    },
    "745": {
        "file_id": 55,
        "content": "The code checks if the content is a picture and downloads it using mediaDownloader function. Then, it censors the picture using coreMediaCensor function and adds the path and censoring data to the review list. If the content is not a picture, it directly censors the content without displaying raw content using coreMediaCensor function with appropriate arguments. Finally, it returns the censored content as 'data'.",
        "type": "comment"
    },
    "746": {
        "file_id": 55,
        "content": "    data = {\"type\": None, \"review\": None}\n    mediaTypes = [\"image\", \"video\"]\n    # mediaTypes = [\"picture\", \"video\"]\n    if content[\"type\"] in mediaTypes:\n        data[\"type\"] = content[\"type\"]\n        mediaPath = content[\"path\"]\n        mdata = coreMediaCensor(mediaPath, (None, None, None), local=True, **groupArgs)\n        # review as video.\n        data[\"review\"] = (mediaPath, mdata)\n    else:\n        raise Exception(\"Unknown Content Type: {}\\n{}\".format(content[\"type\"], content))\n    return data",
        "type": "code",
        "location": "/pyjom/modules/contentCensoring/core.py:333-344"
    },
    "747": {
        "file_id": 55,
        "content": "This code checks the content type, if it's an image or video, then it censor the media using `coreMediaCensor` function and returns the data. If the content type is unknown, it raises an exception.",
        "type": "comment"
    },
    "748": {
        "file_id": 56,
        "content": "/pyjom/modules/contentPosting/__init__.py",
        "type": "filepath"
    },
    "749": {
        "file_id": 56,
        "content": "Importing necessary modules for dummy and online posters to prevent circular import issues.",
        "type": "summary"
    },
    "750": {
        "file_id": 56,
        "content": "from pyjom.modules.contentPosting.dummyPoster import *\nfrom pyjom.modules.contentPosting.onlinePoster import * # prevent circular import",
        "type": "code",
        "location": "/pyjom/modules/contentPosting/__init__.py:1-2"
    },
    "751": {
        "file_id": 56,
        "content": "Importing necessary modules for dummy and online posters to prevent circular import issues.",
        "type": "comment"
    },
    "752": {
        "file_id": 57,
        "content": "/pyjom/modules/contentPosting/bilibiliPoster.py",
        "type": "filepath"
    },
    "753": {
        "file_id": 57,
        "content": "This code defines functions for sending POST requests to Bilibili, handling metadata and exceptions in content posting operations. It also generates a Bilibili URL for input content with optional iterative processing.",
        "type": "summary"
    },
    "754": {
        "file_id": 57,
        "content": "from types import FunctionType\nfrom pyjom.commons import *\nfrom pyjom.platforms.bilibili.uploader import uploadVideo\nfrom lazero.filesystem.temp import (\n    tmpdir,\n    getRandomFileNameUnderDirectoryWithExtension,\n    tmpfile,\n)\n# that generator you must put beforehand.\nimport cv2\nimport requests\ndef registerBilibiliUserVideo(\n    bvid: str,\n    dedeuserid: str,\n    is_mine: bool = True,\n    visible: bool = False,\n    server_domain: str = \"localhost\",\n    server_endpoint: str = \"registerUserVideo\",\n    server_port: int = 7341,\n    success_codes: list[int] = [200, 201],\n):\n    data = {\n        \"bvid\": bvid,\n        \"dedeuserid\": dedeuserid,\n        \"is_mine\": is_mine,\n        \"visible\": visible,\n    }\n    r = requests.post(\n        \"http://{}:{}/{}\".format(server_domain, server_port, server_endpoint), json=data\n    )\n    register_success = r.status_code in success_codes\n    return register_success\n# why you have decorator? so OnlinePoster will not have decorator.\n@decorator\ndef BilibiliPoster(\n    content,\n    iterate=False,",
        "type": "code",
        "location": "/pyjom/modules/contentPosting/bilibiliPoster.py:1-44"
    },
    "755": {
        "file_id": 57,
        "content": "This code defines a function `registerBilibiliUserVideo` which sends a POST request to a server, passing Bilibili video details and returns the success status based on received response. The `BilibiliPoster` decorator is applied to another function `content`, likely for handling content posting operations in the context of Bilibili platform. It seems to involve file manipulation using `cv2` and `requests` library, as well as external dependencies from `pyjom` and `lazero`. The code also uses a generator, but its purpose is not clear from the provided snippet.",
        "type": "comment"
    },
    "756": {
        "file_id": 57,
        "content": "    getPostMetadata=...,  # some lambda calling generator.__next__()\n    contentType=\"video\",\n    dedeuserid: str = \"397424026\",\n    tempdir=\"/dev/shm/medialang/bilibiliPoster\",\n    afterPosting: FunctionType = ...,\n):\n    # are you sure this 'postMetadataGenerator' will generate valid data for us?\n    # anyway let's write for video.\n    # there are two generators. what do you want?\n    # getPostMetadata = lambda: postMetadataGenerator.__next__()\n    from retry import retry\n    @retry(tries=3, delay=5)  # if causing trouble\n    def postContent(elem):  # what is this elem? please check for video producer.\n        with tmpdir(path=tempdir):\n            postMetadata = getPostMetadata()\n            print(\n                \"READY TO POST CONTENT FROM:\", elem\n            )  # this elem is video location for me.\n            if contentType == \"video\":  # single video upload without grouping.\n                videoPath = elem\n                cover_path = getRandomFileNameUnderDirectoryWithExtension(\n                    \"png\", tempdir",
        "type": "code",
        "location": "/pyjom/modules/contentPosting/bilibiliPoster.py:45-67"
    },
    "757": {
        "file_id": 57,
        "content": "This code is defining a function `postContent` that takes an element (elem) as input. The function uses a retry decorator to attempt the post operation three times with a 5-second delay between retries. It also defines the content type as video and a temporary directory for storage. The `getPostMetadata` seems to be used to retrieve metadata for posting, but its validity is questioned. The elem is likely a video location for uploading.",
        "type": "comment"
    },
    "758": {
        "file_id": 57,
        "content": "                )\n                (\n                    cover_target,\n                    mTagSeries,  # are you sure this is a list of tags?\n                    mTitle,\n                    mBgm,  # what is the bgm here used for?\n                    mDescription,\n                    dog_or_cat_original,  # what again is this dog/cat label?\n                    search_tid,\n                ) = postMetadata  # assumptions on video type.\n                # you can fetch this from database. you can pickle this thing.\n                tagString = \",\".join(mTagSeries)\n                # will have exceptions when having name clash. handle it!\n                with tmpfile(cover_path):\n                    cv2.imwrite(cover_path, cover_target)\n                    # you need to save this 'cover_target' to file.\n                    contentId = uploadVideo(\n                        dedeuserid=dedeuserid,  # by decorator.\n                        description=mDescription,\n                        dynamic=mDescription,\n                        tagString=tagString,",
        "type": "code",
        "location": "/pyjom/modules/contentPosting/bilibiliPoster.py:68-88"
    },
    "759": {
        "file_id": 57,
        "content": "The code is responsible for extracting metadata from a tuple called `postMetadata` and storing it into relevant variables. It then joins the tags in the `mTagSeries` list with commas and writes the cover image to a file using OpenCV's imwrite function. Finally, it calls the `uploadVideo` function to upload the video content. The code assumes the video type and has potential exceptions if there is a name clash while joining tags into a string.",
        "type": "comment"
    },
    "760": {
        "file_id": 57,
        "content": "                        tagId=search_tid,\n                        cover_path=cover_path,\n                        videoPath=videoPath,\n                        title=mTitle,\n                    )  # choose to upload and get bvid.\n            else:\n                raise Exception(\n                    \"unknown content type to upload for bilibiliPoster:\", contentType\n                )\n            afterPosting()  # execute no matter what. after posting the content.\n            # now register the uploaded video.\n            if contentType == \"video\":\n                video_bvid = (\n                        contentId\n                        if type(contentId) == str\n                        else contentId.get(\"bvid\", contentId.get(\"BVID\"))\n                    )\n                register_success = registerBilibiliUserVideo(\n                    video_bvid,\n                    str(dedeuserid),\n                )\n                print(\"VIDEO REGISTRATION STATUS?\", register_success)\n                if not register_success:\n                    print(\"VIDEO REGISTRATION ERROR\")",
        "type": "code",
        "location": "/pyjom/modules/contentPosting/bilibiliPoster.py:89-112"
    },
    "761": {
        "file_id": 57,
        "content": "Code chooses to upload and gets bvid based on the content type. If the content type is unknown, it raises an exception. It executes afterPosting() regardless of success or failure. For video content, it registers the uploaded video using registerBilibiliUserVideo and prints the registration status.",
        "type": "comment"
    },
    "762": {
        "file_id": 57,
        "content": "                    breakpoint()\n            if type(contentId) == str:\n                video_identifier = \"bvid_{}\".format(contentId)\n            else:\n                video_identifier = \"aid_{}_bvid_{}\".format(\n                    contentId.get(\"aid\"), contentId.get(\"bvid\")\n                )\n            return \"bilibili://{}/{}/{}\".format(\n                dedeuserid, contentType, video_identifier\n            )  # this content id is fucked.\n    def postContentIterate(content):\n        for elem in content:\n            yield postContent(elem)\n    if iterate:\n        return postContentIterate(content)\n    else:\n        return postContent(content)\n    # content id?",
        "type": "code",
        "location": "/pyjom/modules/contentPosting/bilibiliPoster.py:113-132"
    },
    "763": {
        "file_id": 57,
        "content": "This code is a function to generate a Bilibili-specific URL for content, handling different content ID formats. It also includes an optional iterative processing option for the input content list.",
        "type": "comment"
    },
    "764": {
        "file_id": 58,
        "content": "/pyjom/modules/contentPosting/dummyPoster.py",
        "type": "filepath"
    },
    "765": {
        "file_id": 58,
        "content": "Function \"dummyPoster\" takes content as input, iterates over it if specified, and returns a protocol link.",
        "type": "summary"
    },
    "766": {
        "file_id": 58,
        "content": "from pyjom.commons import *\n@decorator\ndef dummyPoster(content, iterate=False):\n    if iterate:\n        for elem in content:\n            print(\"READY TO POST CONTENT FROM:\",elem)\n    return \"mydarnprotocol://mydarnlink\"",
        "type": "code",
        "location": "/pyjom/modules/contentPosting/dummyPoster.py:1-8"
    },
    "767": {
        "file_id": 58,
        "content": "Function \"dummyPoster\" takes content as input, iterates over it if specified, and returns a protocol link.",
        "type": "comment"
    },
    "768": {
        "file_id": 59,
        "content": "/pyjom/modules/contentPosting/onlinePoster.py",
        "type": "filepath"
    },
    "769": {
        "file_id": 59,
        "content": "This code defines a decorator-like function named OnlinePoster that takes in various parameters such as content, platform, postMetadataGenerator, and afterPosting. It returns an instance of BilibiliPoster for the specified platform (default is bilibili) to handle content posting. The function also utilizes a lambda expression to generate post metadata by iterating through the provided postMetadataGenerator.",
        "type": "summary"
    },
    "770": {
        "file_id": 59,
        "content": "from types import FunctionType\nfrom typing import Generator\nfrom pyjom.modules.contentPosting.bilibiliPoster import BilibiliPoster\n# there is no decorator!\ndef OnlinePoster(\n    content,\n    iterate=False,\n    contentType=\"video\",\n    postMetadataGenerator: Generator = ...,\n    platform=\"bilibili\",\n    afterPosting:FunctionType=...\n):\n    posters = {\"bilibili\": BilibiliPoster}\n    assert platform in posters.keys()\n    getPostMetadata = lambda: postMetadataGenerator.__next__() # how you produce this \"next\" properly? or double?\n    return posters[platform](\n        content,\n        iterate=iterate,\n        contentType=contentType,\n        getPostMetadata=getPostMetadata,\n        afterPosting=afterPosting,\n    )",
        "type": "code",
        "location": "/pyjom/modules/contentPosting/onlinePoster.py:1-23"
    },
    "771": {
        "file_id": 59,
        "content": "This code defines a decorator-like function named OnlinePoster that takes in various parameters such as content, platform, postMetadataGenerator, and afterPosting. It returns an instance of BilibiliPoster for the specified platform (default is bilibili) to handle content posting. The function also utilizes a lambda expression to generate post metadata by iterating through the provided postMetadataGenerator.",
        "type": "comment"
    },
    "772": {
        "file_id": 60,
        "content": "/pyjom/modules/contentProducing/__init__.py",
        "type": "filepath"
    },
    "773": {
        "file_id": 60,
        "content": "This code is importing modules from the \"pyjom\" library, specifically for content production. It includes three different types of producers: dummy, local, and online.",
        "type": "summary"
    },
    "774": {
        "file_id": 60,
        "content": "from pyjom.modules.contentProducing.dummyProducer import *\nfrom pyjom.modules.contentProducing.localProducer import *\nfrom pyjom.modules.contentProducing.onlineProducer import *",
        "type": "code",
        "location": "/pyjom/modules/contentProducing/__init__.py:1-3"
    },
    "775": {
        "file_id": 60,
        "content": "This code is importing modules from the \"pyjom\" library, specifically for content production. It includes three different types of producers: dummy, local, and online.",
        "type": "comment"
    },
    "776": {
        "file_id": 61,
        "content": "/pyjom/modules/contentProducing/dummyProducer.py",
        "type": "filepath"
    },
    "777": {
        "file_id": 61,
        "content": "The code imports necessary modules and defines a dummyProducer function using a decorator. It returns a dictionary with information related to \"husky\" including title, article, video, and summary.",
        "type": "summary"
    },
    "778": {
        "file_id": 61,
        "content": "from pyjom.commons import *\n@decorator\ndef dummyProducer(processed_info):\n    return {\n        \"husky\": {\n            \"title\": \"<a million husky videos>\",\n            \"article\": \"husky is so darn cute\",\n            \"video\": \"<myvideo>\",\n            \"summary\": \"this is my husky\",\n        }\n    }",
        "type": "code",
        "location": "/pyjom/modules/contentProducing/dummyProducer.py:1-13"
    },
    "779": {
        "file_id": 61,
        "content": "The code imports necessary modules and defines a dummyProducer function using a decorator. It returns a dictionary with information related to \"husky\" including title, article, video, and summary.",
        "type": "comment"
    },
    "780": {
        "file_id": 62,
        "content": "/pyjom/modules/contentProducing/localProducer.py",
        "type": "filepath"
    },
    "781": {
        "file_id": 62,
        "content": "The function checks and verifies required filters, detects hits or \"yolov5\" filter, updates cuts dictionary, applies filter to information, and combines filtered info with meta info. Issues exist in handling titles and other elements.",
        "type": "summary"
    },
    "782": {
        "file_id": 62,
        "content": "from pyjom.commons import *\nfrom pyjom.modules.contentProducing.producerTemplates import getProducerTemplate\ndef FilesystemInfoFilter(processed_info, filters={}):\n    # this is just standard filter logic...\n    filtered_info = {}\n    # print(processed_info)\n    # print(\"PROCESSED_INFO\")\n    # breakpoint()\n    for file_path, file_info in processed_info.items():\n        # abandon_flag = False\n        # ensure all filter names must be inside\n        abandon_flag = [\n            filter_name in file_info.keys() for filter_name in filters.keys()\n        ]\n        # print(file_info.keys(), filters.keys(), abandon_flag)\n        # breakpoint()\n        abandon_flag = not all(abandon_flag)  # what is this?\n        metadata = file_info[\n            \"meta\"\n        ]  # is that necessary? do we want to make any filter with it?\n        if abandon_flag:\n            continue  # abandon those without qualificaton info.\n        cuts = {}\n        for filter_name, filter_content in filters.items():\n            if filter_name == \"meta\":",
        "type": "code",
        "location": "/pyjom/modules/contentProducing/localProducer.py:1-27"
    },
    "783": {
        "file_id": 62,
        "content": "Filtering function iterates over processed info, checks if each filter is present for the file. If any filter is missing, it will abandon that item. It uses a generator expression to check if all filter names exist in file_info keys and then negates it. Extracts metadata from file_info and continues if all filters are present.",
        "type": "comment"
    },
    "784": {
        "file_id": 62,
        "content": "                required_type = filter_content.get(\"type\")\n                media_type = metadata[\"type\"]\n                abandon_flag = not required_type == media_type\n                # breakpoint()\n                if abandon_flag:\n                    break\n            elif filter_name == \"labels\":\n                required, at_leasts = filter_content.get(\n                    \"required\", []\n                ), filter_content.get(\"at_leasts\", [])\n                required_flag = all([x in file_info[filter_name] for x in required])\n                if required_flag:\n                    # check all at_leasts.\n                    for at_least_number, elements in at_leasts:\n                        assert at_least_number > 0\n                        assert type(at_least_number) == int\n                        assert type(elements) == list\n                        assert len(elements) > 0\n                        hit_count = sum(\n                            [int(x in file_info[filter_name]) for x in elements]\n                        )",
        "type": "code",
        "location": "/pyjom/modules/contentProducing/localProducer.py:28-48"
    },
    "785": {
        "file_id": 62,
        "content": "This code snippet filters content based on the provided filter name and filter content. It checks if the media type matches the required type, and also verifies if all required labels are present and ensures the number of elements in at_leasts is met. If any condition fails, a breakpoint will be hit.",
        "type": "comment"
    },
    "786": {
        "file_id": 62,
        "content": "                        if hit_count < at_least_number:\n                            abandon_flag = True\n                            break\n                    if abandon_flag:\n                        break\n                else:\n                    abandon_flag = True\n                    break\n            elif filter_name == \"yolov5\":\n                # if type(filter_content) == list:\n                #     breakpoint()\n                objects, min_time = filter_content.get(\n                    \"objects\", None\n                ), filter_content.get(\"min_time\", 2)\n                assert objects != None\n                assert min_time > 0\n                DOT = file_info[filter_name][\"detected_objects_timespan\"]\n                detected_objects = list(DOT.keys())\n                abandon_flag = any([x in objects for x in detected_objects])\n                # what is this?\n                # breakpoint()\n                if not abandon_flag:\n                    break\n                avaliable_cuts = {}\n                for detected_object, timespans in DOT.items():",
        "type": "code",
        "location": "/pyjom/modules/contentProducing/localProducer.py:49-73"
    },
    "787": {
        "file_id": 62,
        "content": "This code checks if a specific number of hits are detected or if a filter named \"yolov5\" is applied. If either condition is met, it sets the abandon_flag and breaks out of the loop. If abandon_flag is True, it retrieves objects and min_time from the filter content, checks if they are not None and greater than 0 respectively. Then, it compares the detected objects with the ones in the \"yolov5\" filter, setting abandon_flag to True if any match is found. If abandon_flag is still False after this check, it proceeds to iterate through the DOT dictionary to populate avaliable_cuts dictionary.",
        "type": "comment"
    },
    "788": {
        "file_id": 62,
        "content": "                    if detected_object not in objects:\n                        continue\n                    for timespan in timespans:\n                        stop, start = timespan[1], timespan[0]\n                        if stop == \"FINAL\":\n                            stop = metadata[\n                                \"duration\"\n                            ]  # do we need to modify the \"FINAL\" into acturally digits?\n                            timespan = (start, stop)  # do this anyway.\n                        timespan_length = stop - start\n                        if timespan_length < min_time:\n                            continue\n                        avaliable_cuts.update(\n                            {\n                                detected_object: avaliable_cuts.get(detected_object, [])\n                                + [timespan]\n                            }\n                        )\n                # collect avaliable cuts.\n                cuts.update({filter_name: avaliable_cuts})\n                # filter out required durations.",
        "type": "code",
        "location": "/pyjom/modules/contentProducing/localProducer.py:74-94"
    },
    "789": {
        "file_id": 62,
        "content": "This code collects available cuts from detected objects and timespans, filters out required durations, and stores the results in a cuts dictionary for later use.",
        "type": "comment"
    },
    "790": {
        "file_id": 62,
        "content": "            elif filter_name == \"framedifference_talib_detector\":\n                size_limit, ratio_limit, duration_limit = (\n                    filter_content.get(\"size_limit\", 0.2),\n                    filter_content.get(\"ratio_limit\", 0.3),\n                    filter_content.get(\"duration_limit\", 3),\n                )\n                avaliable_cuts = []\n                for framework in file_info[filter_name]:\n                    [[up_x, up_y], [down_x, down_y]] = framework[\"coords\"]\n                    frame_width, frame_height = down_x - up_x, down_y - up_y\n                    area = (down_x - up_x) * (down_y - up_y)\n                    height, width = (\n                        metadata[\"resolution\"][\"height\"],\n                        metadata[\"resolution\"][\"width\"],\n                    )\n                    total_area = height * width\n                    size = area / total_area\n                    if size < size_limit:\n                        continue\n                    ratio = min(frame_width, frame_height) / max(",
        "type": "code",
        "location": "/pyjom/modules/contentProducing/localProducer.py:95-114"
    },
    "791": {
        "file_id": 62,
        "content": "This code checks if the filter name is \"framedifference_talib_detector\". If so, it retrieves size_limit, ratio_limit, and duration_limit from filter content. It then iterates over each framework in file_info for this specific filter and extracts its coordinates. It calculates the frame's area and its size relative to the total video size. If the frame's size is less than the size_limit, it continues to the next iteration; otherwise, it calculates the ratio between the frame's width and height and checks if it meets the filter's requirements.",
        "type": "comment"
    },
    "792": {
        "file_id": 62,
        "content": "                        frame_width, frame_height\n                    )\n                    if ratio < ratio_limit:\n                        continue\n                    start, end = framework[\"start\"], framework[\"end\"]\n                    if end == \"FINAL\":\n                        end = metadata[\"duration\"]\n                    duration = end - start\n                    if duration < duration_limit:\n                        continue\n                    # now append your cuts. are they overlapping?\n                    framework2 = {\n                        \"coords\": framework[\"coords\"],\n                        \"timespan\": (start, end),\n                    }\n                    avaliable_cuts.append(framework2)\n                cuts.update({filter_name: avaliable_cuts})\n            if abandon_flag: # is this duplicated?\n                break\n        # print(cuts)\n        # print(\"CUTS:\")\n        filtered_info.update({file_path: cuts})\n        # breakpoint()\n        # # what the fuck? # #\n        # if abandon_flag:\n        #     continue  # abandon those without qualification info.",
        "type": "code",
        "location": "/pyjom/modules/contentProducing/localProducer.py:115-140"
    },
    "793": {
        "file_id": 62,
        "content": "This code filters and stores video cuts based on their dimensions, ratio, duration, and if they overlap. It updates the \"cuts\" dictionary with available cuts for each filter name and stores the information in \"filtered_info\" dictionary under file path. If abandon_flag is set, it breaks or continues to the next iteration.",
        "type": "comment"
    },
    "794": {
        "file_id": 62,
        "content": "        # # what the fuck? # #\n        # breakpoint()\n    return filtered_info\n@decorator\ndef FilesystemProducer(\n    processed_info,\n    filters={},\n    template=None,\n    template_config={},\n):\n    # print(processed_info) # why we only have one single goddamn path?\n    # breakpoint()\n    filtered_info = FilesystemInfoFilter(processed_info, filters=filters)\n    template_function = getProducerTemplate(template)\n    meta_info = {\n        k: processed_info[k][\"meta\"] for k in processed_info.keys()\n    }  # so there is no additional \"meta\" key.\n    # print(filtered_info)  # empty! shit.\n    # print(meta_info)\n    # breakpoint()\n    output = template_function(filtered_info, meta_info, config=template_config)\n    # you need to handle the title and something all over this freaking place.\n    # must be ready for posting.\n    return output",
        "type": "code",
        "location": "/pyjom/modules/contentProducing/localProducer.py:141-169"
    },
    "795": {
        "file_id": 62,
        "content": "This function, FilesystemProducer, takes in processed_info and applies the FilesystemInfoFilter. It then gets a template_function and uses it to combine filtered_info with meta_info. The output is returned, but it seems there are issues with handling titles and other elements throughout the code.",
        "type": "comment"
    },
    "796": {
        "file_id": 63,
        "content": "/pyjom/modules/contentProducing/onlineProducer.py",
        "type": "filepath"
    },
    "797": {
        "file_id": 63,
        "content": "The OnlineProducer function generates media by processing information with a generator and using templates. It creates a unique temporary directory per usage, acquiring a template function if the source is \"giphy\". The code also enables debug mode for breaking after merging ASS files.",
        "type": "summary"
    },
    "798": {
        "file_id": 63,
        "content": "from pyjom.commons import decorator,os\nfrom pyjom.modules.contentProducing.producerTemplates import getProducerTemplate\nfrom lazero.filesystem.temp import tmpdir\n@decorator\ndef OnlineProducer(\n    processed_info_generator,\n    source=\"giphy\",\n    template=None,\n    template_configs=None,\n    fast: bool = True,\n    medialangTmpdirBase=\"/dev/shm/medialang\",\n    debug=False,\n):\n    # template_configs is a generator, it generate configs.\n    # print(\"PROCESSED_INFO_GENERATOR: \", processed_info_generator)\n    # breakpoint()\n    import uuid\n    medialangTmpdir = os.path.join(medialangTmpdirBase, str(uuid.uuid4()))\n    with tmpdir(path=medialangTmpdir) as TD:  # must use another level of abstraction\n        if source == \"giphy\":\n            template_function = getProducerTemplate(template)\n            # print(\"TEMPLATE FUNCTION ACQUIRED %s\" % template_function)\n            # breakpoint()\n            exported_media_locations = template_function(\n                processed_info_generator,\n                configs=template_configs,",
        "type": "code",
        "location": "/pyjom/modules/contentProducing/onlineProducer.py:1-30"
    },
    "799": {
        "file_id": 63,
        "content": "The code defines the OnlineProducer function which is a content producer that uses a generator to process information and generate media. It takes in parameters such as processed_info_generator, source, template, template_configs, fast, medialangTmpdirBase, and debug. The function generates a unique temporary directory for each usage, creating a level of abstraction. If the source is set to \"giphy\", it acquires a template function from getProducerTemplate and uses it to process the generator's data.",
        "type": "comment"
    }
}