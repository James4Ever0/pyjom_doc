{
    "700": {
        "file_id": 49,
        "content": "    # the 'mean' is still not correctified.\n    # ERROR STATUS: False\n    # video codec we use 'copy' if the extension name is the same.\n    outputPathExtension = outputPath.lower().split(\".\")[-1]\n    mediaPathExtension = mediaPath.lower().split(\".\")[-1]\n    outputMediaType = determineMediaTypeByExtension(outputPathExtension)\n    # treat this as a common repository.\n    if outputPathExtension == mediaPathExtension and outputMediaType == \"video\":\n        commandline += [\"-c:v\", \"copy\"]\n    # problem is, the container must be video compabible.\n    # list the thing here?\n    if outputPathExtension == \"mp4\":\n        commandline += [\"-c:a\", \"aac\"]\n    if target_level:\n        commandline += [\"-t\", str(target_level)]\n    if true_peak:\n        commandline += [\"-tp\", str(true_peak)]\n    if overwrite_output:\n        commandline += [\"-f\"]\n    commandline += [mediaPath]\n    status = subprocess.run(commandline)  # is it even successful?\n    returncode = status.returncode\n    try:\n        assert returncode == 0\n        print(\"VOLUME NORMALIZATION SUCCESSFUL\")",
        "type": "code",
        "location": "/pyjom/audiotoolbox.py:98-122"
    },
    "701": {
        "file_id": 49,
        "content": "This code is normalizing the volume of a video file and correcting its container type if necessary. It checks the input and output extensions, sets the video and audio codecs, handles target level, true peak, and overwrite settings, and runs subprocess command to execute FFmpeg for processing. The script prints \"VOLUME NORMALIZATION SUCCESSFUL\" if returncode is 0, indicating successful volume normalization.",
        "type": "comment"
    },
    "702": {
        "file_id": 49,
        "content": "        return outputPath\n    except:\n        import traceback\n        traceback.print_exc()\n        print(\"error when normalizing audio for media: %s\" % mediaPath)\n    # media = ffmpeg.input(videoPath)\n    # audio = media.audio\n    # video = media.video\n    # audio = audio.filter()",
        "type": "code",
        "location": "/pyjom/audiotoolbox.py:123-132"
    },
    "703": {
        "file_id": 49,
        "content": "This code snippet is responsible for normalizing audio for a given media file. If an error occurs during the process, it prints the error message and stack trace using the traceback module.",
        "type": "comment"
    },
    "704": {
        "file_id": 50,
        "content": "/pyjom/templates/medialang/autoCensor/yolov5_detector.mdl.j2",
        "type": "filepath"
    },
    "705": {
        "file_id": 50,
        "content": "This code is creating a tuple containing a JSON file with optional parameters for timestep, threshold and model name, along with the media file path.",
        "type": "summary"
    },
    "706": {
        "file_id": 50,
        "content": "(\".json\", processor=\"yolov5_detector\"{% if timestep %}, timestep={{timestep}}{% endif %} {% if threshold %}, threshold={{threshold}}{% endif %} {% if model %}, model=\"{{model}}\"{% endif %}\n)\n(\"{{ mediafile }}\")",
        "type": "code",
        "location": "/pyjom/templates/medialang/autoCensor/yolov5_detector.mdl.j2:1-4"
    },
    "707": {
        "file_id": 50,
        "content": "This code is creating a tuple containing a JSON file with optional parameters for timestep, threshold and model name, along with the media file path.",
        "type": "comment"
    },
    "708": {
        "file_id": 51,
        "content": "/pyjom/templates/medialang/autoCensor/subtitle_detector.mdl.j2",
        "type": "filepath"
    },
    "709": {
        "file_id": 51,
        "content": "The code specifies a template for the \"subtitle_detector\" processor. If timestep is provided, it includes it in the output. It combines a JSON string with the media file path.",
        "type": "summary"
    },
    "710": {
        "file_id": 51,
        "content": "(\".json\", processor=\"subtitle_detector\"{% if timestep %}, timestep={{timestep}}{% endif %}\n)\n(\"{{ mediafile }}\")",
        "type": "code",
        "location": "/pyjom/templates/medialang/autoCensor/subtitle_detector.mdl.j2:1-4"
    },
    "711": {
        "file_id": 51,
        "content": "The code specifies a template for the \"subtitle_detector\" processor. If timestep is provided, it includes it in the output. It combines a JSON string with the media file path.",
        "type": "comment"
    },
    "712": {
        "file_id": 52,
        "content": "/pyjom/templates/medialang/autoCensor/framediff_detector.mdl.j2",
        "type": "filepath"
    },
    "713": {
        "file_id": 52,
        "content": "The code defines a template for the \"framediff_detector\" processor, which takes an optional \"timestep\" parameter and a media file as input. It may check moving areas, total movements, and local movements, differentiating it from frame border detector.",
        "type": "summary"
    },
    "714": {
        "file_id": 52,
        "content": "(\".json\", processor=\"framediff_detector\"{% if timestep %}, timestep={{timestep}}{% endif %} \n) # different from frame border detector. may check moving areas, check total movements, local movements.\n(\"{{ mediafile }}\")",
        "type": "code",
        "location": "/pyjom/templates/medialang/autoCensor/framediff_detector.mdl.j2:1-4"
    },
    "715": {
        "file_id": 52,
        "content": "The code defines a template for the \"framediff_detector\" processor, which takes an optional \"timestep\" parameter and a media file as input. It may check moving areas, total movements, and local movements, differentiating it from frame border detector.",
        "type": "comment"
    },
    "716": {
        "file_id": 53,
        "content": "/pyjom/templates/medialang/autoCensor/frameborder_detector.mdl.j2",
        "type": "filepath"
    },
    "717": {
        "file_id": 53,
        "content": "This code defines a template for frameborder_detector, which takes in model and config as parameters. By default, the model is framedifference_talib, but it can be configured to be huffline_horizontal_vertical. The output includes main frame time and location, possibly from a moving object.",
        "type": "summary"
    },
    "718": {
        "file_id": 53,
        "content": "(\".json\", processor=\"frameborder_detector\" {% if model %}, model=\"{{model}}\"{% endif %} {% if config %}, config={{config}}{% endif %}\n) # model default to be framedifference_talib, or config it to be huffline_horizontal_vertical, only output main frame time and location. might be moving. i don't know. maybe we need to eliminate all moving things.\n(\"{{ mediafile }}\")",
        "type": "code",
        "location": "/pyjom/templates/medialang/autoCensor/frameborder_detector.mdl.j2:1-4"
    },
    "719": {
        "file_id": 53,
        "content": "This code defines a template for frameborder_detector, which takes in model and config as parameters. By default, the model is framedifference_talib, but it can be configured to be huffline_horizontal_vertical. The output includes main frame time and location, possibly from a moving object.",
        "type": "comment"
    },
    "720": {
        "file_id": 54,
        "content": "/pyjom/templates/medialang/autoCensor/file_format_detector.mdl.j2",
        "type": "filepath"
    },
    "721": {
        "file_id": 54,
        "content": "This code snippet defines a tuple containing the file format \"json\" and specifies the processor \"file_format_detector\". The mediafile variable is used within double curly braces to represent the file's content.",
        "type": "summary"
    },
    "722": {
        "file_id": 54,
        "content": "(\".json\", processor=\"file_format_detector\"\n)\n(\"{{ mediafile }}\")",
        "type": "code",
        "location": "/pyjom/templates/medialang/autoCensor/file_format_detector.mdl.j2:1-4"
    },
    "723": {
        "file_id": 54,
        "content": "This code snippet defines a tuple containing the file format \"json\" and specifies the processor \"file_format_detector\". The mediafile variable is used within double curly braces to represent the file's content.",
        "type": "comment"
    },
    "724": {
        "file_id": 55,
        "content": "/pyjom/templates/medialang/autoCensor/blackout_detector.mdl.j2",
        "type": "filepath"
    },
    "725": {
        "file_id": 55,
        "content": "The code represents a template for the blackout_detector.mdl.j2 file in the pyjom project. It defines a processor called \"blackout_detector\" and includes optional timestep variable, as well as the mediafile path.",
        "type": "summary"
    },
    "726": {
        "file_id": 55,
        "content": "(\".json\", processor=\"blackout_detector\"{% if timestep %}, timestep={{timestep}}{% endif %}\n)\n(\"{{ mediafile }}\")",
        "type": "code",
        "location": "/pyjom/templates/medialang/autoCensor/blackout_detector.mdl.j2:1-4"
    },
    "727": {
        "file_id": 55,
        "content": "The code represents a template for the blackout_detector.mdl.j2 file in the pyjom project. It defines a processor called \"blackout_detector\" and includes optional timestep variable, as well as the mediafile path.",
        "type": "comment"
    },
    "728": {
        "file_id": 56,
        "content": "/pyjom/primitives/weiboPrimitives.py",
        "type": "filepath"
    },
    "729": {
        "file_id": 56,
        "content": "This code defines a class `WeiboPetsReviewer` that inherits from `ContentReviewer`. It has various parameters for configuration and updates the `methodsList` with different methods like \"topic\", \"fetcher\", \"reviewer\", and \"feedback\". The reviewer is meant to automate content labeling tasks.",
        "type": "summary"
    },
    "730": {
        "file_id": 56,
        "content": "from pyjom.main import *\nfrom pyjom.commons import *\n# this is a reviewer, not a poster.\n# you may create interface to label the content and automate the stuff altogether.\nclass WeiboPetsReviewer(ContentReviewer):\n    def __init__(self, enable_log=True, auto=False,semiauto=True, dummy_auto=True,\n        template_names=[],args={},basedir=\"/dev/shm/sina\",autopurge=True):\n        super().__init__()\n        if enable_log:\n            self.log_location = \"logs/sina/pets/\"\n        if autopurge:\n            shutil.rmtree(basedir)\n        self.identifier.typeFix(type(self).__name__)\n        self.methodsList.update(\n            {\n                \"topic\": petsTopicGenerator,\n                \"fetcher\": weiboFetcher,\n                \"reviewer\": keywordDecorator(weiboSearchReviewer, basedir=basedir,auto=auto,semiauto=semiauto,dummy_auto=dummy_auto,template_names=template_names,args=args),\n                \"feedback\": weiboFeedback,\n            }\n        )",
        "type": "code",
        "location": "/pyjom/primitives/weiboPrimitives.py:1-23"
    },
    "731": {
        "file_id": 56,
        "content": "This code defines a class `WeiboPetsReviewer` that inherits from `ContentReviewer`. It has various parameters for configuration and updates the `methodsList` with different methods like \"topic\", \"fetcher\", \"reviewer\", and \"feedback\". The reviewer is meant to automate content labeling tasks.",
        "type": "comment"
    },
    "732": {
        "file_id": 57,
        "content": "/pyjom/primitives/onlinePrimitives.py",
        "type": "filepath"
    },
    "733": {
        "file_id": 57,
        "content": "The code defines the OnlineAutoContentProducer class, initializes variables, updates methodsList with keywordDecorator wrapped instances for content production, and creates OnlineProducer/Poster with multi-platform posting capabilities.",
        "type": "summary"
    },
    "734": {
        "file_id": 57,
        "content": "from pyjom.main import *\nfrom typing import Generator\nfrom types import FunctionType\nclass OnlineAutoContentProducer(ContentProducer):\n    def __init__(\n        self,\n        source=None,\n        debug=False,\n        enable_log=True,\n        fast: bool = True,\n        afterPosting: FunctionType = ...,\n        postMetadataGenerator: Generator = ...,\n        processor_filters={},\n        producer_filters={},\n        platform: str = \"bilibili\",\n        template: str = \"pets_with_music_online\",\n        template_configs: list = [],  # list or 'template_config' generator\n        contentType: str = \"video\",  # for poster.\n        tempdir: str = \"/dev/shm/medialang/online\",\n        metaTopic={\n            \"static\": [[\"dog\", \"cat\", \"puppy\"], [\"funny\", \"cute\"]],\n            \"dynamic\": [[\"samoyed\", \"husky\", \"teddy\", \"chiwawa\"]],\n        },\n        dog_or_cat='dog',\n    ):  # something in this metaTopic is not droppable.\n        super().__init__()\n        # do afterPosting before even start it.\n        # now we might want to check our product before another test.",
        "type": "code",
        "location": "/pyjom/primitives/onlinePrimitives.py:1-30"
    },
    "735": {
        "file_id": 57,
        "content": "The code defines a class called `OnlineAutoContentProducer` which extends the `ContentProducer` class. It has various parameters such as `source`, `debug`, `enable_log`, `fast`, etc., and uses functions from other modules, including `FunctionType` and `Generator`. The constructor initializes the object by calling the parent's constructor using `super().__init__()`, and there is a note that `afterPosting` should be performed before starting. The `metaTopic` dictionary contains categories for static and dynamic content.",
        "type": "comment"
    },
    "736": {
        "file_id": 57,
        "content": "        try:\n            afterPosting()\n        except:\n            pass\n        assert source is not None\n        self.source = source\n        self.tempdir = tempdir\n        self.fast = fast\n        self.metaTopic = metaTopic  # 所谓的超话 超级话题\n        if enable_log:\n            self.log_location = \"logs/local/\"  # what location?\n        self.identifier.typeFix(type(self).__name__)\n        self.methodsList.update(\n            {\n                \"topic\": keywordDecorator(\n                    OnlineTopicGenerator, source=source, metaTopic=metaTopic\n                ),  # how to generate this?\n                \"info\": keywordDecorator(\n                    OnlineFetcher, source=source, tempdir=tempdir\n                ),  # can you do that?\n                \"processor\": keywordDecorator(\n                    OnlineProcessor, source=source, dog_or_cat=dog_or_cat\n                ),  # this is the second thing. how do you process this?\n                # \"reviewer\": filesystemReviewer,\n                \"producer\": keywordDecorator(",
        "type": "code",
        "location": "/pyjom/primitives/onlinePrimitives.py:31-55"
    },
    "737": {
        "file_id": 57,
        "content": "This code attempts to set up various methods for a class. It initializes instance variables, handles logging location if enabled, and updates the methodsList dictionary with keywordDecorator wrapped OnlineTopicGenerator, OnlineFetcher, and OnlineProcessor instances based on provided arguments. The \"reviewer\" method is not implemented, and the \"producer\" method uses keywordDecorator with source argument for its implementation.",
        "type": "comment"
    },
    "738": {
        "file_id": 57,
        "content": "                    OnlineProducer,  # what does this 'OnlineProducer' generate?\n                    source=source,\n                    template=template,\n                    fast=self.fast,\n                    template_configs=template_configs,\n                    debug=debug,  # overkill?\n                ),\n                \"poster\": keywordDecorator(\n                    OnlinePoster,  # you need to be prudent. this is not kids stuff. figure out how to post to multiple platforms the same time, figure out how to post to individual platform one by one.\n                    iterate=True,\n                    contentType=contentType,\n                    postMetadataGenerator=postMetadataGenerator,\n                    platform=platform,\n                    afterPosting=afterPosting,\n                )  # just for debugging.\n                # you also need to change the logic below, for other 'dummy' stuffs.\n                # 'poster':keywordDecorator(dummyPoster, iterate=True) # just for debugging.\n            }",
        "type": "code",
        "location": "/pyjom/primitives/onlinePrimitives.py:56-73"
    },
    "739": {
        "file_id": 57,
        "content": "This code creates an instance of OnlineProducer and OnlinePoster, decorating the latter with a keywordDecorator for multi-platform posting. The OnlineProducer generates content based on source and template, while the OnlinePoster can post to multiple platforms simultaneously or individually. The debug option is used for testing purposes.",
        "type": "comment"
    },
    "740": {
        "file_id": 57,
        "content": "        )",
        "type": "code",
        "location": "/pyjom/primitives/onlinePrimitives.py:74-74"
    },
    "741": {
        "file_id": 57,
        "content": "This line of code is closing a parenthesis, which could potentially be part of a function call or mathematical expression. It indicates that the previous statement or operation has been completed and there are no further instructions to follow within this context.",
        "type": "comment"
    },
    "742": {
        "file_id": 58,
        "content": "/pyjom/primitives/localPrimitives.py",
        "type": "filepath"
    },
    "743": {
        "file_id": 58,
        "content": "The code defines a class for content reviewing, and two classes for automatic content reviewing and producing. The classes have configuration parameters and methods for file operations and topic associations. A producer instance is defined with filters, template, and template_config options.",
        "type": "summary"
    },
    "744": {
        "file_id": 58,
        "content": "from pyjom.main import *\nclass FilesystemContentReviewer(ContentReviewer):\n    def __init__(self, filepath=None, dirpath=None, recursive=False, enable_log=True):\n        super().__init__()\n        if filepath is None:\n            assert dirpath is not None\n        else:\n            raise Exception(\"filepath and dirpath cannot both be None.\")\n        self.filepath = filepath\n        self.dirpath = dirpath\n        self.recursive = recursive\n        if enable_log:\n            self.log_location = \"logs/local/\"\n        self.identifier.typeFix(type(self).__name__)\n        self.methodsList.update(\n            {\n                \"topic\": filesystemTopicGenerator,  # how to generate this?\n                \"fetcher\": filesystemFetcher,\n                \"reviewer\": filesystemReviewer,\n            }\n        )\n    def get_one_topic(self):\n        topic, source = self.methodsList[\"topic\"](\n            filepath=self.filepath, dirpath=self.dirpath, recursive=self.recursive\n        )  # a sequence of things.\n        self.identifier.topicFix(source)",
        "type": "code",
        "location": "/pyjom/primitives/localPrimitives.py:1-29"
    },
    "745": {
        "file_id": 58,
        "content": "This code defines a class, FilesystemContentReviewer, which is a subclass of ContentReviewer. It initializes with optional filepath or dirpath, recursive flag, and enable_log boolean. If enable_log is True, it sets the log_location. The class has a method, get_one_topic(), that retrieves one topic using specified parameters. It also defines three methods (topic, fetcher, reviewer) within its methodsList attribute.",
        "type": "comment"
    },
    "746": {
        "file_id": 58,
        "content": "        return topic\nclass FilesystemAutoContentReviewer(FilesystemContentReviewer):\n    def __init__(\n        self,\n        filepath=None,\n        dirpath=None,\n        recursive=False,\n        enable_log=True,\n        semiauto=True,\n        dummy_auto=True,\n        template_names=[],\n        args={},\n    ):\n        super().__init__(\n            filepath=filepath,\n            dirpath=dirpath,\n            recursive=recursive,\n            enable_log=enable_log,\n        )\n        self.identifier.typeFix(type(self).__name__)\n        self.methodsList.update(\n            {\n                \"reviewer\": keywordDecorator(\n                    filesystemReviewer,\n                    auto=True,\n                    semiauto=semiauto,\n                    dummy_auto=dummy_auto,\n                    template_names=template_names,\n                    args=args,\n                )\n            }\n        )\nclass FilesystemAutoContentProducer(ContentProducer):\n    def __init__(self, filepath=None, dirpath=None, recursive=False, enable_log=T",
        "type": "code",
        "location": "/pyjom/primitives/localPrimitives.py:30-66"
    },
    "747": {
        "file_id": 58,
        "content": "The code defines two classes, `FilesystemAutoContentReviewer` and `FilesystemAutoContentProducer`, which inherit from `FilesystemContentReviewer` and `ContentProducer` respectively. These classes have various parameters for configuration such as file/directory paths, recursive mode, logging settings, and template names. They also have methods for automatic content reviewing and producing.",
        "type": "comment"
    },
    "748": {
        "file_id": 58,
        "content": "rue,reviewerLogs = [],processor_filters={},producer_filters={}, path_replacers = [], template=\"pets_with_music\", template_config = {}):\n        super().__init__()\n        if filepath is None:\n            assert dirpath is not None\n        else:\n            raise Exception(\"filepath and dirpath cannot both be None.\")\n        self.filepath = filepath\n        self.dirpath = dirpath\n        self.recursive = recursive\n        self.reviewerLogs = reviewerLogs\n        if enable_log:\n            self.log_location = \"logs/local/\"\n        self.identifier.typeFix(type(self).__name__)\n        self.methodsList.update(\n            {\n                \"topic\": filesystemTopicGenerator,  # how to generate this?\n                \"info\": filesystemFetcher, # can you do that?\n                \"processor\": keywordDecorator(FilesystemProcessor,reviewerLogs=self.reviewerLogs,filters=processor_filters, path_replacers = path_replacers), # this is the second thing. how do you process this?\n                # \"reviewer\": filesystemReviewer,",
        "type": "code",
        "location": "/pyjom/primitives/localPrimitives.py:66-84"
    },
    "749": {
        "file_id": 58,
        "content": "The code represents a class with file operations. The constructor takes parameters such as filepath, dirpath, recursive flag, reviewerLogs, enable_log, and type name. If filepath is None, it checks if dirpath is not None to avoid both being None. It also sets up log location and updates methods list. \"topic\" method generates a topic, \"info\" method fetches information, and \"processor\" method processes using keyword decorator with given parameters.",
        "type": "comment"
    },
    "750": {
        "file_id": 58,
        "content": "                \"producer\": keywordDecorator(FilesystemProducer, filters=producer_filters, template=template,template_config = template_config),\n            }\n        )\n    def get_one_topic(self):\n        topic, source = self.methodsList[\"topic\"](\n            filepath=self.filepath, dirpath=self.dirpath, recursive=self.recursive\n        )  # a sequence of things.\n        self.identifier.topicFix(source)\n        return topic\n# ctrl + shift + t: reopen closed tab in vscode",
        "type": "code",
        "location": "/pyjom/primitives/localPrimitives.py:85-95"
    },
    "751": {
        "file_id": 58,
        "content": "This code defines a class with methods to get a topic and its associated source, using filepath, dirpath, and recursive parameters. The \"producer\" is defined as a keyword-decorated instance of the FilesystemProducer class, with filters, template, and template_config options. The get_one_topic method returns the topic after applying topicFix from the identifier object.",
        "type": "comment"
    },
    "752": {
        "file_id": 59,
        "content": "/pyjom/primitives/__init__.py",
        "type": "filepath"
    },
    "753": {
        "file_id": 59,
        "content": "This code imports multiple modules from the same package, likely for accessing different sets of primitives.",
        "type": "summary"
    },
    "754": {
        "file_id": 59,
        "content": "from pyjom.primitives.localPrimitives import *\nfrom pyjom.primitives.weiboPrimitives import *\nfrom pyjom.primitives.onlinePrimitives import *",
        "type": "code",
        "location": "/pyjom/primitives/__init__.py:1-3"
    },
    "755": {
        "file_id": 59,
        "content": "This code imports multiple modules from the same package, likely for accessing different sets of primitives.",
        "type": "comment"
    },
    "756": {
        "file_id": 60,
        "content": "/pyjom/medialang/core.py",
        "type": "filepath"
    },
    "757": {
        "file_id": 60,
        "content": "The code defines classes for media language items with functionalities like script representation, validation, exception management, formatting, and executing scripts in a Medialang environment.",
        "type": "summary"
    },
    "758": {
        "file_id": 60,
        "content": "from pyjom.commons import *\nfrom pyjom.medialang.commons import *\nfrom pyjom.medialang.processors import *\nimport re\nimport traceback\nclass lexicalItem:\n    def __init__(self, path, **kwargs):\n        self.path = path\n        self.args = kwargs\n        self.indent = 0\n        self.index = 0\n    def __repr__(self):\n        indent = \"    \" * self.indent\n        mRepr = []\n        mRepr.append(\"{}___medialang_item_[{}]\".format(indent, self.index))\n        mRepr.append(\"{}item path:\".format(indent)+\"  \"+ self.path)\n        mRepr.append(\"{}item args:\".format(indent)+\"  \"+ str(self.args))\n        return \"\\n\".join(mRepr) # is this magic?\nclass lexicalGroup:\n    def __init__(self, items=[]):\n        self.items = []\n        self.index = 0\n        self.indent = 0\n        for item in items:\n            assert type(item) == lexicalItem\n            self.items.append(item)\n    def append(self, item):\n        assert type(item) == lexicalItem\n        self.items.append(item)\n    def dump(self):\n        for item in self.items:\n            yield item # you yield NONE? WTF?",
        "type": "code",
        "location": "/pyjom/medialang/core.py:1-39"
    },
    "759": {
        "file_id": 60,
        "content": "This code defines two classes, `lexicalItem` and `lexicalGroup`, used in the pyjom library for storing and manipulating media language items. The `lexicalItem` class has an `__init__` method that takes a path and optional keyword arguments, and provides an `__repr__` method to represent the item. The `lexicalGroup` class initializes with a list of items, and has methods for appending items and dumping the group's contents. The code also imports necessary modules and checks types of items in the group.",
        "type": "comment"
    },
    "760": {
        "file_id": 60,
        "content": "    def __repr__(self):\n        indent = \"    \" * self.indent\n        mRepr = []\n        mRepr.append(\"{}____________medialang_line_[{}]\".format(indent, self.index))\n        # print(\"ITEMS:\", self.items)\n        for i, item in enumerate(self.dump()):\n            item.indent = self.indent + 1\n            item.index = i\n            mRepr.append(item)\n        # should we return nothing?\n        return \"\\n\".join(mRepr)\nclass lexicalScript:\n    def __init__(self, lines=[]):\n        self.lines = []\n        self.indent = 0\n        self.index = 0\n        for line in lines:\n            assert type(line) == lexicalGroup\n            self.lines.append(line)\n    def append(self, line):\n        assert type(line) == lexicalGroup\n        self.lines.append(line)\n    def dump(self):\n        for line in self.lines:\n            yield line\n    def __repr__(self):\n        indent = \"    \" * self.indent\n        mRepr = []\n        mRepr.append(\"{}____________medialang_script_[{}]\".format(indent, self.index))\n        for i, item in enumerate(self.dump()):",
        "type": "code",
        "location": "/pyjom/medialang/core.py:41-75"
    },
    "761": {
        "file_id": 60,
        "content": "This code defines two classes, `medialang_line` and `lexicalScript`, with a `__repr__` method that represents the objects. The `__repr__` method returns an indented representation of each object's properties. The `lexicalScript` class also has an `append` method to add new lines to the script.",
        "type": "comment"
    },
    "762": {
        "file_id": 60,
        "content": "            item.indent = self.indent + 1\n            item.index = i\n            mRepr.append(item)\n        return \"\\n\".join(mRepr)\nclass Medialang:\n    def __init__(\n        self,\n        script_path=None,\n        script=None,\n        script_obj=None,\n        encoding=\"utf-8\",\n        indent=4,\n        template=False,\n        template_args={},\n        verbose=True,\n        medialangTmpdir=medialangTmpDir\n    ):\n        self.verbose = verbose\n        self.medialangTmpDir = medialangTmpDir\n        self.indent = \" \" * indent\n        self.script_path = script_path\n        self.script_obj = script_obj\n        self.script = script\n        self.encoding = encoding\n        lexList = [script_path, script, script_obj]\n        lexCheck = sum([int(x is None) for x in lexList]) == 2\n        if not lexCheck:\n            raise Exception(\n                \"Can only pass one value to either of script_path, script, script_obj:\\n{}\".format(\n                    lexList\n                )\n            )\n        if script_path is None:\n            if script is None:",
        "type": "code",
        "location": "/pyjom/medialang/core.py:76-110"
    },
    "763": {
        "file_id": 60,
        "content": "This code snippet initializes a Medialang object with various parameters, including script path, script content, and encoding. It also checks for valid input to ensure only one of these values is provided. The exception handling raises an error if the input does not meet this requirement.",
        "type": "comment"
    },
    "764": {
        "file_id": 60,
        "content": "                assert script_obj is not None\n                assert template is False\n                self.script_obj = script_obj\n            else:\n                assert type(script) == str\n                self.script = script\n        else:\n            assert type(script_path) == str\n            try:\n                abspath = getAbsoluteFilePath(script_path)\n            except:\n                medialangFatalError(\n                    \"Failed to resolve script path: {}\".format(script_path), __file__\n                )\n            self.script_path = abspath\n            extension = getFileExtension(script_path)\n            if template:\n                assert extension == \"j2\"\n            else:\n                assert extension in [\"mdl\", \"media\"]\n            with open(abspath, \"r\", encoding=encoding) as f:\n                self.script = f.read()\n        if self.script_obj is not None:\n            self.script = self.generate(self.script_obj)\n        else:\n            if template:\n                assert type(template_args) == dict",
        "type": "code",
        "location": "/pyjom/medialang/core.py:111-138"
    },
    "765": {
        "file_id": 60,
        "content": "This code ensures that the user provides a valid script or script path. It checks if the script is an object, a string, or a file path. If it's a string or a file path, it verifies its type and resolves any relative paths to absolute paths. It then loads the content of the script file and assigns it to 'self.script'. If a script object is provided, the method generates the script using the object. If a template is specified with the script, it asserts that the extension of the script is \"j2\". Otherwise, it asserts that the extension is either \"mdl\" or \"media\". Finally, if a 'template_args' dictionary is provided, it asserts its type and stores the script in 'self.script'.",
        "type": "comment"
    },
    "766": {
        "file_id": 60,
        "content": "                self.script = renderTemplate(self.script, template_args)\n            self.script_obj = self.parse(self.script)\n    def generate_item(self, item_obj, line_max_char=40, level=0):\n        # content = item_obj.content\n        path = item_obj.path\n        item_lines = ['\"{}\"'.format(path)]\n        # print(\"item_lines:\",item_lines)\n        args = item_obj.args\n        # print(\"path:\",path)\n        for key in args.keys():\n            assert not key.startswith(\"#\")\n            # print(\"key:\",key)\n            mitem = args[key]\n            if type(mitem) is str:\n                mitem = '\"{}\"'.format(mitem)\n            elif type(mitem) in [float, int]:\n                mitem = str(mitem)\n            elif mitem in [True, False]:\n                mitem = str(mitem).lower()\n            else:\n                mitem_trial = json.dumps(mitem)\n                if len(mitem_trial) < line_max_char:\n                    mitem = mitem_trial\n                else:\n                    mitem = json.dumps(mitem, indent=self.indent)",
        "type": "code",
        "location": "/pyjom/medialang/core.py:139-164"
    },
    "767": {
        "file_id": 60,
        "content": "This code defines a class that generates items from item objects, handles different data types, and formats the output within a specified line length. The class also has methods to render templates and parse scripts.",
        "type": "comment"
    },
    "768": {
        "file_id": 60,
        "content": "            mitem = \"{}={}\".format(key, mitem)\n            mitem = mitem.split(\"\\n\")\n            for mitem0 in mitem:\n                trial_item = \", \".join([item_lines[-1], mitem0])\n                if len(trial_item) < line_max_char:\n                    item_lines[-1] = trial_item\n                else:\n                    item_lines.append(mitem0)\n        item_lines = \",\\n{}\".format((1 + level) * self.indent).join(item_lines)\n        # print(\"item_lines:\",item_lines)\n        item_lines = \"{}({}\\n{})\\n\".format(\n            level * self.indent, item_lines, level * self.indent\n        )\n        item_lines = item_lines.replace(\",,\", \",\")\n        item_lines = item_lines.replace(\"[,\", \"[\")\n        item_lines = item_lines.replace(\", }\", \"}\")\n        item_lines = item_lines.replace(\", ]\", \"]\")\n        item_lines = item_lines.replace(\"{,\", \"{\")\n        return item_lines\n    def generate(self, script_obj):\n        # default prettify the target\n        script = \"\"\n        for line_obj in script_obj.dump():\n            for level, item_obj in enumerate(line_obj.dump()):",
        "type": "code",
        "location": "/pyjom/medialang/core.py:165-189"
    },
    "769": {
        "file_id": 60,
        "content": "This code is generating a formatted string from nested lists, ensuring that the lines are within character limits and properly indented. It also replaces unnecessary commas with correct formatting for a more readable output.",
        "type": "comment"
    },
    "770": {
        "file_id": 60,
        "content": "                unit = self.generate_item(item_obj, level=level)\n                # print(\"unit:\",unit)\n                script += unit\n            script += \"\\n\"\n        script = script.replace(\",,\", \",\")\n        script = script.replace(\"[,\", \"[\")\n        script = script.replace(\", }\", \"}\")\n        script = script.replace(\", ]\", \"]\")\n        script = script.replace(\"{,\", \"{\")\n        i = 0\n        maxIndent = 0\n        # script = script.replace(\"'\",'\"') # no freaking single quotes.\n        while True:\n            if i == 0:\n                script = script.replace(\",\\n]\", \"\\n]\")\n                script = script.replace(\",\\n]\", \"\\n]\")\n            else:\n                indentStr = self.indent * i\n                if indentStr in script:\n                    script = script.replace(\n                        \",\\n{}]\".format(indentStr), \"\\n{}]\".format(indentStr)\n                    )\n                    script = script.replace(\n                        \",\\n{}\".format(indentStr) + \"}\", \"\\n{}\".format(indentStr) + \"}\"\n                    )",
        "type": "code",
        "location": "/pyjom/medialang/core.py:190-215"
    },
    "771": {
        "file_id": 60,
        "content": "This code generates a script by creating units of code from item objects, adds indentation and replaces unnecessary commas and quotes. It also handles specific formatting issues like replacing multiple newlines with single ones and ensuring correct syntax for closing brackets or braces.",
        "type": "comment"
    },
    "772": {
        "file_id": 60,
        "content": "                else:\n                    maxIndent = i - 1\n                    break\n            i += 1\n        for index0 in range(maxIndent):\n            indentStr = self.indent * (maxIndent - index0)\n            if indentStr in script:\n                script = script.replace(\n                    \"{}], \".format(indentStr),\n                    \"{}],\\n{}\".format(indentStr, indentStr),\n                )\n                script = script.replace(\n                    \"{}\".format(indentStr) + \"}, \",\n                    \"{}\".format(indentStr) + \"},\\n\" + \"{}\".format(indentStr),\n                )\n        for index in range(maxIndent):\n            indentStr = self.indent * (maxIndent - index)\n            if indentStr in script:\n                # print(\"running\", len(indentStr))\n                script = script.replace(\n                    \"[{}\".format(indentStr),\n                    \"[\",\n                )\n                script = script.replace(\n                    \",{}\".format(indentStr),\n                    \",\",\n                )",
        "type": "code",
        "location": "/pyjom/medialang/core.py:216-242"
    },
    "773": {
        "file_id": 60,
        "content": "This code finds the maximum indent level in a script and replaces occurrences of newline-separated items with the appropriate indentation. It also removes extra indentation from list or tuple elements and removes extra indentation after commas.",
        "type": "comment"
    },
    "774": {
        "file_id": 60,
        "content": "                script = script.replace(\n                    \"{\" + \"{}\".format(indentStr),\n                    \"{\",\n                )\n        script = script.replace(\",,\", \",\")\n        script = script.replace(\"[,\", \"[\")\n        script = script.replace(\", }\", \"}\")\n        script = script.replace(\", ]\", \"]\")\n        script = script.replace(\"{,\", \"{\")\n        script = script.replace(\"{ {\", \"{{\")\n        script = script.replace(\"} }\", \"}}\")\n        script = script.replace(\"] ]\", \"]]\")\n        script = script.replace(\"[ [\", \"[[\")\n        script = script.replace(\"[ \", \"[\")\n        if script.endswith(\"\\n\\n\"):\n            script = script[:-2]\n        if script.startswith(\"\\n\"):\n            script = script[1:]\n        return script\n    def detectGrammar(self, line):\n        result = line.replace(\"\\n\", \"\").replace(\" \", \"\").replace(\"\\t\", \"\")\n        return len(result) != 0\n    def getItems(self, line):\n        # assume there will not be enclosed brackets in string?\n        values = {\"(\": +1, \")\": -1}\n        base = 0\n        items = []",
        "type": "code",
        "location": "/pyjom/medialang/core.py:243-271"
    },
    "775": {
        "file_id": 60,
        "content": "The code is performing a series of string replacements to ensure that the script adheres to proper syntax. It removes extra brackets and newline characters, and detects non-empty lines. The getItems function assumes no nested enclosed brackets in strings.",
        "type": "comment"
    },
    "776": {
        "file_id": 60,
        "content": "        item = \"\"\n        for char in line:\n            value = 0 if char not in values.keys() else values[char]\n            base += value\n            if base > 0:\n                item += char\n            if base == 0 and value != 0:\n                item += char\n                items.append(item)\n                item = \"\"\n        return items\n    def parseItem(self, item):\n        # have dangerous eval.\n        body = item.strip()\n        body = item[1:-1]\n        # print(\"body length:\",len(body))\n        path = re.findall(r'^\"([^\"]+)\"', body)[0]\n        # print(\"found path:\",path)\n        mdict = body[len(path) + 2 :]\n        mdict = mdict.strip()\n        if self.detectGrammar(mdict):\n            mdict = mdict[1:]  # omit the comma.\n            text = \"\"\n            mdict2 = \"\"\n            values = {\"(\": +1, \")\": -1}\n            base = 0\n            try:\n                assert mdict[-1] != \",\"\n            except:\n                raise Exception(\"Found trailing comma:\\n\", mdict)\n            for index, char in enumerate(mdict):",
        "type": "code",
        "location": "/pyjom/medialang/core.py:272-303"
    },
    "777": {
        "file_id": 60,
        "content": "This code parses a string by iterating over each character, accumulating characters that have corresponding values in a dictionary and creating items based on the accumulated value. It also includes a function to parse an item which uses regex to find a path and then processes the remaining string according to specific rules. The code raises an exception if there is a trailing comma in the processed string.",
        "type": "comment"
    },
    "778": {
        "file_id": 60,
        "content": "                lineEnd = index == (len(mdict) - 1)\n                value = 0 if char not in values.keys() else values[char]\n                base += value\n                if char == \"=\":\n                    key = text.strip()\n                    assert not key.startswith(\"#\")\n                    mdict2 += '\"{}\":'.format(key)\n                    text = \"\"\n                elif (char == \",\" and base == 0) or lineEnd:\n                    if lineEnd:\n                        text += char\n                    mtext = text.strip()\n                    # print(\"mtext:\",mtext)\n                    if mtext in [\"False\", \"True\"]:\n                        mtext = mtext.lower()\n                    mdict2 += \"{}\".format(mtext)\n                    if not lineEnd:\n                        mdict2 += \",\"\n                    text = \"\"\n                    if lineEnd:\n                        break\n                else:\n                    text += char\n            # print(\"mdict:\",mdict)\n            mdict2 = mdict2.replace(\"(\", \"[\").replace(\")\", \"]\")",
        "type": "code",
        "location": "/pyjom/medialang/core.py:304-328"
    },
    "779": {
        "file_id": 60,
        "content": "This code processes a string, line by line, and converts it into a dictionary format. It handles key-value pairs separated by \":\" and comma-separated values. If the value is not found in given keys, it defaults to 0. If the value is \"True\" or \"False\", it converts it to lowercase before adding to the dictionary. The code also handles line endings and removes leading \"#\" from keys. Finally, it replaces parentheses with square brackets before returning the processed dictionary.",
        "type": "comment"
    },
    "780": {
        "file_id": 60,
        "content": "            mdict = \"{\" + mdict2 + \"}\"  # might be empty somehow.\n            # print(mdict)\n            mdict = json.loads(mdict)\n        else:\n            mdict = {}\n        item_obj = lexicalItem(path, **mdict)\n        return item_obj\n    def parse(self, script):\n        # will raise exception on unparseable lines.\n        script_obj = lexicalScript()\n        lines = script.split(\"\\n\\n\")\n        lines = [x for x in lines if self.detectGrammar(x)]\n        for line in lines:\n            line_obj = lexicalGroup()\n            # first let's remove all comments.\n            comment_expression = re.compile(r\"#[^\\n]+\")\n            newLine = \"\"\n            for elem in comment_expression.split(line):\n                if not comment_expression.match(elem):\n                    newLine+=elem\n            line = newLine\n            line = line.replace(\"\\n\", \"\").replace(\"\\t\", \"\")\n            line = line.strip()  # have extra spacings.\n            for item in self.getItems(line):\n                if self.detectGrammar(item):\n                    # print(\"item:\",item)",
        "type": "code",
        "location": "/pyjom/medialang/core.py:329-355"
    },
    "781": {
        "file_id": 60,
        "content": "This code defines two functions, \"parse\" and \"__init__\". The \"__init__\" function initializes a class with a path argument. The \"parse\" function takes a script as input, splits it into lines, filters out unparseable lines, and creates objects for each line that is parseable. It removes comments, trims whitespace, and checks if the resulting items are parseable. If so, it adds them to a lexicalGroup object, which will then be added to a lexicalScript object. The code also contains a method to get items from a line of code.",
        "type": "comment"
    },
    "782": {
        "file_id": 60,
        "content": "                    # print(\"item length:\",len(item))\n                    # breakpoint()\n                    try:\n                        item_obj = self.parseItem(item)\n                        line_obj.append(item_obj)\n                    except:\n                        traceback.print_exc()\n                        error_msg = \"Error found in:\\n{}\".format(item)\n                        if self.script_path:\n                            error_msg += \"\\nScript at:\\n{}\".format(self.script_path)\n                        raise Exception(error_msg)\n            script_obj.append(line_obj)\n        return script_obj\n    def prettify(self, script=None, inplace=False):\n        if script == None:\n            assert self.script is not None\n            script = self.script\n        if self.script_obj is None:\n            script_obj = self.parse(script)\n        else:\n            script_obj = self.script_obj\n        script = self.generate(script_obj)\n        if self.script_path is not None:\n            if inplace:\n                with open(self.script_path, \"w+\", encoding=self.encoding) as f:",
        "type": "code",
        "location": "/pyjom/medialang/core.py:356-381"
    },
    "783": {
        "file_id": 60,
        "content": "The code is parsing a script and handling any errors that occur during the process. It appends lines to a script object, checks if the script_obj exists, generates the script based on the script_obj, and writes it to the specified file (if inplace=True).",
        "type": "comment"
    },
    "784": {
        "file_id": 60,
        "content": "                    f.write(script)\n        return script\n    def checkItemType(self, item):\n        assert type(item) == lexicalItem  # you really should learn how to rest.\n        path = item.path\n        if path.startswith(\".\"):\n            return \"output\"\n        for key in medialangProtocols:\n            for elem in medialangProtocols[key]:\n                if path.startswith(elem):\n                    return key\n        if os.path.exists(path):\n            return \"input\"\n        return \"output\"\n    def objectAssertion(self, previous, objectType):\n        assert objectType in [\"input\", \"output\"]\n        if objectType == \"output\":\n            assert previous is not None\n    def objectExecutor(self, item, previous=None):\n        objectType = self.checkItemType(item)\n        path = item.path\n        args = item.args\n        self.objectAssertion(previous, objectType)\n        result = {}  # how to ensure it will do?\n        if objectType == \"output\":\n            if path.startswith(\".\"):\n                function = dotProcessors[path]",
        "type": "code",
        "location": "/pyjom/medialang/core.py:382-411"
    },
    "785": {
        "file_id": 60,
        "content": "This code contains various utility functions used in the medialang module. The 'checkItemType' function determines if an item is an input, output, or protocol file based on its path. The 'objectAssertion' function ensures that the specified object type is either \"input\" or \"output\". Lastly, the 'objectExecutor' function executes a specific action depending on the object type by calling appropriate functions.",
        "type": "comment"
    },
    "786": {
        "file_id": 60,
        "content": "                result = function(item, previous, verbose=self.verbose, medialangTmpDir=self.medialangTmpDir)\n        else:\n            if os.path.exists(path):\n                data = fsProcessor(item, previous=previous, verbose=self.verbose, medialangTmpDir = self.medialangTmpDir)\n                result = data\n            else:\n                pass\n                # inputs. handle with protocols?\n        return result\n    def scriptStructExecutor(self, script_struct):\n        script_type = script_struct[\"type\"]\n        resources = script_struct[\"resource\"]\n        targets = script_struct[\"target\"]\n        data_array = []\n        data = None\n        print(\"Medialang script type:\", script_type)\n        if script_type == \"input\":\n            for item in targets.items:\n                data = self.objectExecutor(item, previous=data)\n            for resource in resources:\n                mdata = copy.deepcopy(data)\n                for item in resource.items:\n                    mdata = self.objectExecutor(item, previous=mdata)",
        "type": "code",
        "location": "/pyjom/medialang/core.py:412-435"
    },
    "787": {
        "file_id": 60,
        "content": "The code is implementing a script execution function. It checks the type of script and executes it accordingly, handling inputs, resources, and targets. The scriptStructExecutor function determines the type of script (input) and iterates through its targets and resources to execute objects using the objectExecutor function. If the path exists, it calls the fsProcessor function; otherwise, it does nothing.",
        "type": "comment"
    },
    "788": {
        "file_id": 60,
        "content": "                data_array.append(mdata)\n        else:\n            for index0, resource in enumerate(resources):\n                # print(\"RESOURCE ENUMERATE\",index0, resource)\n                # breakpoint()\n                mdata = None\n                mdata_array = []\n                for index1, item in enumerate(resource.items):\n                    mdata = self.objectExecutor(item, previous=mdata)\n                    if self.verbose:\n                        print(\"input {}-{}:\".format(index0, index1), mdata) # this is the wrong data array!\n                    mdata_array.append({\"item\":item, \"cache\": mdata}) # where you store all the intermediate files per clip.\n                data_array.append(copy.deepcopy(mdata_array))\n            data = copy.deepcopy(data_array) # so this is your freaking data! let's decide your approach all inside that dotProcessor instead of generating trash here!\n            for item in targets.items:\n                data = self.objectExecutor(item, previous=data)\n        return data, data_array # why you return this!",
        "type": "code",
        "location": "/pyjom/medialang/core.py:436-452"
    },
    "789": {
        "file_id": 60,
        "content": "This code appears to be part of a larger program that processes media resources. It seems to create arrays of intermediate data for each clip, deep copy them into the main data array, and then execute objects on the main data array. The function returns two values: data and data_array. The purpose or use of these returned values is unclear in this context.",
        "type": "comment"
    },
    "790": {
        "file_id": 60,
        "content": "        # currently, data is now the editly json, and data_array is the medialang items array\n        # what about the slient flag? deal with it later!\n    def execute(self):\n        script_obj_lines = self.script_obj.lines\n        assert len(script_obj_lines) >= 1\n        script_struct = {\n            \"target\": script_obj_lines[0],\n            \"resource\": script_obj_lines[1:],\n        }\n        first_target = script_struct[\"target\"].items[0]\n        script_type = self.checkItemType(first_target)\n        script_struct[\"type\"] = script_type\n        item_types = [\"input\", \"output\"]\n        for item_type in item_types:\n            if script_type == item_type:\n                # this is analysis type mediascript. all following shall be output.\n                for line in script_struct[\"resource\"]:\n                    elem = line.items[\n                        0\n                    ]  # only make sure the first item of each line is in agreement with the type rules.\n                    this_item_type = self.checkItemType(elem)",
        "type": "code",
        "location": "/pyjom/medialang/core.py:453-474"
    },
    "791": {
        "file_id": 60,
        "content": "This code defines a function that executes a script object, splits it into target and resource sections, determines the type of the script (input or output), and checks the item type for each line in the resource section.",
        "type": "comment"
    },
    "792": {
        "file_id": 60,
        "content": "                    try:\n                        assert this_item_type is not item_type\n                    except:\n                        traceback.print_exc()\n                        print(\"Medialang Error when parsing resource:\")\n                        print(line)\n                        print(\"Medialang itemtype:\", this_item_type)\n                        print(elem)\n                        if self.script_path:\n                            print(\"Medialang Script path:\", self.script_path)\n                        os.abort()\n                result = self.scriptStructExecutor(script_struct)\n                return result  # tuple (data, data_array)",
        "type": "code",
        "location": "/pyjom/medialang/core.py:475-487"
    },
    "793": {
        "file_id": 60,
        "content": "This code segment is part of a script that handles parsing resources in a Medialang environment. If the item type doesn't match, it prints an error message and aborts the script. Afterwards, it executes the script structure and returns a tuple containing data and data_array.",
        "type": "comment"
    },
    "794": {
        "file_id": 61,
        "content": "/pyjom/medialang/commons.py",
        "type": "filepath"
    },
    "795": {
        "file_id": 61,
        "content": "This code defines functions for serializing SRT objects, handling fatal errors in Medialang, and generating temporary media file names. It also sets the default temporary media directory and uses UUIDs to generate unique filenames.",
        "type": "summary"
    },
    "796": {
        "file_id": 61,
        "content": "from pyjom.commons import *\ndef serializeSRT(srtObj):\n    index = srtObj.index\n    start = srtObj.start.total_seconds()\n    end = srtObj.end.total_seconds()\n    content = srtObj.content\n    data = {\"index\": index, \"timespan\": [start, end], \"content\": content}\n    return data\ndef medialangFatalError(error_msg, script_file):\n    print(\"Medialang fatal error:\", os.path.abspath(script_file))\n    print(error_msg)\n    os.abort()\nmedialangTmpDir = \"/dev/shm/medialang\"\ndef getTmpMediaName(medialangTmpDir = medialangTmpDir):\n    while True:\n        uniq_id = str(uuid.uuid4())\n        uniq_id = uniq_id.replace(\"-\", \"\")\n        fname = \"{}.ts\".format(uniq_id)\n        fpath = os.path.join(medialangTmpDir, fname) # why no respect to the medialang config!\n        if not os.path.exists(fpath):\n            return fpath",
        "type": "code",
        "location": "/pyjom/medialang/commons.py:1-29"
    },
    "797": {
        "file_id": 61,
        "content": "This code defines functions for serializing SRT objects, handling fatal errors in Medialang, and generating temporary media file names. It also sets the default temporary media directory and uses UUIDs to generate unique filenames.",
        "type": "comment"
    },
    "798": {
        "file_id": 62,
        "content": "/pyjom/medialang/__main__.py",
        "type": "filepath"
    },
    "799": {
        "file_id": 62,
        "content": "The code sets up argument parsing for a medialang file path, initializes a Medialang object with the parsed script_path, and if the script_obj is not None, it prettifies the script in-place and prints the path of the prettified script.",
        "type": "summary"
    }
}