{
    "5400": {
        "file_id": 701,
        "content": "C%22%E4%BB%99%E6%9E%97%E8%A1%97%E9%81%93%5C%22%2C%5C%22townDivisionCode%5C%22%3A%5C%22320113007%5C%22%2C%5C%22type%5C%22%3A%5C%22deliver%5C%22%7D%7D%2C%5C%22eleme%5C%22%3A%7B%5C%22storeInfos%5C%22%3A%5B%7B%5C%22storeId%5C%22%3A%5C%22999%5C%22%7D%5D%7D%2C%5C%22meeting_place%5C%22%3A%7B%7D%2C%5C%22on_time_promise%5C%22%3A%7B%5C%22storeInfos%5C%22%3A%5B%7B%5C%22storeId%5C%22%3A%5C%22353585008%5C%22%7D%2C%7B%5C%22storeId%5C%22%3A%5C%22353612036%5C%22%7D%2C%7B%5C%22storeId%5C%22%3A%5C%22525826023%5C%22%7D%5D%7D%2C%5C%22same_city_buy%5C%22%3A%7B%7D%2C%5C%22tmall_market_o2o%5C%22%3A%7B%5C%22storeInfos%5C%22%3A%5B%7B%5C%22storeId%5C%22%3A%5C%22235565019%5C%22%7D%5D%7D%2C%5C%22txd%5C%22%3A%7B%5C%22storeInfos%5C%22%3A%5B%7B%5C%22storeId%5C%22%3A%5C%22707447478%5C%22%7D%5D%7D%7D%22%2C%22gpsEnabled%22%3A%22false%22%2C%\"",
        "type": "code",
        "location": "/tests/taobao_guangguang_download_哇哦视频_淘宝逛逛_tiktok_douyin/taobao_query.sh:11-11"
    },
    "5401": {
        "file_id": 701,
        "content": "This code contains nested JSON objects representing various services and store information for an online platform. It includes options for food delivery, eleme, meeting place, on-time promise, same city buy, tmall_market_o2o, and txd with their respective store IDs. GPS is disabled.",
        "type": "comment"
    },
    "5402": {
        "file_id": 702,
        "content": "/tests/taobao_guangguang_download_哇哦视频_淘宝逛逛_tiktok_douyin/run_weishi.sh",
        "type": "filepath"
    },
    "5403": {
        "file_id": 702,
        "content": "This command starts Mitmproxy in Socks5 mode, listens on port 8050 for incoming connections, writes logs to weishi.log, and enables handling of WebSocket streams.",
        "type": "summary"
    },
    "5404": {
        "file_id": 702,
        "content": "mitmproxy --mode socks5 --listen-port 8050 -w weishi.log --set stream_websocket=true",
        "type": "code",
        "location": "/tests/taobao_guangguang_download_哇哦视频_淘宝逛逛_tiktok_douyin/run_weishi.sh:1-1"
    },
    "5405": {
        "file_id": 702,
        "content": "This command starts Mitmproxy in Socks5 mode, listens on port 8050 for incoming connections, writes logs to weishi.log, and enables handling of WebSocket streams.",
        "type": "comment"
    },
    "5406": {
        "file_id": 703,
        "content": "/tests/taobao_guangguang_download_哇哦视频_淘宝逛逛_tiktok_douyin/run_gg.sh",
        "type": "filepath"
    },
    "5407": {
        "file_id": 703,
        "content": "This command starts mitmproxy in socks5 mode, listening on port 8050 and logs to gg.log. It also enables websocket streaming support. The user asks for domain name confirmation and doubts about IP stability.",
        "type": "summary"
    },
    "5408": {
        "file_id": 703,
        "content": "mitmproxy --mode socks5 --listen-port 8050 -w gg.log --set stream_websocket=true\n# what is the domain name for this service? are you sure the ip will not change?",
        "type": "code",
        "location": "/tests/taobao_guangguang_download_哇哦视频_淘宝逛逛_tiktok_douyin/run_gg.sh:1-3"
    },
    "5409": {
        "file_id": 703,
        "content": "This command starts mitmproxy in socks5 mode, listening on port 8050 and logs to gg.log. It also enables websocket streaming support. The user asks for domain name confirmation and doubts about IP stability.",
        "type": "comment"
    },
    "5410": {
        "file_id": 704,
        "content": "/tests/taobao_guangguang_download_哇哦视频_淘宝逛逛_tiktok_douyin/README.md",
        "type": "filepath"
    },
    "5411": {
        "file_id": 704,
        "content": "This code seems to be related to the tiktok_douyin module of pyjom project. It refers to a server address (111.48.141.77:8081) and mentions that the direction arrows indicate request and response, suggesting it deals with network communication. The code also references a query related to taobao guangguang, indicating it could be used for data retrieval from the Tmall platform of Taobao, involving an app crawler. It also refers to a JAR file for further information on how this is implemented.",
        "type": "summary"
    },
    "5412": {
        "file_id": 704,
        "content": "weishi use jce with TYPE_COMPRESS\nwhat is this server doing?\n111.48.141.77:8081\nmaybe the direction is not right.\n-> is response.\n<- is request.\nhttps://github.com/tsuzcx/qq_apk/blob/36c43445f737ed1c8854ce9dadac3979a0fc8b90/com.tencent.tim/classes.jar/com/tencent/beacon/base/net/b/d.java\nfor taobao guangguang it seems just a query away. but that query is a long one. hard to tell.\n淘口令解析\n淘宝app爬虫",
        "type": "code",
        "location": "/tests/taobao_guangguang_download_哇哦视频_淘宝逛逛_tiktok_douyin/README.md:1-17"
    },
    "5413": {
        "file_id": 704,
        "content": "This code seems to be related to the tiktok_douyin module of pyjom project. It refers to a server address (111.48.141.77:8081) and mentions that the direction arrows indicate request and response, suggesting it deals with network communication. The code also references a query related to taobao guangguang, indicating it could be used for data retrieval from the Tmall platform of Taobao, involving an app crawler. It also refers to a JAR file for further information on how this is implemented.",
        "type": "comment"
    },
    "5414": {
        "file_id": 705,
        "content": "/tests/taobao_guangguang_download_哇哦视频_淘宝逛逛_tiktok_douyin/guangguang_update.sh",
        "type": "filepath"
    },
    "5415": {
        "file_id": 705,
        "content": "The code fetches Taobao API content recommendations using JSONP, specific parameters, and JavaScript version 2.6.1 with authentication cookies in two GET requests; it also sends a POST request with JSON format to an API endpoint including authentication, but the purpose remains unclear.",
        "type": "summary"
    },
    "5416": {
        "file_id": 705,
        "content": "# curl 'https://h5api.m.taobao.com/h5/mtop.taobao.content.detail.mix.recommend.h5/1.0/?jsv=2.6.1&appKey=12574478&t=1652513788601&sign=898aac6857c0497f83579230a5117e9e&api=mtop.taobao.content.detail.mix.recommend.h5&v=1.0&H5Request=true&preventFallback=true&type=jsonp&dataType=jsonp&callback=mtopjsonp3&data=%7B%22contentId%22%3A%22346882467812%22%2C%22source%22%3A%22guangguang_cainixihuan%22%2C%22pageSize%22%3A5%2C%22pageIndex%22%3A0%2C%22bizParameters%22%3A%22%7B%5C%22itemIds%5C%22%3A%5B%5D%2C%5C%22contentId%5C%22%3A%5C%22346882467812%5C%22%2C%5C%22videoId%5C%22%3A%5C%22346882467812%5C%22%7D%22%2C%22extendParameters%22%3A%22%7B%5C%22expoContents%5C%22%3A%5C%22346882467812%5C%22%2C%5C%22slideAction%5C%22%3A%5C%22up%5C%22%2C%5C%22utparam%5C%22%3Anull%2C%5C%22page%5C%22%3A%5C%22guess-guangguang%5C%22%7D%22%7D' -H 'User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:91.0) Gecko/20100101 Firefox/91.0' -H 'Accept: */*' -H 'Accept-Language: en-US,en;q=0.5' --compressed -H 'Connection: keep-alive' ",
        "type": "code",
        "location": "/tests/taobao_guangguang_download_哇哦视频_淘宝逛逛_tiktok_douyin/guangguang_update.sh:1-1"
    },
    "5417": {
        "file_id": 705,
        "content": "This code is making a GET request to retrieve data from the Taobao API endpoint for content recommendations. It uses JSONP as the data type and callback parameter, specifies the content ID and source, and sets some other parameters like page size and index.",
        "type": "comment"
    },
    "5418": {
        "file_id": 705,
        "content": "-H 'Referer: https://market.m.taobao.com/' -H 'Cookie: cna=xXJJF/edElYCAd9ok0ozTO9S; isg=BJCQTV2Txmwd0ZnJwllsjEHhYtfiWXSjzRmbHophXOu-xTBvMmlEM-b3nQUlDix7; tfstk=cXgPBIwvIGQj6XUTrzaedIY7JeERZ4r3bZPLqdArAHqPwSrci16Limmag5IpJuf..; l=eBSy3J_rg94a6G7SBOfahurza77OSIOYYuPzaNbMiOCP9L1H5PGOW64n2rTMC31Nh6zWR3orgupwBeYBYIc8c1UNiHwStXDmn; miid=5838535061391394454; enc=iGbYsBExryBryNGDIeLiB3TSNdcdTPSzvhRgC0EExZrv5jHl85qb6bwqwxCyHxis8MkbUtiGLNI%2FRL7axbcx4GXUUuIsmiBDAl4K%2BLKyFBGK0mR%2FlBHvBVipuG5%2BY2CL; thw=cn; t=bc8cdf0df40cdf9cf6967741f7a75f8a; _m_h5_tk=8461de16a664d8efdf7a03b9cb8551f9_1652520895580; _m_h5_tk_enc=4a0616ef73708445252bf305732ce7fe; xlly_s=1' -H 'Sec-Fetch-Dest: script' -H 'Sec-Fetch-Mode: no-cors' -H 'Sec-Fetch-Site: same-site' -H 'TE: trailers'\n# how to get the freaking cat?\n# but what are these signs?\ncurl  'https://h5api.m.taobao.com/h5/mtop.taobao.content.detail.mix.recommend.h5/1.0/?jsv=2.6.1&appKey=12574478&t=1652513788601&sign=898aac6857c0497f83579230a5117e9e&api=mtop.taobao.c",
        "type": "code",
        "location": "/tests/taobao_guangguang_download_哇哦视频_淘宝逛逛_tiktok_douyin/guangguang_update.sh:1-7"
    },
    "5419": {
        "file_id": 705,
        "content": "This code is making a HTTP GET request to 'https://h5api.m.taobao.com/h5/mtop.taobao.content.detail.mix.recommend.h5/1.0/' with various headers, including Cookie and Referer. The purpose might be to fetch data from the server or interact with the website's API. It seems to involve authentication as it contains multiple cookies and other tokens.",
        "type": "comment"
    },
    "5420": {
        "file_id": 705,
        "content": "ontent.detail.mix.recommend.h5&v=1.0&H5Request=true&preventFallback=true&type=jsonp&dataType=jsonp&callback=mtopjsonp3&data=%7B%22contentId%22%3A%22346882467812%22%2C%22source%22%3A%22guangguang_cainixihuan%22%2C%22pageSize%22%3A5%2C%22pageIndex%22%3A0%2C%22bizParameters%22%3A%22%7B%5C%22itemIds%5C%22%3A%5B%5D%2C%5C%22contentId%5C%22%3A%5C%22346882467812%5C%22%2C%5C%22videoId%5C%22%3A%5C%22346882467812%5C%22%7D%22%2C%22extendParameters%22%3A%22%7B%5C%22expoContents%5C%22%3A%5C%22346882467812%5C%22%2C%5C%22slideAction%5C%22%3A%5C%22up%5C%22%2C%5C%22utparam%5C%22%3Anull%2C%5C%22page%5C%22%3A%5C%22guess-guangguang%5C%22%7D%22%7D'  -H \"Cookie: _m_h5_tk=8461de16a664d8efdf7a03b9cb8551f9_1652520895580; _m_h5_tk_enc=4a0616ef73708445252bf305732ce7fe;\"\n# mtop.taobao.content.detail.mix.recommend.h5\n# execute it twice to get the cookie. no need for other shits.\n# jsv\n# \t2.6.1\n# appKey\n# \t12574478\n# t\n# \t1652513695322\n# sign\n# \t8b9b8134ff54f4d4a725dc37db8f10e1\n# api\n# \tmtop.taobao.content.detail.mix.detail.h5\n# v",
        "type": "code",
        "location": "/tests/taobao_guangguang_download_哇哦视频_淘宝逛逛_tiktok_douyin/guangguang_update.sh:7-22"
    },
    "5421": {
        "file_id": 705,
        "content": "The code is making a GET request to retrieve the recommended content from Taobao's API. It includes specific parameters, such as content ID, source, page size, and page index. The request is using JSONP format with a specified callback function \"mtopjsonp3\". The cookies _m_h5_tk and _m_h5_tk_enc are included in the headers for authentication. The code is written in JavaScript (jsv) using version 2.6.1. The request will be executed twice, but it's unclear why, as there are no other relevant instructions provided.",
        "type": "comment"
    },
    "5422": {
        "file_id": 705,
        "content": "# \t1.0\n# H5Request\n# \ttrue\n# preventFallback\n# \ttrue\n# type\n# \tjsonp\n# dataType\n# \tjsonp\n# callback\n# \tmtopjsonp1\n# data\n# \t{\"contentId\":\"346882467812\",\"source\":\"guangguang_cainixihuan\",\"extendParameters\":\"{\\\"page\\\":\\\"guess-guangguang\\\",\\\"product_type\\\":\\\"videointeract\\\"}\"}\n# contentId, videoId, expoContents, all have videoId inside\n# https://market.m.taobao.com/app/tb-source-app/video-fullpage/pages/index?wh_weex=true&wx_navbar_hidden=true&origin=VideoInteract%7Ca310p.13800399.0.0%7C%7B%22contentId%22%3A%22346882467812%22%7D&contentId=346882467812&source=guess-guangguang&type=guangguang_cainixihuan&spm=a2141.1.guessitemtab_1.3&accountId=0&videoUrl=https%3A%2F%2Fcloud.video.taobao.com%2Fplay%2Fu%2Fnull%2Fp%2F1%2Fe%2F6%2Ft%2F1%2F346882467812.mp4&coverImage=https%3A%2F%2Fimg.alicdn.com%2Fimgextra%2Fi2%2F604321789%2FO1CN01rVTgs31P5PIQ7r2JR_!!604321789.jpg&id=346882467812&sourceType=other&suid=7f31e56f-2878-4462-9a5a-acd7d5deeec5&ut_sk=1.W4yy2CtIMUMDAA1l3Dnx4jNG_21646297_1651742283972.Copy.tblive-video&",
        "type": "code",
        "location": "/tests/taobao_guangguang_download_哇哦视频_淘宝逛逛_tiktok_douyin/guangguang_update.sh:23-39"
    },
    "5423": {
        "file_id": 705,
        "content": "This code seems to be a request for video information from Taobao API, specifying parameters like contentId, source, and extendParameters. It is using JSONP as the data type and includes a callback function \"mtopjsonp1\". The URL points to video resources on Taobao's platform.",
        "type": "comment"
    },
    "5424": {
        "file_id": 705,
        "content": "un=42ad1253bebcb796f3ba5a7177d3a823&share_crt_v=1&un_site=0&sp_abtk=common_tblive-video_commonInfo&sp_tk=55Sf5a%2B55Zyo54S25pyJ5Li65LiK5a2Q5piv5Y675L2g&cpp=1&shareurl=true&short_name=h.fJE9C6B&bxsign=scdEMXp8zB45hs84KNhAae8siAPZ43wmqm4C-4UXtj2EzGyI0oMyb12vk2tKevOe4p1bZfPRmWxc9UVR3vFx6qhAj6WS0roAs_XJt2bkVF7n1o6YetJv7wgLiCitW-wW5CW&sm=ee59f9&app=firefox\n# https://g.alicdn.com/tnode/fullpageshortvideo/2.1.0/main.json.json\n# wtf is this shit? binary?\n# https://g.alicdn.com/tnode/fullpageshortvideo/2.1.0/main.json.json\nset $parameter=\"359455393248\"\ncurl  'https://h5api.m.taobao.com/h5/mtop.taobao.content.detail.mix.recommend.h5/1.0/?jsv=2.6.1&api=mtop.taobao.content.detail.mix.recommend.h5&v=1.0&H5Request=true&preventFallback=true&type=jsonp&dataType=jsonp&callback=mtopjsonp3&data=%7B%22contentId%22%3A%22'$parameter'%22%2C%22source%22%3A%22guangguang_cainixihuan%22%2C%22pageSize%22%3A5%2C%22pageIndex%22%3A0%2C%22bizParameters%22%3A%22%7B%5C%22itemIds%5C%22%3A%5B%5D%2C%5C%22contentId%5C%22%3A%5C%",
        "type": "code",
        "location": "/tests/taobao_guangguang_download_哇哦视频_淘宝逛逛_tiktok_douyin/guangguang_update.sh:39-47"
    },
    "5425": {
        "file_id": 705,
        "content": "This code seems to be a URL for fetching data using the cURL command-line tool. It makes a GET request to 'https://h5api.m.taobao.com/...' with specific parameters like jsv, api, preventFallback, type, dataType, and callback, along with the contentId and source. The purpose of this request is unclear as it's mentioned that \"wtf is this shit? binary?\"",
        "type": "comment"
    },
    "5426": {
        "file_id": 705,
        "content": "22'$parameter'%5C%22%2C%5C%22videoId%5C%22%3A%5C%22'$parameter'%5C%22%7D%22%2C%22extendParameters%22%3A%22%7B%5C%22expoContents%5C%22%3A%5C%22'$parameter'%5C%22%2C%5C%22slideAction%5C%22%3A%5C%22up%5C%22%2C%5C%22utparam%5C%22%3Anull%2C%5C%22page%5C%22%3A%5C%22guess-guangguang%5C%22%7D%22%7D'  -H \"Cookie: _m_h5_tk=8461de16a664d8efdf7a03b9cb8551f9_1652520895580; _m_h5_tk_enc=4a0616ef73708445252bf305732ce7fe;\"",
        "type": "code",
        "location": "/tests/taobao_guangguang_download_哇哦视频_淘宝逛逛_tiktok_douyin/guangguang_update.sh:47-47"
    },
    "5427": {
        "file_id": 705,
        "content": "This code is sending a POST request with parameters in JSON format to an API endpoint. The request includes \"videoId\" and \"extendParameters\" which contain values from '$parameter'. It also sets a Cookie header for authentication.",
        "type": "comment"
    },
    "5428": {
        "file_id": 706,
        "content": "/tests/still_watermark_auto_removal/test_auto_video_watermark_detection.sh",
        "type": "filepath"
    },
    "5429": {
        "file_id": 706,
        "content": "cd into the automatic-watermark-detection directory and execute the video_watermark_detection.py script for watermark detection in videos.",
        "type": "summary"
    },
    "5430": {
        "file_id": 706,
        "content": "cd automatic-watermark-detection\npython3 video_watermark_detection.py",
        "type": "code",
        "location": "/tests/still_watermark_auto_removal/test_auto_video_watermark_detection.sh:1-3"
    },
    "5431": {
        "file_id": 706,
        "content": "cd into the automatic-watermark-detection directory and execute the video_watermark_detection.py script for watermark detection in videos.",
        "type": "comment"
    },
    "5432": {
        "file_id": 707,
        "content": "/tests/still_watermark_auto_removal/maxRectangleSolver.py",
        "type": "filepath"
    },
    "5433": {
        "file_id": 707,
        "content": "The code defines checkOverlap for point validation and solves the maximum rectangle problem, iterating through candidate rectangles, detecting overlaps, and displaying the best candidate in red. It also sorts and prints top 5 areas.",
        "type": "summary"
    },
    "5434": {
        "file_id": 707,
        "content": "import sympy\nimport json\ndata = json.loads(open(\"test_special.json\", \"r\").read())\ncanvas = data[\"canvas\"]\nrectangles = data[\"rectangles\"]\ncanvasWidth, canvasHeight = canvas\nxValid = [0, canvasWidth]\nyValid = [0, canvasHeight]\nmRects = []\ndef checkContains(rect, point):\n    xPoints = [p[0] for p in rect]\n    yPoints = [p[1] for p in rect]\n    maxX, minX = max(xPoints), min(xPoints)\n    maxY, minY = max(yPoints), min(yPoints)\n    x, y = point\n    return x > minX and x < maxX and y > minY and y < maxY\n# def checkOverlapAsymmetric(rect0, rect1):\n#     for point in rect0:\n#         if checkContains(rect1, point):\n#             return True\n#         # also check for intersections?\n#     return False\n# Python program to check if rectangles overlap\nclass D2Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\ndef getRectDiagonalPoints(rect):\n    xPoints = [p[0] for p in rect]\n    yPoints = [p[1] for p in rect]\n    maxX, minX = max(xPoints), min(xPoints)\n    maxY, minY = max(yPoints), min(yPoints)\n    p0, p1 = D2Point(minX, minY), D2Point(maxX, maxY)",
        "type": "code",
        "location": "/tests/still_watermark_auto_removal/maxRectangleSolver.py:1-43"
    },
    "5435": {
        "file_id": 707,
        "content": "Code reads JSON data containing a canvas and rectangles. It validates points, creates a function to check if two rectangles overlap, and defines D2Point class for storing 2D point coordinates.",
        "type": "comment"
    },
    "5436": {
        "file_id": 707,
        "content": "    return p0, p1\ndef do_overlap(l1, r1, l2, r2):\n    # if rectangle has area 0, no overlap\n    if l1.x == r1.x or l1.y == r1.y or r2.x == l2.x or l2.y == r2.y:\n        return False\n    # If one rectangle is on left side of other\n    if l1.x >= r2.x or l2.x >= r1.x:\n        return False\n    if l1.y >= r2.y or l2.y >= r1.y:\n        return False\n    return True\ndef checkOverlap(rect0, rect1):\n    return do_overlap(*getRectDiagonalPoints(rect0),*getRectDiagonalPoints(rect1))\nfor x, y, mWidth, mHeight in rectangles:\n    xValid.append(x)\n    xValid.append(x + mWidth)\n    yValid.append(y)\n    yValid.append(y + mHeight)\n    p0, p1, p2, p3 = (\n        (x, y),\n        (x + mWidth, y),\n        (x + mWidth, y + mHeight),\n        (x, y + mHeight),\n    )\n    # mRectangle = sympy.Polygon(p0,p1,p2,p3)\n    mRectangle = [p0, p1, p2, p3]\n    mRects.append(mRectangle)\ndef purify(xValid):\n    xValid = list(set(xValid))\n    xValid.sort()\n    return xValid\ndef checkOverlapAgainstRectList(rect, rectList):\n    for testRect in rectList:\n        if checkOverlap(rect, testRect):",
        "type": "code",
        "location": "/tests/still_watermark_auto_removal/maxRectangleSolver.py:44-85"
    },
    "5437": {
        "file_id": 707,
        "content": "This code defines a function checkOverlap which takes two rectangles and checks if they overlap. The function do_overlap is used to determine if the rectangles have any area of overlap. It also includes utility functions like getRectDiagonalPoints, purify, and checkOverlapAgainstRectList for manipulating and comparing rectangles. The code creates a list of rectangles and checks for overlaps between each rectangle and others in a separate list.",
        "type": "comment"
    },
    "5438": {
        "file_id": 707,
        "content": "            return True\n    return False\nxValid = purify(xValid)\nyValid = purify(yValid)\ntotalCandidates = []\ndef getRectArea(rect):\n    xPoints = [p[0] for p in rect]\n    yPoints = [p[1] for p in rect]\n    maxX, minX = max(xPoints), min(xPoints)\n    maxY, minY = max(yPoints), min(yPoints)\n    return (maxX - minX) * (maxY - minY)\nbestCandidate = None\nbestArea = 0\nfor ix0 in range(0, len(xValid)-1):\n    for ix1 in range(ix0+1, len(xValid)):\n        for iy0 in range(0, len(yValid)-1):\n            for iy1 in range(iy0+1, len(yValid)):\n                x0, x1, y0, y1 = xValid[ix0], xValid[ix1], yValid[iy0], yValid[iy1]\n                x, y = x0, y0\n                mWidth, mHeight = x1 - x, y1 - y\n                p0, p1, p2, p3 = (\n                    (x, y),\n                    (x + mWidth, y),\n                    (x + mWidth, y + mHeight),\n                    (x, y + mHeight),\n                )\n                rectCandidate = [p0, p1, p2, p3]\n                area = getRectArea(rectCandidate)\n                if area <= bestArea:",
        "type": "code",
        "location": "/tests/still_watermark_auto_removal/maxRectangleSolver.py:86-120"
    },
    "5439": {
        "file_id": 707,
        "content": "The code is implementing a maximum rectangle solver algorithm. It iterates over the x and y validated points to generate all possible rectangles, calculating their areas using the getRectArea function. The best candidate with the highest area is stored.",
        "type": "comment"
    },
    "5440": {
        "file_id": 707,
        "content": "                    continue\n                if checkOverlapAgainstRectList(rectCandidate, mRects):\n                    break\n                bestCandidate = rectCandidate.copy()\n                bestArea = area\n                # print(\"UPDATING:\",bestCandidate)\n                # print('AREA:', bestArea)\n                # totalCandidates.append(rectCandidate.copy())\nprint(\"final candidate:\", bestCandidate)\n# plot this?\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Rectangle\nfig, ax = plt.subplots()\nax.plot([canvasWidth, canvasHeight])\n# add rectangle to plot\ndef plotRect(ax, x, y, width, height, facecolor):\n    ax.add_patch(Rectangle((x, y), width, height, facecolor=facecolor, fill=True))\ndef rectToXYWH(rect):\n    xPoints = [p[0] for p in rect]\n    yPoints = [p[1] for p in rect]\n    maxX, minX = max(xPoints), min(xPoints)\n    maxY, minY = max(yPoints), min(yPoints)\n    x, y = minX, minY\n    width, height = (maxX - minX), (maxY - minY)\n    return x, y, width, height\nplotRect(ax,0,0,canvasWidth, canvasHeight,'black')",
        "type": "code",
        "location": "/tests/still_watermark_auto_removal/maxRectangleSolver.py:121-151"
    },
    "5441": {
        "file_id": 707,
        "content": "This code finds the maximum rectangle by iterating through candidate rectangles and checking for overlaps. It updates the best candidate and area if a better one is found, then plots the final candidate rectangle on a plot.",
        "type": "comment"
    },
    "5442": {
        "file_id": 707,
        "content": "for rect in mRects:\n    x,y, width, height = rectToXYWH(rect)\n    plotRect(ax,x,y,width,height,'white')\nplotRect(ax,*rectToXYWH(bestCandidate),'red')\n# display plot\nplt.show()\n# totalCandidates.sort(key = lambda rect: -getRectArea(rect))\n# for rect in totalCandidates[:5]:\n#     print(rect)",
        "type": "code",
        "location": "/tests/still_watermark_auto_removal/maxRectangleSolver.py:153-161"
    },
    "5443": {
        "file_id": 707,
        "content": "The code generates and plots rectangles using given coordinates and dimensions, with the best candidate rectangle displayed in red. It also sorts the total list of candidate rectangles by area and prints the top 5 areas.",
        "type": "comment"
    },
    "5444": {
        "file_id": 708,
        "content": "/tests/still_watermark_auto_removal/EAST-Detector-for-text-detection-using-OpenCV-master/README.md",
        "type": "filepath"
    },
    "5445": {
        "file_id": 708,
        "content": "EAST Detector code in OpenCV enables real-time, accurate text detection in natural scenes, addressing challenges like angles, lighting, and non-ideal surfaces. The project welcomes improvements via pull requests and is licensed under MIT.",
        "type": "summary"
    },
    "5446": {
        "file_id": 708,
        "content": "# EAST Detector for Text Detection\nOpenCV’s EAST(Efficient and Accurate Scene Text Detection ) text detector is a deep learning model, based on a novel architecture and training pattern. It is capable of \n- running at near real-time at 13 FPS on 720p images and \n- obtains state-of-the-art text detection accuracy.\n[Link to paper](https://arxiv.org/pdf/1704.03155.pdf)\nOpenCV’s text detector implementation of EAST is quite robust, capable of localizing text even when it’s blurred, reflective, or partially obscured.\nThere are many natural scene text detection challenges that have been described by Celine Mancas-Thillou and Bernard Gosselin in their excellent 2017 paper, [Natural Scene Text Understanding](https://www.tcts.fpms.ac.be/publications/regpapers/2007/VS_cmtbg2007.pdf) below:\n- **Image/sensor noise**: Sensor noise from a handheld camera is typically higher than that of a traditional scanner. Additionally, low-priced cameras will typically interpolate the pixels of raw sensors to produce real colors.",
        "type": "code",
        "location": "/tests/still_watermark_auto_removal/EAST-Detector-for-text-detection-using-OpenCV-master/README.md:1-13"
    },
    "5447": {
        "file_id": 708,
        "content": "Code for OpenCV's EAST Detector implementation for text detection, capable of real-time performance and high accuracy. Based on a novel architecture and training pattern, it can detect text even when blurred, reflective or partially obscured. The code addresses challenges like sensor noise from handheld cameras.",
        "type": "comment"
    },
    "5448": {
        "file_id": 708,
        "content": "- **Viewing angles**: Natural scene text can naturally have viewing angles that are not parallel to the text, making the text harder to recognize.\nBlurring: Uncontrolled environments tend to have blur, especially if the end user is utilizing a smartphone that does not have some form of stabilization.\n- **Lighting conditions**: We cannot make any assumptions regarding our lighting conditions in natural scene images. It may be near dark, the flash on the camera may be on, or the sun may be shining brightly, saturating the entire image.\n- **Resolution**: Not all cameras are created equal — we may be dealing with cameras with sub-par resolution.\n- **Non-paper objects**: Most, but not all, paper is not reflective (at least in context of paper you are trying to scan). Text in natural scenes may be reflective, including logos, signs, etc.\n- **Non-planar objects**: Consider what happens when you wrap text around a bottle — the text on the surface becomes distorted and deformed. While humans may sti",
        "type": "code",
        "location": "/tests/still_watermark_auto_removal/EAST-Detector-for-text-detection-using-OpenCV-master/README.md:15-24"
    },
    "5449": {
        "file_id": 708,
        "content": "The code discusses various challenges in natural scene text detection, such as viewing angles, lighting conditions, resolution, non-paper objects (like reflective surfaces), and non-planar objects (such as distorted text on curved surfaces). These factors make it difficult to recognize and extract text from natural scenes.",
        "type": "comment"
    },
    "5450": {
        "file_id": 708,
        "content": "ll be able to easily “detect” and read the text, our algorithms will struggle. We need to be able to handle such use cases.\n- **Unknown layout**: We cannot use any a priori information to give our algorithms “clues” as to where the text resides.\n## Contributing\nPull requests are welcome. For major changes, please open an issue first to discuss what you would like to change.\n### Thanks to [Adrian's Blog](https://www.pyimagesearch.com/2018/08/20/opencv-text-detection-east-text-detector/) for a comprehensive blog on EAST Detector.\n## License\n[MIT](https://choosealicense.com/licenses/mit/)",
        "type": "code",
        "location": "/tests/still_watermark_auto_removal/EAST-Detector-for-text-detection-using-OpenCV-master/README.md:24-35"
    },
    "5451": {
        "file_id": 708,
        "content": "This code is from the README file of a project that utilizes EAST Detector, an OpenCV-based text detection algorithm. The project aims to improve its algorithms' ability to handle complex text layouts and use cases. It welcomes pull requests for major changes and is licensed under MIT.",
        "type": "comment"
    },
    "5452": {
        "file_id": 709,
        "content": "/tests/still_watermark_auto_removal/EAST-Detector-for-text-detection-using-OpenCV-master/opencv_text_detection_image.py",
        "type": "filepath"
    },
    "5453": {
        "file_id": 709,
        "content": "The code loads an input image, preprocesses it, resizes using argparse, detects text with OpenCV and EAST Detector, calculates prediction time, filters low-confidence detections, extracts scores & geometrical data, applies non-maxima suppression, scales coordinates, draws bounding boxes on the original image, and displays it.",
        "type": "summary"
    },
    "5454": {
        "file_id": 709,
        "content": "# USAGE\n# python3 opencv_text_detection_image.py --image images/lebron_james.jpg --east frozen_east_text_detection.pb\n# import the necessary packages\nfrom imutils.object_detection import non_max_suppression\nimport numpy as np\nimport argparse\nimport time\nimport cv2\n# construct the argument parser and parse the arguments\nap = argparse.ArgumentParser()\nap.add_argument(\"-i\", \"--image\", type=str,\n                help=\"path to input image\")\nap.add_argument(\"-east\", \"--east\", type=str,\n                help=\"path to input EAST text detector\")\nap.add_argument(\"-c\", \"--min-confidence\", type=float, default=0.5,\n                help=\"minimum probability required to inspect a region\")\nap.add_argument(\"-w\", \"--width\", type=int, default=320,\n                help=\"resized image width (should be multiple of 32)\")\nap.add_argument(\"-e\", \"--height\", type=int, default=320,\n                help=\"resized image height (should be multiple of 32)\")\nargs = vars(ap.parse_args())\n# load the input image and grab the image dimensions\nimage = cv2.imread(args[\"image\"])",
        "type": "code",
        "location": "/tests/still_watermark_auto_removal/EAST-Detector-for-text-detection-using-OpenCV-master/opencv_text_detection_image.py:1-26"
    },
    "5455": {
        "file_id": 709,
        "content": "This code loads an input image and applies preprocessing steps. It utilizes the argparse module to accept command-line arguments, allowing users to specify the input image path and the East text detector model file. It also sets default values for confidence threshold and resized image dimensions, which can be overridden by command-line options.",
        "type": "comment"
    },
    "5456": {
        "file_id": 709,
        "content": "orig = image.copy()\n(H, W) = image.shape[:2]\n# set the new width and height and then determine the ratio in change\n# for both the width and height\n(newW, newH) = (args[\"width\"], args[\"height\"])\nrW = W / float(newW)\nrH = H / float(newH)\n# resize the image and grab the new image dimensions\nimage = cv2.resize(image, (newW, newH))\n(H, W) = image.shape[:2]\n# define the two output layer names for the EAST detector model that\n# we are interested -- the first is the output probabilities and the\n# second can be used to derive the bounding box coordinates of text\nlayerNames = [\n    \"feature_fusion/Conv_7/Sigmoid\",\n    \"feature_fusion/concat_3\"]\n# load the pre-trained EAST text detector\nprint(\"[INFO] loading EAST text detector...\")\nnet = cv2.dnn.readNet(args[\"east\"])\n# construct a blob from the image and then perform a forward pass of\n# the model to obtain the two output layer sets\nblob = cv2.dnn.blobFromImage(image, 1.0, (W, H),\n                             (123.68, 116.78, 103.94), swapRB=True, crop=False)\nstart = time.time()",
        "type": "code",
        "location": "/tests/still_watermark_auto_removal/EAST-Detector-for-text-detection-using-OpenCV-master/opencv_text_detection_image.py:27-55"
    },
    "5457": {
        "file_id": 709,
        "content": "This code performs image preprocessing, resizing and loads the EAST text detector model for text detection. It sets the original image copy, calculates new width and height based on arguments, resizes the image, gets updated dimensions, defines output layer names for the model, loads the pre-trained EAST text detector model, constructs a blob from the image, performs a forward pass of the model to obtain two output layers.",
        "type": "comment"
    },
    "5458": {
        "file_id": 709,
        "content": "net.setInput(blob)\n(scores, geometry) = net.forward(layerNames)\nend = time.time()\n# show timing information on text prediction\nprint(\"[INFO] text detection took {:.6f} seconds\".format(end - start))\n# grab the number of rows and columns from the scores volume, then\n# initialize our set of bounding box rectangles and corresponding\n# confidence scores\n(numRows, numCols) = scores.shape[2:4]\nrects = []\nconfidences = []\n# loop over the number of rows\nfor y in range(0, numRows):\n    # extract the scores (probabilities), followed by the geometrical\n    # data used to derive potential bounding box coordinates that\n    # surround text\n    scoresData = scores[0, 0, y]\n    xData0 = geometry[0, 0, y]\n    xData1 = geometry[0, 1, y]\n    xData2 = geometry[0, 2, y]\n    xData3 = geometry[0, 3, y]\n    anglesData = geometry[0, 4, y]\n    # loop over the number of columns\n    for x in range(0, numCols):\n        # if our score does not have sufficient probability, ignore it\n        if scoresData[x] < args[\"min_confidence\"]:\n            continue",
        "type": "code",
        "location": "/tests/still_watermark_auto_removal/EAST-Detector-for-text-detection-using-OpenCV-master/opencv_text_detection_image.py:56-86"
    },
    "5459": {
        "file_id": 709,
        "content": "Code performs text detection using OpenCV and EAST Detector. It calculates the time taken for text prediction, extracts scores and geometrical data, filters out low-confidence detections, and stores bounding box rectangles and corresponding confidence scores in lists.",
        "type": "comment"
    },
    "5460": {
        "file_id": 709,
        "content": "        # compute the offset factor as our resulting feature maps will\n        # be 4x smaller than the input image\n        (offsetX, offsetY) = (x * 4.0, y * 4.0)\n        # extract the rotation angle for the prediction and then\n        # compute the sin and cosine\n        angle = anglesData[x]\n        cos = np.cos(angle)\n        sin = np.sin(angle)\n        # use the geometry volume to derive the width and height of\n        # the bounding box\n        h = xData0[x] + xData2[x]\n        w = xData1[x] + xData3[x]\n        # compute both the starting and ending (x, y)-coordinates for\n        # the text prediction bounding box\n        endX = int(offsetX + (cos * xData1[x]) + (sin * xData2[x]))\n        endY = int(offsetY - (sin * xData1[x]) + (cos * xData2[x]))\n        startX = int(endX - w)\n        startY = int(endY - h)\n        # add the bounding box coordinates and probability score to\n        # our respective lists\n        rects.append((startX, startY, endX, endY))\n        confidences.append(scoresData[x])\n# apply non-maxima suppression to suppress weak, overlapping bounding",
        "type": "code",
        "location": "/tests/still_watermark_auto_removal/EAST-Detector-for-text-detection-using-OpenCV-master/opencv_text_detection_image.py:88-115"
    },
    "5461": {
        "file_id": 709,
        "content": "This code computes the bounding box coordinates and confidence scores for text predictions, using input data such as angles, offsets, xData values. It then applies non-maxima suppression to suppress weak overlapping bounding boxes, likely for further processing or object detection purposes.",
        "type": "comment"
    },
    "5462": {
        "file_id": 709,
        "content": "# boxes\nboxes = non_max_suppression(np.array(rects), probs=confidences)\n# loop over the bounding boxes\nfor (startX, startY, endX, endY) in boxes:\n    # scale the bounding box coordinates based on the respective\n    # ratios\n    startX = int(startX * rW)\n    startY = int(startY * rH)\n    endX = int(endX * rW)\n    endY = int(endY * rH)\n    # draw the bounding box on the image\n    cv2.rectangle(orig, (startX, startY), (endX, endY), (0, 255, 0), 2)\n# show the output image\ncv2.imshow(\"Text Detection\", orig)\ncv2.waitKey(0)",
        "type": "code",
        "location": "/tests/still_watermark_auto_removal/EAST-Detector-for-text-detection-using-OpenCV-master/opencv_text_detection_image.py:116-133"
    },
    "5463": {
        "file_id": 709,
        "content": "This code performs non-maximum suppression on bounding box coordinates, scales the coordinates based on image ratios, draws bounding boxes on the original image using OpenCV, and displays the resulting image.",
        "type": "comment"
    },
    "5464": {
        "file_id": 710,
        "content": "/tests/still_watermark_auto_removal/automatic-watermark-detection/video_watermark_detection.py",
        "type": "filepath"
    },
    "5465": {
        "file_id": 710,
        "content": "The code employs OpenCV and Deep Learning for watermark detection, estimation, and removal. It detects video watermarks using adaptive thresholding, applies Gaussian blur, scales, and draws boxes before saving the information to a JSON file.",
        "type": "summary"
    },
    "5466": {
        "file_id": 710,
        "content": "# sample few images from a video.\nimport random\n## we import our version of cv2 here? or uninstall and reinstall opencv-python with custom things?\nimport pathlib\nimport sys\nsite_path = pathlib.Path(\"/usr/local/lib/python3.9/site-packages\")\ncv2_libs_dir = site_path / 'cv2' / f'python-{sys.version_info.major}.{sys.version_info.minor}'\nprint(cv2_libs_dir)\ncv2_libs = sorted(cv2_libs_dir.glob(\"*.so\"))\nif len(cv2_libs) == 1:\n    print(\"INSERTING:\",cv2_libs[0].parent)\n    sys.path.insert(1, str(cv2_libs[0].parent))\nimport cv2\nimport progressbar as pb\nvideoPaths = [\n    \"/root/Desktop/works/pyjom/tests/still_watermark_auto_removal/kunfu_cat.mp4\", # bilibili animal video compilation\n    \"/root/Desktop/works/pyjom/tests/bilibili_practices/bilibili_video_translate/japan_day.webm\", # youtube animation with watermark\n    \"/root/Desktop/works/pyjom/samples/video/LiGHT3ZCi.mp4\", # animal video compilation with pip and large area of watermark\n]  # his watermark. scorpa.\nvideo_path = videoPaths[2]\n# will change this shit.\n# shall we downscale this thing?",
        "type": "code",
        "location": "/tests/still_watermark_auto_removal/automatic-watermark-detection/video_watermark_detection.py:1-25"
    },
    "5467": {
        "file_id": 710,
        "content": "The code imports necessary libraries, checks and inserts custom OpenCV library paths, defines a list of video paths, and selects the third video for processing.",
        "type": "comment"
    },
    "5468": {
        "file_id": 710,
        "content": "# video = cv2.\n# video_path = \"\"\n# long loading time since we are backing up.\nsample_count = 60\nvideo_cap = cv2.VideoCapture(video_path)\nfps = video_cap.get(cv2.CAP_PROP_FPS)  # 60.\nframe_count = int(video_cap.get(cv2.CAP_PROP_FRAME_COUNT))\nprint(frame_count)\nsample_indexs = [x for x in range(frame_count)]\nsample_indexs = random.sample(sample_indexs, sample_count)\n# import copy\nimageSet = []\nfor frame_index_counter in pb.progressbar(range(frame_count)):  # are you sure?\n    success, frame = video_cap.read()\n    if not success:\n        break\n    if frame_index_counter in sample_indexs:\n        imageSet.append(frame.copy())\nfrom src import *\ngx, gy, gxlist, gylist = estimate_watermark_imgSet(imageSet)\n# print(len(imageSet))\ncropped_gx, cropped_gy, watermark_location = crop_watermark(gx, gy, location=True)\nW_m = poisson_reconstruct(cropped_gx, cropped_gy)\nW_full = poisson_reconstruct(gx, gy)\nprint(cropped_gx.shape, cropped_gy.shape, W_m.shape)  # (50, 137, 3) may vary.\nprint(watermark_location)  # ((1022, 21), (1072, 158)) inverted x,y! hell.",
        "type": "code",
        "location": "/tests/still_watermark_auto_removal/automatic-watermark-detection/video_watermark_detection.py:27-62"
    },
    "5469": {
        "file_id": 710,
        "content": "This code reads frames from a video, randomly selects some frames to analyze for watermark detection, and then estimates the watermark using poisson reconstruction. The code also outputs the shape of the detected watermark and its location on the frames. It may not use progress bar properly and has an issue with inverted x and y coordinates for watermark location.",
        "type": "comment"
    },
    "5470": {
        "file_id": 710,
        "content": "# cv2.imshow(\"WATERMARK\",W_m)\n# cv2.imshow(\"WATERMARK_FULL\",W_full)\n# # remove the freaking watermark please?\n# cv2.waitKey(0)\n# east_net = \"/media/root/help/pyjom/tests/still_watermark_auto_removal/EAST-Detector-for-text-detection-using-OpenCV-master/frozen_east_text_detection.pb\"\n# net = cv2.dnn.readNet(east_net)\n# H,W = W_full.shape[:2]\n# newH = (H//32)*32\n# newW = (W//32)*32\n# rH, rW = H/float(newH), W/float(newW)\n# W_full = cv2.resize(W_full,(newW,newH))\nmaxval, minval = np.max(W_full), np.min(W_full)\nW_full = (W_full - minval) * (255 / (maxval - minval))  # is that necessary?\n# # print(,W_full.shape,W_full.dtype)\nW_full = W_full.astype(np.uint8)\n# # breakpoint()\n# newH,newW = W_full.shape[:2]\n# # 14.122540090957173 -17.575702620638673 (1080, 1920, 3) float64\n# # you even have negative values. what the fuck?\n# blob = cv2.dnn.blobFromImage(W_full, 1.0, (newW, newH), (123.68, 116.78, 103.94), swapRB=True, crop=False)\n# # start = time.time()\n# net.setInput(blob)\n# layerNames = [\n# \t\"feature_fusion/Conv_7/Sigmoid\",",
        "type": "code",
        "location": "/tests/still_watermark_auto_removal/automatic-watermark-detection/video_watermark_detection.py:64-91"
    },
    "5471": {
        "file_id": 710,
        "content": "The code is using OpenCV and TensorFlow to detect and remove a watermark from an input image. It resizes the input image, normalizes pixel values, preprocesses the image with a DNN (Deep Neural Network), and then sets the input for the network's feature extraction layer.",
        "type": "comment"
    },
    "5472": {
        "file_id": 710,
        "content": "# \t\"feature_fusion/concat_3\"]\n# (scores, geometry) = net.forward(layerNames)\n# def decode_predictions(scores, geometry,min_confidence=0.5):\n# \t# grab the number of rows and columns from the scores volume, then\n# \t# initialize our set of bounding box rectangles and corresponding\n# \t# confidence scores\n# \t(numRows, numCols) = scores.shape[2:4]\n# \trects = []\n# \tconfidences = []\n# \t# loop over the number of rows\n# \tfor y in range(0, numRows):\n# \t\t# extract the scores (probabilities), followed by the\n# \t\t# geometrical data used to derive potential bounding box\n# \t\t# coordinates that surround text\n# \t\tscoresData = scores[0, 0, y]\n# \t\txData0 = geometry[0, 0, y]\n# \t\txData1 = geometry[0, 1, y]\n# \t\txData2 = geometry[0, 2, y]\n# \t\txData3 = geometry[0, 3, y]\n# \t\tanglesData = geometry[0, 4, y]\n# \t\t# loop over the number of columns\n# \t\tfor x in range(0, numCols):\n# \t\t\t# if our score does not have sufficient probability,\n# \t\t\t# ignore it\n# \t\t\tif scoresData[x] < min_confidence:\n# \t\t\t\tcontinue\n# \t\t\t# compute the offset factor as our resulting feature",
        "type": "code",
        "location": "/tests/still_watermark_auto_removal/automatic-watermark-detection/video_watermark_detection.py:92-119"
    },
    "5473": {
        "file_id": 710,
        "content": "The code is decoding the predictions of a deep learning model for watermark detection. It iterates through the scores and geometrical data to extract bounding box coordinates and angles, discarding low-confidence predictions.",
        "type": "comment"
    },
    "5474": {
        "file_id": 710,
        "content": "# \t\t\t# maps will be 4x smaller than the input image\n# \t\t\t(offsetX, offsetY) = (x * 4.0, y * 4.0)\n# \t\t\t# extract the rotation angle for the prediction and\n# \t\t\t# then compute the sin and cosine\n# \t\t\tangle = anglesData[x]\n# \t\t\tcos = np.cos(angle)\n# \t\t\tsin = np.sin(angle)\n# \t\t\t# use the geometry volume to derive the width and height\n# \t\t\t# of the bounding box\n# \t\t\th = xData0[x] + xData2[x]\n# \t\t\tw = xData1[x] + xData3[x]\n# \t\t\t# compute both the starting and ending (x, y)-coordinates\n# \t\t\t# for the text prediction bounding box\n# \t\t\tendX = int(offsetX + (cos * xData1[x]) + (sin * xData2[x]))\n# \t\t\tendY = int(offsetY - (sin * xData1[x]) + (cos * xData2[x]))\n# \t\t\tstartX = int(endX - w)\n# \t\t\tstartY = int(endY - h)\n# \t\t\t# add the bounding box coordinates and probability score\n# \t\t\t# to our respective lists\n# \t\t\trects.append((startX, startY, endX, endY))\n# \t\t\tconfidences.append(scoresData[x])\n# \t# return a tuple of the bounding boxes and associated confidences\n# \treturn (rects, confidences)\n# (rects, confidences) = decode_predictions(scores, geometry)",
        "type": "code",
        "location": "/tests/still_watermark_auto_removal/automatic-watermark-detection/video_watermark_detection.py:120-144"
    },
    "5475": {
        "file_id": 710,
        "content": "This code block extracts the rotation angle, computes sin and cosine values, derives bounding box width and height from geometry volume, calculates starting and ending coordinates of text prediction bounding boxes, appends these coordinates to rects list, and probability scores to confidences list. Finally, it returns a tuple containing the bounding boxes and associated confidences.",
        "type": "comment"
    },
    "5476": {
        "file_id": 710,
        "content": "# from imutils.object_detection import non_max_suppression\n# boxes = non_max_suppression(np.array(rects), probs=confidences)\n# rW=rH=1\n# no box painting.\n# for (startX, startY, endX, endY) in boxes:\n#     # scale the bounding box coordinates based on the respective\n#     # ratios\n#     startX = int(startX * rW)\n#     startY = int(startY * rH)\n#     endX = int(endX * rW)\n#     endY = int(endY * rH)\n#     # draw the bounding box on the frame\n#     cv2.rectangle(W_full, (startX, startY), (endX, endY), (0, 255, 0), 2)\n# # you could implement your own watermark detector network so far. it is easy.\n# # maybe directly using optical flow and gradients will be prettier?\n# W_full\nsrc = W_full\nscale_percent = 50\n# calculate the 50 percent of original dimensions\nwidth = int(src.shape[1] * scale_percent / 100)\nheight = int(src.shape[0] * scale_percent / 100)\n# dsize\ndsize = (width, height)\n# resize image\noutput = cv2.resize(src, dsize)\ngray_output = cv2.cvtColor(output, cv2.COLOR_BGR2GRAY)\ngray_output = cv2.GaussianBlur(gray_output, (11, 3), 0)",
        "type": "code",
        "location": "/tests/still_watermark_auto_removal/automatic-watermark-detection/video_watermark_detection.py:146-181"
    },
    "5477": {
        "file_id": 710,
        "content": "The code performs non-maximum suppression on rectangles, scales bounding box coordinates based on aspect ratios, draws bounding boxes on frames, and resizes the image with 50% scale while converting it to grayscale and applying Gaussian blur.",
        "type": "comment"
    },
    "5478": {
        "file_id": 710,
        "content": "thresh_output = cv2.adaptiveThreshold(\n    gray_output, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 11, 2\n)\nthresh_output = 255 - thresh_output\n# cnts, hierachy = cv2.findContours(thresh_output,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE) # really freaking bad. we should invert this.\ncnts, hierachy = cv2.findContours(\n    thresh_output, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE\n)  # really freaking bad. we should invert this.\n# cv2.RETR_EXTERNAL\n[a, b] = output.shape[:2]\nmyMask = np.zeros(shape=[a, b], dtype=np.uint8)\n# this is for video watermarks. how about pictures? do we need to cut corners? how to find the freaking watermark again?\nfor cnt in cnts:\n    x, y, w, h = cv2.boundingRect(cnt)  # Draw the bounding box image=\n    # cv2.rectangle(output, (x,y), (x+w,y+h), (0,0,255),2)\n    cv2.rectangle(myMask, (x, y), (x + w, y + h), 255, -1)\ndilated_mask = cv2.GaussianBlur(myMask, (11, 11), 0)\ncv2.threshold(dilated_mask, 256 / 2, 255, cv2.THRESH_BINARY, dilated_mask)\ncnts2, hierachy2 = cv2.findContours(",
        "type": "code",
        "location": "/tests/still_watermark_auto_removal/automatic-watermark-detection/video_watermark_detection.py:183-206"
    },
    "5479": {
        "file_id": 710,
        "content": "This code applies adaptive thresholding to detect watermarks in a video. It then identifies contours and creates a mask using bounding boxes, applies Gaussian blur, and finally finds the contours again for further processing.",
        "type": "comment"
    },
    "5480": {
        "file_id": 710,
        "content": "    dilated_mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE\n)\nmyMask2 = np.zeros(shape=[a, b], dtype=np.uint8)\n# this is for video watermarks. how about pictures? do we need to cut corners? how to find the freaking watermark again?\nheight, width = myMask2.shape[:2]\nrectangles = []\nfor cnt in cnts2:\n    x, y, w, h = cv2.boundingRect(cnt)  # Draw the bounding box image=\n    # cv2.rectangle(output, (x,y), (x+w,y+h), (0,0,255),2)\n    rectangles.append((x,y,w,h))\n    cv2.rectangle(myMask2, (x, y), (x + w, y + h), 255, -1)\nimport json\ndata = {\"canvas\":(width, height), 'rectangles':rectangles}\ndataString = json.dumps(data)\nwith open(\"test.json\", 'w+') as f: f.write(dataString)\nprint(\"TOTAL {} CONTOURS.\".format(len(cnts2)))  # paint those contours.\n# cv2.imshow(\"IMAGE\",thresh_output)\ncv2.imshow(\"MPICTURE\", myMask2)\ncv2.waitKey(0)\n# fill those areas and you will get it.\n# how do we remove this shit?\n# also how do we remove other weird things? like floating watermarks?\n# print(imageSet[0].shape)\n# breakpoint()",
        "type": "code",
        "location": "/tests/still_watermark_auto_removal/automatic-watermark-detection/video_watermark_detection.py:207-239"
    },
    "5481": {
        "file_id": 710,
        "content": "Code creates a mask for video watermarks by detecting contours and drawing bounding boxes. It saves the mask information to a JSON file. The code also displays the mask as an image. The code is not specifically designed for images; modifications are needed to handle other formats like images with floating watermarks.",
        "type": "comment"
    },
    "5482": {
        "file_id": 711,
        "content": "/tests/qq_share_autojs/unlock_and_run_autox.sh",
        "type": "filepath"
    },
    "5483": {
        "file_id": 711,
        "content": "The script checks if the device is locked, runs Auto.js script, monitors the flag file for changes and loops until it completes or encounters an error.",
        "type": "summary"
    },
    "5484": {
        "file_id": 711,
        "content": "bash adb_check_lock.sh \nfunction autox_run {\n  adb -s 192.168.10.3:5555 shell touch /storage/emulated/0/flag\n  bash adb_autox_launch.sh\n  while true\n  do\n    adb -s 192.168.10.3:5555 shell cat /storage/emulated/0/flag\n    if [[ $? -eq 1 ]]\n    then\n      echo \"script complete\"\n      exit\n    else\n      echo \"script running\"\n      sleep 1\n    fi\n  done\n}\nwhile true\ndo\n  autox_run\n  # you need to ensure the script run as expected.\ndone",
        "type": "code",
        "location": "/tests/qq_share_autojs/unlock_and_run_autox.sh:1-24"
    },
    "5485": {
        "file_id": 711,
        "content": "The script checks if the device is locked, runs Auto.js script, monitors the flag file for changes and loops until it completes or encounters an error.",
        "type": "comment"
    },
    "5486": {
        "file_id": 712,
        "content": "/tests/qq_share_autojs/test_qq_share.sh",
        "type": "filepath"
    },
    "5487": {
        "file_id": 712,
        "content": "This code launches the JumpActivity in the Tencent MobileQQ app, passing a complex URI with various data such as file type, file data, title, description, and URL to share. The shared content is related to Bilibili video recommendation server. It specifies the app name and package name (tv.danmaku.bili).",
        "type": "summary"
    },
    "5488": {
        "file_id": 712,
        "content": "am start -n com.tencent.mobileqq/com.tencent.mobileqq.activity.JumpActivity -a android.intent.action.VIEW -d 'mqqapi://share/to_fri?src_type=app&version=1&file_type=news&file_data=L3N0b3JhZ2UvZW11bGF0ZWQvMC9QaWN0dXJlcy9zaGFyZS8xMjcyMDY0MzU0&file_uri=Y29udGVudDovL3R2LmRhbm1ha3UuYmlsaS5maWxlcHJvdmlkZXIvb3BlbnNka19leHRlcm5hbC9zaGFyZTJxcV90ZW1wNDIwOTU0OTNhYjhlZGRhZmYzMWQ1Y2ZjYWYzZjE3MDQuanBn&title=5ZOU5ZOp5ZOU5ZOp&description=5aSn5Z6L5pS/6K6654mH772c5paw5pe25Luj562U5Y23&share_id=100951776&url=aHR0cHM6Ly9iMjMudHYvdGRKZGd6WT9zaGFyZV9tZWRpdW09YW5kcm9pZCZzaGFyZV9zb3VyY2U9cXEmYmJpZD1YWTFCQjcyMUIxRjk3MzQ4REJERTQyOTdGRTFCNEFCRTI2QkFBJnRzPTE2NjcyNzU0ODI4MTY=&app_name=5ZOU5ZOp5ZOU5ZOp&req_type=Nw==&mini_program_appid=MTEwOTkzNzU1Nw==&mini_program_path=cGFnZXMvdmlkZW8vdmlkZW8/YnZpZD1CVjFuZTQxMUw3aHkmc2hhcmVfc291cmNlPXFxX3VnYyZ1bmlxdWVfaz10ZEpkZ3pZ&mini_program_type=Mw==&cflag=MA==&third_sd=dHJ1ZQ==' -e pkg_name tv.danmaku.bili",
        "type": "code",
        "location": "/tests/bilibili_video_recommendation_server/xml_and_json_qq_send/test_launch_share.sh:1-1"
    },
    "5489": {
        "file_id": 712,
        "content": "This code launches the JumpActivity in the Tencent MobileQQ app, passing a complex URI with various data such as file type, file data, title, description, and URL to share. The shared content is related to Bilibili video recommendation server. It specifies the app name and package name (tv.danmaku.bili).",
        "type": "comment"
    },
    "5490": {
        "file_id": 713,
        "content": "/tests/qq_share_autojs/parse_qq_url.py",
        "type": "filepath"
    },
    "5491": {
        "file_id": 713,
        "content": "The code parses a QQ share URL, handles base64 encoding and decoding, stores values in a new dictionary for sharing, encodes URL parameters, prints them, opens the link using os.system().",
        "type": "summary"
    },
    "5492": {
        "file_id": 713,
        "content": "url = \"mqqapi://share/to_fri?src_type=app&version=1&file_type=news&file_data=L3N0b3JhZ2UvZW11bGF0ZWQvMC9QaWN0dXJlcy9zaGFyZS8xMjcyMDY0MzU0&file_uri=Y29udGVudDovL3R2LmRhbm1ha3UuYmlsaS5maWxlcHJvdmlkZXIvb3BlbnNka19leHRlcm5hbC9zaGFyZTJxcV90ZW1wNDIwOTU0OTNhYjhlZGRhZmYzMWQ1Y2ZjYWYzZjE3MDQuanBn&title=5ZOU5ZOp5ZOU5ZOp&description=5aSn5Z6L5pS/6K6654mH772c5paw5pe25Luj562U5Y23&share_id=100951776&url=aHR0cHM6Ly9iMjMudHYvdGRKZGd6WT9zaGFyZV9tZWRpdW09YW5kcm9pZCZzaGFyZV9zb3VyY2U9cXEmYmJpZD1YWTFCQjcyMUIxRjk3MzQ4REJERTQyOTdGRTFCNEFCRTI2QkFBJnRzPTE2NjcyNzU0ODI4MTY=&app_name=5ZOU5ZOp5ZOU5ZOp&req_type=Nw==&mini_program_appid=MTEwOTkzNzU1Nw==&mini_program_path=cGFnZXMvdmlkZW8vdmlkZW8/YnZpZD1CVjFuZTQxMUw3aHkmc2hhcmVfc291cmNlPXFxX3VnYyZ1bmlxdWVfaz10ZEpkZ3pZ&mini_program_type=Mw==&cflag=MA==&third_sd=dHJ1ZQ==\"\nfrom urllib.parse import urlparse, parse_qs\nparse_result=urlparse(url)\n#print(parse_result)\n#breakpoint()\n#\n#params=['count', 'encode', 'fragment', 'geturl', 'hostname', 'index', 'netloc', 'params', 'password', 'path', 'port', 'query', 'scheme', 'username']",
        "type": "code",
        "location": "/tests/qq_share_autojs/parse_qq_url.py:1-9"
    },
    "5493": {
        "file_id": 713,
        "content": "This code is parsing a URL using urllib.parse, extracting its components and possibly preparing for further processing. The URL appears to be related to QQ share and contains various parameters including app name, file data, description, etc.",
        "type": "comment"
    },
    "5494": {
        "file_id": 713,
        "content": "#for k in params:\n#    print(\"key:\",k,\"value:\",eval(\"parse_result.{}\".format(k)))\n#[scheme]://[netloc/hostname]/[path]?[query]\ndict_result=parse_qs(parse_result.query)\nnon_b64vals=[\"share_id\",\"src_type\",\"version\",\"file_type\"]\nimport base64\ndef dec_b64(v):\n    if type(v) == str:\n        v = v.encode()\n    v=base64.b64decode(v)\n    v=v.decode()\n    return v\ndef enc_b64(v):\n    if type(v) == str:\n        v = v.encode()\n    v=base64.b64encode(v)\n    v=v.decode()\n    return v\nnew_q={}\nmypic=\"/storage/emulated/0/Pictures/share/cat.gif\"\nmyuri='file://{}'.format(mypic)\nshortlink=\"uHML5mi\"\nbvid=\"BV1zd4y117WF\"\nfor k,v in dict_result.items():\n    v=v[0]\n    if k == \"file_data\":\n        v=enc_b64(mypic)\n    elif k == \"file_uri\":\n        v=enc_b64(myuri)\n    elif k == \"share_id\":\n        v=100951776\n    elif k == \"url\":\n        v=\"https://b23.tv/\"+shortlink\n        v=enc_b64(v)\n    elif k == \"mini_program_path\":\n        v=enc_b64(\"pages/video/video?bvid=\"+bvid)\n    elif k == \"description\":\n        v=enc_b64(\"喵喵喵\")\n    new_q.update({k:v})",
        "type": "code",
        "location": "/tests/qq_share_autojs/parse_qq_url.py:10-55"
    },
    "5495": {
        "file_id": 713,
        "content": "The code is parsing a QQ share URL, decoding and encoding specific values using base64, and storing them in a new dictionary. It also includes hardcoded values such as file path, shortlink, and bvid. The purpose seems to be related to sharing files or links within the QQ platform.",
        "type": "comment"
    },
    "5496": {
        "file_id": 713,
        "content": "    #for printing purpose\n    if k not in non_b64vals:\n        v=dec_b64(v)\n    print(k,\":\",v)\nfrom urllib.parse import urlencode\nnew_qs=urlencode(new_q)\nprint()\ntemplate=\"am start -n com.tencent.mobileqq/com.tencent.mobileqq.activity.JumpActivity -a android.intent.action.VIEW -d 'mqqapi://share/to_fri?{}' -e pkg_name tv.danmaku.bili\"\ncmd=template.format(new_qs)\nprint(cmd)\nimport os\nos.system(cmd)",
        "type": "code",
        "location": "/tests/qq_share_autojs/parse_qq_url.py:56-67"
    },
    "5497": {
        "file_id": 713,
        "content": "The code encodes URL parameters, prints them, and then executes a command to open a QQ share link in the mobile app. It converts base64 values if needed for printing, formats the command with URL parameters, and uses os.system() to execute the command.",
        "type": "comment"
    },
    "5498": {
        "file_id": 714,
        "content": "/tests/qq_share_autojs/launch_autojs.sh",
        "type": "filepath"
    },
    "5499": {
        "file_id": 714,
        "content": "This code uses the am start command to launch the ShortcutActivity in AutoJS, passing the path of a JavaScript file (\"/storage/emulated/0/脚本/show_toast.js\") as an argument. This could be used for executing a specific AutoJS script on the device.",
        "type": "summary"
    }
}