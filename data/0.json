{
    "0": {
        "file_id": 0,
        "content": "/README.md",
        "type": "filepath"
    },
    "1": {
        "file_id": 0,
        "content": "The code represents the README.md file for the \"pyjom\" project, an automated content generation tool for media. It provides installation and usage instructions, integration plans with AI models like ChatGPT, related notes, GitHub repo link, readthedocs documentation, and mentions chaotic architecture possibly to be organized in the future. The README also includes links for donating via WeChat or Alipay and displays the author's star history.",
        "type": "summary"
    },
    "2": {
        "file_id": 0,
        "content": "# pyjom\n<p align=\"center\">\n    <a href=\"https://github.com/James4Ever0/pyjom\"><img alt=\"pyjom\" src=\"https://visitor-badge.glitch.me/badge?page_id=James4Ever0.pyjom\"></a>\n    <a href=\"https://github.com/James4Ever0/pyjom\"><img alt=\"pyjom\" src=\"https://img.shields.io/github/stars/James4Ever0/pyjom.svg\"></a>\n    <a href=\"https://github.com/James4Ever0/pyjom/releases\"><img alt=\"pyjom\" src=\"https://img.shields.io/github/release/James4Ever0/pyjom.svg\"></a>\n</p>\n[English version](./README.en.md)\n<p align=\"center\">\n  <a href=\"https://pyjom.readthedocs.io/en/latest/\">\n    <img src=\"https://tse4-mm.cn.bing.net/th/id/OIP-C.g0coL4omeFEhXvTh5rxedAHaKZ?pid=ImgDet&rs=1\" alt=\"pyjom\">\n  </a>\n</p>\n## 介绍\n自动化的自媒体内容制造机 自动运维自媒体 无人值守创作直播 全平台可运行 做一个有思想的复读机 有金饭碗的ebegger\n计划将ChatGPT类模型接入本项目 构造提示词集合 流水线式工作 (可以创建以前利用传统程序难以做到的事情 比如编写剧本 追踪视频来源 提取还原URL 反馈学习等等)\n## 文档\nreadthedocs 编写中 [文档地址](https://pyjom.readthedocs.io/en/latest/)\n## 我的笔记\n[杂乱的笔记](https://github.com/James4Ever0/notes) 有可能对你理解本项目有帮助\n## 软件架构\n本工程非常的乱 如果你能跑通 祝贺你\n自己以前写过很多有关于自媒体自动化的程序 不知道放到什么地方去了 可以的话会进行整理",
        "type": "code",
        "location": "/README.md:1-35"
    },
    "3": {
        "file_id": 0,
        "content": "This code represents the README.md file of the \"pyjom\" project, which is an automated content generation tool for media. It includes links to the GitHub repository and readthedocs documentation, as well as a brief introduction, plan to integrate ChatGPT-like models, and information about related notes. The code also mentions that the project architecture is chaotic and suggests it might be organized in the future.",
        "type": "comment"
    },
    "4": {
        "file_id": 0,
        "content": "以前还有一些关于AGI的代码 量化交易相关的 感兴趣自行查看\n## 安装教程\n1. pull下来本仓库\n2. 安装linux系统\n3. 安装python3\n4. 一切随缘\n## 使用说明\n1. 随便翻看目录 阅读代码并运行\n2. 看看我的笔记\n3. 看看相关的项目\n## 参与贡献\n1. Fork 本仓库\n2. 本地运行\n3. 提交代码\n4. 新建 Pull Request\n## 特技\n本人擅长到处聊天然后寻找灵感 毕竟没有灵感就没有代码 没有笔记\n据说投喂可以加快开发者写文档的速度 还有几率收到私发的女装照哦\n如果你想捐款 就投喂我吧~\n<table border=\"0\">\n  <tr>\n    <th>微信投喂</th>\n    <th>支付宝投喂</th>\n  </tr>\n  <tr>\n    <td><img width=\"100\" height=\"100\" src=\"https://api.qrserver.com/v1/create-qr-code/?size=300x300&data=wxp://f2f0V92qUQI0aBO5PXtWezujxMm-C1KFub6qCi1Obt3cn1KjZqDPqoWKn8ICCcwdt8zU\"></td>\n    <td><img width=\"100\" height=\"100\" src=\"https://api.qrserver.com/v1/create-qr-code/?size=300x300&data=https://qr.alipay.com/tsx10243tdewwaxrvullge8\"></td>\n  </tr>\n</table>\n## Star History\n<img src=\"https://api.star-history.com/svg?repos=james4ever0/pyjom&Timeline\" style=\"filter: invert(100%);\"></img>",
        "type": "code",
        "location": "/README.md:37-81"
    },
    "5": {
        "file_id": 0,
        "content": "This code is a README file for a Python project. It provides instructions on how to install and use the software, as well as information about contributing to the project. Additionally, it includes links for donating via WeChat or Alipay and displays the author's star history.",
        "type": "comment"
    },
    "6": {
        "file_id": 1,
        "content": "/README.en.md",
        "type": "filepath"
    },
    "7": {
        "file_id": 1,
        "content": "The code is a README for the \"pyjom\" project, providing an overview, installation instructions, and details on its top-down approach to create a Python content producer. It also includes information on contributing and using Gitee features with dependencies and Star History API integration for visualization.",
        "type": "summary"
    },
    "8": {
        "file_id": 1,
        "content": "# pyjom\n<p align=\"center\">\n    <a href=\"https://github.com/James4Ever0/pyjom\"><img alt=\"pyjom\" src=\"https://visitor-badge.glitch.me/badge?page_id=James4Ever0.pyjom\"></a>\n    <a href=\"https://github.com/James4Ever0/pyjom\"><img alt=\"pyjom\" src=\"https://img.shields.io/github/stars/James4Ever0/pyjom.svg\"></a>\n    <a href=\"https://github.com/James4Ever0/pyjom/releases\"><img alt=\"pyjom\" src=\"https://img.shields.io/github/release/James4Ever0/pyjom.svg\"></a>\n</p>\n#### Description\njerk off machine in python, or in other words, \"we media machine\", \"fully automated content producer\", \"the repeater\", \"the feedback loop\", \"retribution\"\n#### Software Architecture\nbased on top-down approach, this time we do not initiate the whole project from details since doing so will lose the grip on the infrastructure.\nwe try to build toy projects, toy modules in different folders. the whole thing shall be installable on pypi, avaliable to post to official pypi.org. not necessarily running on actual data yet.\n#### Installation",
        "type": "code",
        "location": "/README.en.md:1-17"
    },
    "9": {
        "file_id": 1,
        "content": "This code is a README for the \"pyjom\" project. It provides an overview of what the project does, its software architecture, and installation instructions. The project focuses on creating a content producer using Python, with a top-down approach to build modular components.",
        "type": "comment"
    },
    "10": {
        "file_id": 1,
        "content": "1.  git clone this project.\n2.  pip3 install pyjom\n3.  config the pyjom properly with cookies, passwords and so on.\n#### Instructions\n1.  pyjom requires several dependencies, shall be avaliable on all platforms.\n2.  xxxx\n3.  xxxx\n#### Contribution\n1.  Fork the repository\n2.  Create Feat_xxx branch\n3.  Commit your code\n4.  Create Pull Request\n#### Gitee Feature\n1.  You can use Readme\\_XXX.md to support different languages, such as Readme\\_en.md, Readme\\_zh.md\n2.  Gitee blog [blog.gitee.com](https://blog.gitee.com)\n3.  Explore open source project [https://gitee.com/explore](https://gitee.com/explore)\n4.  The most valuable open source project [GVP](https://gitee.com/gvp)\n5.  The manual of Gitee [https://gitee.com/help](https://gitee.com/help)\n6.  The most popular members  [https://gitee.com/gitee-stars/](https://gitee.com/gitee-stars/)\n## Star History\n<img src=\"https://api.star-history.com/svg?repos=james4ever0/pyjom&Timeline\" style=\"filter: invert(100%);\"></img>",
        "type": "code",
        "location": "/README.en.md:19-49"
    },
    "11": {
        "file_id": 1,
        "content": "The code contains instructions for setting up the project, contributing to it, and information about Gitee features. It requires dependencies, and shows a star history visualization using the Star History API.",
        "type": "comment"
    },
    "12": {
        "file_id": 2,
        "content": "/tasks/README.md",
        "type": "filepath"
    },
    "13": {
        "file_id": 2,
        "content": "Code snippet describes the importance of having adequate actions for a project to avoid serious problems. It also mentions utilizing the entire project in practical ways, including the old AutoUP repo, to extract knowledge and data persistently.",
        "type": "summary"
    },
    "14": {
        "file_id": 2,
        "content": "Modules are good. Tests are good. In fact, everything could be good. But the shortage of actions will lead to serious problems.\nThis will make use of the entire project in every way, in practical manners, including the old AutoUP repo.\nThis will bring about the grit out of the project, running persistently to get practical knowledge/data.",
        "type": "code",
        "location": "/tasks/README.md:1-5"
    },
    "15": {
        "file_id": 2,
        "content": "Code snippet describes the importance of having adequate actions for a project to avoid serious problems. It also mentions utilizing the entire project in practical ways, including the old AutoUP repo, to extract knowledge and data persistently.",
        "type": "comment"
    },
    "16": {
        "file_id": 3,
        "content": "/tasks/qq/login_opq_arm64_another_account.sh",
        "type": "filepath"
    },
    "17": {
        "file_id": 3,
        "content": "The code initiates the login process on an ARM64 platform using Firefox browser. It navigates to a specific URL (localhost:8784/v1/Login/GetQRcode) and may require removing credential files for relogin.",
        "type": "summary"
    },
    "18": {
        "file_id": 3,
        "content": "# arm64\nfirefox http://localhost:8784/v1/Login/GetQRcode\n# if want to relogin must remove credential files. maybe it supports multi logins.",
        "type": "code",
        "location": "/tasks/qq/login_opq_arm64_another_account.sh:1-4"
    },
    "19": {
        "file_id": 3,
        "content": "The code initiates the login process on an ARM64 platform using Firefox browser. It navigates to a specific URL (localhost:8784/v1/Login/GetQRcode) and may require removing credential files for relogin.",
        "type": "comment"
    },
    "20": {
        "file_id": 4,
        "content": "/tasks/qq/login_opq_arm64.sh",
        "type": "filepath"
    },
    "21": {
        "file_id": 4,
        "content": "This code appears to be for an ARM64 system, likely running a Linux distribution. It launches Firefox and navigates it to a QR code login endpoint (localhost:8780/v1/Login/GetQRcode). It suggests that removing credential files may be necessary for relogin, possibly supporting multi-logins.",
        "type": "summary"
    },
    "22": {
        "file_id": 4,
        "content": "# arm64\nfirefox http://localhost:8780/v1/Login/GetQRcode\n# if want to relogin must remove credential files. maybe it supports multi logins.",
        "type": "code",
        "location": "/tasks/qq/login_opq_arm64.sh:1-4"
    },
    "23": {
        "file_id": 4,
        "content": "This code appears to be for an ARM64 system, likely running a Linux distribution. It launches Firefox and navigates it to a QR code login endpoint (localhost:8780/v1/Login/GetQRcode). It suggests that removing credential files may be necessary for relogin, possibly supporting multi-logins.",
        "type": "comment"
    },
    "24": {
        "file_id": 5,
        "content": "/tasks/qq/qq_red_packet_collect/test_qrcode_insert_replace.py",
        "type": "filepath"
    },
    "25": {
        "file_id": 5,
        "content": "This code imports a function to remove and insert QR codes, then tests it with two image inputs and a specific qrcode_path. It displays the output images in a window before exiting.",
        "type": "summary"
    },
    "26": {
        "file_id": 5,
        "content": "from ad_template_2_functional import removeAndInsertQRCode\nimport cv2\ndef test_main():\n    images = [\n        \"/root/Desktop/works/pyjom/samples/image/qrcode_test/no_qrcode.jpg\",\n        \"/root/Desktop/works/pyjom/samples/image/qrcode_test/with_qrcode.jpg\",\n    ]  # convert to compatible formats first.\n    qrcode_path = \"/root/Desktop/works/pyjom/tests/bilibili_video_recommendation_server/ebegging_template.png\"\n    for img in images:\n        output = removeAndInsertQRCode(img, qrcode_path, None)\n        cv2.imshow(\"IMG\", output)\n        cv2.waitKey(0)\nif __name__ == \"__main__\":\n    test_main()",
        "type": "code",
        "location": "/tasks/qq/qq_red_packet_collect/test_qrcode_insert_replace.py:1-20"
    },
    "27": {
        "file_id": 5,
        "content": "This code imports a function to remove and insert QR codes, then tests it with two image inputs and a specific qrcode_path. It displays the output images in a window before exiting.",
        "type": "comment"
    },
    "28": {
        "file_id": 6,
        "content": "/tasks/qq/qq_red_packet_collect/test_neo4j_creds.py",
        "type": "filepath"
    },
    "29": {
        "file_id": 6,
        "content": "This code tests Neo4j credentials by iterating through various usernames and passwords, attempting to connect and retrieve a single node result. It prints the retrieved result and the used credentials if successful, or catches any exceptions during the process.",
        "type": "summary"
    },
    "30": {
        "file_id": 6,
        "content": "from adtools import getNeo4jDriver\ndef test_login():\n    usernames = [\"kali\", \"user\", \"neo4j\", \"admin\", \"parrot\", \"\"]\n    passwords = [\"neo4j\", \"kali\", \"parrot\", \"admin\", \"password\", \"\"]\n    for u in usernames:\n        for p in passwords:\n            try:\n                driver = getNeo4jDriver(username=u, password=p, debug=False)\n                # print('RESPONSE?',r)\n                with driver.session() as session:\n                    result = session.run(\"MATCH (n) RETURN n LIMIT 1\")\n                    print(result.single())\n                    print(\"USING:\", u, p)\n            except:\n                pass\n                # import traceback\n                # traceback.print_exc()",
        "type": "code",
        "location": "/tasks/qq/qq_red_packet_collect/test_neo4j_creds.py:1-19"
    },
    "31": {
        "file_id": 6,
        "content": "This code tests Neo4j credentials by iterating through various usernames and passwords, attempting to connect and retrieve a single node result. It prints the retrieved result and the used credentials if successful, or catches any exceptions during the process.",
        "type": "comment"
    },
    "32": {
        "file_id": 7,
        "content": "/tasks/qq/qq_red_packet_collect/test_make_dog_cat_connection.py",
        "type": "filepath"
    },
    "33": {
        "file_id": 7,
        "content": "This code imports a function from adtools to test making connections between cats and dogs. It defines three test functions: \"test_main\", \"test_delete\", and \"test_query\". The \"test_query\" function retrieves cat and dog ads. The main code block runs the \"test_query\" function if this script is run directly.",
        "type": "summary"
    },
    "34": {
        "file_id": 7,
        "content": "from adtools import makeCatOrDogConnections, getCatOrDogAd\ndef test_main():\n    makeCatOrDogConnections(\"123\", \"345\", \"cat\", debug=True)\ndef test_delete():\n    makeCatOrDogConnections(\"123\", \"345\", \"cat\", debug=True, delete=True)\ndef test_query():\n    response = getCatOrDogAd(\"cat\", debug=True)\n    response = getCatOrDogAd(\"dog\", debug=True)\nif __name__ == \"__main__\":\n    test_query()",
        "type": "code",
        "location": "/tasks/qq/qq_red_packet_collect/test_make_dog_cat_connection.py:1-18"
    },
    "35": {
        "file_id": 7,
        "content": "This code imports a function from adtools to test making connections between cats and dogs. It defines three test functions: \"test_main\", \"test_delete\", and \"test_query\". The \"test_query\" function retrieves cat and dog ads. The main code block runs the \"test_query\" function if this script is run directly.",
        "type": "comment"
    },
    "36": {
        "file_id": 8,
        "content": "/tasks/qq/qq_red_packet_collect/test_get_all_my_videos.py",
        "type": "filepath"
    },
    "37": {
        "file_id": 8,
        "content": "Code makes a POST request to localhost on port 7341, endpoint \"searchUserVideos\", with an empty query and tid 0 for the latest video of own user. Uses requests library, prints data in JSON format using rich library.",
        "type": "summary"
    },
    "38": {
        "file_id": 8,
        "content": "import requests\nport, endpoint = 7341, \"searchUserVideos\"\npostData = {\"query\":\"\", \"tid\": 0, \"method\": \"online\"} # this is to get latest video of my own. fuck. better turned into registration based method.\n# postData = {'query':\"狗\", \"tid\":0, \"method\":\"bm25\"}\nr = requests.post(f\"http://localhost:{port}/{endpoint}\", json=postData)\ndata = r.json()\nprint(\"data\")\nimport rich\nrich.print(data)",
        "type": "code",
        "location": "/tasks/qq/qq_red_packet_collect/test_get_all_my_videos.py:1-11"
    },
    "39": {
        "file_id": 8,
        "content": "Code makes a POST request to localhost on port 7341, endpoint \"searchUserVideos\", with an empty query and tid 0 for the latest video of own user. Uses requests library, prints data in JSON format using rich library.",
        "type": "comment"
    },
    "40": {
        "file_id": 9,
        "content": "/tasks/qq/qq_red_packet_collect/test_cat_dog_info_get.py",
        "type": "filepath"
    },
    "41": {
        "file_id": 9,
        "content": "The code imports the getCatOrDogAd function from adtools, defines test_init and test_cats_and_dogs_get_video_names functions. test_init randomly selects a response from getCatOrDogAd (20 responses) for 'cat' category and prints the video information. test_cats_and_dogs_get_video_names iterates over 'cat' and 'dog' categories, retrieves videos using getCatOrDogAd with method 'bm25', and prints their titles. The code also checks if the __name__ is '__main__' to execute either test_init or test_cats_and_dogs_get_video_names function.",
        "type": "summary"
    },
    "42": {
        "file_id": 9,
        "content": "import random\nfrom adtools import getCatOrDogAd\ndef test_init():\n    cat_or_dog='cat'\n    for _ in range(2):\n        responses = getCatOrDogAd(cat_or_dog)\n        videoInfo = random.choice(responses[:20])\n        print(videoInfo)\n        print()\ndef test_cats_and_dogs_get_video_names():\n    for category in ['cat','dog']:\n        print(\"_\"*20)\n        print(\"CATEGORY?\",category)\n        print()\n        responses = getCatOrDogAd(category,method='bm25') # it does not update that often. use online search instead? (fill keywords in description)\n        for info in responses:\n            title = info['title']\n            print(\"VIDEO?\",title)\nif __name__ == '__main__':\n    # test_init()\n    test_cats_and_dogs_get_video_names()",
        "type": "code",
        "location": "/tasks/qq/qq_red_packet_collect/test_cat_dog_info_get.py:1-25"
    },
    "43": {
        "file_id": 9,
        "content": "The code imports the getCatOrDogAd function from adtools, defines test_init and test_cats_and_dogs_get_video_names functions. test_init randomly selects a response from getCatOrDogAd (20 responses) for 'cat' category and prints the video information. test_cats_and_dogs_get_video_names iterates over 'cat' and 'dog' categories, retrieves videos using getCatOrDogAd with method 'bm25', and prints their titles. The code also checks if the __name__ is '__main__' to execute either test_init or test_cats_and_dogs_get_video_names function.",
        "type": "comment"
    },
    "44": {
        "file_id": 10,
        "content": "/tasks/qq/qq_red_packet_collect/test_download_qq_image.sh",
        "type": "filepath"
    },
    "45": {
        "file_id": 10,
        "content": "This script downloads a QQ image using curl, saves it as \"qq_image_received.image\", and is compatible with OpenCV for processing.",
        "type": "summary"
    },
    "46": {
        "file_id": 10,
        "content": "# you cannot receive qq voice with opq!\n# but you can download image when it has not expired.\n# what is the type of this image?\ncurl -L -o qq_image_received.image \"http://gchat.qpic.cn/gchatpic_new/3318506826/205569604-2534335053-7D3B7BA4B3476AD210837D8C86F2E8DA/0?vuin=917521610&term=255&pictype=0\"\n# cv2 can handle that.",
        "type": "code",
        "location": "/tasks/qq/qq_red_packet_collect/test_download_qq_image.sh:1-6"
    },
    "47": {
        "file_id": 10,
        "content": "This script downloads a QQ image using curl, saves it as \"qq_image_received.image\", and is compatible with OpenCV for processing.",
        "type": "comment"
    },
    "48": {
        "file_id": 11,
        "content": "/tasks/qq/qq_red_packet_collect/test_check_dog_cat.py",
        "type": "filepath"
    },
    "49": {
        "file_id": 11,
        "content": "This code imports a function to check if an image is of a cat or dog. It prints the rate limits and then runs the check function on an image URL three times, displaying the results. If the confidence score for either 'cat' or 'dog' is above 0.4, it returns that species name.",
        "type": "summary"
    },
    "50": {
        "file_id": 11,
        "content": "from adtools import checkIsCatOrDogImage, rateLimits\nimage_url = \"http://gchat.qpic.cn/gchatpic_new/3318506826/205569604-2534335053-7D3B7BA4B3476AD210837D8C86F2E8DA/0?vuin=917521610&term=255&pictype=0\"\nprint(\"RATE LIMITS?\", rateLimits)\nfor _ in range(3):\n    r= checkIsCatOrDogImage(image_url) # will raise Exception! warning\n    print(\"RESULT?\")\n    import rich\n    rich.print(r)\nthreshold = 0.4\n# for species in r:\n#     name = species['identity']\n#     if name in ['cat','dog']:\n#         conf = species['confidence']\n#         if conf > threshold:\n#             return name",
        "type": "code",
        "location": "/tasks/qq/qq_red_packet_collect/test_check_dog_cat.py:1-20"
    },
    "51": {
        "file_id": 11,
        "content": "This code imports a function to check if an image is of a cat or dog. It prints the rate limits and then runs the check function on an image URL three times, displaying the results. If the confidence score for either 'cat' or 'dog' is above 0.4, it returns that species name.",
        "type": "comment"
    },
    "52": {
        "file_id": 12,
        "content": "/tasks/qq/qq_red_packet_collect/test_ad_generator.py",
        "type": "filepath"
    },
    "53": {
        "file_id": 12,
        "content": "Iterates through a list of video data, generates Bilibili video ads using provided info, displays the image output on screen and waits for key press.",
        "type": "summary"
    },
    "54": {
        "file_id": 12,
        "content": "from ad_template_2_functional import generateBilibiliVideoAd, getAdLock\nvideoData = [\n    [\n        \"BV1Qd4y177Tc\",\n        \"bbb\",\n        \"https://i0.hdslb.com/bfs/archive/8a5f0a2bdffc99d33776c9d1f101521c0fc85e31.jpg\",\n    ],\n    [\n        \"BV1FG411K7Cd\",\n        \"aaa\",\n        \"https://i2.hdslb.com/bfs/archive/6423c88a8d3011a6a911627d9100b4cc4f08758d.jpg\",\n    ],\n]\nimport cv2\nfor (bvid, title_text, image_link) in videoData:\n    with getAdLock():\n        output_path, output_standalone, output_masked_path = generateBilibiliVideoAd(\n            bvid, title_text, image_link\n        )\n        img = cv2.imread(output_path)\n        cv2.imshow(\"IMAGE\", img)\n        cv2.waitKey(0)",
        "type": "code",
        "location": "/tasks/qq/qq_red_packet_collect/test_ad_generator.py:1-25"
    },
    "55": {
        "file_id": 12,
        "content": "Iterates through a list of video data, generates Bilibili video ads using provided info, displays the image output on screen and waits for key press.",
        "type": "comment"
    },
    "56": {
        "file_id": 13,
        "content": "/tasks/qq/qq_red_packet_collect/test_adtools.sh",
        "type": "filepath"
    },
    "57": {
        "file_id": 13,
        "content": "This code changes the current directory (CD) and then runs a test script named \"test_make_dog_cat_connection.py\" using the pytest-3 command, specifically focusing on the test function \"test_query\". This might be related to testing connections between dog and cat data.",
        "type": "summary"
    },
    "58": {
        "file_id": 13,
        "content": "cd . # really sure that is just because of insufficient power supply for external drives?\npytest-3 -s test_make_dog_cat_connection.py::test_query",
        "type": "code",
        "location": "/tasks/qq/qq_red_packet_collect/test_adtools.sh:1-2"
    },
    "59": {
        "file_id": 13,
        "content": "This code changes the current directory (CD) and then runs a test script named \"test_make_dog_cat_connection.py\" using the pytest-3 command, specifically focusing on the test function \"test_query\". This might be related to testing connections between dog and cat data.",
        "type": "comment"
    },
    "60": {
        "file_id": 14,
        "content": "/tasks/qq/qq_red_packet_collect/red_packet.yaml",
        "type": "filepath"
    },
    "61": {
        "file_id": 14,
        "content": "The code establishes a window with three panes, executes shell commands for server testing, bilibili video recommendation, and xiaoice chat API; requires login and cautions on Gitter token pasting.",
        "type": "summary"
    },
    "62": {
        "file_id": 14,
        "content": "session_name: qq_red_packet\nwindows:\n  - window_name: qq_red_packet_window\n    layout: tiled\n    shell_command_before:\n      - cd ~/Desktop/works/pyjom # run as a first command in all panes\n      - bash # to ensure we use the right shell\n      - conda deactivate # to disable conda enviorment\n    panes:\n      - shell_command:\n          - cd tests/qq_opqbot\n          - cd opq_arm64\n          - bash launch.sh # will kill all opqbots.\n      - shell_command: # magic from https://www.wikitechy.com/tutorials/linux/how-to-write-stderr-to-a-file-while-using-tee-with-a-pipe\n          - sleep 10\n          - cd tasks/qq/qq_red_packet_collect # run multiple commands in this pane\n          - keepalive python3 botoy_redpacket_collect.py 1>/dev/null 2> >(tee -a logs/redPacketLog_0.log >&2)\n          # - python3 botoy_redpacket_collect.py 1>/dev/null\n        #   - python3 botoy_redpacket_collect.py --log 1 --log_file 0 1>/dev/null 2> >(tee -a redPacketLog_0.log >&2)\n      # it seems we need another github account to have another gitter developer token.",
        "type": "code",
        "location": "/tasks/qq/qq_red_packet_collect/red_packet.yaml:1-20"
    },
    "63": {
        "file_id": 14,
        "content": "This code is setting up a window with tiled layout and three panes. The first pane runs a command to change the directory, the second pane waits for 10 seconds before changing to another directory, and the third pane runs a Python script called `botoy_redpacket_collect.py`, redirecting both standard output (STDOUT) and standard error (STDERR) to a log file while using `keepalive` to keep the script running indefinitely.",
        "type": "comment"
    },
    "64": {
        "file_id": 14,
        "content": "      - shell_command:\n          - cd tests/qq_opqbot\n          - cd opq_arm64_another_account\n          - sleep 3\n          - bash launch.sh # port 8784\n      - shell_command:\n          - sleep 10\n          - cd tasks/qq/qq_red_packet_collect # run multiple commands in this pane\n          - keepalive python3 botoy_redpacket_collect.py --qq 917521610 --port 8784 1>/dev/null 2> >(tee -a logs/redPacketLog_1.log >&2)\n          # - python3 botoy_redpacket_collect.py --qq 917521610 --port 8784 1>/dev/null \n        #   - python3 botoy_redpacket_collect.py  --log 1 --log_file 0 --qq 917521610 --port 8784 1>/dev/null 2> >(tee -a redPacketLog_1.log >&2)\n      - shell_command: # GPT2 LOCAL CHATBOT SERVER\n          - cd tests/cpm_chinese_chitchat_model_gpt2/server/\n          - bash launch.sh\n      - shell_command: # text censor api\n          - cd tasks/qq/qq_red_packet_collect/textfilter \n          - bash launch.sh\n      - shell_command: # image dog/cat recognition server\n          - cd tests/bezier_paddlehub_dogcat_detector_serving",
        "type": "code",
        "location": "/tasks/qq/qq_red_packet_collect/red_packet.yaml:21-39"
    },
    "65": {
        "file_id": 14,
        "content": "This code is setting up and running multiple services for a chatbot application. It changes directories, executes scripts to launch servers, and specifies ports and other configurations for each service. The primary focus appears to be on the \"botoy_redpacket_collect\" application, which requires multiple command line options.",
        "type": "comment"
    },
    "66": {
        "file_id": 14,
        "content": "          - python3 server.py\n      - shell_command:\n          - cd tests/bilibili_video_recommendation_server\n          - python3 test.py\n      - shell_command: # xiaoice chat api\n          - cd tests/microsoft_xiaobing_conversation_bing\n          # - node chat_with_session_id.js\n          # - bash xiaobing_server_keepalive.sh\n          - keepalive node chat_with_session_id.js # try it. you may want to replace it with python.\n      # login first!\n      # when pasting gitter tokens, be careful.",
        "type": "code",
        "location": "/tasks/qq/qq_red_packet_collect/red_packet.yaml:40-50"
    },
    "67": {
        "file_id": 14,
        "content": "The code includes three separate shell commands for running different Python and Node.js scripts related to server testing, bilibili video recommendation, and a xiaoice chat API. It also mentions the need to login first and advises being careful when pasting Gitter tokens.",
        "type": "comment"
    },
    "68": {
        "file_id": 15,
        "content": "/tasks/qq/qq_red_packet_collect/README.md",
        "type": "filepath"
    },
    "69": {
        "file_id": 15,
        "content": "This code provides the URLs to relogin for two users, Yukio and Miaomiao, as well as a command to clear the group chat log using either `cat` or (deprecated) `echo` commands.",
        "type": "summary"
    },
    "70": {
        "file_id": 15,
        "content": "to relogin, go to:\nfor yukio:\nhttp://localhost:8780/v1/Login/GetQRcode\nfor miaomiao:\nhttp://localhost:8784/v1/Login/GetQRcode\nto clear group chat log:\n```bash\ncat /dev/null > redPacketLog_0.log \n```\n(deprecated)\n```bash\necho > redPacketLog_0.log\n```",
        "type": "code",
        "location": "/tasks/qq/qq_red_packet_collect/README.md:1-20"
    },
    "71": {
        "file_id": 15,
        "content": "This code provides the URLs to relogin for two users, Yukio and Miaomiao, as well as a command to clear the group chat log using either `cat` or (deprecated) `echo` commands.",
        "type": "comment"
    },
    "72": {
        "file_id": 16,
        "content": "/tasks/qq/qq_red_packet_collect/launch.sh",
        "type": "filepath"
    },
    "73": {
        "file_id": 16,
        "content": "Starts a new TMUX session, kills the previously running session with the name \"qq_red_packet\", and then loads the red_packet.yaml configuration file to set up the session environment.",
        "type": "summary"
    },
    "74": {
        "file_id": 16,
        "content": "tmux kill-session -t qq_red_packet\ntmuxp load red_packet.yaml",
        "type": "code",
        "location": "/tasks/qq/qq_red_packet_collect/launch.sh:1-2"
    },
    "75": {
        "file_id": 16,
        "content": "Starts a new TMUX session, kills the previously running session with the name \"qq_red_packet\", and then loads the red_packet.yaml configuration file to set up the session environment.",
        "type": "comment"
    },
    "76": {
        "file_id": 17,
        "content": "/tasks/qq/qq_red_packet_collect/deprecated_botoy_redpacket_collect_account_2.py",
        "type": "filepath"
    },
    "77": {
        "file_id": 17,
        "content": "This code is for the arm64 version of opqbot, disabling a 复读机 plugin and using the same config. It listens for group messages and processes red packet information, starting a daemon thread if a red packet is received.",
        "type": "summary"
    },
    "78": {
        "file_id": 17,
        "content": "# for arm64 version of opqbot\n# disable that 复读机 plugin.\n# disable this shit. we use the same config.\nfrom base_opq import *\n@bot.on_group_msg\ndef group(ctx: GroupMsg):\n    # print('收到群消息，群号为', ctx.FromGroupId)\n    data_dict = ctx.data  # recommend to use this json object. or not?\n    group_id = data_dict[\"FromGroupId\"]\n    RedBaginfo = data_dict[\"RedBaginfo\"]\n    if RedBaginfo is not None:\n        print(\"RECEIVED RED PACKET\")\n        startDaemonThread(openRedBag, (RedBaginfo, group_id))\n    # breakpoint()\nif __name__ == \"__main__\":\n    bot.run()\n# do not send porn shits or you need to relogin.",
        "type": "code",
        "location": "/tasks/qq/qq_red_packet_collect/deprecated_botoy_redpacket_collect_account_2.py:1-26"
    },
    "79": {
        "file_id": 17,
        "content": "This code is for the arm64 version of opqbot, disabling a 复读机 plugin and using the same config. It listens for group messages and processes red packet information, starting a daemon thread if a red packet is received.",
        "type": "comment"
    },
    "80": {
        "file_id": 18,
        "content": "/tasks/qq/qq_red_packet_collect/commons.py",
        "type": "filepath"
    },
    "81": {
        "file_id": 18,
        "content": "The code has functions for replacing consecutive characters, checking a \"trace_source\" key, and improving sentence processing. It also handles text manipulation, generates weighted random yields, and shuffles elements if desired.",
        "type": "summary"
    },
    "82": {
        "file_id": 18,
        "content": "import random\nimport re\nfrom string import punctuation\nfrom base_opq import stderrPrint\ndef keywordDecorator(func, **kwargs2):\n    def mytarget(*margs, **kwargs):\n        if \"trace_source\" in kwargs.keys():\n            if kwargs2[\"trace_source\"]:\n                return func(*margs, **kwargs, **kwargs2), \".\".join(\n                    [__name__, func.__name__]\n                )\n        return func(*margs, **kwargs, **kwargs2)\n    return mytarget\ndef replaceDuplicateChar(sentence: str, char=\" \", maxRepeat: int = 3):\n    assert maxRepeat >= 0\n    source = char * (maxRepeat + 1)\n    target = char * maxRepeat\n    # c=0\n    while True:\n        # c+=1\n        # stderrPrint(\"RETRYING\",c)\n        if source in sentence:\n            # stderrPrint(len(source), len(target))\n            sentence = sentence.replace(source, target)\n        else:\n            break  # freaking important!\n    return sentence\ndef replaceDuplicateChars(sentence: str, maxRepeat: int = 3):\n    chars = set(list(sentence))\n    for char in chars:\n        sentence = replaceDuplicateChar(sentence, char, maxRepeat=maxRepeat)",
        "type": "code",
        "location": "/tasks/qq/qq_red_packet_collect/commons.py:1-38"
    },
    "83": {
        "file_id": 18,
        "content": "This code defines a function `replaceDuplicateChar` that replaces consecutive characters with the specified character and maximum repeats, and a function `replaceDuplicateChars` that applies this operation to all characters in the sentence. The code also includes a decorator `keywordDecorator` which checks if a \"trace_source\" key exists in the kwargs dictionary and performs an action accordingly.",
        "type": "comment"
    },
    "84": {
        "file_id": 18,
        "content": "    return sentence\n# this is not replaceDuplicateWords. this is removeDuplicateWords\n# don't know how to implement replaceDuplicateWords yet... use markov network? use CPM?\ndef removeDuplicateWords(sentence: str, removeWordLengthThreshold: int = 2):\n    # TODO: remove duplicate words inside, using jieba.\n    import jieba\n    wordList = jieba.lcut(sentence)\n    newWordList = []\n    for word in wordList:\n        if len(word) >= removeWordLengthThreshold:\n            if word in newWordList:\n                continue\n        newWordList.append(word)\n    # TODO: collect the candidateWordList from chat history.\n    # TODO: force replace mode: at least replace (n) words inside sentence\n    # TODO: mark words as replaceble by word type.\n    return \"\".join(newWordList)\ndef cutIncompleteSentenceTail(\n    sentence: str, threshold: int = len(\"这个群是我老公，你要是让我管管你老公\")\n):  # wtf?\n    if len(sentence) > threshold:\n        pun = \"，。……——“”‘’！； \" + punctuation  # with english space and puncs.\n        punList = list(set(list(pun)))",
        "type": "code",
        "location": "/tasks/qq/qq_red_packet_collect/commons.py:39-66"
    },
    "85": {
        "file_id": 18,
        "content": "This code contains two functions: `removeDuplicateWords` and `cutIncompleteSentenceTail`. The first function aims to remove duplicate words from a sentence using the jieba library. It also mentions potential future improvements like collecting candidate word lists from chat history, replacing words based on their type, and enforcing a minimum number of replacements in the sentence. The second function is for cutting incomplete sentences that exceed a certain length threshold. It utilizes punctuation to separate the sentence into potentially complete segments. There are also mentions of potential improvements like collecting candidate word lists from chat history and replacing words based on their type.",
        "type": "comment"
    },
    "86": {
        "file_id": 18,
        "content": "        pattern = re.compile(\n            \"|\".join([re.escape(punctualChar) for punctualChar in punList])\n        )\n        resultList = re.split(pattern, sentence)\n        resultList = [x for x in resultList if len(x) > 0]\n        for index in range(\n            1, len(resultList)\n        ):  # will return first sentence nevertheless.\n            if pattern.match(resultList[-index]):  # suspected punctual element.\n                sentence = \"\".join(resultList)[:-index]\n                return sentence\n        sentence = resultList[0]  # failsafe.\n    return sentence\ndef generatedSentenceFixer(sentence, threshold=len(\"这个群是我老公，你要是让我管管你老公\"), maxRepeat=3):\n    sentence = replaceDuplicateChars(sentence, maxRepeat=maxRepeat)\n    sentence = cutIncompleteSentenceTail(sentence, threshold=threshold)\n    return sentence\ndef weightedRandomYielder(\n    elemList: list, elemWeights: list, shuffle=True, no_repeat=True, single=False\n):\n    assert len(elemList) >= 2\n    assert len(elemWeights) == len(elemList)\n    baseList = []",
        "type": "code",
        "location": "/tasks/qq/qq_red_packet_collect/commons.py:67-93"
    },
    "87": {
        "file_id": 18,
        "content": "The code contains functions for manipulating text, specifically for cutting incomplete sentences and fixing generated sentences. It also includes a function to generate a weighted random yield from two lists of equal length.",
        "type": "comment"
    },
    "88": {
        "file_id": 18,
        "content": "    for elem, weight in zip(elemList, elemWeights):\n        assert weight > 0\n        assert type(weight) == int\n        baseList += [elem] * weight\n    if shuffle:\n        random.shuffle(baseList)\n    usedElem = []\n    for elem in baseList:\n        if single:\n            return elem\n        if not no_repeat:\n            yield elem\n        elif elem in usedElem:\n            continue\n        else:\n            usedElem.append(elem)\n            yield elem",
        "type": "code",
        "location": "/tasks/qq/qq_red_packet_collect/commons.py:94-110"
    },
    "89": {
        "file_id": 18,
        "content": "Iterates through elements and their weights, adds elements to base list accordingly. If shuffle is True, randomizes the order of baseList. Iterates through baseList, yielding elements one at a time while handling non-repeating elements and avoiding repeats.",
        "type": "comment"
    },
    "90": {
        "file_id": 19,
        "content": "/tasks/qq/qq_red_packet_collect/chatApis.py",
        "type": "filepath"
    },
    "91": {
        "file_id": 19,
        "content": "The code utilizes libraries, chat functions for various APIs, and a function named `getChatApiReply` that selects an API, handles exceptions, logs errors, and returns responses.",
        "type": "summary"
    },
    "92": {
        "file_id": 19,
        "content": "import random\nimport urllib.parse\nimport requests\nfrom base_opq import getGroupNameFromDict\n# disable all proxies.\nimport os\nimport time\nos.environ[\"http_proxy\"] = \"\"\nos.environ[\"https_proxy\"] = \"\"\n# do not use freaking proxy, otherwise QingYunKe will not respond.\ndef checkApi(func, message, name):\n    response_message = func(message)\n    if response_message != None:\n        print(\"{} RESPONSE:\".format(name), response_message)\ndef chatAtri(\n    msg: str, group_id, retryFlag=False, timeout=5, BASE=\"http://api.nekomimi.icu/v1/\"\n):\n    url = BASE + \"chat?msg=%s\" % urllib.parse.quote(msg)\n    response = requests.get(url, timeout=timeout)\n    if response.status_code == 200:\n        data = response.json()\n        if data[\"status\"] == \"success\":\n            return data[\"message\"]\n    # return None\n    # nothing is returned if have error.\n    print(\"ATRI ERROR:\", response.status_code, response.json())\ndef chatGPT2Local(\n    msg: str, group_id, retryFlag=False, timeout=5, BASE=\"http://127.0.0.1:8729/\"\n):\n    # url = BASE + '?text=%s' % urllib.parse.quote(msg)",
        "type": "code",
        "location": "/tasks/qq/qq_red_packet_collect/chatApis.py:1-39"
    },
    "93": {
        "file_id": 19,
        "content": "Code imports required libraries, disables proxies, and includes two chat functions (chatAtri and chatGPT2Local) for interacting with different APIs. chatAtri sends a message to the Atri API, while chatGPT2Local communicates with a local GPT-2 model through HTTP requests. Both return the response message if successful; otherwise, they print an error message.",
        "type": "comment"
    },
    "94": {
        "file_id": 19,
        "content": "    url = BASE\n    params = {\"text\": msg, \"retry\": retryFlag, \"group_id\": group_id}\n    response = requests.get(url, params=params)  # simply ignore timeout.\n    # response = requests.get(url, timeout=timeout, params = params)\n    if response.status_code == 200:\n        data = response.text\n        if len(data) > 0:\n            return data\n    # return None\n    # nothing is returned if have error.\n    print(\"GPT2LOCAL NO RESPONSE ERROR\")  # unknown error.\n# import subprocess\n# import json\ndef chatQingKeYun(\n    msg: str,\n    group_id,\n    retryFlag=False,\n    timeout=5,\n    url=\"http://api.qingyunke.com/api.php?key=free&appid=0&msg=\",\n):\n    msg = urllib.parse.quote(msg)\n    myUrl = url + msg\n    # print(myUrl)\n    # output = subprocess.check_output([\"curl\", myUrl])\n    # data = json.loads(output.decode(\"utf-8\"))\n    # import requests\n    data = requests.get(myUrl, timeout=timeout)\n    data = data.json()\n    print(data)\n    result = data[\"result\"]\n    assert result == 0  # 202 -> busy\n    content = data[\"content\"]\n    return content",
        "type": "code",
        "location": "/tasks/qq/qq_red_packet_collect/chatApis.py:40-76"
    },
    "95": {
        "file_id": 19,
        "content": "This function uses the QingKeYun API to process and return responses for a given message. It takes in parameters including the message text, group ID, retry flag, and timeout duration. The code handles potential errors, prints \"GPT2LOCAL NO RESPONSE ERROR\" when there is no response or an unknown error occurs.",
        "type": "comment"
    },
    "96": {
        "file_id": 19,
        "content": "    # breakpoint()\ndef chatOwnThink(msg: str, group_id, retryFlag=False, timeout=5):\n    url = \"https://api.ownthink.com/bot?appid=xiaosi&userid=user&spoken=\"\n    msg = urllib.parse.quote(msg)\n    myUrl = url + msg\n    data = requests.get(myUrl, timeout=timeout)\n    data = data.json()\n    # output = subprocess.check_output([\"curl\", myUrl])\n    # data = json.loads(output.decode(\"utf-8\"))\n    if data[\"message\"] == \"success\":\n        if data[\"data\"][\"type\"] == 5000:\n            return data[\"data\"][\"info\"][\"text\"]\n    # print(data)\n    # breakpoint()\n    # result = data['result']\n    # assert result == 0  # 202 -> busy\n    # content = data['content']\n    # return content\ndef chatXiaoIce(msg, group_id, retryFlag=False, timeout=5):\n    import requests\n    topic = getGroupNameFromDict(group_id)\n    if topic is None:\n        topic = \"aaa\"  # default topic. nothing.\n    r = requests.get(\n        \"http://localhost:8735/chat\",\n        params={\"topic\": topic, \"message\": msg},\n        timeout=timeout,\n    )\n    if r.status_code == 200:",
        "type": "code",
        "location": "/tasks/qq/qq_red_packet_collect/chatApis.py:77-111"
    },
    "97": {
        "file_id": 19,
        "content": "chatOwnThink and chatXiaoIce are two functions used to communicate with the ownthink.com API and local XiaoIce API, respectively. They both take a message as input, along with a group ID and optional retry flag and timeout values. If the request is successful, the function returns the text response from the API. The code also contains comments for potential future implementation of error handling, assertion checks, and content retrieval.",
        "type": "comment"
    },
    "98": {
        "file_id": 19,
        "content": "        try:\n            content = r.json()\n            assert content[\"msg\"] == \"success\"\n            reply = content[\"reply\"]\n            return reply\n        except:\n            from lazero.utils.logger import traceError\n            traceError(\"xiaoice client error\")\n    else:\n        print(\"xiaoice client got abnormal response code:\", r.status_code)\n# changed. non_standard.\ndef getChatApiReply(\n    msg: str, group_id, chatApiIndex=0, retryFlag=False, timeout=15\n):  # 15 seconds of grace time.\n    # chatApis = [chatQingKeYun, chatAtri]\n    # blacklist chatOwnThink.\n    chatApis = [chatAtri, chatGPT2Local, chatXiaoIce]  # no random shit!\n    # chatApi = random.choice(chatApis)\n    chatApi = chatApis[chatApiIndex]\n    try:\n        reply = chatApi(msg, group_id, retryFlag=retryFlag, timeout=timeout)\n        # will be None anyway.\n        return reply\n    except:\n        pass",
        "type": "code",
        "location": "/tasks/qq/qq_red_packet_collect/chatApis.py:112-139"
    },
    "99": {
        "file_id": 19,
        "content": "This code defines a function `getChatApiReply` that selects a chat API from a list and tries to retrieve a response for the input message. If an exception occurs, it logs an error or returns None if the retry flag is set. The code also includes a try-except block to handle potential exceptions during the API request.",
        "type": "comment"
    }
}