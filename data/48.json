{
    "4800": {
        "file_id": 626,
        "content": "# strange.\nfrom __future__ import absolute_import, division, print_function\nimport logging\nimport scapy.config\nimport scapy.layers.l2\nimport scapy.route\nimport socket\nimport math\nimport errno\nimport os\nimport getopt\nimport sys\nmyPort = 5555\nmyInterface = \"wlan0\"\n# list avaliable devices.\nfrom adb_wrapper import AdbWrapper\na = AdbWrapper()\ndevices = a.devices()\nprint(devices)\n# exit()\nconnected_addresses = []\nfor key, value in devices.items():\n    address = key\n    connected_addresses.append(address)\n    deviceType = value\n# not working.\nif os.geteuid() != 0:\n        print('You need to be root to run this script', file=sys.stderr)\n        sys.exit(1)\nscanAddress = None\nfor network, netmask, _, interface, address, _ in scapy.config.conf.route.routes:\n    # print(interface, address)\n    if interface == myInterface:\n        myAddress = address.split(\".\")\n        myAddress[3] = \"0/24\"\n        scanAddress = \".\".join(myAddress)\n        print(scanAddress, interface)\n        break\nif scanAddress is not None:\n    # now scan this interface with masscan.",
        "type": "code",
        "location": "/tests/adb_phone_control_termux_network_broadcast_scrcpy_appium_airtest/get_modifier_with_masscan_scapy.py:1-42"
    },
    "4801": {
        "file_id": 626,
        "content": "The code imports necessary libraries, initializes variables, and connects with available devices using AdbWrapper. It then checks if the user is root before attempting to scan a specific network interface using masscan.",
        "type": "comment"
    },
    "4802": {
        "file_id": 626,
        "content": "    import masscan\n    mas = masscan.PortScanner()\n    mas.scan(scanAddress, ports=str(myPort), arguments='--max-rate 1000')\n    result = mas.scan_result\n    # usually it only show opens.\n    import json\n    scanResultDict = json.loads(result)['scan']\n    for key, value in scanResultDict.items():\n        address = key\n        for port in value:\n            if port['port'] == myPort and port['status'] =='open':\n                # print(address, myPort)\n                # we need to connect to it!\n                connect_address = \"{}:{}\".format(address,myPort)\n                print(connect_address)\n                if not connect_address in connected_addresses:\n                    print(\"connecting device:\", connect_address)\n                    # command1 = \"adb tcpip 5555\"\n                    # no need to restart?\n                    command2 = \"adb connect {}\".format(connect_address)\n                    # os.system(command1)\n                    os.system(command2)",
        "type": "code",
        "location": "/tests/adb_phone_control_termux_network_broadcast_scrcpy_appium_airtest/get_modifier_with_masscan_scapy.py:43-64"
    },
    "4803": {
        "file_id": 626,
        "content": "This code is using the Masscan library to scan for open ports on a specified address. It then checks if the desired port is open, and if so, connects to it by running \"adb connect\" command. The connected addresses are stored in the connected_addresses list. This code is part of a broader script for controlling devices over network.",
        "type": "comment"
    },
    "4804": {
        "file_id": 627,
        "content": "/tests/adb_phone_control_termux_network_broadcast_scrcpy_appium_airtest/get_modifier.sh",
        "type": "filepath"
    },
    "4805": {
        "file_id": 627,
        "content": "This line establishes a TCP/IP connection on port 5555 for ADB, ensuring the device is reachable over the network.",
        "type": "summary"
    },
    "4806": {
        "file_id": 627,
        "content": "adb tcpip 5555 # will not restart if already in tcpip mode\\",
        "type": "code",
        "location": "/tests/adb_phone_control_termux_network_broadcast_scrcpy_appium_airtest/get_modifier.sh:1-1"
    },
    "4807": {
        "file_id": 627,
        "content": "This line establishes a TCP/IP connection on port 5555 for ADB, ensuring the device is reachable over the network.",
        "type": "comment"
    },
    "4808": {
        "file_id": 628,
        "content": "/tests/still_watermark_auto_removal/test_auto_video_watermark_detection.sh",
        "type": "filepath"
    },
    "4809": {
        "file_id": 628,
        "content": "cd into the automatic-watermark-detection directory and execute the video_watermark_detection.py script for watermark detection in videos.",
        "type": "summary"
    },
    "4810": {
        "file_id": 628,
        "content": "cd automatic-watermark-detection\npython3 video_watermark_detection.py",
        "type": "code",
        "location": "/tests/still_watermark_auto_removal/test_auto_video_watermark_detection.sh:1-3"
    },
    "4811": {
        "file_id": 628,
        "content": "cd into the automatic-watermark-detection directory and execute the video_watermark_detection.py script for watermark detection in videos.",
        "type": "comment"
    },
    "4812": {
        "file_id": 629,
        "content": "/tests/still_watermark_auto_removal/maxRectangleSolver.py",
        "type": "filepath"
    },
    "4813": {
        "file_id": 629,
        "content": "The code defines checkOverlap for point validation and solves the maximum rectangle problem, iterating through candidate rectangles, detecting overlaps, and displaying the best candidate in red. It also sorts and prints top 5 areas.",
        "type": "summary"
    },
    "4814": {
        "file_id": 629,
        "content": "import sympy\nimport json\ndata = json.loads(open(\"test_special.json\", \"r\").read())\ncanvas = data[\"canvas\"]\nrectangles = data[\"rectangles\"]\ncanvasWidth, canvasHeight = canvas\nxValid = [0, canvasWidth]\nyValid = [0, canvasHeight]\nmRects = []\ndef checkContains(rect, point):\n    xPoints = [p[0] for p in rect]\n    yPoints = [p[1] for p in rect]\n    maxX, minX = max(xPoints), min(xPoints)\n    maxY, minY = max(yPoints), min(yPoints)\n    x, y = point\n    return x > minX and x < maxX and y > minY and y < maxY\n# def checkOverlapAsymmetric(rect0, rect1):\n#     for point in rect0:\n#         if checkContains(rect1, point):\n#             return True\n#         # also check for intersections?\n#     return False\n# Python program to check if rectangles overlap\nclass D2Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\ndef getRectDiagonalPoints(rect):\n    xPoints = [p[0] for p in rect]\n    yPoints = [p[1] for p in rect]\n    maxX, minX = max(xPoints), min(xPoints)\n    maxY, minY = max(yPoints), min(yPoints)\n    p0, p1 = D2Point(minX, minY), D2Point(maxX, maxY)",
        "type": "code",
        "location": "/tests/still_watermark_auto_removal/maxRectangleSolver.py:1-43"
    },
    "4815": {
        "file_id": 629,
        "content": "Code reads JSON data containing a canvas and rectangles. It validates points, creates a function to check if two rectangles overlap, and defines D2Point class for storing 2D point coordinates.",
        "type": "comment"
    },
    "4816": {
        "file_id": 629,
        "content": "    return p0, p1\ndef do_overlap(l1, r1, l2, r2):\n    # if rectangle has area 0, no overlap\n    if l1.x == r1.x or l1.y == r1.y or r2.x == l2.x or l2.y == r2.y:\n        return False\n    # If one rectangle is on left side of other\n    if l1.x >= r2.x or l2.x >= r1.x:\n        return False\n    if l1.y >= r2.y or l2.y >= r1.y:\n        return False\n    return True\ndef checkOverlap(rect0, rect1):\n    return do_overlap(*getRectDiagonalPoints(rect0),*getRectDiagonalPoints(rect1))\nfor x, y, mWidth, mHeight in rectangles:\n    xValid.append(x)\n    xValid.append(x + mWidth)\n    yValid.append(y)\n    yValid.append(y + mHeight)\n    p0, p1, p2, p3 = (\n        (x, y),\n        (x + mWidth, y),\n        (x + mWidth, y + mHeight),\n        (x, y + mHeight),\n    )\n    # mRectangle = sympy.Polygon(p0,p1,p2,p3)\n    mRectangle = [p0, p1, p2, p3]\n    mRects.append(mRectangle)\ndef purify(xValid):\n    xValid = list(set(xValid))\n    xValid.sort()\n    return xValid\ndef checkOverlapAgainstRectList(rect, rectList):\n    for testRect in rectList:\n        if checkOverlap(rect, testRect):",
        "type": "code",
        "location": "/tests/still_watermark_auto_removal/maxRectangleSolver.py:44-85"
    },
    "4817": {
        "file_id": 629,
        "content": "This code defines a function checkOverlap which takes two rectangles and checks if they overlap. The function do_overlap is used to determine if the rectangles have any area of overlap. It also includes utility functions like getRectDiagonalPoints, purify, and checkOverlapAgainstRectList for manipulating and comparing rectangles. The code creates a list of rectangles and checks for overlaps between each rectangle and others in a separate list.",
        "type": "comment"
    },
    "4818": {
        "file_id": 629,
        "content": "            return True\n    return False\nxValid = purify(xValid)\nyValid = purify(yValid)\ntotalCandidates = []\ndef getRectArea(rect):\n    xPoints = [p[0] for p in rect]\n    yPoints = [p[1] for p in rect]\n    maxX, minX = max(xPoints), min(xPoints)\n    maxY, minY = max(yPoints), min(yPoints)\n    return (maxX - minX) * (maxY - minY)\nbestCandidate = None\nbestArea = 0\nfor ix0 in range(0, len(xValid)-1):\n    for ix1 in range(ix0+1, len(xValid)):\n        for iy0 in range(0, len(yValid)-1):\n            for iy1 in range(iy0+1, len(yValid)):\n                x0, x1, y0, y1 = xValid[ix0], xValid[ix1], yValid[iy0], yValid[iy1]\n                x, y = x0, y0\n                mWidth, mHeight = x1 - x, y1 - y\n                p0, p1, p2, p3 = (\n                    (x, y),\n                    (x + mWidth, y),\n                    (x + mWidth, y + mHeight),\n                    (x, y + mHeight),\n                )\n                rectCandidate = [p0, p1, p2, p3]\n                area = getRectArea(rectCandidate)\n                if area <= bestArea:",
        "type": "code",
        "location": "/tests/still_watermark_auto_removal/maxRectangleSolver.py:86-120"
    },
    "4819": {
        "file_id": 629,
        "content": "The code is implementing a maximum rectangle solver algorithm. It iterates over the x and y validated points to generate all possible rectangles, calculating their areas using the getRectArea function. The best candidate with the highest area is stored.",
        "type": "comment"
    },
    "4820": {
        "file_id": 629,
        "content": "                    continue\n                if checkOverlapAgainstRectList(rectCandidate, mRects):\n                    break\n                bestCandidate = rectCandidate.copy()\n                bestArea = area\n                # print(\"UPDATING:\",bestCandidate)\n                # print('AREA:', bestArea)\n                # totalCandidates.append(rectCandidate.copy())\nprint(\"final candidate:\", bestCandidate)\n# plot this?\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Rectangle\nfig, ax = plt.subplots()\nax.plot([canvasWidth, canvasHeight])\n# add rectangle to plot\ndef plotRect(ax, x, y, width, height, facecolor):\n    ax.add_patch(Rectangle((x, y), width, height, facecolor=facecolor, fill=True))\ndef rectToXYWH(rect):\n    xPoints = [p[0] for p in rect]\n    yPoints = [p[1] for p in rect]\n    maxX, minX = max(xPoints), min(xPoints)\n    maxY, minY = max(yPoints), min(yPoints)\n    x, y = minX, minY\n    width, height = (maxX - minX), (maxY - minY)\n    return x, y, width, height\nplotRect(ax,0,0,canvasWidth, canvasHeight,'black')",
        "type": "code",
        "location": "/tests/still_watermark_auto_removal/maxRectangleSolver.py:121-151"
    },
    "4821": {
        "file_id": 629,
        "content": "This code finds the maximum rectangle by iterating through candidate rectangles and checking for overlaps. It updates the best candidate and area if a better one is found, then plots the final candidate rectangle on a plot.",
        "type": "comment"
    },
    "4822": {
        "file_id": 629,
        "content": "for rect in mRects:\n    x,y, width, height = rectToXYWH(rect)\n    plotRect(ax,x,y,width,height,'white')\nplotRect(ax,*rectToXYWH(bestCandidate),'red')\n# display plot\nplt.show()\n# totalCandidates.sort(key = lambda rect: -getRectArea(rect))\n# for rect in totalCandidates[:5]:\n#     print(rect)",
        "type": "code",
        "location": "/tests/still_watermark_auto_removal/maxRectangleSolver.py:153-161"
    },
    "4823": {
        "file_id": 629,
        "content": "The code generates and plots rectangles using given coordinates and dimensions, with the best candidate rectangle displayed in red. It also sorts the total list of candidate rectangles by area and prints the top 5 areas.",
        "type": "comment"
    },
    "4824": {
        "file_id": 630,
        "content": "/tests/still_watermark_auto_removal/EAST-Detector-for-text-detection-using-OpenCV-master/README.md",
        "type": "filepath"
    },
    "4825": {
        "file_id": 630,
        "content": "EAST Detector code in OpenCV enables real-time, accurate text detection in natural scenes, addressing challenges like angles, lighting, and non-ideal surfaces. The project welcomes improvements via pull requests and is licensed under MIT.",
        "type": "summary"
    },
    "4826": {
        "file_id": 630,
        "content": "# EAST Detector for Text Detection\nOpenCV’s EAST(Efficient and Accurate Scene Text Detection ) text detector is a deep learning model, based on a novel architecture and training pattern. It is capable of \n- running at near real-time at 13 FPS on 720p images and \n- obtains state-of-the-art text detection accuracy.\n[Link to paper](https://arxiv.org/pdf/1704.03155.pdf)\nOpenCV’s text detector implementation of EAST is quite robust, capable of localizing text even when it’s blurred, reflective, or partially obscured.\nThere are many natural scene text detection challenges that have been described by Celine Mancas-Thillou and Bernard Gosselin in their excellent 2017 paper, [Natural Scene Text Understanding](https://www.tcts.fpms.ac.be/publications/regpapers/2007/VS_cmtbg2007.pdf) below:\n- **Image/sensor noise**: Sensor noise from a handheld camera is typically higher than that of a traditional scanner. Additionally, low-priced cameras will typically interpolate the pixels of raw sensors to produce real colors.",
        "type": "code",
        "location": "/tests/still_watermark_auto_removal/EAST-Detector-for-text-detection-using-OpenCV-master/README.md:1-13"
    },
    "4827": {
        "file_id": 630,
        "content": "Code for OpenCV's EAST Detector implementation for text detection, capable of real-time performance and high accuracy. Based on a novel architecture and training pattern, it can detect text even when blurred, reflective or partially obscured. The code addresses challenges like sensor noise from handheld cameras.",
        "type": "comment"
    },
    "4828": {
        "file_id": 630,
        "content": "- **Viewing angles**: Natural scene text can naturally have viewing angles that are not parallel to the text, making the text harder to recognize.\nBlurring: Uncontrolled environments tend to have blur, especially if the end user is utilizing a smartphone that does not have some form of stabilization.\n- **Lighting conditions**: We cannot make any assumptions regarding our lighting conditions in natural scene images. It may be near dark, the flash on the camera may be on, or the sun may be shining brightly, saturating the entire image.\n- **Resolution**: Not all cameras are created equal — we may be dealing with cameras with sub-par resolution.\n- **Non-paper objects**: Most, but not all, paper is not reflective (at least in context of paper you are trying to scan). Text in natural scenes may be reflective, including logos, signs, etc.\n- **Non-planar objects**: Consider what happens when you wrap text around a bottle — the text on the surface becomes distorted and deformed. While humans may sti",
        "type": "code",
        "location": "/tests/still_watermark_auto_removal/EAST-Detector-for-text-detection-using-OpenCV-master/README.md:15-24"
    },
    "4829": {
        "file_id": 630,
        "content": "The code discusses various challenges in natural scene text detection, such as viewing angles, lighting conditions, resolution, non-paper objects (like reflective surfaces), and non-planar objects (such as distorted text on curved surfaces). These factors make it difficult to recognize and extract text from natural scenes.",
        "type": "comment"
    },
    "4830": {
        "file_id": 630,
        "content": "ll be able to easily “detect” and read the text, our algorithms will struggle. We need to be able to handle such use cases.\n- **Unknown layout**: We cannot use any a priori information to give our algorithms “clues” as to where the text resides.\n## Contributing\nPull requests are welcome. For major changes, please open an issue first to discuss what you would like to change.\n### Thanks to [Adrian's Blog](https://www.pyimagesearch.com/2018/08/20/opencv-text-detection-east-text-detector/) for a comprehensive blog on EAST Detector.\n## License\n[MIT](https://choosealicense.com/licenses/mit/)",
        "type": "code",
        "location": "/tests/still_watermark_auto_removal/EAST-Detector-for-text-detection-using-OpenCV-master/README.md:24-35"
    },
    "4831": {
        "file_id": 630,
        "content": "This code is from the README file of a project that utilizes EAST Detector, an OpenCV-based text detection algorithm. The project aims to improve its algorithms' ability to handle complex text layouts and use cases. It welcomes pull requests for major changes and is licensed under MIT.",
        "type": "comment"
    },
    "4832": {
        "file_id": 631,
        "content": "/tests/still_watermark_auto_removal/EAST-Detector-for-text-detection-using-OpenCV-master/opencv_text_detection_image.py",
        "type": "filepath"
    },
    "4833": {
        "file_id": 631,
        "content": "The code loads an input image, preprocesses it, resizes using argparse, detects text with OpenCV and EAST Detector, calculates prediction time, filters low-confidence detections, extracts scores & geometrical data, applies non-maxima suppression, scales coordinates, draws bounding boxes on the original image, and displays it.",
        "type": "summary"
    },
    "4834": {
        "file_id": 631,
        "content": "# USAGE\n# python3 opencv_text_detection_image.py --image images/lebron_james.jpg --east frozen_east_text_detection.pb\n# import the necessary packages\nfrom imutils.object_detection import non_max_suppression\nimport numpy as np\nimport argparse\nimport time\nimport cv2\n# construct the argument parser and parse the arguments\nap = argparse.ArgumentParser()\nap.add_argument(\"-i\", \"--image\", type=str,\n                help=\"path to input image\")\nap.add_argument(\"-east\", \"--east\", type=str,\n                help=\"path to input EAST text detector\")\nap.add_argument(\"-c\", \"--min-confidence\", type=float, default=0.5,\n                help=\"minimum probability required to inspect a region\")\nap.add_argument(\"-w\", \"--width\", type=int, default=320,\n                help=\"resized image width (should be multiple of 32)\")\nap.add_argument(\"-e\", \"--height\", type=int, default=320,\n                help=\"resized image height (should be multiple of 32)\")\nargs = vars(ap.parse_args())\n# load the input image and grab the image dimensions\nimage = cv2.imread(args[\"image\"])",
        "type": "code",
        "location": "/tests/still_watermark_auto_removal/EAST-Detector-for-text-detection-using-OpenCV-master/opencv_text_detection_image.py:1-26"
    },
    "4835": {
        "file_id": 631,
        "content": "This code loads an input image and applies preprocessing steps. It utilizes the argparse module to accept command-line arguments, allowing users to specify the input image path and the East text detector model file. It also sets default values for confidence threshold and resized image dimensions, which can be overridden by command-line options.",
        "type": "comment"
    },
    "4836": {
        "file_id": 631,
        "content": "orig = image.copy()\n(H, W) = image.shape[:2]\n# set the new width and height and then determine the ratio in change\n# for both the width and height\n(newW, newH) = (args[\"width\"], args[\"height\"])\nrW = W / float(newW)\nrH = H / float(newH)\n# resize the image and grab the new image dimensions\nimage = cv2.resize(image, (newW, newH))\n(H, W) = image.shape[:2]\n# define the two output layer names for the EAST detector model that\n# we are interested -- the first is the output probabilities and the\n# second can be used to derive the bounding box coordinates of text\nlayerNames = [\n    \"feature_fusion/Conv_7/Sigmoid\",\n    \"feature_fusion/concat_3\"]\n# load the pre-trained EAST text detector\nprint(\"[INFO] loading EAST text detector...\")\nnet = cv2.dnn.readNet(args[\"east\"])\n# construct a blob from the image and then perform a forward pass of\n# the model to obtain the two output layer sets\nblob = cv2.dnn.blobFromImage(image, 1.0, (W, H),\n                             (123.68, 116.78, 103.94), swapRB=True, crop=False)\nstart = time.time()",
        "type": "code",
        "location": "/tests/still_watermark_auto_removal/EAST-Detector-for-text-detection-using-OpenCV-master/opencv_text_detection_image.py:27-55"
    },
    "4837": {
        "file_id": 631,
        "content": "This code performs image preprocessing, resizing and loads the EAST text detector model for text detection. It sets the original image copy, calculates new width and height based on arguments, resizes the image, gets updated dimensions, defines output layer names for the model, loads the pre-trained EAST text detector model, constructs a blob from the image, performs a forward pass of the model to obtain two output layers.",
        "type": "comment"
    },
    "4838": {
        "file_id": 631,
        "content": "net.setInput(blob)\n(scores, geometry) = net.forward(layerNames)\nend = time.time()\n# show timing information on text prediction\nprint(\"[INFO] text detection took {:.6f} seconds\".format(end - start))\n# grab the number of rows and columns from the scores volume, then\n# initialize our set of bounding box rectangles and corresponding\n# confidence scores\n(numRows, numCols) = scores.shape[2:4]\nrects = []\nconfidences = []\n# loop over the number of rows\nfor y in range(0, numRows):\n    # extract the scores (probabilities), followed by the geometrical\n    # data used to derive potential bounding box coordinates that\n    # surround text\n    scoresData = scores[0, 0, y]\n    xData0 = geometry[0, 0, y]\n    xData1 = geometry[0, 1, y]\n    xData2 = geometry[0, 2, y]\n    xData3 = geometry[0, 3, y]\n    anglesData = geometry[0, 4, y]\n    # loop over the number of columns\n    for x in range(0, numCols):\n        # if our score does not have sufficient probability, ignore it\n        if scoresData[x] < args[\"min_confidence\"]:\n            continue",
        "type": "code",
        "location": "/tests/still_watermark_auto_removal/EAST-Detector-for-text-detection-using-OpenCV-master/opencv_text_detection_image.py:56-86"
    },
    "4839": {
        "file_id": 631,
        "content": "Code performs text detection using OpenCV and EAST Detector. It calculates the time taken for text prediction, extracts scores and geometrical data, filters out low-confidence detections, and stores bounding box rectangles and corresponding confidence scores in lists.",
        "type": "comment"
    },
    "4840": {
        "file_id": 631,
        "content": "        # compute the offset factor as our resulting feature maps will\n        # be 4x smaller than the input image\n        (offsetX, offsetY) = (x * 4.0, y * 4.0)\n        # extract the rotation angle for the prediction and then\n        # compute the sin and cosine\n        angle = anglesData[x]\n        cos = np.cos(angle)\n        sin = np.sin(angle)\n        # use the geometry volume to derive the width and height of\n        # the bounding box\n        h = xData0[x] + xData2[x]\n        w = xData1[x] + xData3[x]\n        # compute both the starting and ending (x, y)-coordinates for\n        # the text prediction bounding box\n        endX = int(offsetX + (cos * xData1[x]) + (sin * xData2[x]))\n        endY = int(offsetY - (sin * xData1[x]) + (cos * xData2[x]))\n        startX = int(endX - w)\n        startY = int(endY - h)\n        # add the bounding box coordinates and probability score to\n        # our respective lists\n        rects.append((startX, startY, endX, endY))\n        confidences.append(scoresData[x])\n# apply non-maxima suppression to suppress weak, overlapping bounding",
        "type": "code",
        "location": "/tests/still_watermark_auto_removal/EAST-Detector-for-text-detection-using-OpenCV-master/opencv_text_detection_image.py:88-115"
    },
    "4841": {
        "file_id": 631,
        "content": "This code computes the bounding box coordinates and confidence scores for text predictions, using input data such as angles, offsets, xData values. It then applies non-maxima suppression to suppress weak overlapping bounding boxes, likely for further processing or object detection purposes.",
        "type": "comment"
    },
    "4842": {
        "file_id": 631,
        "content": "# boxes\nboxes = non_max_suppression(np.array(rects), probs=confidences)\n# loop over the bounding boxes\nfor (startX, startY, endX, endY) in boxes:\n    # scale the bounding box coordinates based on the respective\n    # ratios\n    startX = int(startX * rW)\n    startY = int(startY * rH)\n    endX = int(endX * rW)\n    endY = int(endY * rH)\n    # draw the bounding box on the image\n    cv2.rectangle(orig, (startX, startY), (endX, endY), (0, 255, 0), 2)\n# show the output image\ncv2.imshow(\"Text Detection\", orig)\ncv2.waitKey(0)",
        "type": "code",
        "location": "/tests/still_watermark_auto_removal/EAST-Detector-for-text-detection-using-OpenCV-master/opencv_text_detection_image.py:116-133"
    },
    "4843": {
        "file_id": 631,
        "content": "This code performs non-maximum suppression on bounding box coordinates, scales the coordinates based on image ratios, draws bounding boxes on the original image using OpenCV, and displays the resulting image.",
        "type": "comment"
    },
    "4844": {
        "file_id": 632,
        "content": "/tests/still_watermark_auto_removal/automatic-watermark-detection/video_watermark_detection.py",
        "type": "filepath"
    },
    "4845": {
        "file_id": 632,
        "content": "The code employs OpenCV and Deep Learning for watermark detection, estimation, and removal. It detects video watermarks using adaptive thresholding, applies Gaussian blur, scales, and draws boxes before saving the information to a JSON file.",
        "type": "summary"
    },
    "4846": {
        "file_id": 632,
        "content": "# sample few images from a video.\nimport random\n## we import our version of cv2 here? or uninstall and reinstall opencv-python with custom things?\nimport pathlib\nimport sys\nsite_path = pathlib.Path(\"/usr/local/lib/python3.9/site-packages\")\ncv2_libs_dir = site_path / 'cv2' / f'python-{sys.version_info.major}.{sys.version_info.minor}'\nprint(cv2_libs_dir)\ncv2_libs = sorted(cv2_libs_dir.glob(\"*.so\"))\nif len(cv2_libs) == 1:\n    print(\"INSERTING:\",cv2_libs[0].parent)\n    sys.path.insert(1, str(cv2_libs[0].parent))\nimport cv2\nimport progressbar as pb\nvideoPaths = [\n    \"/root/Desktop/works/pyjom/tests/still_watermark_auto_removal/kunfu_cat.mp4\", # bilibili animal video compilation\n    \"/root/Desktop/works/pyjom/tests/bilibili_practices/bilibili_video_translate/japan_day.webm\", # youtube animation with watermark\n    \"/root/Desktop/works/pyjom/samples/video/LiGHT3ZCi.mp4\", # animal video compilation with pip and large area of watermark\n]  # his watermark. scorpa.\nvideo_path = videoPaths[2]\n# will change this shit.\n# shall we downscale this thing?",
        "type": "code",
        "location": "/tests/still_watermark_auto_removal/automatic-watermark-detection/video_watermark_detection.py:1-25"
    },
    "4847": {
        "file_id": 632,
        "content": "The code imports necessary libraries, checks and inserts custom OpenCV library paths, defines a list of video paths, and selects the third video for processing.",
        "type": "comment"
    },
    "4848": {
        "file_id": 632,
        "content": "# video = cv2.\n# video_path = \"\"\n# long loading time since we are backing up.\nsample_count = 60\nvideo_cap = cv2.VideoCapture(video_path)\nfps = video_cap.get(cv2.CAP_PROP_FPS)  # 60.\nframe_count = int(video_cap.get(cv2.CAP_PROP_FRAME_COUNT))\nprint(frame_count)\nsample_indexs = [x for x in range(frame_count)]\nsample_indexs = random.sample(sample_indexs, sample_count)\n# import copy\nimageSet = []\nfor frame_index_counter in pb.progressbar(range(frame_count)):  # are you sure?\n    success, frame = video_cap.read()\n    if not success:\n        break\n    if frame_index_counter in sample_indexs:\n        imageSet.append(frame.copy())\nfrom src import *\ngx, gy, gxlist, gylist = estimate_watermark_imgSet(imageSet)\n# print(len(imageSet))\ncropped_gx, cropped_gy, watermark_location = crop_watermark(gx, gy, location=True)\nW_m = poisson_reconstruct(cropped_gx, cropped_gy)\nW_full = poisson_reconstruct(gx, gy)\nprint(cropped_gx.shape, cropped_gy.shape, W_m.shape)  # (50, 137, 3) may vary.\nprint(watermark_location)  # ((1022, 21), (1072, 158)) inverted x,y! hell.",
        "type": "code",
        "location": "/tests/still_watermark_auto_removal/automatic-watermark-detection/video_watermark_detection.py:27-62"
    },
    "4849": {
        "file_id": 632,
        "content": "This code reads frames from a video, randomly selects some frames to analyze for watermark detection, and then estimates the watermark using poisson reconstruction. The code also outputs the shape of the detected watermark and its location on the frames. It may not use progress bar properly and has an issue with inverted x and y coordinates for watermark location.",
        "type": "comment"
    },
    "4850": {
        "file_id": 632,
        "content": "# cv2.imshow(\"WATERMARK\",W_m)\n# cv2.imshow(\"WATERMARK_FULL\",W_full)\n# # remove the freaking watermark please?\n# cv2.waitKey(0)\n# east_net = \"/media/root/help/pyjom/tests/still_watermark_auto_removal/EAST-Detector-for-text-detection-using-OpenCV-master/frozen_east_text_detection.pb\"\n# net = cv2.dnn.readNet(east_net)\n# H,W = W_full.shape[:2]\n# newH = (H//32)*32\n# newW = (W//32)*32\n# rH, rW = H/float(newH), W/float(newW)\n# W_full = cv2.resize(W_full,(newW,newH))\nmaxval, minval = np.max(W_full), np.min(W_full)\nW_full = (W_full - minval) * (255 / (maxval - minval))  # is that necessary?\n# # print(,W_full.shape,W_full.dtype)\nW_full = W_full.astype(np.uint8)\n# # breakpoint()\n# newH,newW = W_full.shape[:2]\n# # 14.122540090957173 -17.575702620638673 (1080, 1920, 3) float64\n# # you even have negative values. what the fuck?\n# blob = cv2.dnn.blobFromImage(W_full, 1.0, (newW, newH), (123.68, 116.78, 103.94), swapRB=True, crop=False)\n# # start = time.time()\n# net.setInput(blob)\n# layerNames = [\n# \t\"feature_fusion/Conv_7/Sigmoid\",",
        "type": "code",
        "location": "/tests/still_watermark_auto_removal/automatic-watermark-detection/video_watermark_detection.py:64-91"
    },
    "4851": {
        "file_id": 632,
        "content": "The code is using OpenCV and TensorFlow to detect and remove a watermark from an input image. It resizes the input image, normalizes pixel values, preprocesses the image with a DNN (Deep Neural Network), and then sets the input for the network's feature extraction layer.",
        "type": "comment"
    },
    "4852": {
        "file_id": 632,
        "content": "# \t\"feature_fusion/concat_3\"]\n# (scores, geometry) = net.forward(layerNames)\n# def decode_predictions(scores, geometry,min_confidence=0.5):\n# \t# grab the number of rows and columns from the scores volume, then\n# \t# initialize our set of bounding box rectangles and corresponding\n# \t# confidence scores\n# \t(numRows, numCols) = scores.shape[2:4]\n# \trects = []\n# \tconfidences = []\n# \t# loop over the number of rows\n# \tfor y in range(0, numRows):\n# \t\t# extract the scores (probabilities), followed by the\n# \t\t# geometrical data used to derive potential bounding box\n# \t\t# coordinates that surround text\n# \t\tscoresData = scores[0, 0, y]\n# \t\txData0 = geometry[0, 0, y]\n# \t\txData1 = geometry[0, 1, y]\n# \t\txData2 = geometry[0, 2, y]\n# \t\txData3 = geometry[0, 3, y]\n# \t\tanglesData = geometry[0, 4, y]\n# \t\t# loop over the number of columns\n# \t\tfor x in range(0, numCols):\n# \t\t\t# if our score does not have sufficient probability,\n# \t\t\t# ignore it\n# \t\t\tif scoresData[x] < min_confidence:\n# \t\t\t\tcontinue\n# \t\t\t# compute the offset factor as our resulting feature",
        "type": "code",
        "location": "/tests/still_watermark_auto_removal/automatic-watermark-detection/video_watermark_detection.py:92-119"
    },
    "4853": {
        "file_id": 632,
        "content": "The code is decoding the predictions of a deep learning model for watermark detection. It iterates through the scores and geometrical data to extract bounding box coordinates and angles, discarding low-confidence predictions.",
        "type": "comment"
    },
    "4854": {
        "file_id": 632,
        "content": "# \t\t\t# maps will be 4x smaller than the input image\n# \t\t\t(offsetX, offsetY) = (x * 4.0, y * 4.0)\n# \t\t\t# extract the rotation angle for the prediction and\n# \t\t\t# then compute the sin and cosine\n# \t\t\tangle = anglesData[x]\n# \t\t\tcos = np.cos(angle)\n# \t\t\tsin = np.sin(angle)\n# \t\t\t# use the geometry volume to derive the width and height\n# \t\t\t# of the bounding box\n# \t\t\th = xData0[x] + xData2[x]\n# \t\t\tw = xData1[x] + xData3[x]\n# \t\t\t# compute both the starting and ending (x, y)-coordinates\n# \t\t\t# for the text prediction bounding box\n# \t\t\tendX = int(offsetX + (cos * xData1[x]) + (sin * xData2[x]))\n# \t\t\tendY = int(offsetY - (sin * xData1[x]) + (cos * xData2[x]))\n# \t\t\tstartX = int(endX - w)\n# \t\t\tstartY = int(endY - h)\n# \t\t\t# add the bounding box coordinates and probability score\n# \t\t\t# to our respective lists\n# \t\t\trects.append((startX, startY, endX, endY))\n# \t\t\tconfidences.append(scoresData[x])\n# \t# return a tuple of the bounding boxes and associated confidences\n# \treturn (rects, confidences)\n# (rects, confidences) = decode_predictions(scores, geometry)",
        "type": "code",
        "location": "/tests/still_watermark_auto_removal/automatic-watermark-detection/video_watermark_detection.py:120-144"
    },
    "4855": {
        "file_id": 632,
        "content": "This code block extracts the rotation angle, computes sin and cosine values, derives bounding box width and height from geometry volume, calculates starting and ending coordinates of text prediction bounding boxes, appends these coordinates to rects list, and probability scores to confidences list. Finally, it returns a tuple containing the bounding boxes and associated confidences.",
        "type": "comment"
    },
    "4856": {
        "file_id": 632,
        "content": "# from imutils.object_detection import non_max_suppression\n# boxes = non_max_suppression(np.array(rects), probs=confidences)\n# rW=rH=1\n# no box painting.\n# for (startX, startY, endX, endY) in boxes:\n#     # scale the bounding box coordinates based on the respective\n#     # ratios\n#     startX = int(startX * rW)\n#     startY = int(startY * rH)\n#     endX = int(endX * rW)\n#     endY = int(endY * rH)\n#     # draw the bounding box on the frame\n#     cv2.rectangle(W_full, (startX, startY), (endX, endY), (0, 255, 0), 2)\n# # you could implement your own watermark detector network so far. it is easy.\n# # maybe directly using optical flow and gradients will be prettier?\n# W_full\nsrc = W_full\nscale_percent = 50\n# calculate the 50 percent of original dimensions\nwidth = int(src.shape[1] * scale_percent / 100)\nheight = int(src.shape[0] * scale_percent / 100)\n# dsize\ndsize = (width, height)\n# resize image\noutput = cv2.resize(src, dsize)\ngray_output = cv2.cvtColor(output, cv2.COLOR_BGR2GRAY)\ngray_output = cv2.GaussianBlur(gray_output, (11, 3), 0)",
        "type": "code",
        "location": "/tests/still_watermark_auto_removal/automatic-watermark-detection/video_watermark_detection.py:146-181"
    },
    "4857": {
        "file_id": 632,
        "content": "The code performs non-maximum suppression on rectangles, scales bounding box coordinates based on aspect ratios, draws bounding boxes on frames, and resizes the image with 50% scale while converting it to grayscale and applying Gaussian blur.",
        "type": "comment"
    },
    "4858": {
        "file_id": 632,
        "content": "thresh_output = cv2.adaptiveThreshold(\n    gray_output, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 11, 2\n)\nthresh_output = 255 - thresh_output\n# cnts, hierachy = cv2.findContours(thresh_output,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE) # really freaking bad. we should invert this.\ncnts, hierachy = cv2.findContours(\n    thresh_output, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE\n)  # really freaking bad. we should invert this.\n# cv2.RETR_EXTERNAL\n[a, b] = output.shape[:2]\nmyMask = np.zeros(shape=[a, b], dtype=np.uint8)\n# this is for video watermarks. how about pictures? do we need to cut corners? how to find the freaking watermark again?\nfor cnt in cnts:\n    x, y, w, h = cv2.boundingRect(cnt)  # Draw the bounding box image=\n    # cv2.rectangle(output, (x,y), (x+w,y+h), (0,0,255),2)\n    cv2.rectangle(myMask, (x, y), (x + w, y + h), 255, -1)\ndilated_mask = cv2.GaussianBlur(myMask, (11, 11), 0)\ncv2.threshold(dilated_mask, 256 / 2, 255, cv2.THRESH_BINARY, dilated_mask)\ncnts2, hierachy2 = cv2.findContours(",
        "type": "code",
        "location": "/tests/still_watermark_auto_removal/automatic-watermark-detection/video_watermark_detection.py:183-206"
    },
    "4859": {
        "file_id": 632,
        "content": "This code applies adaptive thresholding to detect watermarks in a video. It then identifies contours and creates a mask using bounding boxes, applies Gaussian blur, and finally finds the contours again for further processing.",
        "type": "comment"
    },
    "4860": {
        "file_id": 632,
        "content": "    dilated_mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE\n)\nmyMask2 = np.zeros(shape=[a, b], dtype=np.uint8)\n# this is for video watermarks. how about pictures? do we need to cut corners? how to find the freaking watermark again?\nheight, width = myMask2.shape[:2]\nrectangles = []\nfor cnt in cnts2:\n    x, y, w, h = cv2.boundingRect(cnt)  # Draw the bounding box image=\n    # cv2.rectangle(output, (x,y), (x+w,y+h), (0,0,255),2)\n    rectangles.append((x,y,w,h))\n    cv2.rectangle(myMask2, (x, y), (x + w, y + h), 255, -1)\nimport json\ndata = {\"canvas\":(width, height), 'rectangles':rectangles}\ndataString = json.dumps(data)\nwith open(\"test.json\", 'w+') as f: f.write(dataString)\nprint(\"TOTAL {} CONTOURS.\".format(len(cnts2)))  # paint those contours.\n# cv2.imshow(\"IMAGE\",thresh_output)\ncv2.imshow(\"MPICTURE\", myMask2)\ncv2.waitKey(0)\n# fill those areas and you will get it.\n# how do we remove this shit?\n# also how do we remove other weird things? like floating watermarks?\n# print(imageSet[0].shape)\n# breakpoint()",
        "type": "code",
        "location": "/tests/still_watermark_auto_removal/automatic-watermark-detection/video_watermark_detection.py:207-239"
    },
    "4861": {
        "file_id": 632,
        "content": "Code creates a mask for video watermarks by detecting contours and drawing bounding boxes. It saves the mask information to a JSON file. The code also displays the mask as an image. The code is not specifically designed for images; modifications are needed to handle other formats like images with floating watermarks.",
        "type": "comment"
    },
    "4862": {
        "file_id": 633,
        "content": "/tests/tencent_video_recommendation_extraction/requests_html_test.py",
        "type": "filepath"
    },
    "4863": {
        "file_id": 633,
        "content": "Imports pyppeteer and initializes an HTMLSession object, sets the URL to a QQ video page, uses session.get() to fetch the page's content, then iterates through all absolute links in the fetched HTML using r.html.absolute_links. Prints each link.",
        "type": "summary"
    },
    "4864": {
        "file_id": 633,
        "content": "from requests_html import HTMLSession # use pyppeteer.\nsession = HTMLSession()\n# url='https://www.baidu.com/'\nurl = 'http://v.qq.com/x/page/m0847y71q98.html'\nr = session.get(url)\nfor link in r.html.absolute_links:\n    print(link)",
        "type": "code",
        "location": "/tests/tencent_video_recommendation_extraction/requests_html_test.py:1-8"
    },
    "4865": {
        "file_id": 633,
        "content": "Imports pyppeteer and initializes an HTMLSession object, sets the URL to a QQ video page, uses session.get() to fetch the page's content, then iterates through all absolute links in the fetched HTML using r.html.absolute_links. Prints each link.",
        "type": "comment"
    },
    "4866": {
        "file_id": 634,
        "content": "/tests/tencent_video_recommendation_extraction/playwright_with_elinks.sh",
        "type": "filepath"
    },
    "4867": {
        "file_id": 634,
        "content": "This code executes a Python script and an elinks command to extract recommended video IDs from a webpage, searching for them in specific HTML elements.",
        "type": "summary"
    },
    "4868": {
        "file_id": 634,
        "content": "python3 dump_page.py\nelinks -dump dump.html > dump.log\n# please find recommended video id in <div data-vid=\"<vid>\">\n# or in <img src=\"//puui.qpic.cn/vpic_cover/<vid>/<vid>_old_ori.jpg/s640x360?max_age=7776000\">",
        "type": "code",
        "location": "/tests/tencent_video_recommendation_extraction/playwright_with_elinks.sh:1-5"
    },
    "4869": {
        "file_id": 634,
        "content": "This code executes a Python script and an elinks command to extract recommended video IDs from a webpage, searching for them in specific HTML elements.",
        "type": "comment"
    },
    "4870": {
        "file_id": 635,
        "content": "/tests/tencent_video_recommendation_extraction/phantomjs_test.js",
        "type": "filepath"
    },
    "4871": {
        "file_id": 635,
        "content": "This code uses PhantomJS and creates a new page. It opens the specified URL, checks if the status is \"success\", then retrieves the HTML of the page using evaluate() and outputs it to the console before exiting.",
        "type": "summary"
    },
    "4872": {
        "file_id": 635,
        "content": "var page = require('webpage').create();\npage.open('http://v.qq.com/x/page/m0847y71q98.html', function(status) {\n    //console.log(\"Status: \" + status);\n    if (status === \"success\") {\n        //\tpage.render('example.png');\n        result = page.evaluate(() => document.body.innerHTML);\n        console.log(result)\n    }\n    phantom.exit();\n});",
        "type": "code",
        "location": "/tests/tencent_video_recommendation_extraction/phantomjs_test.js:1-10"
    },
    "4873": {
        "file_id": 635,
        "content": "This code uses PhantomJS and creates a new page. It opens the specified URL, checks if the status is \"success\", then retrieves the HTML of the page using evaluate() and outputs it to the console before exiting.",
        "type": "comment"
    },
    "4874": {
        "file_id": 636,
        "content": "/tests/tencent_video_recommendation_extraction/loop_all_tags.py",
        "type": "filepath"
    },
    "4875": {
        "file_id": 636,
        "content": "This code reads the \"dump.html\" file, parses it with BeautifulSoup, and then iterates over all elements to check if their attributes include 'src' or 'href'. If so, it prints the key-value pair for further examination.",
        "type": "summary"
    },
    "4876": {
        "file_id": 636,
        "content": "from bs4 import BeautifulSoup\ndata = open(\"dump.html\",'r').read()\nsoup = BeautifulSoup(data)\nfor elem in soup.find_all():\n    # print(elem.attrs)\n    # for further examination\n    attrs = elem.attrs\n    for key in ['src', 'href']:\n        if key in attrs.keys():\n            print(key, attrs[key])",
        "type": "code",
        "location": "/tests/tencent_video_recommendation_extraction/loop_all_tags.py:1-14"
    },
    "4877": {
        "file_id": 636,
        "content": "This code reads the \"dump.html\" file, parses it with BeautifulSoup, and then iterates over all elements to check if their attributes include 'src' or 'href'. If so, it prints the key-value pair for further examination.",
        "type": "comment"
    },
    "4878": {
        "file_id": 637,
        "content": "/tests/tencent_video_recommendation_extraction/dump_page.py",
        "type": "filepath"
    },
    "4879": {
        "file_id": 637,
        "content": "This code uses Playwright library to launch a headless Chromium browser, navigates to a QQ video page, waits for the DOM content loaded state, retrieves the HTML content, writes it to a \"dump.html\" file, and then closes the browser.",
        "type": "summary"
    },
    "4880": {
        "file_id": 637,
        "content": "from playwright.sync_api import sync_playwright\ndef run(playwright):\n    webkit = playwright.chromium\n    browser = webkit.launch(headless=True)\n    context = browser.new_context()\n    page = context.new_page()\n    page.goto(\"https://v.qq.com/x/page/m0847y71q98.html\")\n    page.wait_for_load_state(\"domcontentloaded\")\n    content = page.content()\n    with open(\"dump.html\", 'w+') as f: f.write(content)\n    print(\"content write to dump.html\")\n    browser.close()\nwith sync_playwright() as playwright:\n    run(playwright)",
        "type": "code",
        "location": "/tests/tencent_video_recommendation_extraction/dump_page.py:1-16"
    },
    "4881": {
        "file_id": 637,
        "content": "This code uses Playwright library to launch a headless Chromium browser, navigates to a QQ video page, waits for the DOM content loaded state, retrieves the HTML content, writes it to a \"dump.html\" file, and then closes the browser.",
        "type": "comment"
    },
    "4882": {
        "file_id": 638,
        "content": "/tests/english_chinese_mixing_spliter/test_tts.py",
        "type": "filepath"
    },
    "4883": {
        "file_id": 638,
        "content": "This code imports TTS module and generates audio from a given text, iterating through analyzed data for each language. English tool is needed as no English option available currently.",
        "type": "summary"
    },
    "4884": {
        "file_id": 638,
        "content": "from paddlebobo_paddletools_tts import TTSExecutor\nfrom english_grepper import analyze_mixed_text\nmtext = \"你这dollar有问题啊\"\n# analyze this shit.\n# you can translate all english into chinese. doesn't hurt.\ntext_analyze_result = analyze_mixed_text(mtext)\n# print(text_analyze_result)\n# breakpoint()\ntts_config = {\"zh\": {\"model_tag\": 'fastspeech2_csmsc-zh',\n                     \"voc_tag\": \"hifigan_csmsc-zh\", \"lang\": \"zh\"}, \"en\": {\"model_tag\": 'fastspeech2_ljspeech-en',\n                                                                          \"voc_tag\": \"hifigan_ljspeech-en\", \"lang\": \"en\"}}\n# tts_config = {\"zh\": {\"model_tag\": 'tacotron2_csmsc-zh',\n#                      \"voc_tag\": \"hifigan_csmsc-zh\", \"lang\": \"zh\"}, \"en\": {\"model_tag\": 'tacotron2_ljspeech-en',\n#                      \"voc_tag\": \"hifigan_ljspeech-en\", \"lang\": \"en\"}}\nfor langid in [\"en\", \"zh\"]:\n    lang_config = tts_config[langid]\n    TTS = TTSExecutor('default.yaml', **lang_config)  # PaddleSpeech语音合成模块\n    # do we need to delete the TTS?\n    for data in text_analyze_result[langid]:",
        "type": "code",
        "location": "/tests/english_chinese_mixing_spliter/test_tts.py:1-25"
    },
    "4885": {
        "file_id": 638,
        "content": "The code imports necessary modules, defines a mixed text string, analyzes the text for English and Chinese segments using 'analyze_mixed_text' function, creates a TTSExecutor object with specified configurations for English (en) and Chinese (zh), and finally, iterates through the analyzed data for each language.",
        "type": "comment"
    },
    "4886": {
        "file_id": 638,
        "content": "        index, text = data[\"index\"], data[\"text\"]\n        wavfile = TTS.run(\n            text=text, output='output_{}_{}.wav'.format(langid, index))  # 合成音频\n    del TTS\n# there is no freaking english shit.\n# we need english tool.\n# you can also translate this shit.",
        "type": "code",
        "location": "/tests/english_chinese_mixing_spliter/test_tts.py:26-32"
    },
    "4887": {
        "file_id": 638,
        "content": "This code is importing the TTS module and running it to generate audio from a given text. The output file name includes the language ID and index, indicating different languages or speakers may be involved. However, an English tool is needed as there currently seems to be no English option available in the existing codebase.",
        "type": "comment"
    },
    "4888": {
        "file_id": 639,
        "content": "/tests/english_chinese_mixing_spliter/sample_strings.txt",
        "type": "filepath"
    },
    "4889": {
        "file_id": 639,
        "content": "The code contains a mix of English and Chinese text, representing a sample of mixed-language strings for testing purposes. It includes phrases such as \"你这dollar有问题啊\" (This dollar has a problem), \"版本号2.1.0alpha\" (Version 2.1.0 alpha), and \"mixed-content warning别说我没提醒你\" (Mixed content warning, I told you not to say anything).",
        "type": "summary"
    },
    "4890": {
        "file_id": 639,
        "content": "你这dollar有问题啊\n2000万巨资！经费燃烧\n版本号2.1.0alpha，但是这个premature state让人担心\nDo not say a word.她睡觉了。mixed-content warning别说我没提醒你",
        "type": "code",
        "location": "/tests/english_chinese_mixing_spliter/sample_strings.txt:1-4"
    },
    "4891": {
        "file_id": 639,
        "content": "The code contains a mix of English and Chinese text, representing a sample of mixed-language strings for testing purposes. It includes phrases such as \"你这dollar有问题啊\" (This dollar has a problem), \"版本号2.1.0alpha\" (Version 2.1.0 alpha), and \"mixed-content warning别说我没提醒你\" (Mixed content warning, I told you not to say anything).",
        "type": "comment"
    },
    "4892": {
        "file_id": 640,
        "content": "/tests/english_chinese_mixing_spliter/paddlebobo_paddletools_tts.py",
        "type": "filepath"
    },
    "4893": {
        "file_id": 640,
        "content": "This code creates a text-to-speech synthesis model, initializes the architecture, and processes English and Chinese models. It concatenates audio files and deletes objects upon deallocation.",
        "type": "summary"
    },
    "4894": {
        "file_id": 640,
        "content": "import os\nimport numpy as np\nimport paddle\nimport soundfile as sf\nimport yaml\nfrom yacs.config import CfgNode\nfrom paddlespeech.cli.utils import download_and_decompress\nfrom paddlespeech.cli.utils import MODEL_HOME\nfrom paddlespeech.t2s.frontend import English\nfrom paddlespeech.s2t.utils.dynamic_import import dynamic_import\nfrom paddlespeech.t2s.frontend.zh_frontend import Frontend\nfrom paddlespeech.t2s.modules.normalizer import ZScore\nfrom paddlespeech.cli.tts.infer import model_alias, pretrained_models\nmodel_alias2 = {\n    # acoustic model\n    \"fastspeech2\": \"paddlespeech.t2s.models.fastspeech2:FastSpeech2\",\n    \"fastspeech2_inference\": \"paddlespeech.t2s.models.fastspeech2:StyleFastSpeech2Inference\",\n    # voc\n    \"pwgan\":\n    \"paddlespeech.t2s.models.parallel_wavegan:PWGGenerator\",\n    \"pwgan_inference\":\n    \"paddlespeech.t2s.models.parallel_wavegan:PWGInference\",\n}\nmodel_alias.update(model_alias2)\n# pretrained_models = {\n#     # fastspeech2\n#     \"fastspeech2_csmsc-zh\": {\n#         'url':\n#         'https://p",
        "type": "code",
        "location": "/tests/english_chinese_mixing_spliter/paddlebobo_paddletools_tts.py:1-35"
    },
    "4895": {
        "file_id": 640,
        "content": "The code is importing necessary libraries and modules, defining model aliases for acoustic models (fastspeech2) and vocoders (pwgan), and potentially updating pretrained_models dictionary.",
        "type": "comment"
    },
    "4896": {
        "file_id": 640,
        "content": "addlespeech.bj.bcebos.com/Parakeet/released_models/fastspeech2/fastspeech2_nosil_baker_ckpt_0.4.zip',\n#         'md5':\n#         '637d28a5e53aa60275612ba4393d5f22',\n#         'config':\n#         'default.yaml',\n#         'ckpt':\n#         'snapshot_iter_76000.pdz',\n#         'speech_stats':\n#         'speech_stats.npy',\n#         'phones_dict':\n#         'phone_id_map.txt',\n#         'pitch_stats':\n#         'pitch_stats.npy',\n#         'energy_stats':\n#         'energy_stats.npy',\n#     },\n#     # pwgan\n#     \"pwgan_csmsc-zh\": {\n#         'url':\n#         'https://paddlespeech.bj.bcebos.com/Parakeet/released_models/pwgan/pwg_baker_ckpt_0.4.zip',\n#         'md5':\n#         '2e481633325b5bdf0a3823c714d2c117',\n#         'config':\n#         'pwg_default.yaml',\n#         'ckpt':\n#         'pwg_snapshot_iter_400000.pdz',\n#         'speech_stats':\n#         'pwg_stats.npy',\n#     },\n# }\nfor k in [\"fastspeech2_csmsc-zh\",\"fastspeech2_ljspeech-en\"]:\n    model_config = {'pitch_stats':\n        'pitch_stats.npy',\n        'energy_stats':",
        "type": "code",
        "location": "/tests/english_chinese_mixing_spliter/paddlebobo_paddletools_tts.py:35-69"
    },
    "4897": {
        "file_id": 640,
        "content": "This code is a dictionary containing two models: \"fastspeech2_csmsc-zh\" and \"fastspeech2_ljspeech-en\". Each model has its URL, MD5, config file, checkpoint file, and optional statistics files. These models seem to be used for speech synthesis, as they require pitch and energy stats.",
        "type": "comment"
    },
    "4898": {
        "file_id": 640,
        "content": "        'energy_stats.npy',}\n    pretrained_models[k].update(model_config)\nclass TTSExecutor():\n    def __init__(self, config,model_tag = 'fastspeech2_csmsc-zh', voc_tag = \"pwgan_csmsc-zh\",lang=\"zh\"):\n        langId1 = model_tag.split(\"-\")[-1]\n        langId2 = voc_tag.split(\"-\")[-1]\n        assert langId1 == langId2\n        assert langId2 == lang\n        assert lang in [\"zh\",\"en\"]\n        self.lang = lang\n        # match the freaking dataset!\n        #FastSpeech2 or something else. we need freaking english!\n        am_res_path = self._get_pretrained_path(model_tag)\n        am_config = os.path.join(am_res_path,pretrained_models[model_tag]['config'])\n        am_ckpt = os.path.join(am_res_path,pretrained_models[model_tag]['ckpt'])\n        am_stat = os.path.join(am_res_path, pretrained_models[model_tag]['speech_stats'])\n        # must have phones_dict in acoustic\n        phones_dict = os.path.join(am_res_path, pretrained_models[model_tag]['phones_dict'])\n        # StyleFastSpeech\n        pitch_stats = os.path.join(am_res_path, pretrained_models[model_tag]['pitch_stats'])",
        "type": "code",
        "location": "/tests/english_chinese_mixing_spliter/paddlebobo_paddletools_tts.py:70-91"
    },
    "4899": {
        "file_id": 640,
        "content": "The code is initializing a TTSExecutor object with config and model_tag parameters. It checks if the model_tag matches the language specified, and then retrieves the necessary paths for the acoustic model, phones dictionary, and pitch statistics using the pretrained_models dictionary.",
        "type": "comment"
    }
}