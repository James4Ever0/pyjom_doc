{
    "800": {
        "file_id": 67,
        "content": "/pyjom/modules/globalOptimizer/dummyOptimizer.py",
        "type": "filepath"
    },
    "801": {
        "file_id": 67,
        "content": "The code defines two decorators, `dummyOptimizer` and `dummyReviewOptimizer`, which take in a topic, feedback or review as parameters. They are intended for some optimization process but seem to be not optimized themselves. The inner function within `dummyOptimizer` prints the current topic and feedback, returning \"pending\". `dummyReviewOptimizer` returns \"processed and labeled content.\". It's unclear how these functions are meant to be used or their actual functionality.",
        "type": "summary"
    },
    "802": {
        "file_id": 67,
        "content": "from pyjom.commons import *\nfrom lazero.program.functools import (\n    iterateWithTempDirectory,\n)  # you can also switch to 'AUTO'\n@decorator  # called 'iterateWithTempDirectory'\ndef dummyOptimizer(topic, feedback):  # wtf is this?\n    # not optimized. need schedule.\n    @iterateWithTempDirectory()\n    def inner(elem):\n        print(\"current topic: %s\" % str(topic))\n        print(\"from feedback:\", elem)\n        return \"pending\"\n    return inner(feedback)\n@decorator\ndef dummyReviewOptimizer(topic, feedback, review):\n    return \"processed and labeled content.\"",
        "type": "code",
        "location": "/pyjom/modules/globalOptimizer/dummyOptimizer.py:1-21"
    },
    "803": {
        "file_id": 67,
        "content": "The code defines two decorators, `dummyOptimizer` and `dummyReviewOptimizer`, which take in a topic, feedback or review as parameters. They are intended for some optimization process but seem to be not optimized themselves. The inner function within `dummyOptimizer` prints the current topic and feedback, returning \"pending\". `dummyReviewOptimizer` returns \"processed and labeled content.\". It's unclear how these functions are meant to be used or their actual functionality.",
        "type": "comment"
    },
    "804": {
        "file_id": 68,
        "content": "/pyjom/modules/globalOptimizer/__init__.py",
        "type": "filepath"
    },
    "805": {
        "file_id": 68,
        "content": "The code imports all functions and classes from the \"dummyOptimizer\" module in the \"pyjom.modules.globalOptimizer\" package.",
        "type": "summary"
    },
    "806": {
        "file_id": 68,
        "content": "from pyjom.modules.globalOptimizer.dummyOptimizer import *",
        "type": "code",
        "location": "/pyjom/modules/globalOptimizer/__init__.py:1-1"
    },
    "807": {
        "file_id": 68,
        "content": "The code imports all functions and classes from the \"dummyOptimizer\" module in the \"pyjom.modules.globalOptimizer\" package.",
        "type": "comment"
    },
    "808": {
        "file_id": 69,
        "content": "/pyjom/modules/topicGenerator/weiboTopicGenerator.py",
        "type": "filepath"
    },
    "809": {
        "file_id": 69,
        "content": "This code imports necessary modules and defines a topic generator function for pets. It returns a fixed topic in both Chinese and English languages, demonstrating simple multilingual support.",
        "type": "summary"
    },
    "810": {
        "file_id": 69,
        "content": "from pyjom.commons import *\n@decorator\ndef petsTopicGenerator():\n    # this is just some primitive topic, always return the same thing.\n    # topics cannot be multilingual.\n    return {\"entities\": [{\"chinese\": \"搞笑 宠物\", \"english\": \"funny pets\"}]}",
        "type": "code",
        "location": "/pyjom/modules/topicGenerator/weiboTopicGenerator.py:1-8"
    },
    "811": {
        "file_id": 69,
        "content": "This code imports necessary modules and defines a topic generator function for pets. It returns a fixed topic in both Chinese and English languages, demonstrating simple multilingual support.",
        "type": "comment"
    },
    "812": {
        "file_id": 70,
        "content": "/pyjom/modules/topicGenerator/onlineTopicGenerator.py",
        "type": "filepath"
    },
    "813": {
        "file_id": 70,
        "content": "The code imports functions for keyword removal and topic modeling in English/Chinese, selects words by shuffling topics, fetches random keywords to request gifs/videos from a local server, and retrieves a random picture with related words using keyword and topic modeling.",
        "type": "summary"
    },
    "814": {
        "file_id": 70,
        "content": "from pyjom.commons import *\nfrom pyjom.languagetoolbox import englishTopicModeling, chineseTopicModeling\nfrom lazero.utils.tools import flattenUnhashableList  # one of my classic methods\nimport requests\n# import jieba\nfrom typing import Literal\ndef removeKeywordDuplicates(keywords):\n    keywordsType = type(keywords)\n    inputFuncs = {\n        str: lambda x: x.split(\" \"),\n        list: lambda x: x,\n        tuple: lambda x: list(x),\n    }\n    outputFuncs = {\n        str: lambda x: \" \".join(x),\n        list: lambda x: x,\n        tuple: lambda x: tuple(x),\n    }\n    if keywordsType in inputFuncs.keys():\n        keywordsList = inputFuncs[keywordsType](keywords)\n    else:\n        raise Exception(\"Unknown keywords type: %s\" % type(keywords))\n    keywordsSet = set(keywordsList)\n    keywordsSetList = list(keywordsSet)\n    return outputFuncs[keywordsType](keywordsSetList)\ndef topicModeling(sentences: list[str], lang=\"en\"):  # specify language please?\n    # python does not enforce type checking. use third party tool such as linter instead.",
        "type": "code",
        "location": "/pyjom/modules/topicGenerator/onlineTopicGenerator.py:1-33"
    },
    "815": {
        "file_id": 70,
        "content": "This code imports necessary modules and defines two functions: `removeKeywordDuplicates` for removing duplicate keywords in a list or string, and `topicModeling` for topic modeling with specified language (English or Chinese). It also includes an exception handling for unknown keyword types.",
        "type": "comment"
    },
    "816": {
        "file_id": 70,
        "content": "    if lang == \"en\":\n        topics = englishTopicModeling(sentences)\n        return topics\n    elif lang == \"zh\":\n        topics = chineseTopicModeling(sentences)\n        return topics\n    else:\n        raise Exception(\"Unknown language: %s\" % lang)\ndef topicWordSelection(\n    topics,\n    core_topic_set: set,\n    selected_topic_list: list,\n    mode: Literal[\"combined\", \"separate\"] = \"combined\",\n    threshold=10,\n):\n    if len(selected_topic_list) > threshold:\n        for _ in range(len(selected_topic_list) - threshold):\n            selected_topic_list.pop(0)  # right way to remove elem from original list.\n    selected_topic_set = set(list(core_topic_set) + selected_topic_list)\n    import random\n    mTopics = topics.copy()\n    random.shuffle(mTopics)\n    for topic in mTopics:\n        words = topic[mode]\n        words = [x for x in words if x not in selected_topic_set]\n        if len(words) > 0:\n            word = random.choice(words)\n            selected_topic_list.append(word)  # no need to go elsewhere.\n            return word",
        "type": "code",
        "location": "/pyjom/modules/topicGenerator/onlineTopicGenerator.py:34-65"
    },
    "817": {
        "file_id": 70,
        "content": "The code checks the language input and applies the appropriate topic modeling function. It then performs word selection by removing words already in the list, shuffling the remaining topics, and randomly choosing a new word to append to the selected_topic_list until it reaches a specified threshold.",
        "type": "comment"
    },
    "818": {
        "file_id": 70,
        "content": "    print(\"no topic word this time\")\n    return None\ndef getMetaTopicString(metaTopic):\n    staticCandidates = [random.choice(x) for x in metaTopic.get(\"static\", [])]\n    optionalCandidates = [random.choice(x) for x in metaTopic.get(\"optional\", [])]\n    if len(optionalCandidates) > 0:\n        optionalCandidates = random.choice(optionalCandidates)\n    if type(optionalCandidates) != list:\n        optionalCandidates = [optionalCandidates]\n    dynamicCandidates = [random.choice(x) for x in metaTopic.get(\"dynamic\", [])]\n    samples = random.sample(\n        dynamicCandidates, random.randint(0, len(dynamicCandidates))\n    )\n    # print(staticCandidates)\n    # print(optionalCandidates)\n    # print(samples)\n    # breakpoint()\n    return \" \".join(staticCandidates + optionalCandidates + samples)\n@decorator\ndef OnlineTopicGenerator(\n    source=\"giphy\",\n    metaTopic={\n        \"static\": [[\"dog\", \"cat\"], [\"funny\", \"cute\"]],\n        \"dynamic\": [[\"samoyed\", \"husky\", \"teddy\", \"chiwawa\"]],\n    },  # this is not a matrix.\n    # sample_size = 10 # per search.",
        "type": "code",
        "location": "/pyjom/modules/topicGenerator/onlineTopicGenerator.py:66-95"
    },
    "819": {
        "file_id": 70,
        "content": "The code defines a function called `getMetaTopicString` which takes a metaTopic dictionary as input and returns a string of topic words. It first generates static, optional, and dynamic candidates from the provided metaTopic dictionary. Then, it selects one candidate from each category and combines them into a final string. The code also includes a print statement and a breakpoint for debugging purposes. Finally, the decorator `@decorator` is used to apply some functionality to the `OnlineTopicGenerator` function.",
        "type": "comment"
    },
    "820": {
        "file_id": 70,
        "content": "    timeout:float=20\n):\n    getKeywords = lambda: getMetaTopicString(metaTopic)\n    core_topic_set = {\n        *flattenUnhashableList([value for key, value in metaTopic.items()])\n    }  # common way to initialize a set.\n    selected_topic_list = []\n    if source == \"giphy\":\n        waitForServerUp(8902, \"nodejs giphy server\")\n        keywords = getKeywords()\n        while True:\n            import time\n            time.sleep(0.5)\n            harvestedData = []\n            try:\n                source_type = random.choice([\"videos\", \"gifs\"])\n                # source_type = 'videos' # for debugging\n                if random.random() > 0.5:\n                    with requests.get(\n                        \"http://127.0.0.1:8902/random\",\n                        params={\"q\": keywords, \"rating\": \"g\", \"type\": source_type},\n                        verify=False,\n                        proxies=None,\n                        timeout=timeout\n                    ) as mRandomPicture:  # may you get stickers?\n                        mRandomPictureJson = mRandomPicture.json()",
        "type": "code",
        "location": "/pyjom/modules/topicGenerator/onlineTopicGenerator.py:96-122"
    },
    "821": {
        "file_id": 70,
        "content": "Code fetches random keywords from a metaTopic string and sends GET requests to a local server (running on 127.0.0.1:8902) for gifs or videos related to these keywords. If the keyword-related request is successful, it stores the result in mRandomPictureJson variable. This process continues until a timeout occurs or until another condition breaks the loop. The code also has debugging support by allowing the source_type to be hardcoded as 'videos'.",
        "type": "comment"
    },
    "822": {
        "file_id": 70,
        "content": "                        harvestedData += mRandomPictureJson[\"data\"]\n                        randomPictureId = mRandomPictureJson[\"data\"][0][\"id\"]\n                else:\n                    with requests.get(\n                        \"http://127.0.0.1:8902/search\",\n                        params={\"q\": keywords, \"rating\": \"g\", \"type\": source_type},\n                        verify=False,\n                        proxies=None,\n                        timeout=timeout\n                    ) as mSearchPictures:\n                        mSearchPicturesJson = mSearchPictures.json()\n                        harvestedData += mSearchPicturesJson[\"data\"]\n                        randomPictureId = random.choice(mSearchPicturesJson[\"data\"])[\n                            \"id\"\n                        ]\n                selectedWord = None\n                with requests.get(\n                    \"http://127.0.0.1:8902/related\",\n                    params={\n                        \"q\": randomPictureId,\n                        \"type\": source_type,",
        "type": "code",
        "location": "/pyjom/modules/topicGenerator/onlineTopicGenerator.py:123-143"
    },
    "823": {
        "file_id": 70,
        "content": "This code is making a request to an API, harvesting data based on keywords and type, and selecting a random picture. It also retrieves related words for the selected picture.",
        "type": "comment"
    },
    "824": {
        "file_id": 70,
        "content": "                    },\n                    verify=False,\n                    proxies=None,  # seems not working? wtf?\n                ) as mRelatedPictures:\n                    mRelatedPicturesJson = mRelatedPictures.json()\n                    harvestedData += mRelatedPicturesJson[\"data\"]\n                    sentences = [x[\"title\"] for x in mRelatedPicturesJson[\"data\"]]\n                    topics = topicModeling(sentences)\n                    selectedWord = topicWordSelection(\n                        topics, core_topic_set, selected_topic_list\n                    )\n                if not selectedWord is None:\n                    keywords = \" \".join(\n                        [getKeywords(), selectedWord]\n                    )  # for next iteration.\n                    print(\"REFRESHING KEYWORDS:\", keywords)\n                else:\n                    keywords = getKeywords()\n                # recheck keywords!\n                keywords = removeKeywordDuplicates(keywords)\n            except:\n                import traceback",
        "type": "code",
        "location": "/pyjom/modules/topicGenerator/onlineTopicGenerator.py:144-165"
    },
    "825": {
        "file_id": 70,
        "content": "This code segment fetches related pictures from a URL, performs topic modeling on the titles of these images, selects a word from the core topic set for further keyword generation, and handles potential exceptions.",
        "type": "comment"
    },
    "826": {
        "file_id": 70,
        "content": "                traceback.print_exc()\n                print(\"ERROR WHEN FETCHING GIPHY TOPIC\")\n            for elem in harvestedData:\n                yield elem[\"id\"], json_auto_float_int(elem[\"media\"])",
        "type": "code",
        "location": "/pyjom/modules/topicGenerator/onlineTopicGenerator.py:167-170"
    },
    "827": {
        "file_id": 70,
        "content": "This code block catches exceptions that may occur while fetching GIPHY topics. It prints the error trace and a descriptive message, then proceeds to iterate through the harvested data, yielding each entry's ID and media value after converting it using json_auto_float_int function.",
        "type": "comment"
    },
    "828": {
        "file_id": 71,
        "content": "/pyjom/modules/topicGenerator/localTopicGenerator.py",
        "type": "filepath"
    },
    "829": {
        "file_id": 71,
        "content": "The filesystemTopicGenerator function generates topics from file/directory paths, checking their validity and appending to a list of file names. It returns a dictionary with protocol, path, and content (filepaths).",
        "type": "summary"
    },
    "830": {
        "file_id": 71,
        "content": "from pyjom.commons import *\nimport os\n@decorator\ndef filesystemTopicGenerator(filepath=None, dirpath=None, recursive=False):\n    mfilelist = []\n    protocol = None\n    path = getHostname() + \"@\"\n    if filepath is not None:\n        assert os.path.isfile(filepath)\n        mpath = os.path.abspath(filepath)\n        protocol = \"file\"\n        path += mpath\n        mfilelist.append(mpath)\n    else:\n        assert dirpath is not None\n        assert os.path.isdir(dirpath)\n        dirpath = os.path.abspath(dirpath)\n        path += dirpath\n        if recursive:\n            protocol = \"dir_recursive\"\n            for _, _, files in os.walk(dirpath):\n                for fname in files:\n                    fpath = os.path.join(dirpath, fname)\n                    if os.path.isfile(fpath):\n                        # mpath = os.path.abspath(fpath)\n                        mfilelist.append(fpath)\n        else:\n            protocol = \"dir\"\n            mfiles = os.listdir(dirpath)\n            for fname in mfiles:\n                fpath = os.path.join(dirpath, fname)",
        "type": "code",
        "location": "/pyjom/modules/topicGenerator/localTopicGenerator.py:1-33"
    },
    "831": {
        "file_id": 71,
        "content": "The code defines a filesystemTopicGenerator function that generates topics from file or directory paths. It takes filepath and dirpath as input parameters, with optional recursive flag for directories. It checks if the given filepath exists or if the dirpath is a valid directory. If so, it appends the file/directory path to a list of file names. The protocol is set based on whether a file or directory was provided and used in generating topics.",
        "type": "comment"
    },
    "832": {
        "file_id": 71,
        "content": "                if os.path.isfile(fpath):\n                    # mpath = os.path.abspath(fpath)\n                    mfilelist.append(fpath)\n    return {\"protocol\": protocol, \"path\": path, \"content\": mfilelist}",
        "type": "code",
        "location": "/pyjom/modules/topicGenerator/localTopicGenerator.py:34-37"
    },
    "833": {
        "file_id": 71,
        "content": "Checks if a file exists at the specified path, appends absolute file paths to list, and returns a dictionary containing protocol, path, and content (filepaths).",
        "type": "comment"
    },
    "834": {
        "file_id": 72,
        "content": "/pyjom/modules/topicGenerator/dummyTopicGenerator.py",
        "type": "filepath"
    },
    "835": {
        "file_id": 72,
        "content": "The code imports the \"decorator\" function from the \"pyjom.commons\" module and defines two functions: \"dummyTopic()\" that returns the string \"pets\", and \"metaTopic(selected_source)\" which returns a list of titles based on the selected source. These functions are likely used for generating topic ideas or names.",
        "type": "summary"
    },
    "836": {
        "file_id": 72,
        "content": "from pyjom.commons import *\n@decorator\ndef dummyTopic():\n    return \"pets\"\n@decorator\ndef metaTopic(selected_source):\n    sources = {\n        \"baidu_baijiahao\": [\"shitty title1\"],\n        \"bilibili_trending\": [\"boy with women's clothes\"],\n    }\n    return sources[selected_source]",
        "type": "code",
        "location": "/pyjom/modules/topicGenerator/dummyTopicGenerator.py:1-15"
    },
    "837": {
        "file_id": 72,
        "content": "The code imports the \"decorator\" function from the \"pyjom.commons\" module and defines two functions: \"dummyTopic()\" that returns the string \"pets\", and \"metaTopic(selected_source)\" which returns a list of titles based on the selected source. These functions are likely used for generating topic ideas or names.",
        "type": "comment"
    },
    "838": {
        "file_id": 73,
        "content": "/pyjom/modules/topicGenerator/__init__.py",
        "type": "filepath"
    },
    "839": {
        "file_id": 73,
        "content": "This code imports modules from various topic generators (dummy, weibo, local, online) within the pyjom project. It appears to be related to generating topics or data for a specific purpose.",
        "type": "summary"
    },
    "840": {
        "file_id": 73,
        "content": "from pyjom.modules.topicGenerator.dummyTopicGenerator import *\nfrom pyjom.modules.topicGenerator.weiboTopicGenerator import *\nfrom pyjom.modules.topicGenerator.localTopicGenerator import *\nfrom pyjom.modules.topicGenerator.onlineTopicGenerator import *",
        "type": "code",
        "location": "/pyjom/modules/topicGenerator/__init__.py:1-4"
    },
    "841": {
        "file_id": 73,
        "content": "This code imports modules from various topic generators (dummy, weibo, local, online) within the pyjom project. It appears to be related to generating topics or data for a specific purpose.",
        "type": "comment"
    },
    "842": {
        "file_id": 74,
        "content": "/pyjom/modules/contentPosting/onlinePoster.py",
        "type": "filepath"
    },
    "843": {
        "file_id": 74,
        "content": "This code defines a decorator-like function named OnlinePoster that takes in various parameters such as content, platform, postMetadataGenerator, and afterPosting. It returns an instance of BilibiliPoster for the specified platform (default is bilibili) to handle content posting. The function also utilizes a lambda expression to generate post metadata by iterating through the provided postMetadataGenerator.",
        "type": "summary"
    },
    "844": {
        "file_id": 74,
        "content": "from types import FunctionType\nfrom typing import Generator\nfrom pyjom.modules.contentPosting.bilibiliPoster import BilibiliPoster\n# there is no decorator!\ndef OnlinePoster(\n    content,\n    iterate=False,\n    contentType=\"video\",\n    postMetadataGenerator: Generator = ...,\n    platform=\"bilibili\",\n    afterPosting:FunctionType=...\n):\n    posters = {\"bilibili\": BilibiliPoster}\n    assert platform in posters.keys()\n    getPostMetadata = lambda: postMetadataGenerator.__next__() # how you produce this \"next\" properly? or double?\n    return posters[platform](\n        content,\n        iterate=iterate,\n        contentType=contentType,\n        getPostMetadata=getPostMetadata,\n        afterPosting=afterPosting,\n    )",
        "type": "code",
        "location": "/pyjom/modules/contentPosting/onlinePoster.py:1-23"
    },
    "845": {
        "file_id": 74,
        "content": "This code defines a decorator-like function named OnlinePoster that takes in various parameters such as content, platform, postMetadataGenerator, and afterPosting. It returns an instance of BilibiliPoster for the specified platform (default is bilibili) to handle content posting. The function also utilizes a lambda expression to generate post metadata by iterating through the provided postMetadataGenerator.",
        "type": "comment"
    },
    "846": {
        "file_id": 75,
        "content": "/pyjom/modules/contentPosting/dummyPoster.py",
        "type": "filepath"
    },
    "847": {
        "file_id": 75,
        "content": "Function \"dummyPoster\" takes content as input, iterates over it if specified, and returns a protocol link.",
        "type": "summary"
    },
    "848": {
        "file_id": 75,
        "content": "from pyjom.commons import *\n@decorator\ndef dummyPoster(content, iterate=False):\n    if iterate:\n        for elem in content:\n            print(\"READY TO POST CONTENT FROM:\",elem)\n    return \"mydarnprotocol://mydarnlink\"",
        "type": "code",
        "location": "/pyjom/modules/contentPosting/dummyPoster.py:1-8"
    },
    "849": {
        "file_id": 75,
        "content": "Function \"dummyPoster\" takes content as input, iterates over it if specified, and returns a protocol link.",
        "type": "comment"
    },
    "850": {
        "file_id": 76,
        "content": "/pyjom/modules/contentPosting/bilibiliPoster.py",
        "type": "filepath"
    },
    "851": {
        "file_id": 76,
        "content": "This code defines functions for sending POST requests to Bilibili, handling metadata and exceptions in content posting operations. It also generates a Bilibili URL for input content with optional iterative processing.",
        "type": "summary"
    },
    "852": {
        "file_id": 76,
        "content": "from types import FunctionType\nfrom pyjom.commons import *\nfrom pyjom.platforms.bilibili.uploader import uploadVideo\nfrom lazero.filesystem.temp import (\n    tmpdir,\n    getRandomFileNameUnderDirectoryWithExtension,\n    tmpfile,\n)\n# that generator you must put beforehand.\nimport cv2\nimport requests\ndef registerBilibiliUserVideo(\n    bvid: str,\n    dedeuserid: str,\n    is_mine: bool = True,\n    visible: bool = False,\n    server_domain: str = \"localhost\",\n    server_endpoint: str = \"registerUserVideo\",\n    server_port: int = 7341,\n    success_codes: list[int] = [200, 201],\n):\n    data = {\n        \"bvid\": bvid,\n        \"dedeuserid\": dedeuserid,\n        \"is_mine\": is_mine,\n        \"visible\": visible,\n    }\n    r = requests.post(\n        \"http://{}:{}/{}\".format(server_domain, server_port, server_endpoint), json=data\n    )\n    register_success = r.status_code in success_codes\n    return register_success\n# why you have decorator? so OnlinePoster will not have decorator.\n@decorator\ndef BilibiliPoster(\n    content,\n    iterate=False,",
        "type": "code",
        "location": "/pyjom/modules/contentPosting/bilibiliPoster.py:1-44"
    },
    "853": {
        "file_id": 76,
        "content": "This code defines a function `registerBilibiliUserVideo` which sends a POST request to a server, passing Bilibili video details and returns the success status based on received response. The `BilibiliPoster` decorator is applied to another function `content`, likely for handling content posting operations in the context of Bilibili platform. It seems to involve file manipulation using `cv2` and `requests` library, as well as external dependencies from `pyjom` and `lazero`. The code also uses a generator, but its purpose is not clear from the provided snippet.",
        "type": "comment"
    },
    "854": {
        "file_id": 76,
        "content": "    getPostMetadata=...,  # some lambda calling generator.__next__()\n    contentType=\"video\",\n    dedeuserid: str = \"397424026\",\n    tempdir=\"/dev/shm/medialang/bilibiliPoster\",\n    afterPosting: FunctionType = ...,\n):\n    # are you sure this 'postMetadataGenerator' will generate valid data for us?\n    # anyway let's write for video.\n    # there are two generators. what do you want?\n    # getPostMetadata = lambda: postMetadataGenerator.__next__()\n    from retry import retry\n    @retry(tries=3, delay=5)  # if causing trouble\n    def postContent(elem):  # what is this elem? please check for video producer.\n        with tmpdir(path=tempdir):\n            postMetadata = getPostMetadata()\n            print(\n                \"READY TO POST CONTENT FROM:\", elem\n            )  # this elem is video location for me.\n            if contentType == \"video\":  # single video upload without grouping.\n                videoPath = elem\n                cover_path = getRandomFileNameUnderDirectoryWithExtension(\n                    \"png\", tempdir",
        "type": "code",
        "location": "/pyjom/modules/contentPosting/bilibiliPoster.py:45-67"
    },
    "855": {
        "file_id": 76,
        "content": "This code is defining a function `postContent` that takes an element (elem) as input. The function uses a retry decorator to attempt the post operation three times with a 5-second delay between retries. It also defines the content type as video and a temporary directory for storage. The `getPostMetadata` seems to be used to retrieve metadata for posting, but its validity is questioned. The elem is likely a video location for uploading.",
        "type": "comment"
    },
    "856": {
        "file_id": 76,
        "content": "                )\n                (\n                    cover_target,\n                    mTagSeries,  # are you sure this is a list of tags?\n                    mTitle,\n                    mBgm,  # what is the bgm here used for?\n                    mDescription,\n                    dog_or_cat_original,  # what again is this dog/cat label?\n                    search_tid,\n                ) = postMetadata  # assumptions on video type.\n                # you can fetch this from database. you can pickle this thing.\n                tagString = \",\".join(mTagSeries)\n                # will have exceptions when having name clash. handle it!\n                with tmpfile(cover_path):\n                    cv2.imwrite(cover_path, cover_target)\n                    # you need to save this 'cover_target' to file.\n                    contentId = uploadVideo(\n                        dedeuserid=dedeuserid,  # by decorator.\n                        description=mDescription,\n                        dynamic=mDescription,\n                        tagString=tagString,",
        "type": "code",
        "location": "/pyjom/modules/contentPosting/bilibiliPoster.py:68-88"
    },
    "857": {
        "file_id": 76,
        "content": "The code is responsible for extracting metadata from a tuple called `postMetadata` and storing it into relevant variables. It then joins the tags in the `mTagSeries` list with commas and writes the cover image to a file using OpenCV's imwrite function. Finally, it calls the `uploadVideo` function to upload the video content. The code assumes the video type and has potential exceptions if there is a name clash while joining tags into a string.",
        "type": "comment"
    },
    "858": {
        "file_id": 76,
        "content": "                        tagId=search_tid,\n                        cover_path=cover_path,\n                        videoPath=videoPath,\n                        title=mTitle,\n                    )  # choose to upload and get bvid.\n            else:\n                raise Exception(\n                    \"unknown content type to upload for bilibiliPoster:\", contentType\n                )\n            afterPosting()  # execute no matter what. after posting the content.\n            # now register the uploaded video.\n            if contentType == \"video\":\n                video_bvid = (\n                        contentId\n                        if type(contentId) == str\n                        else contentId.get(\"bvid\", contentId.get(\"BVID\"))\n                    )\n                register_success = registerBilibiliUserVideo(\n                    video_bvid,\n                    str(dedeuserid),\n                )\n                print(\"VIDEO REGISTRATION STATUS?\", register_success)\n                if not register_success:\n                    print(\"VIDEO REGISTRATION ERROR\")",
        "type": "code",
        "location": "/pyjom/modules/contentPosting/bilibiliPoster.py:89-112"
    },
    "859": {
        "file_id": 76,
        "content": "Code chooses to upload and gets bvid based on the content type. If the content type is unknown, it raises an exception. It executes afterPosting() regardless of success or failure. For video content, it registers the uploaded video using registerBilibiliUserVideo and prints the registration status.",
        "type": "comment"
    },
    "860": {
        "file_id": 76,
        "content": "                    breakpoint()\n            if type(contentId) == str:\n                video_identifier = \"bvid_{}\".format(contentId)\n            else:\n                video_identifier = \"aid_{}_bvid_{}\".format(\n                    contentId.get(\"aid\"), contentId.get(\"bvid\")\n                )\n            return \"bilibili://{}/{}/{}\".format(\n                dedeuserid, contentType, video_identifier\n            )  # this content id is fucked.\n    def postContentIterate(content):\n        for elem in content:\n            yield postContent(elem)\n    if iterate:\n        return postContentIterate(content)\n    else:\n        return postContent(content)\n    # content id?",
        "type": "code",
        "location": "/pyjom/modules/contentPosting/bilibiliPoster.py:113-132"
    },
    "861": {
        "file_id": 76,
        "content": "This code is a function to generate a Bilibili-specific URL for content, handling different content ID formats. It also includes an optional iterative processing option for the input content list.",
        "type": "comment"
    },
    "862": {
        "file_id": 77,
        "content": "/pyjom/modules/contentPosting/__init__.py",
        "type": "filepath"
    },
    "863": {
        "file_id": 77,
        "content": "Importing necessary modules for dummy and online posters to prevent circular import issues.",
        "type": "summary"
    },
    "864": {
        "file_id": 77,
        "content": "from pyjom.modules.contentPosting.dummyPoster import *\nfrom pyjom.modules.contentPosting.onlinePoster import * # prevent circular import",
        "type": "code",
        "location": "/pyjom/modules/contentPosting/__init__.py:1-2"
    },
    "865": {
        "file_id": 77,
        "content": "Importing necessary modules for dummy and online posters to prevent circular import issues.",
        "type": "comment"
    },
    "866": {
        "file_id": 78,
        "content": "/pyjom/modules/contentCensoring/__init__.py",
        "type": "filepath"
    },
    "867": {
        "file_id": 78,
        "content": "This code imports two parts, label and filter, from the contentCensoring module's core and autoCensor submodules in the pyjom library.",
        "type": "summary"
    },
    "868": {
        "file_id": 78,
        "content": "# two parts: label and filter\nfrom pyjom.modules.contentCensoring.core import *\nfrom pyjom.modules.contentCensoring.autoCensor import *",
        "type": "code",
        "location": "/pyjom/modules/contentCensoring/__init__.py:1-3"
    },
    "869": {
        "file_id": 78,
        "content": "This code imports two parts, label and filter, from the contentCensoring module's core and autoCensor submodules in the pyjom library.",
        "type": "comment"
    },
    "870": {
        "file_id": 79,
        "content": "/pyjom/modules/contentCensoring/core.py",
        "type": "filepath"
    },
    "871": {
        "file_id": 79,
        "content": "This code creates a media downloader GUI with library integration, progress updates, customizable appearance, and tabular post topics. It uses decorator function `keywordDecorator` to censor media based on input parameters and handles unknown content types with exceptions.",
        "type": "summary"
    },
    "872": {
        "file_id": 79,
        "content": "from tkinter import *\nfrom pyjom.commons import *\nfrom pyjom.modules.contentCensoring.autoCensor import *\n# import tkinter.font\nimport requests\nimport traceback\nimport os\nimport command_spawner\nfrom progressbar import *\n# add progressbar\ndef mediaDownloader(url, mblogid, basedir=None, index=None):\n    try:\n        with requests.get(url) as r: # what is the media file suffix?\n            suffix = url.split(\"?\")[0].split(\".\")[-1]\n            mid = mblogid if index is None else \"{}[{}]\".format(mblogid, index)\n            fname = \"{}.{}\".format(mid, suffix)\n            if not os.path.exists(basedir):\n                os.mkdir(basedir)\n            fpath = os.path.join(basedir, fname)\n            size = int(r.headers[\"Content-Length\"].strip())\n            mbytes = 0\n            widgets = [\n                fpath,\n                \": \",\n                Bar(marker=\"|\", left=\"[\", right=\" \"),\n                Percentage(),\n                \" \",\n                FileTransferSpeed(),\n                \"] \",\n                \" of {0}MB\".format(str(round(size / 1024 / 1024, 2))[:4]),",
        "type": "code",
        "location": "/pyjom/modules/contentCensoring/core.py:1-32"
    },
    "873": {
        "file_id": 79,
        "content": "This code snippet is for a media downloader function that uses the requests library to download a file from a given URL. It also includes functionality for handling progress updates using the progressbar module, and it creates a folder to store the downloaded files if one does not already exist. The function takes in parameters such as the URL of the file to be downloaded, an optional mblog ID (and index) for creating a unique file name based on this ID, and an optional base directory where the files will be stored. If no base directory is provided, it will create one automatically with the specified name. The function determines the file's suffix by parsing the URL and extracting the last part of the string after any query parameters. Once the download starts, it tracks progress using a widget that displays a bar indicating the percentage completed, along with other information like the current file transfer speed. It also calculates and displays the size of the file in MB as it downloads.",
        "type": "comment"
    },
    "874": {
        "file_id": 79,
        "content": "            ]\n            pbar = ProgressBar(widgets=widgets, maxval=size).start()\n            mfile = []\n            for buf in r.iter_content(1024):\n                if buf:\n                    mfile.append(buf)\n                    mbytes += len(buf)\n                    pbar.update(mbytes)\n            pbar.finish()\n            print(\"saved to {}\".format(fpath))\n            with open(fpath, \"wb\") as f:\n                for byteContent in mfile:\n                    f.write(byteContent)\n            return fpath\n    except:\n        traceback.print_exc()\n        print(\"error in mediaDownloader:\\n\", url)\n    return None\nx_buffer = None\ntag_x_offset =None\ntag_y_counter =None\ndef censorInterface(\n    mtitle, mtopic, mcontent,mtags=[], local=False\n):  # this could be a standard template.\n    global x_buffer,tag_x_offset,tag_y_counter\n    assert type(mtopic) == list\n    assert type(mtags) == list\n    is_on = {key:False for key in mtags}\n    def switch(key, buttons, index, is_on):\n        button = buttons[index]\n        if is_on[key]:",
        "type": "code",
        "location": "/pyjom/modules/contentCensoring/core.py:33-65"
    },
    "875": {
        "file_id": 79,
        "content": "The code downloads media content from a URL and saves it to the specified file path. It also includes error handling using try-except block and traceback. The function censorInterface seems to be an interface for switching between tags, where the user can toggle the visibility of different tags on or off.",
        "type": "comment"
    },
    "876": {
        "file_id": 79,
        "content": "            button.config(text=key ,bg = \"grey\",fg=\"black\")\n            is_on[key] = False\n        else:\n            button.config(text = key,bg = \"green\",fg=\"white\")\n            is_on[key] = True\n    def getSwitchLambda(text, on_buttons, index, is_on):\n        return lambda:switch(text, on_buttons, index, is_on)\n    on_buttons = []\n    mfunctions = []\n    mdata = {\"labels\": [], \"comment\": None, \"discard\": False}\n    left, top = 1500, 500\n    parent = Tk()\n    parent.geometry(\"+{}+{}\".format(left, top))\n    # parent\n    default_window_size =(460,400)\n    parent.geometry(\"{0}x{1}\".format(*default_window_size))\n    themepath = joinScriptFileBaseDir(__file__, \"Forest-ttk-theme/forest-dark.tcl\")\n    parent.tk.call(\"source\", themepath)\n    parent.attributes(\"-topmost\", True)\n    if not local:\n        title = Label(\n            parent,\n            text=\"Title:\" + \"\\n\" * 4,\n            fg=\"white\",\n        )\n        title.grid(row=0, column=0, sticky=\"e\")\n        text0 = Text(fg=\"aqua\", height=5, width=24)\n        text0.grid(row=0, column=1)",
        "type": "code",
        "location": "/pyjom/modules/contentCensoring/core.py:66-98"
    },
    "877": {
        "file_id": 79,
        "content": "This code sets up a window with buttons, configures their appearance and state based on the given 'is_on' variable, and provides functions for handling button clicks. It also handles window geometry and theme customization.",
        "type": "comment"
    },
    "878": {
        "file_id": 79,
        "content": "        text0.insert(END, mtitle)\n        # print(mtopic)\n        mlabel = (  # not designed for sina topic format.\n            \"None\" if mtopic == None else \" \".join([\"[{}]\".format(x) for x in mtopic])\n        )\n        label = Label(\n            parent,\n            text=\"Topics:\" + \"\\n\" * 4,\n            fg=\"aqua\",\n        )\n        label.grid(row=1, column=0, sticky=\"e\")\n        text1 = Text(fg=\"aqua\", height=5, width=24)\n        text1.grid(row=1, column=1)\n        text1.insert(END, mlabel)\n        content = Label(\n            parent,\n            text=\"Content:\" + \"\\n\" * 4,\n            fg=\"white\",\n        )\n        content.grid(row=2, column=0, sticky=\"e\")\n        text2 = Text(fg=\"aqua\", height=5, width=24)\n        text2.grid(row=2, column=1)\n        text2.insert(END, mcontent)\n        conrow = 3\n    else:\n        conrow = 0\n    redbutton = Entry(parent, fg=\"red\")\n    redbutton.grid(row=0 + conrow, column=1, sticky=\"ew\")\n    # button_height = 32 # default height?\n    x_buffer = 10\n    tag_x_offset = 0\n    tag_y_counter = 0",
        "type": "code",
        "location": "/pyjom/modules/contentCensoring/core.py:99-134"
    },
    "879": {
        "file_id": 79,
        "content": "This code snippet creates a GUI for displaying post topics and content in a tabular format. It includes labels, text boxes, and a red button. The code handles the case where a topic is given or not, and adjusts the positioning accordingly. The variable \"conrow\" keeps track of the row position for the red button. Variables like \"x_buffer\", \"tag_x_offset\", and \"tag_y_counter\" are used for positioning elements on the screen.",
        "type": "comment"
    },
    "880": {
        "file_id": 79,
        "content": "    # print(\"TEXT:\", text)\n    def placeTagButtons(index, text,tag_x_offset, tag_y_counter, x_buffer, on=False):\n        # global\n        if not on:\n            mButton = Button(parent, text=text, bd = 0,bg=\"grey\",fg=\"black\")\n        else:\n            mButton = Button(parent, text=text, bd = 0,bg=\"green\",fg=\"white\")\n        button_width = mButton.winfo_reqwidth()\n        # 65\n        button_height = mButton.winfo_reqheight()\n        # print(button_width, button_height)\n        # breakpoint()\n        on_buttons.append(mButton)\n        mfunctions.append(getSwitchLambda(text, on_buttons, index, is_on))\n        on_buttons[index].config(command=mfunctions[index])\n        # on_buttons[index].grid_forget()\n        estimate_x_size = tag_x_offset+x_buffer+button_width\n        estimated_y_size = default_window_size[1]+ button_width*1.3*(tag_y_counter+1)\n        if estimate_x_size > default_window_size[0]:\n            tag_x_offset = 0\n            tag_y_counter+=1\n            # change window geometry\n            parent",
        "type": "code",
        "location": "/pyjom/modules/contentCensoring/core.py:135-158"
    },
    "881": {
        "file_id": 79,
        "content": "This code defines a function `placeTagButtons` which creates buttons with specified text and positions them in a window, adjusting the position based on available space. The button color depends on its 'on' parameter, and it stores the button and associated command for later use.",
        "type": "comment"
    },
    "882": {
        "file_id": 79,
        "content": ".geometry(\"{0}x{1}\".format(default_window_size[0], int(default_window_size[1]+ button_height*0.1+(tag_y_counter+1)*button_height*1.2)))\n        elif estimated_y_size > default_window_size[1]:\n            parent.geometry(\"{0}x{1}\".format(default_window_size[0], int(default_window_size[1]+ button_height*0.1+(tag_y_counter+1)*button_height*1.2)))\n        on_buttons[index].place(x=tag_x_offset+x_buffer, y=default_window_size[1]+ button_height*0.1+tag_y_counter*button_height*1.2)\n        tag_x_offset+= button_width\n        return tag_x_offset,tag_y_counter\n        # print(dir(mButton))\n    for index, text in enumerate(is_on.keys()):\n        tag_x_offset,tag_y_counter = placeTagButtons(index, text, tag_x_offset,tag_y_counter, x_buffer)\n        # 32\n        # breakpoint()\n    def add_tag():\n        global tag_x_offset, tag_y_counter, x_buffer\n        mtext = redbutton.get()\n        mtext = mtext.strip()\n        if mtext != \"\": # that is the base line\n            redbutton.delete(0, END)\n            # change this shit.",
        "type": "code",
        "location": "/pyjom/modules/contentCensoring/core.py:158-176"
    },
    "883": {
        "file_id": 79,
        "content": "The code is setting the window geometry and placing button elements on the screen based on certain conditions. It calculates the dimensions and positions of buttons to fit within the available window space, while keeping track of the x-offset and y-counter for future button placement. The code also includes a function called \"add_tag\" that takes user input and checks if it's not empty before making further actions.",
        "type": "comment"
    },
    "884": {
        "file_id": 79,
        "content": "            # mdata[\"labels\"].append(mtext)\n            if mtext not in is_on.keys():\n                is_on.update({mtext:True}) # enable this tag anyway.\n                # and we do some append task here.\n                tag_x_offset, tag_y_counter=placeTagButtons(len(on_buttons), mtext,tag_x_offset, tag_y_counter, x_buffer, on=True)\n    bluebutton = Button(parent, text=\"ADD TAG\", fg=\"aqua\", command=add_tag)\n    bluebutton.grid(row=0 + conrow, column=0, sticky=\"e\")\n    redbutton3 = Label(parent, text=\"Comment:\", fg=\"red\")\n    redbutton3.grid(row=1 + conrow, column=0, sticky=\"e\")\n    redbutton2 = Entry(parent, fg=\"red\")\n    def add_comment():\n        comment = redbutton2.get()\n        if comment != \"\":\n            mdata[\"comment\"] = comment\n    redbutton2.grid(row=1 + conrow, column=1, sticky=\"ew\")\n    def mdestroy():\n        add_tag()\n        add_comment()\n        parent.destroy()\n    def mdestroy2():\n        mdata[\"discard\"] = True\n        parent.destroy()\n    blackbutton = Button(parent, text=\"SUBMIT\", fg=\"red\", command=mdestroy)",
        "type": "code",
        "location": "/pyjom/modules/contentCensoring/core.py:177-206"
    },
    "885": {
        "file_id": 79,
        "content": "This code creates a GUI window for adding tags and comments to content. It enables any previously unused tag, places tag buttons, adds an \"ADD TAG\" button, sets up a comment input field with a \"SUBMIT\" button, and defines functions for adding tags and comments and closing the window.",
        "type": "comment"
    },
    "886": {
        "file_id": 79,
        "content": "    blackbutton.grid(row=1 + conrow, column=2, sticky=\"e\")\n    blackbutton2 = Button(parent, text=\"KILL\", fg=\"yellow\", command=mdestroy2)\n    blackbutton2.grid(row=0 + conrow, column=2, sticky=\"ew\")\n    parent.bind(\"<Return>\", lambda event=None: bluebutton.invoke())\n    parent.bind(\"<Control-Return>\", lambda event=None: mdestroy())\n    # this is for updating the order of tags.\n    parent.bind(\"<KeyRelease>\", lambda event=None: print(\"KEY RELEASED! PLEASE CONSIDER TO BIND THIS EVENT TO UPDATING TAGS ORDER BY INPUT\"))\n    # this is for updating the order of tags.\n    parent.mainloop()\n    mdata[\"labels\"] = [x for x in is_on.keys() if is_on[x]]\n    mdata[\"total_labels\"] = [x for x in is_on.keys()]\n    return mdata\ndef playMedia(mediaPath):\n    cmdline = \"ffplay -alwaysontop -loop 0 -top 0 -left 0 {}\".format(mediaPath)\n    cs = command_spawner.CommandSpawner(command=cmdline, daemon=True)\n    cs.run()\n    return cs\ndef coreMediaCensor(\n    mediaPath,\n    meta,\n    play=True,\n    auto=False,\n    semiauto=True,\n    local=False,",
        "type": "code",
        "location": "/pyjom/modules/contentCensoring/core.py:207-234"
    },
    "887": {
        "file_id": 79,
        "content": "This code includes functions for playing media, core media censoring functionality, and interacting with a GUI. It spawns a command to play media in the background, binds keyboard events, and updates labels' order when a key is released.",
        "type": "comment"
    },
    "888": {
        "file_id": 79,
        "content": "    dummy_auto=True,\n    args={},\n    template_names=[],\n):\n    assert type(local) == bool\n    mtitle, mtopic, mcontent = meta\n    censor_method = (\n        keywordDecorator(autoCensor, args=args, template_names=template_names)\n        if not dummy_auto\n        else dummyAutoCensor\n    )\n    if ((not auto) or semiauto) and play:\n        cs = playMedia(mediaPath)  # siderun.\n        if not auto:\n            mdata = censorInterface(mtitle, mtopic, mcontent, local=local)\n        else:\n            nextData = censor_method(\n                mediaPath, meta, semiauto=semiauto\n            )  # this will not approve the thing. only generate tags and metadata.\n            mdata = censorInterface(mtitle, mtopic, mcontent, local=True)\n            mdata.update(nextData)\n    else:\n        mdata = censor_method(mediaPath, meta, semiauto=semiauto)\n    if ((not auto) or semiauto) and play:\n        cs.kill()\n        os.system(\"killall ffplay\")\n    return mdata\n@decorator\ndef weiboCensor(\n    content,\n    basedir=None,\n    auto=False,\n    semiauto=True,",
        "type": "code",
        "location": "/pyjom/modules/contentCensoring/core.py:235-269"
    },
    "889": {
        "file_id": 79,
        "content": "This code uses a decorator function, `keywordDecorator`, to apply different censoring methods based on the input parameters. If `auto` is False or `semiauto` is True and `play` is True, it calls `playMedia` and applies censoring using the `censor_method`. If `auto` is True, it only generates tags and metadata without approving the content. It also kills any running ffplay instances after playback if necessary.",
        "type": "comment"
    },
    "890": {
        "file_id": 79,
        "content": "    dummy_auto=True,\n    args={},\n    template_names=[],\n):\n    groupArgs = {\n        \"template_names\": template_names,\n        \"auto\": auto,\n        \"semiauto\": semiauto,\n        \"dummy_auto\": dummy_auto,\n        \"args\": args,\n    }\n    if (not auto) or semiauto:\n        os.system(\"killall ffplay\")\n    # we only need video.\n    data = {\"type\": \"text\", \"review\": None}\n    mtitle = content[\"title\"]\n    mtopic = (\n        None if content[\"topic\"] is None else [x[0] for x in content[\"topic\"]]\n    )  # excerpt the topic name only\n    mcontent = content[\"text\"][\"raw\"]\n    meta = (mtitle, mtopic, mcontent)\n    if content[\"video\"] is not None:\n        data[\"type\"] = \"video\"\n        videoUrl = content[\"video\"][\"download_link\"]\n        mblogid = content[\"meta\"][\"mblogid\"]\n        videoPath = mediaDownloader(videoUrl, mblogid, basedir=basedir)\n        mdata = coreMediaCensor(videoPath, meta, **groupArgs)\n        data[\"review\"] = (videoPath, mdata)\n        # return mdata\n    elif content[\"picture\"] is not None and content[\"picture\"] is not []:",
        "type": "code",
        "location": "/pyjom/modules/contentCensoring/core.py:270-299"
    },
    "891": {
        "file_id": 79,
        "content": "This code is creating a dictionary called \"groupArgs\" that holds various parameters. It then checks if the \"auto\" parameter is False or if \"semiauto\" is set, in which case it kills a process named \"ffplay\". Next, it sets the data type to \"text\" and initializes variables for title, topic, and content. If there's a video available, it updates the data type to \"video\", downloads the video, and calls a function \"coreMediaCensor\" with additional parameters. Finally, if there is a picture available but no video, it continues execution.",
        "type": "comment"
    },
    "892": {
        "file_id": 79,
        "content": "        data[\"type\"] = \"picture\"\n        data[\"review\"] = []\n        for index, pictureUrl in enumerate(content[\"picture\"]):\n            picturePath = mediaDownloader(\n                pictureUrl, mblogid, basedir=basedir, index=index\n            )\n            mdata = coreMediaCensor(picturePath, meta, **groupArgs)\n            data[\"review\"].append((picturePath, mdata))\n    else:\n        # just display the raw content.\n        mdata = coreMediaCensor(\n            None, meta, play=False, **groupArgs\n        )  # how to automate this shit?\n        data[\"review\"] = mdata\n    return data\n@decorator\ndef localCensor(\n    content, auto=False, semiauto=True, dummy_auto=True, args={}, template_names=[]\n):\n    # examine local files.\n    # first determine the content type.\n    groupArgs = {\n        \"auto\": auto,\n        \"semiauto\": semiauto,\n        \"dummy_auto\": dummy_auto,\n        \"template_names\": template_names,\n        \"args\": args,\n    }\n    if (not auto) or semiauto:\n        os.system(\"killall ffplay\")\n    # you may play the media as well.",
        "type": "code",
        "location": "/pyjom/modules/contentCensoring/core.py:300-332"
    },
    "893": {
        "file_id": 79,
        "content": "The code checks if the content is a picture and downloads it using mediaDownloader function. Then, it censors the picture using coreMediaCensor function and adds the path and censoring data to the review list. If the content is not a picture, it directly censors the content without displaying raw content using coreMediaCensor function with appropriate arguments. Finally, it returns the censored content as 'data'.",
        "type": "comment"
    },
    "894": {
        "file_id": 79,
        "content": "    data = {\"type\": None, \"review\": None}\n    mediaTypes = [\"image\", \"video\"]\n    # mediaTypes = [\"picture\", \"video\"]\n    if content[\"type\"] in mediaTypes:\n        data[\"type\"] = content[\"type\"]\n        mediaPath = content[\"path\"]\n        mdata = coreMediaCensor(mediaPath, (None, None, None), local=True, **groupArgs)\n        # review as video.\n        data[\"review\"] = (mediaPath, mdata)\n    else:\n        raise Exception(\"Unknown Content Type: {}\\n{}\".format(content[\"type\"], content))\n    return data",
        "type": "code",
        "location": "/pyjom/modules/contentCensoring/core.py:333-344"
    },
    "895": {
        "file_id": 79,
        "content": "This code checks the content type, if it's an image or video, then it censor the media using `coreMediaCensor` function and returns the data. If the content type is unknown, it raises an exception.",
        "type": "comment"
    },
    "896": {
        "file_id": 80,
        "content": "/pyjom/modules/contentCensoring/autoCensor.py",
        "type": "filepath"
    },
    "897": {
        "file_id": 80,
        "content": "This code provides content censoring functionality for media processing software using Tkinter and optional parameters, as well as a semi-auto blacklist feature. It removes specified key-value pairs from the dictionary.",
        "type": "summary"
    },
    "898": {
        "file_id": 80,
        "content": "from tkinter import *\nfrom pyjom.commons import *\nfrom pyjom.medialang.core import *\ndef dummyAutoCensor(contentPath, meta, semiauto=False):\n    mdata = {\n        \"dummyAutoCensor\": {\n            \"input\": {\"path\": contentPath, \"meta\": meta},\n            \"result\": \"some content here!\",\n        }\n    }\n    return mdata\ndef autoCensor(contentPath, meta, template_names=[], semiauto=False, args={}):\n    from pyjom.medialang.core import Medialang\n    mdata = {}\n    template_dirs = [\"medialang\", \"autoCensor\"]\n    medialang_template_paths = template_names  # not always need all templates.\n    semiauto_key_blacklist = []\n    semiauto_template_path_blacklist = []\n    if semiauto:\n        medialang_template_paths = [\n            x\n            for x in medialang_template_paths\n            if x not in semiauto_template_path_blacklist\n        ]\n    for template_name in medialang_template_paths:\n        name = template_name.split(\".\")[0]  # check if starts with meta.\n        template_path = getTemplatePath(template_dirs, template_name)",
        "type": "code",
        "location": "/pyjom/modules/contentCensoring/autoCensor.py:1-31"
    },
    "899": {
        "file_id": 80,
        "content": "This code is for content censoring in a media processing software. It utilizes Tkinter and other modules for functionality, provides a dummy auto-censorship function, and an actual auto-censorship function with optional parameters like template names and semi-auto mode. It also includes a list of blacklisted templates if semi-auto mode is enabled.",
        "type": "comment"
    }
}