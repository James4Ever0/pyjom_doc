{
    "800": {
        "file_id": 61,
        "content": "/pyjom/modules/contentCensoring/__init__.py",
        "type": "filepath"
    },
    "801": {
        "file_id": 61,
        "content": "This code imports two parts, label and filter, from the contentCensoring module's core and autoCensor submodules in the pyjom library.",
        "type": "summary"
    },
    "802": {
        "file_id": 61,
        "content": "# two parts: label and filter\nfrom pyjom.modules.contentCensoring.core import *\nfrom pyjom.modules.contentCensoring.autoCensor import *",
        "type": "code",
        "location": "/pyjom/modules/contentCensoring/__init__.py:1-3"
    },
    "803": {
        "file_id": 61,
        "content": "This code imports two parts, label and filter, from the contentCensoring module's core and autoCensor submodules in the pyjom library.",
        "type": "comment"
    },
    "804": {
        "file_id": 62,
        "content": "/pyjom/modules/methodIdentifier/dummyIdentifier.py",
        "type": "filepath"
    },
    "805": {
        "file_id": 62,
        "content": "The code defines a function `dummyId()` that generates a unique UUID and a class `dummyIdentifier` with instance variables and methods to store fix information related to various components of a system.",
        "type": "summary"
    },
    "806": {
        "file_id": 62,
        "content": "def dummyId():\n    import uuid\n    return uuid.uuid4()\nclass dummyIdentifier:\n    def __init__(self, uuid):\n        self.uuid = uuid\n        self.data = {}\n    def typeFix(self, typeFix):\n        self.data[\"typeFix\"] = typeFix\n    def topicFix(self, topicFix):\n        self.data[\"topicFix\"] = topicFix\n    def infoFix(self, infoFix):\n        self.data[\"infoFix\"] = infoFix\n    def producerFix(self, producerFix):\n        self.data[\"producerFix\"] = producerFix\n    def posterFix(self, posterFix):\n        self.data[\"posterFix\"] = posterFix\n    def feedbackFix(self, feedbackFix):\n        self.data[\"feedbackFix\"] = feedbackFix\n    def updatorFix(self, updatorFix):\n        self.data[\"updatorFix\"] = updatorFix\n    def fetcherFix(self, fetcherFix):\n        self.data[\"fetcherFix\"] = fetcherFix\n    def processorFix(self, processorFix):\n        self.data[\"processorFix\"] = processorFix\n    def optimizerFix(self, optimizerFix):\n        self.data[\"optimizerFix\"] = optimizerFix\n    def reviewerFix(self, reviewerFix):\n        self.data[\"reviewerFix\"] = reviewerFix",
        "type": "code",
        "location": "/pyjom/modules/methodIdentifier/dummyIdentifier.py:1-43"
    },
    "807": {
        "file_id": 62,
        "content": "The code defines a function `dummyId()` that generates a unique UUID and a class `dummyIdentifier` with instance variables and methods to store fix information related to various components of a system.",
        "type": "comment"
    },
    "808": {
        "file_id": 63,
        "content": "/pyjom/modules/methodIdentifier/__init__.py",
        "type": "filepath"
    },
    "809": {
        "file_id": 63,
        "content": "This code imports all the contents from the \"dummyIdentifier\" module in the \"pyjom.modules.methodIdentifier\" package.",
        "type": "summary"
    },
    "810": {
        "file_id": 63,
        "content": "from pyjom.modules.methodIdentifier.dummyIdentifier import *",
        "type": "code",
        "location": "/pyjom/modules/methodIdentifier/__init__.py:1-1"
    },
    "811": {
        "file_id": 63,
        "content": "This code imports all the contents from the \"dummyIdentifier\" module in the \"pyjom.modules.methodIdentifier\" package.",
        "type": "comment"
    },
    "812": {
        "file_id": 64,
        "content": "/pyjom/modules/contentReviewer/weiboSearchReviewer.py",
        "type": "filepath"
    },
    "813": {
        "file_id": 64,
        "content": "This code snippet defines a function called weiboSearchReviewer that reviews content for keywords and censors elements using the weiboCensor function. It prints details, appends reviews to a dictionary, and returns mreview.",
        "type": "summary"
    },
    "814": {
        "file_id": 64,
        "content": "from pyjom.commons import *\nfrom pyjom.modules.contentCensoring.core import weiboCensor\nimport json\n@decorator\ndef weiboSearchReviewer(content, basedir=None, auto=False, semiauto=True,dummy_auto=True,template_names=[], args={}):\n    mreview = {}\n    for key in content.keys():\n        print(\"keyword:\", key)\n        print(\"_\" * 20)\n        mreview[key] = []\n        mcontent = content[key]\n        for elem in mcontent:\n            print(\"element inside:\")\n            print(\"_\" * 20)\n            meta = elem[\"meta\"]\n            feedback = elem[\"feedback\"]\n            _, pretty_printed = jsonPrettyPrint(elem)\n            print(pretty_printed)\n            review, source = weiboCensor(\n                elem, basedir=basedir, semiauto=semiauto, auto=auto, dummy_auto=dummy_auto,template_names=template_names ,args=args\n            )  # unnoticed source.\n            review[\"meta\"] = meta\n            review[\"feedback\"] = feedback\n            print(\"review:\", review)\n            mreview[key].append({\"review\": review, \"source\": source})",
        "type": "code",
        "location": "/pyjom/modules/contentReviewer/weiboSearchReviewer.py:1-27"
    },
    "815": {
        "file_id": 64,
        "content": "This function, weiboSearchReviewer, reviews content for various keywords and calls the weiboCensor function to censor elements. It prints each keyword and element, and then appends the review and source of the review to a dictionary with the corresponding keyword as key. The reviewed content is stored in mreview.",
        "type": "comment"
    },
    "816": {
        "file_id": 64,
        "content": "    return mreview",
        "type": "code",
        "location": "/pyjom/modules/contentReviewer/weiboSearchReviewer.py:28-28"
    },
    "817": {
        "file_id": 64,
        "content": "This code snippet is returning the variable \"mreview\" after performing some operation.",
        "type": "comment"
    },
    "818": {
        "file_id": 65,
        "content": "/pyjom/modules/contentReviewer/localReviewer.py",
        "type": "filepath"
    },
    "819": {
        "file_id": 65,
        "content": "This code defines `filesystemReviewer` for content review, including `filesystemReviewerCoreAnalyzer` and `filesystemReviewerNoGenerator`. It handles analysis, censoring, and returns results. `localReviewer` is created for local processing with arguments args, template_names, and debug.",
        "type": "summary"
    },
    "820": {
        "file_id": 65,
        "content": "from pyjom.commons import jsonPrettyPrint,decorator\nfrom pyjom.modules.contentCensoring.core import localCensor\nimport json\ndef filesystemReviewerCoreAnalyzer(\n    elem, auto=False, semiauto=True, dummy_auto=True, args={}, template_names=[], debug=True\n):\n    if debug:\n        print(\"element inside:\")\n        print(\"_\" * 20)\n        _, pretty_printed = jsonPrettyPrint(elem)\n        print(pretty_printed)\n    # print(\"ELEMENT\", elem)\n    # breakpoint()\n    review, source = localCensor(\n        elem,\n        auto=auto,\n        semiauto=semiauto,\n        dummy_auto=dummy_auto,\n        args=args,\n        template_names=template_names,\n    )  # unnoticed source.\n    if debug:\n        print(\"review:\")\n        # breakpoint()\n        print(json.dumps(review, indent=4))\n    reviewResult = {\"review\": review, \"source\": source}\n    return reviewResult\ndef filesystemReviewerNoGenerator(\n    content,**kwargs\n):\n    mreview = []\n    for elem in content:\n        reviewResult = filesystemReviewerCoreAnalyzer(\n            elem,**kwargs\n        )",
        "type": "code",
        "location": "/pyjom/modules/contentReviewer/localReviewer.py:1-39"
    },
    "821": {
        "file_id": 65,
        "content": "This code defines two functions for content reviewing: `filesystemReviewerCoreAnalyzer` and `filesystemReviewerNoGenerator`. The `filesystemReviewerCoreAnalyzer` function analyzes an element, applies content censoring with optional automation settings, and returns a review result containing the review and source. The `filesystemReviewerNoGenerator` function iterates over content elements, using `filesystemReviewerCoreAnalyzer` to analyze each element and return a list of review results.",
        "type": "comment"
    },
    "822": {
        "file_id": 65,
        "content": "        mreview.append(reviewResult)\n    return mreview\ndef filesystemReviewerGenerator(\n    content, **kwargs\n):\n    # mreview = []\n    for elem in content:\n        reviewResult = filesystemReviewerCoreAnalyzer(\n            elem,**kwargs\n        )\n        yield reviewResult\n    #     mreview.append(reviewResult)\n    # return mreview\n@decorator\ndef filesystemReviewer(\n    content,\n    auto=False,\n    semiauto=True,\n    dummy_auto=True,\n    args={},\n    template_names=[],\n    generator: bool = False,\n    debug=True\n):\n    # print(content)\n    # print('generator flag', generator)\n    # link = content[\"link\"]\n    if not generator:\n        return filesystemReviewerNoGenerator(\n            content,\n            auto=auto,\n            semiauto=semiauto,\n            dummy_auto=dummy_auto,\n            args=args,\n            template_names=template_names,\n            debug=debug\n        )\n    else:\n        return filesystemReviewerGenerator(\n            content,\n            auto=auto,\n            semiauto=semiauto,\n            dummy_auto=dummy_auto,",
        "type": "code",
        "location": "/pyjom/modules/contentReviewer/localReviewer.py:40-86"
    },
    "823": {
        "file_id": 65,
        "content": "This code defines a function `filesystemReviewer` which, depending on the generator flag parameter, returns either the result of `filesystemReviewerNoGenerator` or a review generator using the `filesystemReviewerGenerator` function. The review generator iterates over content elements and yields the results from each call to the `filesystemReviewerCoreAnalyzer`.",
        "type": "comment"
    },
    "824": {
        "file_id": 65,
        "content": "            args=args,\n            template_names=template_names,\n            debug=debug\n        )",
        "type": "code",
        "location": "/pyjom/modules/contentReviewer/localReviewer.py:87-90"
    },
    "825": {
        "file_id": 65,
        "content": "Creates a class instance of localReviewer, passing arguments args, template_names, and debug for processing content review locally.",
        "type": "comment"
    },
    "826": {
        "file_id": 66,
        "content": "/pyjom/modules/contentReviewer/dummyReviewer.py",
        "type": "filepath"
    },
    "827": {
        "file_id": 66,
        "content": "This code imports necessary modules and defines a decorator-wrapped function, 'dummyReviewer', which returns the string \"fantastic. another good day's work.\"",
        "type": "summary"
    },
    "828": {
        "file_id": 66,
        "content": "from pyjom.commons import *\n@decorator\ndef dummyReviewer(content):\n    return \"fantastic. another good day's work.\"",
        "type": "code",
        "location": "/pyjom/modules/contentReviewer/dummyReviewer.py:1-6"
    },
    "829": {
        "file_id": 66,
        "content": "This code imports necessary modules and defines a decorator-wrapped function, 'dummyReviewer', which returns the string \"fantastic. another good day's work.\"",
        "type": "comment"
    },
    "830": {
        "file_id": 67,
        "content": "/pyjom/modules/contentReviewer/__init__.py",
        "type": "filepath"
    },
    "831": {
        "file_id": 67,
        "content": "The code imports different reviewer classes from various modules within the pyjom package for content reviewing purposes, including dummyReviewer, weiboSearchReviewer, and several filesystemReviewer implementations.",
        "type": "summary"
    },
    "832": {
        "file_id": 67,
        "content": "from pyjom.modules.contentReviewer.dummyReviewer import *\nfrom pyjom.modules.contentReviewer.weiboSearchReviewer import *\nfrom pyjom.modules.contentReviewer.localReviewer import (\n    filesystemReviewerGenerator,\n    filesystemReviewerNoGenerator,\n    filesystemReviewerCoreAnalyzer,\n    filesystemReviewer,\n)",
        "type": "code",
        "location": "/pyjom/modules/contentReviewer/__init__.py:1-8"
    },
    "833": {
        "file_id": 67,
        "content": "The code imports different reviewer classes from various modules within the pyjom package for content reviewing purposes, including dummyReviewer, weiboSearchReviewer, and several filesystemReviewer implementations.",
        "type": "comment"
    },
    "834": {
        "file_id": 68,
        "content": "/pyjom/modules/informationProcessing/onlineProcessor.py",
        "type": "filepath"
    },
    "835": {
        "file_id": 68,
        "content": "The OnlineProcessor function processes video elements, applies filters, and has functions for fps filtering and animal detection, with future audio handling planned.",
        "type": "summary"
    },
    "836": {
        "file_id": 68,
        "content": "import pyjom.videotoolbox as vtb\nfrom pyjom.commons import decorator, keywordDecorator\nimport os\nfrom lazero.utils import sprint\nfrom lazero.network import waitForServerUp\nfrom lazero.filesystem import tmpdir\n# # flag = \"topic_with_fetcher\"\n# # should't we have our judgement here?\n#     collection = getMilvusVideoDeduplicationCollection(get_existing = get_existing)\n@decorator\ndef OnlineProcessor(\n    newElems,  # a generator.\n    source=\"giphy\",\n    use_proxy=False,  # use some proxy.\n    clash_refresher_port=8677,\n    proxy_url=\"http://127.0.0.1:8381\",\n    tmpPath=\"/dev/shm/medialang/onlineProcessor\",\n    debug=False,\n    # dog_or_cat?\n    dog_or_cat=\"dog\",\n    yolov5_default_filter_dict={\n        \"dog\": {\"min\": 0.5},\n        \"cat\": {\"min\": 0.5},\n    },\n):\n    if use_proxy:\n        clash_refresher_url = \"http://127.0.0.1:{}\".format(clash_refresher_port)\n        waitForServerUp(clash_refresher_port, \"clash update controller\")\n    def set_proxy():\n        os.environ[\"http_proxy\"] = proxy_url\n        os.environ[\"https_proxy\"] = proxy_url",
        "type": "code",
        "location": "/pyjom/modules/informationProcessing/onlineProcessor.py:1-34"
    },
    "837": {
        "file_id": 68,
        "content": "This code defines a function `OnlineProcessor` that processes new video elements from a generator, using the specified source (e.g., \"giphy\"), and applying dog or cat filters based on the `dog_or_cat` parameter. It also supports using a proxy if `use_proxy` is set to True and waits for the Clash refresher server to be up if necessary. The function sets the HTTP and HTTPS proxies if a proxy is being used.",
        "type": "comment"
    },
    "838": {
        "file_id": 68,
        "content": "    with tmpdir(path=tmpPath) as testDir:\n        # elif flag == \"topic_with_fetcher\":\n        # sprint(\"checking online fetcher\")\n        # print(\"HERE??\",2)\n        if use_proxy:\n            set_proxy()\n        if source == \"giphy\":\n            for elem in newElems:\n                if use_proxy:\n                    waitForServerUp(clash_refresher_port, \"clash update controller\")\n                if debug:\n                    sprint(elem)\n                (item_id, local_video_location) = elem\n                # what is the freaking response?\n                from caer.video.frames_and_fps import (\n                    get_duration,\n                    get_fps_float,\n                    get_res,\n                )\n                # duration = get_duration(local_video_location)\n                from pyjom.commons import checkMinMaxDict\n                from pyjom.videotoolbox import (\n                    corruptVideoFilter,\n                )\n                # usually we want to make video short.\n                # mode: up/down",
        "type": "code",
        "location": "/pyjom/modules/informationProcessing/onlineProcessor.py:36-64"
    },
    "839": {
        "file_id": 68,
        "content": "This code checks the online fetcher and performs operations based on the 'use_proxy', 'source' (giphy), and 'debug' flags. It sets the proxy, waits for the server to update, retrieves video duration, and applies corruptVideoFilter if needed.",
        "type": "comment"
    },
    "840": {
        "file_id": 68,
        "content": "                from typing import Literal\n                def tuneVideoSpeedToBeat(\n                    video_phase: float,\n                    music_phase: float,\n                    mode: Literal[\"speedup\", \"slowdown\"],\n                ):\n                    speed = music_phase / video_phase # change in speed.\n                    speed_min, speed_max = 1, 2\n                    if mode == \"slowdown\":\n                        speed_min /= 2\n                        speed_max /= 2\n                    while True:\n                        if mode in [\"speedup\", \"slowdown\"]:\n                            if speed < speed_min:\n                                speed *= 2\n                            elif speed > speed_max:\n                                speed /= 2\n                            else:\n                                return speed\n                        else:\n                            raise Exception(\"Unknown speed change mode: %s\" % mode)\n                # TODO: tune video speed to match music phase\n                # valid_video = corruptVideoFilter(local_video_location)",
        "type": "code",
        "location": "/pyjom/modules/informationProcessing/onlineProcessor.py:65-89"
    },
    "841": {
        "file_id": 68,
        "content": "This function tunes the video speed based on music phase and mode, either speeding up or slowing down. It uses a while loop to adjust the video speed until it reaches a valid range. If an invalid mode is given, it raises an exception. The code also mentions that a function for tuning the video speed to match the music phase is planned (TODO), but not yet implemented.",
        "type": "comment"
    },
    "842": {
        "file_id": 68,
        "content": "                # if not valid_video:\n                #     continue\n                # video_duration = get_duration(local_video_location)\n                # music_beat_duration = ...  # get from redis!\n                # speed_change_mode = \"speedup\"\n                # speed_change = tuneVideoSpeedToBeat(video_duration, music_beat_duration,mode=speed_change_mode)\n                # # now change the damn speed of video. replace the original video.\n                ###############################################\n                hard_limit = 3.5\n                remedyDurationRange = {\n                    \"min\": 1.5,\n                    \"max\": hard_limit,\n                    \"min_target\": hard_limit,\n                }  # targets in this range can multiply by some factors, looping forward and backward to get gif.\n                # is it corrupted? fuck?\n                def loopVideoTillTarget(\n                    video_path: str,\n                    objective: dict,\n                    scriptPath: str = \"/root/Desktop/works/pyjom/tests/moviepy_loop_video_till_target/loop_till_target.py\",",
        "type": "code",
        "location": "/pyjom/modules/informationProcessing/onlineProcessor.py:90-115"
    },
    "843": {
        "file_id": 68,
        "content": "This code chunk checks if the video is valid and retrieves the video duration. It then gets music beat duration from Redis, sets speed change mode as \"speedup\", and determines the video speed change based on the durations. The hard limit for remedyDurationRange is set to 3.5, with a minimum range of 1.5 and maximum at hard_limit. A function loopVideoTillTarget is defined, taking in video path, objective (dictionary), and scriptPath as parameters.",
        "type": "comment"
    },
    "844": {
        "file_id": 68,
        "content": "                ):\n                    # import moviepy # are you sure you want to import this? i think it will fuck up many things.\n                    # use it externally. please!\n                    # as some commandline script.\n                    success = False\n                    videoDuration = -1\n                    videoValid = False\n                    videoValid = corruptVideoFilter(video_path)\n                    if videoValid:\n                        videoDuration = get_duration(local_video_location)\n                        if videoDuration >= objective[\"min\"]:\n                            cmd = [\n                                \"python3\",\n                                scriptPath,\n                                \"-i\",\n                                video_path,\n                                \"-t\",\n                                str(objective[\"min_target\"]),\n                                \"--replace\",\n                            ]  # you must use some random temp file path...\n                            # use subprocess?",
        "type": "code",
        "location": "/pyjom/modules/informationProcessing/onlineProcessor.py:116-137"
    },
    "845": {
        "file_id": 68,
        "content": "The code checks if a video is valid and meets the minimum duration requirement. If valid, it generates a command for a script using moviepy to extract a portion of the video based on the specified duration. The use of moviepy should be done externally due to potential issues.",
        "type": "comment"
    },
    "846": {
        "file_id": 68,
        "content": "                            import subprocess\n                            r = subprocess.run(cmd)\n                            success = 0 == r.returncode\n                    return videoValid, videoDuration, success\n                videoValid, videoDuration, success = loopVideoTillTarget(\n                    local_video_location, remedyDurationRange\n                )\n                if not videoValid:\n                    print(\"VIDEO NOT VALID.\")\n                    continue\n                elif not success:\n                    print(\"VIDEO DURATION LIMIT OBJECTIVE FAILED.\")\n                    print(f\"MIN: {remedyDurationRange['min']} VIDEO: {videoDuration}\")\n                    continue\n                duration_filter = {\"min\": hard_limit, \"max\": 15}\n                # to loop through short gifs?\n                fps_filter = {\"min\": 7, \"max\": 60}\n                # fps_float = get_fps_float(local_video_location)\n                # duration_valid = checkMinMaxDict(duration,duration_filter)\n                # fps_valid = checkMinMaxDict(fps_float,fps_filter)",
        "type": "code",
        "location": "/pyjom/modules/informationProcessing/onlineProcessor.py:138-161"
    },
    "847": {
        "file_id": 68,
        "content": "The code imports subprocess, runs a command and checks its return code to determine success. It then calls loopVideoTillTarget function with local video location and remedyDurationRange as parameters. If the video is not valid, it prints \"VIDEO NOT VALID.\" and continues. If the objective failed, it prints \"VIDEO DURATION LIMIT OBJECTIVE FAILED.\", current min from remedyDurationRange, and the current video duration and continues. It defines duration_filter and fps_filter dictionaries for filtering.",
        "type": "comment"
    },
    "848": {
        "file_id": 68,
        "content": "                from pyjom.videotoolbox import (\n                    getVideoColorCentrality,\n                    checkVideoColorCentrality,\n                    getEffectiveFPS,\n                    NSFWVideoFilter,\n                    yolov5_bezier_paddlehub_resnet50_dog_cat_video_filter,\n                    dummyFilterFunction,  # just for dog and cat, no other animals.\n                    getVideoTextAreaRatio,\n                )\n                video_color_filter = {\n                    \"centrality\": {\"max\": 0.18},  # stricter limit?\n                    \"max_nearby_center_percentage\": {\"max\": 0.13},\n                }\n                video_effective_fps_filter = {\"min\": 7}\n                videoTextAreaRatioFilter = {\"max\": 0.3}\n                valid = True\n                mList = [\n                    [\n                        corruptVideoFilter,\n                        None,\n                        dummyFilterFunction,\n                        \"video corruption filter\",\n                    ],\n                    [get_duration, duration_filter, checkMinMaxDict, \"duration\"],",
        "type": "code",
        "location": "/pyjom/modules/informationProcessing/onlineProcessor.py:163-187"
    },
    "849": {
        "file_id": 68,
        "content": "The code imports video processing functions from the pyjom.videotoolbox module, sets filter parameters for color centrality, effective FPS, and video text area ratio. It also defines a corruptVideoFilter function and a duration_filter function. The code then checks if all filters are valid to proceed with further processing.",
        "type": "comment"
    },
    "850": {
        "file_id": 68,
        "content": "                    [get_fps_float, fps_filter, checkMinMaxDict, \"fps\"],\n                    [\n                        getVideoTextAreaRatio,\n                        videoTextAreaRatioFilter,\n                        checkMinMaxDict,\n                        \"videoTextAreaRatioFilter\",\n                    ],\n                    [\n                        # yolov5_bezier_paddlehub_resnet50_dog_cat_video_filter,\n                        keywordDecorator(\n                            yolov5_bezier_paddlehub_resnet50_dog_cat_video_filter,\n                            filter_dict={\n                                key: value\n                                for key, value in yolov5_default_filter_dict.items()\n                                if key == dog_or_cat\n                            },\n                        ),\n                        None,\n                        dummyFilterFunction,\n                        \"DogCat\",\n                    ],\n                    [\n                        getVideoColorCentrality,\n                        video_color_filter,",
        "type": "code",
        "location": "/pyjom/modules/informationProcessing/onlineProcessor.py:188-211"
    },
    "851": {
        "file_id": 68,
        "content": "This code defines several processing functions for video analysis, including fps filtering, calculating text area ratio, and filters for detecting dogs or cats based on the provided keywords. These functions are then used to analyze videos and extract relevant information.",
        "type": "comment"
    },
    "852": {
        "file_id": 68,
        "content": "                        checkVideoColorCentrality,\n                        \"video_color_centrality\",\n                    ],\n                    [\n                        getEffectiveFPS,\n                        video_effective_fps_filter,\n                        checkMinMaxDict,\n                        \"EffectiveFPS\",\n                    ],  # also, the dog/cat detector! fuck.\n                    [NSFWVideoFilter, None, dummyFilterFunction, \"NSFW\"],\n                    [\n                        vtb.duplicatedVideoFilter,\n                        None,\n                        dummyFilterFunction,\n                        \"video duplication filter\",\n                    ],\n                ]\n                for function, mFilter, filterFunction, flag in mList:\n                    try:\n                        mValue = function(local_video_location)\n                        valid = filterFunction(mValue, mFilter)\n                        if not valid:\n                            print(\"skipping due to invalid %s: %s\" % (flag, mValue))",
        "type": "code",
        "location": "/pyjom/modules/informationProcessing/onlineProcessor.py:212-234"
    },
    "853": {
        "file_id": 68,
        "content": "This code defines a list of filters for processing videos. Each filter is applied in sequence, and if any filter returns an invalid result, the video is skipped with a message. The NSFW detector is also mentioned as part of one of the filters.",
        "type": "comment"
    },
    "854": {
        "file_id": 68,
        "content": "                            print(\"%s filter:\" % flag, mFilter)\n                            break\n                        else:\n                            print(\"%s test passed.\" % flag)\n                    except:\n                        import traceback\n                        traceback.print_exc()\n                        print(\"skipping due to exception during filtering\")\n                        valid = False\n                        break\n                if not valid:\n                    print(\"abandon video:\", item_id)\n                # breakpoint()\n                if not valid:\n                    if os.path.exists(local_video_location):\n                        print(\"removing abandoned video:\", local_video_location)\n                        os.remove(local_video_location)\n                else:\n                    video_width, video_height = get_res(local_video_location)\n                    yield {\n                        \"location\": local_video_location,\n                        \"item_id\": item_id,\n                        \"meta\": {",
        "type": "code",
        "location": "/pyjom/modules/informationProcessing/onlineProcessor.py:235-258"
    },
    "855": {
        "file_id": 68,
        "content": "This code is testing a filter for an item and either passing or skipping based on exceptions. If it skips, the video file is removed. If it passes, it yields information about the video location and item ID.",
        "type": "comment"
    },
    "856": {
        "file_id": 68,
        "content": "                            \"duration\": get_duration(local_video_location),\n                            \"width\": video_width,\n                            \"height\": video_height,\n                        },\n                    }\n                    # if you abandon that, better delete it!\n                # do time duration check, effective fps check, color centrality check, then the dog/cat check\n                # what's next? find some audio files? or just use one audio?\n                # print(\"HERE??\",3)\n                # print('flag', flag)",
        "type": "code",
        "location": "/pyjom/modules/informationProcessing/onlineProcessor.py:259-268"
    },
    "857": {
        "file_id": 68,
        "content": "This code snippet is initializing a dictionary with key-value pairs for video duration, width, and height. It also creates another nested dictionary representing the video object. The code mentions time duration check, effective fps check, color centrality check, dog/cat check, and possibly audio file handling in future steps.",
        "type": "comment"
    },
    "858": {
        "file_id": 69,
        "content": "/pyjom/modules/informationProcessing/localProcessor.py",
        "type": "filepath"
    },
    "859": {
        "file_id": 69,
        "content": "This code segment processes filesystem information, retrieves metadata, calculates various details, handles GIFs and text files, analyzes YoloV5-detected objects from the \"yolov5\" array, filters file info, discards unwanted files, and returns modified fileinfo dictionary.",
        "type": "summary"
    },
    "860": {
        "file_id": 69,
        "content": "from pyjom.commons import (\n    decorator,\n    get_media_info,\n    json_media_info,\n    ffprobe_media_info,\n    read_json,\n    getTextFileLength,\n    multi_replacer,\n    append_sublist,\n    extract_span,\n    convoluted,\n    update_subdict,\n)\n# you may want to remove text.\n@decorator\ndef FilesystemProcessor(info, reviewerLogs, filters={}, path_replacers={}):\n    # print(\"FILESYSTEM_PROCESSOR INTERCEPTED INFO\",info)\n    # print(\"REVIEWER LOGS:\", reviewerLogs)\n    # breakpoint()\n    # do not handle meta filters here.\n    protocol, files = info  # source paths.\n    # print(\"FILES\", files)\n    # breakpoint()\n    metainfo = {}\n    for elem in files:\n        _type, path = elem[\"type\"], elem[\"path\"]\n        suffix = path.split(\".\")[-1]\n        metaInfo = {\"type\": _type, \"suffix\": suffix, \"filename\": path.split(\"/\")[-1]}\n        if _type == \"video\":\n            einfo = json_media_info(path)\n            for e in einfo[\"media\"][\"track\"]:  # might be gif. how to solve this?\n                mtype = e[\"@type\"]\n                if mtype == \"Video\":",
        "type": "code",
        "location": "/pyjom/modules/informationProcessing/localProcessor.py:1-38"
    },
    "861": {
        "file_id": 69,
        "content": "This code imports various functions and defines a FilesystemProcessor function decorated by the decorator function. It processes information and files from the filesystem, intercepts meta filters, and handles video file information for further processing.",
        "type": "comment"
    },
    "862": {
        "file_id": 69,
        "content": "                    # breakpoint()\n                    resolution = {\"height\": e[\"Height\"], \"width\": e[\"Width\"]}\n                    # color = e[\"ColorSpace\"] # YUV for common video\n            info = get_media_info(path)\n            # print(\"INFO OF %s\", path)\n            # print(info)\n            # breakpoint()\n            video_duration = info[\"videoDuration\"]\n            if \"audioDuration\" not in info.keys():\n                audioInfo = None\n            else:\n                # audioInfo = {}\n                audio_duration = info[\"audioDuration\"]\n                # print(info)\n                # breakpoint()\n                sampleRate = info[\"audioSamplingRate\"]\n                channels = info[\"audioChannel\"]\n                audioInfo = {\n                    \"sampleRate\": sampleRate,\n                    \"channels\": channels,\n                    \"duration\": audio_duration,\n                }\n            resolution = {\"height\": info[\"videoHeight\"], \"width\": info[\"videoWidth\"]}\n            _fps = info[\"videoFrameRate\"]",
        "type": "code",
        "location": "/pyjom/modules/informationProcessing/localProcessor.py:39-62"
    },
    "863": {
        "file_id": 69,
        "content": "This code retrieves media information from a file path and calculates video and audio duration, as well as the resolution and frame rate of the video. It also checks for audio information and stores it separately if available.",
        "type": "comment"
    },
    "864": {
        "file_id": 69,
        "content": "            metaInfo.update(\n                {\n                    \"fps\": _fps,\n                    \"duration\": video_duration,\n                    \"resolution\": resolution,\n                    \"audio\": audioInfo,\n                }\n            )\n        elif _type == \"audio\":\n            info = get_media_info(path)\n            duration = info[\"duration\"]\n            sampleRate = info[\"audioSamplingRate\"]\n            channels = info[\"audioChannel\"]\n            metaInfo.update(\n                {\"sampleRate\": sampleRate, \"channels\": channels, \"duration\": duration}\n            )\n        elif _type == \"image\":  # gif is image. check it out!\n            info = json_media_info(path)\n            for e in info[\"media\"][\"track\"]:\n                mtype = e[\"@type\"]\n                if mtype == \"Image\":\n                    resolution = {\"height\": e[\"Height\"], \"width\": e[\"Width\"]}\n                    # color = e[\"ColorSpace\"]\n            if metaInfo[\"suffix\"].lower() == \"gif\":\n                info = ffprobe_media_info(path)",
        "type": "code",
        "location": "/pyjom/modules/informationProcessing/localProcessor.py:63-87"
    },
    "865": {
        "file_id": 69,
        "content": "This code snippet retrieves media information based on the file type (_type) and updates the metaInfo dictionary accordingly. If it's a video, it fetches fps, video_duration, and resolution. For audio, it gets sampleRate, channels, and duration. Image type checks if it's a GIF, and depending on the result, either uses json_media_info or ffprobe_media_info to get the necessary information.",
        "type": "comment"
    },
    "866": {
        "file_id": 69,
        "content": "                for e in info[\"streams\"]:\n                    codec_name = e[\"codec_name\"]\n                    if codec_name == \"gif\":\n                        duration = e[\"duration\"]\n                        _fps = e[\"avg_frame_rate\"]\n                        metaInfo.update(\n                            {\"duration\": float(duration), \"fps\": eval(_fps)}\n                        )\n            metaInfo.update({\"resolution\": resolution})\n        elif _type == \"text\":  # are you sure about that?\n            metaInfo.update({\"length\": getTextFileLength(path)})\n        metainfo.update({multi_replacer(path, replacer_list=path_replacers): metaInfo})\n    # breakpoint()# get meta information from here.\n    fileinfo = {}\n    for rlog in reviewerLogs:\n        print(\"READING LOG: %s\" % rlog)\n        content_json = read_json(rlog)\n        for elem in content_json:\n            review_tuple = elem[\"review\"][\"review\"]\n            filename = review_tuple[0]\n            filename = multi_replacer(filename, replacer_list=path_replacers)",
        "type": "code",
        "location": "/pyjom/modules/informationProcessing/localProcessor.py:88-108"
    },
    "867": {
        "file_id": 69,
        "content": "This code retrieves file metadata and reviewer logs, then updates meta information based on file type (image, video, or text). It handles GIFs specifically by extracting duration and average frame rate. Text files have their length measured with getTextFileLength(). Reviewer logs are read and mapped to corresponding files using multi_replacer function.",
        "type": "comment"
    },
    "868": {
        "file_id": 69,
        "content": "            sample_review = review_tuple[1]  # convolution with removed text timespan.\n            # print(\"KEYS DUMP:\")\n            primarykey = list(sample_review.keys())[0]  # CHECK THIS KEY FIRST.\n            # print(\"PRIMARYKEY:\",primarykey)\n            primary_sample_content = sample_review[primarykey]\n            # print(primary_sample_content) # hide this shit.\n            if primarykey == \"labels\":\n                discard = sample_review[\"discard\"]\n                if discard:\n                    update_subdict(fileinfo, filename, {\"discard\": True})\n                else:\n                    if primarykey in filters.keys():\n                        if not any(\n                            [x in primary_sample_content for x in filters[primarykey]]\n                        ):\n                            # remove those without the label.\n                            continue\n                    update_subdict(\n                        fileinfo, filename, {\"labels\": primary_sample_content}\n                    )",
        "type": "code",
        "location": "/pyjom/modules/informationProcessing/localProcessor.py:109-128"
    },
    "869": {
        "file_id": 69,
        "content": "This code processes a sample review, checks if its primary key is \"labels\", discards the file if it contains the \"discard\" label, and updates the file info with labels if they match the specified filters.",
        "type": "comment"
    },
    "870": {
        "file_id": 69,
        "content": "                    # does it have any filters?\n                # then we have a list of labels down here.\n                # handle the filters.\n            else:\n                sample_content_type, secondary_key = primary_sample_content.keys()\n                secondary_sample_content = primary_sample_content[secondary_key]\n                third_keys = list(secondary_sample_content.keys())\n                thirdkey = third_keys[0]\n                # print(\"SecondaryKey:\",secondary_key)\n                # print(\"THIRD_KEYS:\",third_keys)\n                main_array_content = secondary_sample_content[thirdkey]\n                if secondary_key == \"yolov5\":\n                    # print(\"YOLOV5 DETECTED\")\n                    # get the time step first. or shall we?\n                    # breakpoint()\n                    identity_dict_array = {}\n                    main_time_array = []\n                    for frame in main_array_content:\n                        _time, _frame, yolov5_detector = (\n                            frame[\"time\"],",
        "type": "code",
        "location": "/pyjom/modules/informationProcessing/localProcessor.py:130-149"
    },
    "871": {
        "file_id": 69,
        "content": "The code checks if the content has any filters. If not, it accesses the sample content type and secondary key, then retrieves the third key. It assigns the main array content based on the secondary key, which is checked for being \"yolov5\". If so, it initializes identity_dict_array and main_time_array, and iterates through the main array content to retrieve time, frame, and yolov5_detector.",
        "type": "comment"
    },
    "872": {
        "file_id": 69,
        "content": "                            frame[\"frame\"],\n                            frame[\"yolov5_detector\"],\n                        )\n                        main_time_array.append(_time)\n                        for detected in yolov5_detector:\n                            # ignore the location. we do not need this shit till we somehow want to focus on the shit.\n                            confidence = detected[\n                                \"confidence\"\n                            ]  # ignore the confidence.\n                            confidence_threshold = 0.6\n                            if confidence <= confidence_threshold:\n                                continue\n                            identity = detected[\"identity\"][\"name\"]\n                            append_sublist(identity_dict_array, identity, _time)\n                    if secondary_key in filters.keys():\n                        if not any(\n                            [\n                                x in identity_dict_array.keys()\n                                for x in filters[secondary_key]",
        "type": "code",
        "location": "/pyjom/modules/informationProcessing/localProcessor.py:150-168"
    },
    "873": {
        "file_id": 69,
        "content": "This code processes detected objects from a YoloV5 detector and filters them based on a confidence threshold. It appends the detected identities to an array if they pass the threshold, and checks if there are secondary filters present for further processing.",
        "type": "comment"
    },
    "874": {
        "file_id": 69,
        "content": "                            ]\n                        ):\n                            continue  # do not have the dogs.\n                    # so check the timespan.\n                    # get consecutive ranges of x == 1. use threshold function like int(x>0.5)\n                    new_identity_array = {}\n                    for t in main_time_array:\n                        for k in identity_dict_array.keys():\n                            if t in identity_dict_array[k]:\n                                # print(\"APPENDING\")\n                                append_sublist(new_identity_array, k, 1)\n                                # print(new_identity_array[k])\n                                # breakpoint()\n                            else:\n                                append_sublist(new_identity_array, k, 0)\n                    # convolution step:\n                    # print(\"NEW IDEITITY ARRAY BEFORE PROCESSING:\", new_identity_array)\n                    main_time_array += [\"FINAL\"]  # add the final time\n                    for k in new_identity_array.keys():",
        "type": "code",
        "location": "/pyjom/modules/informationProcessing/localProcessor.py:169-187"
    },
    "875": {
        "file_id": 69,
        "content": "This code is iterating through a main_time_array and an identity_dict_array to create a new \"new_identity_array\". For each time in the main_time_array, it checks if that time exists within any of the keys' arrays in the identity_dict_array. If so, it appends that key into the new_identity_array with a value of 1. If not, it appends with a value of 0. Afterwards, it adds a final time to the main_time_array and processes the new_identity_array further.",
        "type": "comment"
    },
    "876": {
        "file_id": 69,
        "content": "                        new_identity_array[k] = convoluted(\n                            new_identity_array[k], pad=1, k=5\n                        )\n                        new_identity_array[k] = [\n                            int(x > 0.2) for x in new_identity_array[k]\n                        ]\n                        new_identity_array[k] = extract_span(\n                            new_identity_array[k], target=1\n                        )  # this is span.\n                        # print(new_identity_array[k])\n                        # breakpoint()\n                        new_identity_array[k] = [\n                            (main_time_array[a], main_time_array[b])\n                            for a, b in new_identity_array[k]\n                        ]\n                    # print(\"NEW IDENTITY SPAN ARRAY:\", new_identity_array) # not so sure if the yolov5 detector is not working properly or the confidence threshold is too high.\n                    if secondary_key in filters.keys():\n                        if not any(",
        "type": "code",
        "location": "/pyjom/modules/informationProcessing/localProcessor.py:188-205"
    },
    "877": {
        "file_id": 69,
        "content": "This code segment is processing an identity array by applying convolution, setting values above a threshold, extracting spans from the array based on a target value, and finally rearranging the array elements into pairs of indices. It seems to be part of a larger process involving filters and potentially image or object detection using a YoloV5 detector.",
        "type": "comment"
    },
    "878": {
        "file_id": 69,
        "content": "                            [\n                                x in new_identity_array.keys()\n                                for x in filters[secondary_key]\n                            ]\n                        ):\n                            continue  # double check.\n                    timestep = secondary_sample_content[\"timestep\"]\n                    result = {\n                        \"detected_objects_timespan\": new_identity_array,\n                        \"timestep\": timestep,\n                    }\n                    update_subdict(fileinfo, filename, {\"yolov5\": result})\n                    # breakpoint()\n                    # TODO: complete the convolutional span extractor.\n                    # pass\n                elif (\n                    secondary_key == \"framedifference_talib_detector\"\n                ):  # this one is detecting the pip. active region.\n                    # print(\"{:*^30}\".format(\"FRAMEDIFFERECE DETECTOR\"))\n                    # breakpoint()\n                    min_frame_threshold = 30",
        "type": "code",
        "location": "/pyjom/modules/informationProcessing/localProcessor.py:206-226"
    },
    "879": {
        "file_id": 69,
        "content": "This code is filtering data based on keys in new_identity_array and filters, and then assigns the \"detected_objects_timespan\" and \"timestep\" values to a result dictionary. The function continues if the current key is found in the new_identity_array and filters arrays. If the secondary_key is \"framedifference_talib_detector\", it prints a message and sets min_frame_threshold to 30.",
        "type": "comment"
    },
    "880": {
        "file_id": 69,
        "content": "                    if secondary_key in filters.keys():\n                        min_frame_threshold = filters[secondary_key]\n                    frameborders = []\n                    for k in main_array_content.keys():\n                        frameborder = main_array_content[k]\n                        start, end = frameborder[\"start\"], frameborder[\"end\"]\n                        frame_length = end - start\n                        if frame_length < min_frame_threshold:\n                            continue\n                        frameborders.append(frameborder)\n                    update_subdict(\n                        fileinfo,\n                        filename,\n                        {\"framedifference_talib_detector\": frameborders},\n                    )\n    # finally remove those without filter keys.\n    filterKeys = filters.get(\"ensure\", [y for y in filters.keys() if y != \"meta\"])\n    for k in list(fileinfo.keys()):\n        # do metainfo extraction.\n        # print(\"CORE PATH\")\n        fileinfo[k][\"meta\"] = metainfo[k]",
        "type": "code",
        "location": "/pyjom/modules/informationProcessing/localProcessor.py:227-250"
    },
    "881": {
        "file_id": 69,
        "content": "The code checks if a secondary key exists in the filters dictionary, then sets a minimum frame threshold based on it. It then loops through the main_array_content, filtering out any frameborders with lengths less than the minimum frame threshold. The filtered frameborders are stored in the frameborders list. Finally, the fileinfo dictionary is updated with the framedifference_talib_detector subdict containing the frameborders, and any keys without the \"meta\" tag or keys not in the filterKeys list are removed.",
        "type": "comment"
    },
    "882": {
        "file_id": 69,
        "content": "        fileElemKeys = fileinfo[k].keys()\n        if fileinfo[k].get(\"discard\", False):\n            fileinfo.pop(k)\n            continue\n        mbool_condition = all([x in fileElemKeys for x in filterKeys])\n        # print(\"CHECKING:\",k)\n        # print(\"CONDITION:\",mbool_condition)\n        # breakpoint()\n        if not mbool_condition:\n            fileinfo.pop(k)  # why the fuck you pop all of them!\n    # print(fileinfo)\n    # print(\"____________FILEINFO DUMP____________\")\n    # breakpoint()\n    return fileinfo\n    # fileSystemUrl, fileList = info # I need the processed logs!\n    # return {\"husky\": \"cute husky check my youtube\"} # this is dummy return!",
        "type": "code",
        "location": "/pyjom/modules/informationProcessing/localProcessor.py:251-266"
    },
    "883": {
        "file_id": 69,
        "content": "This code checks if a file should be discarded based on certain conditions and removes it from the fileinfo dictionary if it doesn't meet those conditions. It also prints some debug information for specific files. Finally, it returns the modified fileinfo dictionary.",
        "type": "comment"
    },
    "884": {
        "file_id": 70,
        "content": "/pyjom/modules/informationProcessing/dummyProcessor.py",
        "type": "filepath"
    },
    "885": {
        "file_id": 70,
        "content": "This code imports the decorator function from pyjom.commons and defines a dummyProcessor function, decorated with the @decorator. It takes an info parameter and returns a dictionary containing a \"husky\" key with the value \"cute husky check my youtube\".",
        "type": "summary"
    },
    "886": {
        "file_id": 70,
        "content": "from pyjom.commons import decorator\n@decorator\ndef dummyProcessor(info):\n    return {\"husky\": \"cute husky check my youtube\"}",
        "type": "code",
        "location": "/pyjom/modules/informationProcessing/dummyProcessor.py:1-6"
    },
    "887": {
        "file_id": 70,
        "content": "This code imports the decorator function from pyjom.commons and defines a dummyProcessor function, decorated with the @decorator. It takes an info parameter and returns a dictionary containing a \"husky\" key with the value \"cute husky check my youtube\".",
        "type": "comment"
    },
    "888": {
        "file_id": 71,
        "content": "/pyjom/modules/informationProcessing/__init__.py",
        "type": "filepath"
    },
    "889": {
        "file_id": 71,
        "content": "This code is importing three different processors - dummy, filesystem, and online - from the pyjom.modules.informationProcessing module. These processors may be used for handling information processing tasks.",
        "type": "summary"
    },
    "890": {
        "file_id": 71,
        "content": "from pyjom.modules.informationProcessing.dummyProcessor import dummyProcessor\nfrom pyjom.modules.informationProcessing.localProcessor import FilesystemProcessor\nfrom pyjom.modules.informationProcessing.onlineProcessor import OnlineProcessor",
        "type": "code",
        "location": "/pyjom/modules/informationProcessing/__init__.py:1-3"
    },
    "891": {
        "file_id": 71,
        "content": "This code is importing three different processors - dummy, filesystem, and online - from the pyjom.modules.informationProcessing module. These processors may be used for handling information processing tasks.",
        "type": "comment"
    },
    "892": {
        "file_id": 72,
        "content": "/pyjom/modules/contentPosting/onlinePoster.py",
        "type": "filepath"
    },
    "893": {
        "file_id": 72,
        "content": "This code defines a decorator-like function named OnlinePoster that takes in various parameters such as content, platform, postMetadataGenerator, and afterPosting. It returns an instance of BilibiliPoster for the specified platform (default is bilibili) to handle content posting. The function also utilizes a lambda expression to generate post metadata by iterating through the provided postMetadataGenerator.",
        "type": "summary"
    },
    "894": {
        "file_id": 72,
        "content": "from types import FunctionType\nfrom typing import Generator\nfrom pyjom.modules.contentPosting.bilibiliPoster import BilibiliPoster\n# there is no decorator!\ndef OnlinePoster(\n    content,\n    iterate=False,\n    contentType=\"video\",\n    postMetadataGenerator: Generator = ...,\n    platform=\"bilibili\",\n    afterPosting:FunctionType=...\n):\n    posters = {\"bilibili\": BilibiliPoster}\n    assert platform in posters.keys()\n    getPostMetadata = lambda: postMetadataGenerator.__next__() # how you produce this \"next\" properly? or double?\n    return posters[platform](\n        content,\n        iterate=iterate,\n        contentType=contentType,\n        getPostMetadata=getPostMetadata,\n        afterPosting=afterPosting,\n    )",
        "type": "code",
        "location": "/pyjom/modules/contentPosting/onlinePoster.py:1-23"
    },
    "895": {
        "file_id": 72,
        "content": "This code defines a decorator-like function named OnlinePoster that takes in various parameters such as content, platform, postMetadataGenerator, and afterPosting. It returns an instance of BilibiliPoster for the specified platform (default is bilibili) to handle content posting. The function also utilizes a lambda expression to generate post metadata by iterating through the provided postMetadataGenerator.",
        "type": "comment"
    },
    "896": {
        "file_id": 73,
        "content": "/pyjom/modules/contentPosting/dummyPoster.py",
        "type": "filepath"
    },
    "897": {
        "file_id": 73,
        "content": "Function \"dummyPoster\" takes content as input, iterates over it if specified, and returns a protocol link.",
        "type": "summary"
    },
    "898": {
        "file_id": 73,
        "content": "from pyjom.commons import *\n@decorator\ndef dummyPoster(content, iterate=False):\n    if iterate:\n        for elem in content:\n            print(\"READY TO POST CONTENT FROM:\",elem)\n    return \"mydarnprotocol://mydarnlink\"",
        "type": "code",
        "location": "/pyjom/modules/contentPosting/dummyPoster.py:1-8"
    },
    "899": {
        "file_id": 73,
        "content": "Function \"dummyPoster\" takes content as input, iterates over it if specified, and returns a protocol link.",
        "type": "comment"
    }
}