{
    "800": {
        "file_id": 55,
        "content": "# @reloading\nclass searchVideoForm(queryForm):\n    iterate: bool = False\n    params: dict = {}  # let's just see what you've got here.\nfrom bilibili_api.user import VideoOrder\n# @reloading\nclass searchRegisteredVideoForm(queryForm):\n    tid: int = 0\n    dedeuserid: Union[list[str], str, None] = None\n    videoOrder: VideoOrder = VideoOrder.PUBDATE\n# @reloading\nclass searchUserVideoForm(searchRegisteredVideoForm):\n    dedeuserid: str = \"397424026\"\n    method: Literal[\"online\", \"bm25\"] = \"online\"\n    use_credential: bool = False\n# @reloading\nclass registerUserVideoForm(pydantic.BaseModel):\n    bvid: str\n    dedeuserid: str\n    is_mine: bool = False\n    visible: bool = False\n################################BILIBILI QUERY DATA MODELS######################\n# from pyjom.platforms.bilibili.searchDataParser import parseSearchVideoResult # but you never use this shit.\n# will it load the overheads of pyjom.commons?\n# updated anyio. does that work? will it break dependencies?\nimport pyjq\nfrom bilibili_api import sync, search, user, video",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:154-195"
    },
    "801": {
        "file_id": 55,
        "content": "The code defines four classes: `searchVideoForm`, `searchRegisteredVideoForm`, `searchUserVideoForm`, and `registerUserVideoForm`. These classes inherit from `queryForm` and are used for querying video data on Bilibili. The classes have different parameters, such as `tid`, `dedeuserid`, `videoOrder`, `method`, and `use_credential`, to specify the desired search criteria. The code also imports necessary modules and functions from `bilibili_api` for performing operations on videos, users, and searches.",
        "type": "comment"
    },
    "802": {
        "file_id": 55,
        "content": "from peewee import *\nfrom playhouse.sqlite_ext import SqliteExtDatabase, FTSModel, SearchField, RowIDField\nBSP = search.bilibiliSearchParams\n# you can query for the server status.\n# make it into a dashboard like thing.\n@lru_cache(maxsize=1)\ndef getMajorMinorTopicMappings(debug: bool = False):\n    majorMinorMappings = {}\n    for key, value in BSP.all.tids.__dict__.items():\n        try:\n            major_tid = value.tid\n            if debug:\n                print(\"MAJOR\", key, major_tid)\n            content = {\"major\": {\"tid\": major_tid, \"name\": key}}\n            majorMinorMappings.update(\n                {major_tid: content, key: content, str(major_tid): content}\n            )\n            for subkey, subvalue in value.__dict__.items():\n                if subkey != \"tid\" and type(subvalue) == int:\n                    if debug:\n                        print(\"MINOR\", subkey, subvalue)\n                    content = {\n                        \"major\": {\"tid\": major_tid, \"name\": key},\n                        \"minor\": {\"tid\": subvalue, \"name\": subkey},",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:197-223"
    },
    "803": {
        "file_id": 55,
        "content": "This code retrieves major and minor topic mappings from the bilibiliSearchParams database table and stores them in a dictionary called 'majorMinorMappings'. The function is memoized using @lru_cache decorator to avoid redundant queries. The debug parameter, if set to True, will print the major and minor topics during execution.",
        "type": "comment"
    },
    "804": {
        "file_id": 55,
        "content": "                    }\n                    majorMinorMappings.update(\n                        {subvalue: content, subkey: content, str(subvalue): content}\n                    )\n        except:\n            pass\n    return majorMinorMappings\ndef getTagStringFromTid(tid):\n    majorMinorTopicMappings = getMajorMinorTopicMappings()\n    topic = majorMinorTopicMappings.get(tid, None)\n    tags = []\n    if topic:\n        majorTopic = topic.get(\"major\", {}).get(\"name\", None)\n        minorTopic = topic.get(\"minor\", {}).get(\"name\", None)\n        if majorTopic:\n            tags.append(majorTopic)\n            if minorTopic:\n                tags.append(minorTopic)\n    return \",\".join(tags)\n# also make a decorator for refreshing status, add it to every function.\n# thie refresher is scheduled.\n# you may want to run this beforehand...\nimport schedule\n# do we really need credential for checking our video? you can try.\n@lru_cache(maxsize=3)  # could be bigger.\ndef getUserObject(dedeuserid: str = \"397424026\", use_credential: bool = False):",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:224-257"
    },
    "805": {
        "file_id": 55,
        "content": "This code defines a function `getTagStringFromTid(tid)` that retrieves topic details from a topic ID (tid) and returns a comma-separated list of major and minor topics. It also uses a decorator to refresh the status, scheduled by calling `schedule()`, and a cached version of `getUserObject()` function with an optional dedeuserid and use_credential parameters.",
        "type": "comment"
    },
    "806": {
        "file_id": 55,
        "content": "    dedeuserid_int = int(dedeuserid)\n    if use_credential:\n        credential = getCredentialByDedeUserId(\n            dedeuserid\n        )  # this will cache the cookies. so it allows multiple accounts.\n    else:\n        credential = None\n    u = user.User(dedeuserid_int, credential=credential)\n    return u\nfrom lazero.filesystem.env import getHomeDirectory\nfrom pathlib import Path\nimport os\nfrom peewee import *\nclass BilibiliUser(Model):\n    username = CharField()  # can be updated later.\n    user_id = IntegerField(unique=True)  # this is integer.\n    is_mine = BooleanField(default=False)\n    followers = IntegerField(\n        null=True\n    )  # how to get that? every time you get some video you do this shit? will get you blocked.\n    # well you can check it later.\n    avatar = CharField(null=True)  # warning! charfield max length is 255\n    def userInfoExtracter(self, blacklist=[\"id\"]):\n        info = {\n            key: value for key, value in self.__data__.items() if key not in blacklist\n        }\n        return info",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:258-290"
    },
    "807": {
        "file_id": 55,
        "content": "The code defines a class called BilibiliUser, which inherits from the peewee.Model class. The class has fields for username, user_id (which is unique), is_mine flag, followers count, and avatar URL. A method, userInfoExtracter, is also defined to extract information from the model instance excluding specified keys. Additionally, a function exists to create a new User instance based on the provided dedeuserid and credential.",
        "type": "comment"
    },
    "808": {
        "file_id": 55,
        "content": "class BilibiliVideo(Model):\n    bvid = CharField(unique=True)\n    typeid = IntegerField(null=True)  # string? wtf?\n    visible = BooleanField(null=True)  # are you sure?\n    last_check = DateTimeField(\n        default=datetime.datetime.now\n    )  # well this is not tested. test it!\n    register_date = DateTimeField(default=datetime.datetime.now)\n    poster = ForeignKeyField(\n        BilibiliUser, field=BilibiliUser.user_id\n    )  # is it my account anyway?\n    play = IntegerField(null=True)\n    pic = CharField(null=True)\n    length = IntegerField(null=True)\n    pubdate = IntegerField(default=0, null=True)\n    review = IntegerField(null=True)  # you want to update? according to this?\n    favorites = IntegerField(default=0, null=True)\n    title = CharField(null=True)\n    tag = CharField(null=True)\n    description = CharField(null=True)\n    def videoInfoExtractor(\n        self, blacklist=[\"id\", \"last_check\", \"register_date\", \"poster\"]\n    ):\n        info = {\n            key: value for key, value in self.__data__.items() if key not in blacklist",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:293-318"
    },
    "809": {
        "file_id": 55,
        "content": "This code defines a BilibiliVideo class that inherits from Model and includes various fields such as bvid, typeid, visible, last_check, register_date, poster, play, pic, length, pubdate, review, favorites, title, and tag. The videoInfoExtractor method takes a blacklist parameter and returns information excluding the specified fields.",
        "type": "comment"
    },
    "810": {
        "file_id": 55,
        "content": "        }\n        poster = self.poster\n        try:\n            info[\n                \"poster\"\n            ] = (\n                poster.userInfoExtracter()\n            )  # well it will return as always. no live fetching! it is stored in database.\n        except:\n            import traceback\n            traceback.print_exc()\n            print(\"userinfo might be missing from videoinfo.\")\n        try:\n            info[\"typeid\"] = int(info[\"typeid\"])\n        except:\n            pass\n        return info\nclass BilibiliVideoIndex(FTSModel):\n    rowid = RowIDField()\n    # these three must be preprocessed before put into the search engine, or we cannot retrieve the data correctly.\n    title = SearchField()\n    tag = (\n        SearchField()\n    )  # also what the fuck is going on with the tag? why we cannot get the tag/topic name?\n    description = SearchField()\n    class Meta:\n        database = None  # that's good.\n        options = {\"tokenize\": \"porter\"}  # you need manually separate some\n@lru_cache(maxsize=1)\ndef getBilibiliVideoDatabase():",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:319-354"
    },
    "811": {
        "file_id": 55,
        "content": "This code is initializing a BilibiliVideoIndex model, which extends FTSModel and has three SearchField properties (title, tag, description). It also contains a RowIDField (rowid). The function getBilibiliVideoDatabase() is a cache-friendly function to access the database.",
        "type": "comment"
    },
    "812": {
        "file_id": 55,
        "content": "    db_dir = Path(getHomeDirectory()) / \".bilibili_video\"\n    if not os.path.exists(db_dir):\n        os.mkdir(db_dir)\n    db_path = db_dir / \"database.db\"  # sure this works?\n    # db = SqliteDatabase(db_path)\n    db = SqliteExtDatabase(\n        db_path, pragmas={\"journal_mode\": \"wal\", \"cache_size\": -1024 * 64}\n    )\n    # test the full text search function elsewhere. please?\n    return db\ndef getBilibiliVideoDatabaseAndCreateTables():\n    db = getBilibiliVideoDatabase()\n    db.create_tables([BilibiliUser, BilibiliVideo, BilibiliVideoIndex])\n    return db\n# no need to decorate this thing. only put some 'unchecked' video into array.\ndef registerUser(dedeuserid: str, is_mine: Union[bool, None] = None):\n    user_id = int(dedeuserid)\n    u = BilibiliUser.get_or_none(user_id=user_id)\n    if u is None:  # this is to create.\n        if is_mine is None:\n            is_mine = False\n        userObject = user.User(user_id)\n        userInfo = sync(userObject.get_user_info())\n        # print(userInfo)\n        # print(dir(userInfo))",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:355-383"
    },
    "813": {
        "file_id": 55,
        "content": "The code sets up a SQLite database for the Bilibili video platform. It creates a directory if it doesn't exist, defines the database path, and initializes an SqliteExtDatabase object with specified pragmas. The getBilibiliVideoDatabaseAndCreateTables function creates necessary tables using the defined database, and registerUser function retrieves or creates a BilibiliUser based on the provided dedeuserid.\n\nThe code sets up a SQLite database for the Bilibili video platform by initializing an SqliteExtDatabase object with specified pragmas and creating required tables. The getBilibiliVideoDatabaseAndCreateTables function utilizes this setup, while the registerUser function handles user retrieval or creation based on dedeuserid.",
        "type": "comment"
    },
    "814": {
        "file_id": 55,
        "content": "        # breakpoint()\n        # dict_keys(['list', 're_version', 'total'])\n        # in the 'list' we've got a few recent followers.\n        followersInfo = sync(userObject.get_followers())\n        username = userInfo[\"name\"]\n        followers = followersInfo[\"total\"]\n        avatar = userInfo[\"face\"]\n        (\n            u,\n            _,\n        ) = BilibiliUser.get_and_update_or_create(  # this is wrong. maybe the username is updated.\n            user_id=user_id,\n            username=username,\n            is_mine=is_mine,\n            followers=followers,\n            avatar=avatar,\n        )\n        # when to update? maybe later.\n    elif is_mine is not None and u.is_mine != is_mine:\n        u.is_mine = is_mine\n        u.save()\n    return u\n# @refresh_status_decorator\ndef searchVideos(\n    query: str,\n    iterate: bool = False,\n    page_start: int = 1,\n    params={\"duration\": BSP.all.duration._10分钟以下},  # is that right? maybe?\n    page_size: int = ...,\n):  # what do you expect? you want the xml object let's get it!",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:384-415"
    },
    "815": {
        "file_id": 55,
        "content": "The code appears to be fetching user and video information from the Bilibili platform, handling updates for user profiles, and searching for videos based on a given query. It utilizes functions like `get_followers()`, `BilibiliUser.get_and_update_or_create()`, and `searchVideos()`. The code also includes a refresh status decorator, and handles user profile updates if the 'is_mine' flag changes.",
        "type": "comment"
    },
    "816": {
        "file_id": 55,
        "content": "    # search the thing directly? or you distill keywords from it?\n    search_type = search.SearchObjectType.VIDEO\n    # or you use some baidu magic?\n    # anyway, let's begin.\n    # warning: this is coroutine.\n    # you might want some magic. with 'suppressException' and pickledFunction?\n    def getResultParsed(result):\n        mresult = pyjq.all(\n            \".result[] | {mid, author, pic, play, is_pay, duration, bvid, description, title, pubdate, tag, typename, typeid, review, favorites, danmaku, rank_score, like, upic} | select (.title != null and .bvid != null)\",\n            result,\n        )\n        return mresult\n    def getResult(page):\n        result = sync(\n            search.search_by_type(\n                query,\n                search_type,\n                params=params,\n                page=page,\n                **jsonify(dict(page_size=page_size)),\n            )\n        )\n        return result\n    result = getResult(page_start)\n    numPages = result[\"numPages\"]  # usually we select the topmost candidates.",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:416-442"
    },
    "817": {
        "file_id": 55,
        "content": "This code searches for results on Bilibili using the search_type parameter and query. It uses coroutines to get the result, then extracts and returns parsed data from the result. The function gets the result by calling a search API with specified parameters and retrieves the number of pages from the returned result.",
        "type": "comment"
    },
    "818": {
        "file_id": 55,
        "content": "    # print(result)\n    if numPages < page_start:\n        page_start_current = 1\n    else:\n        page_start_current = page_start\n        mresult = getResultParsed(result)\n        for v in mresult:\n            yield v\n    if not iterate:\n        page_range = range(page_start_current, page_start_current + 1)\n    else:\n        import progressbar\n        print(f\"iterating page range: {page_start_current}-{numPages}\")\n        page_range = progressbar.progressbar(range(page_start_current, numPages + 1))\n    for page in page_range:\n        if page != page_start:\n            result = getResult(page)\n            mresult = getResultParsed(result)\n            for v in mresult:\n                yield v\n    # you can use the upic to render some deceptive ads, but better not?\n    # so you want to persist these results or not?\n    # better persist so we can reuse.\n    # no persistance?\n    # check some interesting result.\n    # no selection?\n    # you should use the parser found elsewhere. or not?\n    # breakpoint()\n    # remove keyword highlight from title. will you?",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:443-474"
    },
    "819": {
        "file_id": 55,
        "content": "The code is responsible for iterating through a range of pages, fetching data from each page, and processing the results. It also includes checks to see if persistence is required or if any selections need to be made. Additionally, it considers whether to remove keyword highlights from titles. The code may also handle potential errors or breakpoints with a `breakpoint()` statement.",
        "type": "comment"
    },
    "820": {
        "file_id": 55,
        "content": "    # result['result'][0].keys()\n    # keys = [\n    #     \"type\",\n    #     \"id\",\n    #     \"author\",\n    #     \"mid\",\n    #     \"typeid\",\n    #     \"typename\",\n    #     \"arcurl\",\n    #     \"aid\",\n    #     \"bvid\",\n    #     \"title\",\n    #     \"description\",\n    #     \"arcrank\",\n    #     \"pic\",\n    #     \"play\",\n    #     \"video_review\",\n    #     \"favorites\",\n    #     \"tag\",\n    #     \"review\",\n    #     \"pubdate\",\n    #     \"senddate\",\n    #     \"duration\",\n    #     \"badgepay\",\n    #     \"hit_columns\",\n    #     \"view_type\",\n    #     \"is_pay\",\n    #     \"is_union_video\",\n    #     \"rec_tags\",\n    #     \"new_rec_tags\",\n    #     \"rank_score\",\n    #     \"like\",\n    #     \"upic\",\n    #     \"corner\",\n    #     \"cover\",\n    #     \"desc\",\n    #     \"url\",\n    #     \"rec_reason\",\n    #     \"danmaku\",\n    # ]\n    # rank score is important!\n# you need my credential!\n# better reuse the code.\ndef checkVideoInDatabase(bvid: str):\n    # we use peewee (of course our modified version)\n    db = getBilibiliVideoDatabase()\n    db.create_tables([BilibiliVideo, BilibiliUser])",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:475-525"
    },
    "821": {
        "file_id": 55,
        "content": "This code is defining a function `checkVideoInDatabase` that takes a video bvid as input, initializes a Peewee database, creates tables for BilibiliVideo and BilibiliUser, and checks if the video already exists in the database. It returns True if the video is found, otherwise False.",
        "type": "comment"
    },
    "822": {
        "file_id": 55,
        "content": "    result = BilibiliVideo.get_or_none(BilibiliVideo.bvid == bvid)\n    return result  # check it elsewhere?\n# get my videos first!\nimport math\n# @refresh_status_decorator\nfrom bilibili_api.user import VideoOrder\ndef indexAndGetVideoObject(\n    v, bilibiliUser\n):  # let's wrap this shit. eliminate those 'erroneous' display.\n    try:\n        v[\"typeid\"] = int(v[\"typeid\"])\n    except:\n        pass\n    favdict = {}\n    favorites = v.get(\"favorites\", None)\n    if favorites is not None:\n        favdict[\"favorites\"] = favorites\n    bilibiliVideo, flag = BilibiliVideo.get_and_update_or_create(\n        bvid=v[\"bvid\"],\n        typeid=v[\"typeid\"],\n        visible=True,  # are you sure?\n        last_check=datetime.datetime.now(),  # well this is not tested. test it!\n        poster=bilibiliUser,  # is it my account anyway?\n        play=v[\"play\"],\n        pic=linkFixer(v[\"pic\"]),\n        length=videoDurationStringToSeconds(v.get(\"length\", v.get(\"duration\"))),\n        review=v.get(\"comment\", v.get(\"review\")),\n        pubdate=v.get(\"created\", v.get(\"pubdate\")),",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:526-558"
    },
    "823": {
        "file_id": 55,
        "content": "This code retrieves a BilibiliVideo object based on the provided bvid and typeid, updates or creates it if necessary, and fills in various attributes from the given video dictionary. The poster attribute is set to bilibiliUser, assuming it belongs to that user's account. The visible attribute is set to True by default, but this may need verification. The last_check timestamp is set to the current datetime, and the code attempts to fix the pic URL with a linkFixer function call.",
        "type": "comment"
    },
    "824": {
        "file_id": 55,
        "content": "        description=v[\"description\"],\n        title=clearHtmlTags(v[\"title\"]),  # it may contain highlights. be warned\n        tag=v[\"tag\"],\n        **favdict,\n        # _debug=True\n    )\n    # print(\"f\", flag)\n    # print(v)\n    # print(bilibiliUser)\n    # breakpoint()\n    bilibiliVideoIndex, _ = BilibiliVideoIndex.get_and_update_or_create(\n        rowid=bilibiliVideo.id,\n        description=textPreprocessing(bilibiliVideo.description),\n        tag=textPreprocessing(bilibiliVideo.tag),\n        title=textPreprocessing(bilibiliVideo.title),\n    )\n    return bilibiliVideo\ndef getUserVideos(\n    tid=0,\n    keyword=\"\",\n    order=VideoOrder.PUBDATE,\n    dedeuserid: str = \"397424026\",\n    use_credential: bool = False,\n    stop_on_duplicate: bool = True,\n    sleep: int = 2,\n    page_num: int = 1,\n    page_size: int = 30,\n):  # all videos? just at init.\n    pn = page_num\n    # some stop condition for early termination.\n    # if any of the video exists in the database, we stop this shit.\n    bilibiliUser = registerUser(\n        dedeuserid,",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:559-593"
    },
    "825": {
        "file_id": 55,
        "content": "The code retrieves a user's videos from Bilibili and processes them, updating the database with the video information. It also provides options for filtering and pagination.",
        "type": "comment"
    },
    "826": {
        "file_id": 55,
        "content": "    )\n    u = getUserObject(dedeuserid=dedeuserid, use_credential=use_credential)\n    # tid\tint, optional\t分区 ID. Defaults to 0（全部）\n    # pn\tint, optional\t页码，从 1 开始. Defaults to 1.\n    # ps\t(int, optional)\t每一页的视频数. Defaults to 30.\n    # keyword\tstr, optional\t搜索关键词. Defaults to \"\".\n    # order\tVideoOrder, optional\t排序方式. Defaults to VideoOrder.PUBDATE\n    # this is async. use sync.\n    stopped = False\n    while not stopped:\n        videos = sync(\n            u.get_videos(pn=pn, keyword=keyword, tid=tid, order=order, ps=page_size)\n        )\n        # print(videos)\n        # dict_keys(['list', 'page', 'episodic_button', 'is_risk', 'gaia_res_type', 'gaia_data'])\n        page = videos[\"page\"]  # pagination options\n        numPages = math.ceil(page[\"count\"] / page[\"ps\"])\n        # print('NUM PAGES',numPages)\n        # topicDict = videos[\"list\"][\"tlist\"]\n        # {'1': {'tid': 1, 'count': 13, 'name': '动画'}, '160': {'tid': 160, 'count': 257, 'name': '生活'}, '181': {'tid': 181, 'count': 2, 'name': '影视'}, '188': {'t",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:594-613"
    },
    "827": {
        "file_id": 55,
        "content": "This code is retrieving videos from the Bilibili platform, using a specific user object and various parameters such as pagination and keyword. It fetches data in pages and calculates the number of pages based on the total count of videos. The code handles pagination and possibly retrieves topic information based on different categories (tid).",
        "type": "comment"
    },
    "828": {
        "file_id": 55,
        "content": "id': 188, 'count': 4, 'name': '科技'}, '217': {'tid': 217, 'count': 4, 'name': '动物圈'}, '234': {'tid': 234, 'count': 1, 'name': '运动'}, '3': {'tid': 3, 'count': 9, 'name': '音乐'}, '36': {'tid': 36, 'count': 30, 'name': '知识'}, '4': {'tid': 4, 'count': 67, 'name': '游戏'}}\n        # breakpoint()\n        video_list = videos[\"list\"][\"vlist\"]\n        # breakpoint()\n        if video_list == []:\n            break\n        for v in video_list:\n            bvid = v[\"bvid\"]\n            subTypeId = v[\"typeid\"]\n            tagString = getTagStringFromTid(subTypeId)\n            v.update({\"tag\": tagString})\n            result = checkVideoInDatabase(bvid)\n            if result and stop_on_duplicate:\n                stopped = True\n                break\n            # print(v)\n            # dict_keys(['comment', 'typeid', 'play', 'pic', 'subtitle', 'description', 'copyright', 'title', 'review', 'author', 'mid', 'created', 'length', 'video_review', 'aid', 'bvid', 'hide_click', 'is_pay', 'is_union_video', 'is_steins_gate', 'is_live_playback'])",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:613-629"
    },
    "829": {
        "file_id": 55,
        "content": "The code is iterating through a list of videos and for each video, it updates the tag string using getTagStringFromTid function. Then, it checks if the video already exists in the database using checkVideoInDatabase function. If the video is found and stop_on_duplicate is True, the loop breaks and stopped is set to True.",
        "type": "comment"
    },
    "830": {
        "file_id": 55,
        "content": "            # breakpoint()\n            # bad idea. you should get the bilibiliUser before you do this.\n            bilibiliVideo = indexAndGetVideoObject(v, bilibiliUser)\n            yield bilibiliVideo\n        # videos['list']['vlist'][0].keys()\n        # dict_keys(['comment', 'typeid', 'play', 'pic', 'subtitle', 'description', 'copyright', 'title', 'review', 'author', 'mid', 'created', 'length', 'video_review', 'aid', 'bvid', 'hide_click', 'is_pay', 'is_union_video', 'is_steins_gate', 'is_live_playback'])\n        if pn >= numPages:\n            break\n        elif not stop_on_duplicate:\n            break  # this is the hint of merely using this as a search tool\n        time.sleep(sleep)\n        pn += 1\n# cannot resolve 217?\ndef resolveSubTidsFromTid(tid: int):\n    if type(tid) != int:\n        tid = int(tid)\n    MMTM = getMajorMinorTopicMappings()\n    allTids = [t for t in MMTM.keys() if type(t) == int]\n    if tid == 0:\n        return allTids\n    elif tid not in allTids:\n        raise Exception(\"Invalid tid: %d\" % tid)",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:630-653"
    },
    "831": {
        "file_id": 55,
        "content": "This code appears to be part of a larger program responsible for interacting with the Bilibili platform's database. It utilizes functions like `indexAndGetVideoObject`, `getMajorMinorTopicMappings`, and `resolveSubTidsFromTid`. The main functionality seems to involve looping through pages of videos, obtaining video objects, and resolving subtopic IDs from a given topic ID. There is also a mechanism for handling duplicate or redundant data and an optional sleep function to control the speed at which the program retrieves information.",
        "type": "comment"
    },
    "832": {
        "file_id": 55,
        "content": "    else:\n        myTids = set()\n        myTids.add(tid)\n        # print(\"ALL TIDS?\")\n        # import rich\n        # rich.print(allTids)\n        # rich.print(MMTM)\n        myTopic = MMTM[tid]\n        # myTopic = allTids[tid]\n        if myTopic.get(\"minor\", None) == None:\n            # this is a major topic\n            for t in allTids:\n                subTopic = MMTM[t]\n                if subTopic.get(\"major\", {}).get(\"tid\", None) == tid:\n                    subTid = subTopic.get(\"minor\", {}).get(\"tid\", tid)\n                    myTids.add(subTid)\n        return list(myTids)\ndef searchRegisteredVideosAndGetResultList(\n    keyword: str,\n    tid: int = 0,\n    dedeuserid: Union[str, None, list[str]] = \"397424026\",\n    videoOrder=VideoOrder.PUBDATE,  # FAVOURITE, VIEW\n    page_num: int = 1,\n    page_size: int = 10,\n):\n    resultList = []\n    resolvedTids = resolveSubTidsFromTid(tid)\n    condition = (BilibiliVideo.typeid in resolvedTids) & (BilibiliVideo.visible == True)\n    if dedeuserid is not None:\n        if type(dedeuserid) == str:",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:654-686"
    },
    "833": {
        "file_id": 55,
        "content": "Code resolves subtopics from a given topic ID and returns a list of associated topic IDs. It checks if the topic is major or minor, then searches for subtopics related to the main topic. Finally, it adds the subtopic's minor topic IDs to the list. This function can be used to find videos related to specific keywords within registered topics and return a result list based on video order preference.",
        "type": "comment"
    },
    "834": {
        "file_id": 55,
        "content": "            dedeuserids = [dedeuserid]\n        else:\n            dedeuserids = dedeuserid\n        dedeuserids = [int(d) for d in dedeuserids]\n    else:\n        dedeuserids = None\n        # print(\"DEDEUSERIDS:\", dedeuserids)\n    # vlist = [v for v in (BilibiliVideo.select().where(condition) or [])]\n    # http://docs.peewee-orm.com/en/latest/peewee/relationships.html#relationships\n    def getVgen(selector, videoOrder):\n        nonlocal condition, dedeuserids\n        vgen = selector\n        # breakpoint()\n        if dedeuserids:\n            from functools import reduce\n            condition &= reduce(\n                lambda a, b: a | b,\n                [BilibiliUser.user_id == int(userid) for userid in dedeuserids],\n            )\n            vgen = vgen.join(BilibiliUser).where(\n                condition\n            )  # this statement does not work.\n        else:\n            vgen = vgen.where(condition)\n        favorites = BilibiliVideo.favorites\n        pubdate = BilibiliVideo.pubdate\n        view = BilibiliVideo.play",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:687-716"
    },
    "835": {
        "file_id": 55,
        "content": "This code retrieves bilibili videos based on a given condition. It takes into account dedeuserids, which are either provided as a list or None. If dedeuserids is not None, it applies the condition to filter the videos by specific users. Finally, it sorts and selects the videos based on favorites, pubdate, and view count.",
        "type": "comment"
    },
    "836": {
        "file_id": 55,
        "content": "        if videoOrder == VideoOrder.FAVORITE:  # this is fake ordering.\n            order = favorites.desc()  # desc\n        elif videoOrder == VideoOrder.VIEW:\n            order = view.desc()  # desc\n        elif videoOrder == VideoOrder.PUBDATE:  # also desc.\n            order = pubdate.desc()  # most recent video.\n        else:\n            order = None\n        if order is not None:\n            vgen = vgen.order_by(order)\n        return vgen\n    # user_video_ids = [v.id for v in vgen or []]\n    # print('user of videos',set([v.poster.user_id for v in vgen or []]))\n    # breakpoint()\n    results = getVgen(\n        BilibiliVideoIndex.search_bm25(keyword).join(\n            BilibiliVideo, on=(BilibiliVideoIndex.rowid == BilibiliVideo.id)\n        ),\n        videoOrder,\n    ).paginate(  # again this is wrong.\n        page_num, page_size\n    )\n    for index, video_index in enumerate(results):\n        bilibiliVideo = BilibiliVideo.get(id=video_index.rowid)  # this shall be fast.\n        # what is the count? you need to reorder?",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:717-742"
    },
    "837": {
        "file_id": 55,
        "content": "The code retrieves videos based on a specified ordering (favorites, view count, or publication date) and performs a search using the BM25 algorithm. It then paginates the results and retrieves additional information for each video by calling `BilibiliVideo.get()`. The code also includes a comment indicating that reordering might be necessary in the future.",
        "type": "comment"
    },
    "838": {
        "file_id": 55,
        "content": "        # bvid = bilibiliVideo.bvid\n        # cover = bilibiliVideo.pic\n        order = None\n        # you should return the video_index.\n        resultList.append((bilibiliVideo, order))\n    # resultList.sort(key=lambda x: x[1])\n    return resultList\ndef searchRegisteredVideos(\n    keyword: str,\n    tid: int = 0,\n    dedeuserid: Union[list[str], str, None] = \"397424026\",\n    videoOrder=VideoOrder.PUBDATE,  # FAVOURITE, VIEW\n    page_num: int = 1,\n    page_size: int = 30,\n):\n    resultList = searchRegisteredVideosAndGetResultList(\n        tid=tid,\n        dedeuserid=dedeuserid,\n        videoOrder=videoOrder,\n        page_num=page_num,\n        page_size=page_size,\n        keyword=keyword,\n    )\n    for v, _ in resultList:\n        yield v  # this is bilibiliVideoIndex, but you also needs the bvid.\ndef searchUserVideos(\n    keyword: str,\n    tid: int = 0,\n    dedeuserid: str = \"397424026\",\n    method: Literal[\"online\", \"bm25\"] = \"online\",\n    use_credential: bool = False,\n    videoOrder=VideoOrder.PUBDATE,  # FAVOURITE, VIEW",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:743-778"
    },
    "839": {
        "file_id": 55,
        "content": "This code defines functions for searching registered and user videos on Bilibili. The functions take a keyword, video order, tid, dedeuserid, page number, and page size as parameters. It searches for videos based on the provided parameters and returns a list of bilibiliVideoIndex objects along with their orders.",
        "type": "comment"
    },
    "840": {
        "file_id": 55,
        "content": "    page_num: int = 1,\n    page_size: int = 30,\n):  # you can support this in database?\n    # you want keyword search or not? it's better than searching in database. i think.\n    # but database search saves bandwidth.\n    # better use semantic search. but now we use hybrid search instead.\n    # hybrid search: metatopic plus bm25\n    # or not?\n    # just dump that shit.\n    # check if keyword overlaps.\n    # how to search my video? and how to measure relevance?\n    if method == \"online\":\n        resultList = []\n        order = None\n        for v in getUserVideos(\n            tid=tid,\n            order=videoOrder,\n            keyword=keyword,\n            dedeuserid=dedeuserid,\n            use_credential=use_credential,\n            stop_on_duplicate=False,\n            page_num=page_num,\n            page_size=page_size,\n        ):\n            # what is the content? plan to update?\n            # print(\"SEARCHED USER VIDEO ID:\", v_id)\n            resultList.append((v, order))\n        # info = u.get_videos(keyword=keyword,order=videoOrder)",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:779-806"
    },
    "841": {
        "file_id": 55,
        "content": "The code performs a hybrid search for videos, combining metatopic and BM25 search algorithms, to find the most relevant results based on a given keyword. It also retrieves video information and stores it in a list for further processing or display.",
        "type": "comment"
    },
    "842": {
        "file_id": 55,
        "content": "    elif method == \"bm25\":\n        # export all video? shit?\n        # you should tokenize the thing.\n        # but this search does not have limitations!\n        resultList = searchRegisteredVideosAndGetResultList(\n            tid=tid,\n            dedeuserid=dedeuserid,\n            videoOrder=videoOrder,\n            page_num=page_num,\n            page_size=page_size,\n            keyword=keyword,\n        )\n    for v, _ in resultList:\n        yield v  # this is bilibiliVideoIndex, but you also needs the bvid.\n# you can make excerpt from video to lure people into viewing your video.\ndef getVideoInfo(bvid: str):\n    v = video.Video(bvid=bvid)\n    info = sync(v.get_info())\n    return info\ndef registerUserVideo(\n    bvid: str,\n    dedeuserid: str,\n    is_mine: bool = False,\n    visible: bool = False,  # no checking on video visibility? maybe we need to do this after search.\n):  # this is the video i just post. must be regularly checked then add to candidate list. you can check it when another call for my videos has been issued.",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:807-837"
    },
    "843": {
        "file_id": 55,
        "content": "The code is performing a search for registered videos on Bilibili platform, utilizing the BM25 search algorithm. It returns the video results without any limitations and allows for further processing like excerpt generation to attract viewers. The code also includes functions for getting video information and registering user videos with optional visibility settings.",
        "type": "comment"
    },
    "844": {
        "file_id": 55,
        "content": "    # register user first, then register the video.\n    # you will store it to database.\n    u = registerUser(dedeuserid, is_mine)\n    # check if exists.\n    v = BilibiliVideo.get_or_none(BilibiliVideo.bvid == bvid)\n    new = v is None\n    if new:\n        BilibiliVideo.create(bvid=bvid, visible=visible, poster=u)  # it must be new.\n    return new\n# grace period to be one day. that's long enough. or not?\n# we still need some more experiment.\ndef checkVideoVisibility(bvid: str, debug: bool = False):\n    visible = False  # you might want some 'err' parameter. but that only indicates inavalibility of certain video, not video flagged as permanently invisible.\n    try:\n        info = getVideoInfo(bvid)  # getting shit? we need some normal video for test.\n        state = info[\"state\"]\n        visible = state == 0\n    except:\n        if debug:\n            import traceback\n            traceback.print_exc()\n            print(\"error when checking video status: %s\" % bvid)\n    return visible\n# check api doc for hint.\ndef checkRegisteredVideo(",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:838-869"
    },
    "845": {
        "file_id": 55,
        "content": "This code is responsible for checking the visibility of a bilibili video. It first checks if the user and video are registered in the database, and then fetches the video information to determine its state. If the state is 0, the video is considered visible; otherwise, it's invisible. In case of an error during the process, the debug parameter can be used to print the exception for further investigation. The code also includes a function to register user and video in the database, and another function for checking if a video has been registered before. The grace period for checking video visibility is set to one day, but it suggests that more experimentation might be needed to optimize this duration.",
        "type": "comment"
    },
    "846": {
        "file_id": 55,
        "content": "    bvid: str,\n    grace_period=datetime.timedelta(days=1),\n    check_interval=datetime.timedelta(hours=1),\n):  # maybe the video is not immediately visible after registration.\n    # check if they are published or not.\n    # ____CI____CI____CI____ (before check video info. decide to check or not.)\n    # __________GP__________ (after check video info. decide to delete or not.)\n    published = False\n    bilibiliVideo = BilibiliVideo.get_or_none(bvid=bvid)\n    now = datetime.datetime.now()\n    needCheck = False\n    if bilibiliVideo:\n        visible = bilibiliVideo.visible\n        needCheck = now - bilibiliVideo.last_check >= check_interval\n        needRemove = now - bilibiliVideo.register_date >= grace_period\n        if (\n            visible and needRemove\n        ):  # do not remove. it just need to be check again, when using checkPublishedVideo. this value is used for double check.\n            published = True\n        else:\n            if needCheck:\n                visible = checkVideoVisibility(bvid)\n                if visible:",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:870-892"
    },
    "847": {
        "file_id": 55,
        "content": "Checks if a video is published or not by comparing its registration date and last check time with the given grace period and check interval. If needed, it calls `checkVideoVisibility` function to verify visibility.",
        "type": "comment"
    },
    "848": {
        "file_id": 55,
        "content": "                    published = True\n                elif needRemove:\n                    bilibiliVideo.delete_instance()\n    # you update that 'last_check' and compare it with 'checkin_date'\n    # you can schedule check every hour. not all the time.\n    # basically the same thing. but we do not delete these video till the time is too late, after check.\n    return published, not needCheck\n# seems bilibili can automatically categorize video.\n# we just need to find out how?\ndef checkPublishedVideo(bvid: str):  # this is only done during retrieval.\n    # if published, the video is taken down afterwards, we will delete it.\n    # check if video is still visible or taken down.\n    # if video is not visible then we delete this video from database.\n    # v = video.Video(bvid=bvid)\n    # print(info)\n    # dict_keys(['bvid', 'aid', 'videos', 'tid', 'tname', 'copyright', 'pic', 'title', 'pubdate', 'ctime', 'desc', 'desc_v2', 'state', 'duration', 'forward', 'rights', 'owner', 'stat', 'dynamic', 'dimension', 'pre",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:893-910"
    },
    "849": {
        "file_id": 55,
        "content": "This code is for a database platform, specifically Bilibili. It checks if videos are still visible or taken down and deletes them if not. The code updates 'last_check' and compares it with 'checkin_date', scheduling check every hour. It also mentions that Bilibili automatically categorizes videos, and this function is used during retrieval to find out how it does so.",
        "type": "comment"
    },
    "850": {
        "file_id": 55,
        "content": "miere', 'teenage_mode', 'is_chargeable_season', 'is_story', 'no_cache', 'subtitle', 'is_season_display', 'user_garb', 'honor_reply', 'like_icon'])\n    #  'state': -4,\n    # bad state! what is the meaning of this state?\n    # normal; state -> 0\n    avaliable = False\n    bilibiliVideo = BilibiliVideo.get_or_none(bvid=bvid)\n    if (\n        bilibiliVideo is not None\n    ):  # might be our 'registered' video but not yet been published.\n        published, needCheckAgain = checkRegisteredVideo(bvid)\n        if published:\n            if not needCheckAgain:\n                published = True\n            else:\n                visible = checkVideoVisibility(bvid)\n                avaliable = visible\n                if not visible:\n                    # remove that thing.\n                    bilibiliVideoIndex = BilibiliVideo.get_or_none(\n                        rowid=bilibiliVideo.id\n                    )\n                    bilibiliVideo.delete_instance()\n                    if bilibiliVideoIndex is not None:\n                        # remove that thing.",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:910-933"
    },
    "851": {
        "file_id": 55,
        "content": "Checking if a Bilibili video with the given bvid exists and is available. If it exists, checks if it has been published or needs further checking. If unpublished or visibility issues, deletes the entry in the database.",
        "type": "comment"
    },
    "852": {
        "file_id": 55,
        "content": "                        bilibiliVideoIndex.delete_instance()\n                else:\n                    bilibiliVideo.last_check = datetime.datetime.now()\n                    bilibiliVideo.visible = True\n                    bilibiliVideo.save()\n    else:\n        print(\"video %s is not registered.\" % bvid)\n    # info['stat'].keys()\n    # dict_keys(['aid', 'view', 'danmaku', 'reply', 'favorite', 'coin', 'share', 'now_rank', 'his_rank', 'like', 'dislike', 'evaluation', 'argue_msg'])\n    # breakpoint()\n    # if anything goes wrong, do not return the state.\n    # if you want update, better do it here. we are checking and updating the video.\n    # we use some random video for test.\n    return avaliable\n# i suggest you to use sqlalchemy. since this is no ordinary task.\n# you cannot just check every video of your own in the past.\n## following code is for test purpose.\n# shall write some server.\n# not fastapi!\ndef searchAndRegisterVideos(\n    query: str,\n    iterate: bool = False,\n    page_start: int = 1,\n    params={\"duration\": BSP.all.duration._10分钟以下},",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:934-963"
    },
    "853": {
        "file_id": 55,
        "content": "This code deletes a bilibiliVideoInstance if it's not registered, otherwise updates the last_check and makes it visible. If something goes wrong, it doesn't return state, and suggests using SQLAlchemy for more complex tasks. The function allows searching and registering videos, with optional parameters like query, iterate, page_start, and params. It mentions testing the code with a random video and recommends writing a server (not FastAPI).",
        "type": "comment"
    },
    "854": {
        "file_id": 55,
        "content": "    # 'order': BSP.all.order.综合排序\n    # # you can add this parameter later on.\n    page_size: int = ...,\n):\n    results = searchVideos(\n        query,\n        iterate=iterate,\n        page_start=page_start,\n        params=params,\n        page_size=page_size,\n    )\n    # db = getBilibiliVideoDatabaseAndCreateTables()\n    # this database connection will be established elsewhere.\n    for v in results:  # shall you called them 'tags' instead of 'tag'.\n        # print(v)\n        # breakpoint()\n        mid, author, upic = v[\"mid\"], v[\"author\"], v[\"upic\"]\n        bilibiliUser, _ = BilibiliUser.get_and_update_or_create(\n            username=author, user_id=mid, avatar=linkFixer(upic)\n        )\n        # v.update({'comment':v['review'],'created':v['pubdate']})\n        bilibiliVideo = indexAndGetVideoObject(v, bilibiliUser)\n        # bilibiliVideo, _ = BilibiliVideo.get_and_update_or_create(\n        #     bvid=v[\"bvid\"],\n        #     typeid=v[\"typeid\"],\n        #     visible=True,  # are you sure?\n        #     last_check=datetime.datetime.now(),  # well this is not tested. test it!",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:964-990"
    },
    "855": {
        "file_id": 55,
        "content": "This code searches videos based on a query and iterate parameter, retrieves results, and establishes a database connection elsewhere. It then iterates through the results, gets or creates BilibiliUser objects, indexes and retrieves video objects for each result, and potentially updates or creates BilibiliVideo objects.",
        "type": "comment"
    },
    "856": {
        "file_id": 55,
        "content": "        #     poster=bilibiliUser,  # is it my account anyway?\n        #     play=v[\"play\"],\n        #     pic=linkFixer(v[\"pic\"]),\n        #     length=videoDurationStringToSeconds(v[\"duration\"]),\n        #     review=v[\"review\"],\n        #     pubdate=v[\"pubdate\"],\n        #     favorites=v[\"favorites\"],\n        #     description=v[\"description\"],\n        #     title=v[\"title\"],\n        #     tag=v[\"tag\"],\n        # )\n        # bilibiliVideoIndex, _ = BilibiliVideoIndex.get_and_update_or_create(\n        #     rowid=bilibiliVideo.id,\n        #     description=textPreprocessing(bilibiliVideo.description),\n        #     tag=textPreprocessing(bilibiliVideo.tag),\n        #     title=textPreprocessing(bilibiliVideo.title),\n        # )\n        yield bilibiliVideo\n# @reloading\ndef getVideoInfosFromVideoGenerator(vgen):\n    vlist = []\n    for v in vgen:\n        if type(v) == BilibiliVideo:\n            vlist.append(v.videoInfoExtractor())\n    return vlist\ndef searchVideosByForm(form:searchUserVideoForm, default_page_size:int=30):",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:991-1019"
    },
    "857": {
        "file_id": 55,
        "content": "This code is retrieving video information from a generator and creating a list of BilibiliVideo objects. It then returns this list after extracting video information from each object in the generator. The get_and_update_or_create function updates or creates a new BilibiliVideoIndex record based on the description, tag, and title fields. The searchVideosByForm function searches for videos using a provided form and a default page size of 30.",
        "type": "comment"
    },
    "858": {
        "file_id": 55,
        "content": "    vgen = searchUserVideos(\n        form.query_for_search,\n        form.tid,\n        form.dedeuserid,\n        form.method,\n        form.use_credential,\n        form.videoOrder,\n        form.page_num,\n        default(form.page_size, default_page_size),\n    )\n    videoInfos = getVideoInfosFromVideoGenerator(vgen)\n    return videoInfos\ndef refresh_latest_video_of_user(uid: int):  # must be online.\n    form = searchUserVideoForm(method=\"online\", tid=0, query=\"\", dedeuserid=str(uid))\n    videoInfos = searchVideosByForm(form)\ndef refresh_status(\n    grace_period=datetime.timedelta(days=1),\n    check_interval=datetime.timedelta(hours=1),\n    sleep: int = 2,\n    target_user_uids: list[int] = [397424026],\n):\n    for uid in target_user_uids:\n        try:\n            refresh_latest_video_of_user(uid)\n            time.sleep(sleep)\n        except:\n            import traceback\n            traceback.print_exc()\n            print(f\"Failed to refresh latest video status of user {uid}\")\n    # what to do? just select and update?\n    # but you need the database object. it is loop dependency!",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:1020-1053"
    },
    "859": {
        "file_id": 55,
        "content": "This code defines functions for searching videos and refreshing the latest video status of a user. The 'searchVideosByForm' function takes search parameters and returns a list of video information. 'refresh_latest_video_of_user' searches for the latest online video of a specified user. In 'refresh_status', the code loops through a list of target users, refreshes their latest video status, and handles exceptions with sleep and error printing. The code seems to be part of a larger system that requires database interaction to select and update records.",
        "type": "comment"
    },
    "860": {
        "file_id": 55,
        "content": "    # well we can split the function.\n    # just for initialization?\n    now_minus_check_interval = datetime.datetime.now() - check_interval\n    selector = BilibiliVideo.select(BilibiliVideo.bvid).where(\n        (BilibiliVideo.last_check < now_minus_check_interval)\n        & (\n            BilibiliVideo.visible == False\n        )  # only check invisible videos. invisible videos will be removed after 1 day of inavaliability.\n    )  # need check or not?\n    print(\"refreshing video status\")\n    for bvid in progressbar.progressbar(selector):\n        checkRegisteredVideo(\n            bvid, grace_period=grace_period, check_interval=check_interval\n        )\n        time.sleep(sleep)\n    return\ndef refresh_status_decorator(func):\n    def wrapper(*args, **kwargs):\n        schedule.run_pending()\n        return func(*args, **kwargs)\n    return wrapper\n@refresh_status_decorator  # this might prevent you adding the decorator everywhere?\ndef getBilibiliVideoDatabaseCreateTablesAndRefreshStatus():\n    db = getBilibiliVideoDatabaseAndCreateTables()",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:1054-1082"
    },
    "861": {
        "file_id": 55,
        "content": "This function initializes a database and checks for invisible Bilibili videos, updating their status after a day of invisibility. It uses progressbar to track progress and sleep for a brief period between iterations. The getBilibiliVideoDatabaseCreateTablesAndRefreshStatus function creates tables and calls the refresh_status decorator on another function.",
        "type": "comment"
    },
    "862": {
        "file_id": 55,
        "content": "    return db\n# somewhere here:\n# https://fastapi.tiangolo.com/es/tutorial/debugging/\n@lru_cache(maxsize=1)\ndef bootstrap():\n    db = getBilibiliVideoDatabaseAndCreateTables()\n    refresh_status()  # ensure the database is connected.\n    schedule.every(20).minutes.do(refresh_status)\ndef bilibiliRecommendationServer(\n    welcome_message=\"bilibili recommendation server\", port=7341\n):\n    bootstrap()\n    from fastapi import FastAPI\n    import uvicorn\n    import pydantic\n    app = FastAPI()\n    @app.get(\"/\")\n    # #@reloading\n    def server_hello():\n        schedule.run_pending()\n        return welcome_message\n    # just asking. post or get?\n    @app.post(\"/searchVideos\")  # what do you want to have? all fields?\n    # #@reloading\n    def search_videos(form: searchVideoForm):\n        # print('received params:',params) # it is str.\n        # breakpoint()\n        schedule.run_pending()\n        params = {\n            \"duration\": BSP.all.duration._10分钟以下\n        } | form.params  # this is default parameter.\n        # breakpoint()",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:1083-1123"
    },
    "863": {
        "file_id": 55,
        "content": "The code initializes the Bilibili video database, sets up a scheduler to refresh the status periodically, and creates a FastAPI application for serving a recommendation server with a welcome message route (\"/\") and a search route (\"/searchVideos\"). The search route accepts a POST request with parameters.",
        "type": "comment"
    },
    "864": {
        "file_id": 55,
        "content": "        vgen = searchAndRegisterVideos(\n            form.query_for_search,\n            iterate=form.iterate,\n            page_start=form.page_num,\n            params=params,\n            page_size=default(form.page_size, ...),\n        )\n        videoInfos = getVideoInfosFromVideoGenerator(vgen)\n        return videoInfos\n    @app.post(\"/searchRegisteredVideos\")\n    # #@reloading\n    def search_registered_videos(form: searchRegisteredVideoForm):\n        schedule.run_pending()\n        vgen = searchRegisteredVideos(\n            form.query_for_search,\n            form.tid,\n            form.dedeuserid,\n            form.videoOrder,\n            form.page_num,\n            default(form.page_size, 30),\n        )\n        videoInfos = getVideoInfosFromVideoGenerator(vgen)\n        return videoInfos\n    @app.post(\"/searchUserVideos\")\n    # #@reloading\n    def search_user_videos(form: searchUserVideoForm):\n        schedule.run_pending()\n        videoInfos = searchVideosByForm(form)\n        return videoInfos\n    @app.post(\"/registerUserVideo\")",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:1124-1157"
    },
    "865": {
        "file_id": 55,
        "content": "This code appears to contain various endpoints for searching and registering videos on a platform. It utilizes form data to query for specific search results, and then retrieves the video information from the generated video generators. It also schedules tasks and handles different types of video forms.",
        "type": "comment"
    },
    "866": {
        "file_id": 55,
        "content": "    # #@reloading\n    def register_user_video(form: registerUserVideoForm):\n        schedule.run_pending()\n        new = registerUserVideo(form.bvid, form.dedeuserid, form.is_mine, form.visible)\n        if new:\n            print(\"----\")\n            print(\"registered user video:\", form.bvid)\n            print(\"user:\", form.dedeuserid)\n            print(\"is_mine:\", form.is_mine)\n            print(\"visible:\", form.visible)\n            print(\"----\")\n        else:\n            print(\"video already registered.\")\n        return {\"is_new\": new}\n    uvicorn.run(app, host=\"0.0.0.0\", port=port)\nif __name__ == \"__main__\":\n    bilibiliRecommendationServer()",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/database.py:1158-1178"
    },
    "867": {
        "file_id": 55,
        "content": "This code registers a user video on Bilibili platform. It utilizes the registerUserVideoForm to store necessary information, schedules pending tasks for execution, and prints details if the registration is successful or not. The code also runs the Uvicorn server for the application, specifying the host and port. If this file is executed directly, it calls bilibiliRecommendationServer() function.",
        "type": "comment"
    },
    "868": {
        "file_id": 56,
        "content": "/pyjom/platforms/bilibili/credentials.py",
        "type": "filepath"
    },
    "869": {
        "file_id": 56,
        "content": "The code handles bilibili login/logout, stores credentials in TinyDB, verifies them and provides functions for SMS-based credential input/removal. It uses a decorator `bilibiliCredential` that retrieves user credentials and wraps function calls with them.",
        "type": "summary"
    },
    "870": {
        "file_id": 56,
        "content": "# you need to manage login/logout and credential storage.\n# first you need to get 'home' directory\nfrom lazero.search.api import getHomeDirectory\nimport os\nfrom bilibili_api import sync, Credential\nfrom bilibili_api.user import get_self_info\nfrom bilibili_api import settings\nfrom bilibili_api.login import (\n    # login_with_password,\n    login_with_sms,\n    send_sms,\n    PhoneNumber,\n    # Check,\n)\nsettings.geetest_auto_open = False\nhome = getHomeDirectory()\ndbPath = os.path.join(home, \".bilibili_api.json\")\nimport tinydb\ndb = tinydb.TinyDB(dbPath)  # is this variable shared in this module?\nUser = tinydb.Query()\ndef verifyCredential(credential, returnName=True):\n    try:\n        name = sync(get_self_info(credential))[\"name\"]\n        print(\"credential is valid for:\", name)\n        db.upsert(\n            {\n                \"name\": name,  # does not show up in credential.\n                \"dedeuserid\": credential.dedeuserid,\n                \"bili_jct\": credential.bili_jct,\n                \"buvid3\": credential.buvid3,\n                \"sessdata\": credential.sessdata,",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/credentials.py:2-38"
    },
    "871": {
        "file_id": 56,
        "content": "The code manages login/logout and credential storage for the Bilibili API. It retrieves the 'home' directory, creates a TinyDB instance at the specified path to store user credentials, and provides a function `verifyCredential` to check if a given credential is valid. The code also sets geetest_auto_open to False and imports necessary modules for Bilibili API interaction.",
        "type": "comment"
    },
    "872": {
        "file_id": 56,
        "content": "            },\n            User.dedeuserid == credential.dedeuserid,\n        )\n        if returnName:\n            return name\n        else:\n            return True\n    except:\n        import traceback\n        traceback.print_exc()\n        print(\"invalid credential:\", credential)\n        return False\ndef removeCredentialByDedeUserId(dedeuserid: str):\n    try:\n        db.remove(User.dedeuserid == dedeuserid)\n        return True\n    except:\n        import traceback\n        traceback.print_exc()\n        print(\n            \"error when removing credential from database for dedeuserid:\", dedeuserid\n        )\n        return False\n# from lazero.program.functools import skipException\nfrom lazero.program.functools import suppressException\n# @skipException(defaultReturn = None, breakpoint_flag=True, debug_flag=True, global_variables=globals(), local_variables=locals()) # send_sms is not definded here. WTF?\n@suppressException(defaultReturn=None, showException=True)  # trycatch based.\ndef getCredentialViaSMS():\n    phone = input(\"请输入手机号：\")",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/credentials.py:39-74"
    },
    "873": {
        "file_id": 56,
        "content": "The code is a Python implementation for managing bilibili credentials. The `getCredentialViaSMS` function allows users to input their phone number and retrieves the corresponding credential via SMS verification. The `removeCredentialByDedeUserId` function removes a credential from the database based on the provided dedeuserid. Both functions handle exceptions using try-except blocks, providing error messages and returning False if any errors occur during execution.",
        "type": "comment"
    },
    "874": {
        "file_id": 56,
        "content": "    print(\"正在登录。\")\n    send_sms(PhoneNumber(phone, country=\"+86\"))  # 默认设置地区为中国大陆\n    code = input(\"请输入验证码：\")\n    c = login_with_sms(PhoneNumber(phone, country=\"+86\"), code)\n    credential = c\n    # first, check if this is a valid credential.\n    name = verifyCredential(credential)\n    return credential, name\ndef getCredentialByDedeUserId(dedeuserid: str = \"397424026\"):\n    dataList = db.search(User.dedeuserid == dedeuserid)\n    if len(dataList) != 1:\n        if len(dataList) != 0:\n            # remove all related records.\n            print(\"multiple credentials found for dedeuserid:\", dedeuserid)\n            removeCredentialByDedeUserId(dedeuserid)\n        else:\n            print(\"no credential found for dedeuserid:\", dedeuserid)\n    else:\n        # check validity.\n        data = dataList[0].copy()\n        print(\"try to login credential fetched from db:\", data)\n        oldName = data.pop(\"name\")\n        print(\"previous name:\", oldName)\n        credential = Credential(**data)\n        name = verifyCredential(credential)",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/credentials.py:75-101"
    },
    "875": {
        "file_id": 56,
        "content": "The code is responsible for logging in to a Bilibili account and retrieving the user's credentials. It first attempts to log in using an SMS verification code, then checks if the provided credential is valid by verifying it with the database. The function `getCredentialByDedeUserId` allows fetching credentials based on the given dedeuserid. If multiple or no credentials are found for the specified id, appropriate error messages are printed and potentially irrelevant records are removed from the database.",
        "type": "comment"
    },
    "876": {
        "file_id": 56,
        "content": "        if name != False:\n            print(\"login successful:\", name)\n            return credential\n        else:\n            print(\"login failed with existing credential for user:\", oldName)\n            removeCredentialByDedeUserId(\n                dedeuserid\n            )  # warning. my credential has been removed because of that async problem. please relogin.\n    # anyway if you are here, nothing in database related to this dedeuserid now.\n    # you choose to login via SMS.\n    while True:\n        # could be troublesome.\n        result = getCredentialViaSMS()\n        if result != None:  # has type check here?\n            credential, name = result\n            if name != False:\n                print(\"登录成功\")\n                # update with this credential!\n                # next, check if this is the credential we need.\n                if credential.dedeuserid == dedeuserid:\n                    return credential\n                else:\n                    print(\"dedeuserid not right.\")\n                    print(",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/credentials.py:102-125"
    },
    "877": {
        "file_id": 56,
        "content": "The code checks if the provided name is not False and prints \"login successful\" along with the name. If the name is False, it prints a failed login message and removes the existing credential associated with the user. The code then allows the user to log in via SMS. It retrieves the credential from SMS and checks if the dedeuserid matches the desired value. If it does, the credential is returned; otherwise, a message is printed indicating that the dedeuserid is incorrect.",
        "type": "comment"
    },
    "878": {
        "file_id": 56,
        "content": "                        \"user %s (dedeuserid: %s) does not have dedeuserid: %s\"\n                        % (name, credential.dedeuserid, dedeuserid)\n                    )\n        else:\n            print(\"登陆失败\")\ndef bilibiliCredential(func):\n    def wrapper(*args, dedeuserid=\"397424026\", **kwargs):\n        credential = getCredentialByDedeUserId(dedeuserid)\n        if type(kwargs) != dict:\n            kwargs = {}\n        return func(*args, **(kwargs | {'credential': credential}))\n    return wrapper",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/credentials.py:126-140"
    },
    "879": {
        "file_id": 56,
        "content": "The code defines a decorator called `bilibiliCredential` that takes a function as input and returns a new function wrapper. The wrapper retrieves the credentials for a specific `dedeuserid`, and if the user exists, it passes the function call with the credential as an argument. If the keyword arguments are not of type dictionary, it converts them into an empty dictionary.",
        "type": "comment"
    },
    "880": {
        "file_id": 57,
        "content": "/pyjom/platforms/bilibili/searchDataParser.py",
        "type": "filepath"
    },
    "881": {
        "file_id": 57,
        "content": "This function parses Bilibili video data, enabling metadata extraction and error handling. It retrieves bvid, pubdate, author name, tags, title, duration, play count, cover image, and description, while disabling specified author-related tags.",
        "type": "summary"
    },
    "882": {
        "file_id": 57,
        "content": "import json\n# from bs4 import BeautifulSoup\nfrom lazero.utils.logger import sprint\nfrom pyjom.platforms.bilibili.utils import (\n    # generatorToList,\n    linkFixer,\n    traceError,\n    extractLinks,\n    videoDurationStringToSeconds,\n    getAuthorKeywords,\n    clearHtmlTags,\n    splitTitleTags,\n    removeAuthorRelatedTags,\n)\ndef parseVideoSearchItem(video, disableList: list = [], debug=False):\n    from pyjom.platforms.bilibili.utils import detectAuthorRelatedKeywords\n    bvid = video[\"bvid\"]\n    pubdate = video[\"pubdate\"]\n    if \"author\" not in disableList:\n        author = video[\"author\"]\n        author_id = video[\n            \"mid\"\n        ]  # this is important. may let us able to find out the fans count.\n    else:\n        author = \"\"\n        author_id = -1\n    author_keywords = getAuthorKeywords(author)\n    if \"tag\" not in disableList:\n        tag = video[\"tag\"]\n        tags = tag.split(\",\")\n        tags = [\n            tag for tag in tags if not detectAuthorRelatedKeywords(tag, author_keywords)\n        ]\n    else:",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/searchDataParser.py:1-37"
    },
    "883": {
        "file_id": 57,
        "content": "Function to parse video search item data from Bilibili platform, takes a video object and an optional list of keywords to disable (author and tag). Extracts bvid, pubdate, author name, author ID, tags, and filters out author-related tags if specified.",
        "type": "comment"
    },
    "884": {
        "file_id": 57,
        "content": "        tags = []\n    if \"typeid\" not in disableList and \"typename\" not in disableList:\n        categoryId = int(video.get(\"typeid\", video.get(\"type_id\")))\n        categoryName = video.get(\"typename\", video.get(\"type_name\"))\n    else:\n        categoryId = 0\n        categoryName = \"\"\n    title = video[\"title\"]  # remove those markers, please?\n    title = clearHtmlTags(title)\n    title = removeAuthorRelatedTags(title, author)\n    title, title_tags = splitTitleTags(\n        title, author_keywords\n    )  # use author for filtering unwanted title tags.\n    duration = video[\"duration\"]  # this is not recommended. we need seconds.\n    play = video.get(\"play\", video.get(\"view\"))  # select some hot videos.\n    cover = video[\"pic\"]\n    cover = linkFixer(cover)\n    if \"description\" not in disableList:\n        description = video.get(\"description\", video.get(\"desc\"))\n        description = clearHtmlTags(description)\n        description = removeAuthorRelatedTags(description, author)\n    else:\n        description = \"\"\n    links_in_description, bgms, description = extractLinks(description)",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/searchDataParser.py:38-61"
    },
    "885": {
        "file_id": 57,
        "content": "The code checks for certain video types and disables them if present in the disable list. It retrieves category ID, category name, title, duration, play count, cover image, and description from the video data. The title is cleaned by removing markers, clearing HTML tags, and filtering unwanted tags using author keywords. Duration and play count are retrieved with fallback options. Cover image is fixed for links. If description is not disabled, it's also cleaned of HTML tags and filtered for author-related tags, and links in the description, background music, and modified description are extracted.",
        "type": "comment"
    },
    "886": {
        "file_id": 57,
        "content": "    duration_seconds = videoDurationStringToSeconds(duration)\n    resultTuple = (\n        author,\n        author_id,\n        bvid,\n        tags,\n        categoryId,\n        categoryName,\n        title,\n        duration_seconds,\n        play,\n        cover,\n        description,\n        links_in_description,\n        bgms,\n        title_tags,\n        pubdate,\n    )\n    if debug:\n        for metadata in resultTuple:\n            print(metadata)\n    from lazero.utils.logger import sprint\n    if debug:\n        sprint()\n    return resultTuple\n# you might want the creater's name, to filter out unwanted parts.\ndef iterateResultList(resultList, debug=False):\n    for video in resultList:\n        # be warned cause all these things might fail.\n        try:\n            if video[\"type\"] == \"video\":\n                yield parseVideoSearchItem(video, debug=debug)\n        except:\n            traceError(\"error iterating video metadata\")\n            continue\ndef parseSearchAllResult(data, debug=False):\n    # if not generator:\n    #     return generatorToList(parseSearchAllResult(data, debug=debug,generator=True))",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/searchDataParser.py:62-106"
    },
    "887": {
        "file_id": 57,
        "content": "The code defines functions for parsing and iterating through search results from a specific platform, bilibili. It converts video duration strings to seconds, extracts relevant metadata, and handles potential errors during iteration.",
        "type": "comment"
    },
    "888": {
        "file_id": 57,
        "content": "    results = data[\"result\"]\n    for elem in results:\n        try:\n            if elem[\"result_type\"] == \"video\":\n                resultList = elem[\"data\"]\n                for videoMetadata in iterateResultList(resultList, debug=debug):\n                    yield videoMetadata\n        except:\n            traceError(\"error iterating data results\")\ndef parseSearchVideoResult(data, debug=False):\n    # if not generator:\n    #     return generatorToList(parseSearchVideoResult(data, debug=debug,generator=True))\n    try:\n        resultList = data[\"result\"]\n        try:\n            for videoMetadata in iterateResultList(resultList, debug=debug):\n                try:\n                    yield videoMetadata\n                except:\n                    traceError(\"error iterating video metadata\")\n        except:\n            traceError(\"error iterating result list\")\n    except:\n        traceError(\"error parsing search video result\")\ndef parseVideoInfo(videoInfo, debug=False):\n    data = videoInfo\n    # no tag out here.\n    secondaryVideoInfoList = []",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/searchDataParser.py:107-138"
    },
    "889": {
        "file_id": 57,
        "content": "The code defines functions for parsing search video results and video information from data. It iterates through the results, extracting relevant metadata, and handles potential errors during the process. The parsed results are then yielded or converted to a list if necessary.",
        "type": "comment"
    },
    "890": {
        "file_id": 57,
        "content": "    data_copy = data.copy()\n    data_copy.update({\"author\": data[\"owner\"][\"name\"], \"mid\": data[\"owner\"][\"mid\"]})\n    data_copy.update(data[\"stat\"])\n    primaryVideoInfo = parseVideoSearchItem(\n        data_copy, disableList=[\"tag\", \"typeid\", \"typename\"], debug=debug\n    )\n    # videoInfoList.append(primaryVideoInfo)\n    season = data.get(\"ugc_season\", {})  # we only care about this thing.\n    season_cover = season.get(\"cover\", None)  # it could be noting.\n    sections = season.get(\"sections\", [])\n    for section in sections:\n        for episode in section[\"episodes\"]:\n            # print(episode.keys())\n            # breakpoint()\n            arc = episode[\"arc\"]\n            stat = arc[\"stat\"]\n            videoInfo = episode.copy()\n            videoInfo.update(stat)\n            videoInfo.update(arc)\n            authorRelatedVideoInfo = parseVideoSearchItem(\n                videoInfo,\n                disableList=[\"tag\", \"typeid\", \"typename\", \"description\", \"author\"],\n                debug=debug,\n            )  # author is the same as the original video.",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/searchDataParser.py:139-162"
    },
    "891": {
        "file_id": 57,
        "content": "This code parses bilibili search data and extracts relevant information. It creates a primary video info, updates it with necessary attributes, handles seasonal content, and iterates through episodes to create individual video infos for each episode. This is done by updating video stats and arc attributes, then calling parseVideoSearchItem function. The author remains the same as the original video.",
        "type": "comment"
    },
    "892": {
        "file_id": 57,
        "content": "            secondaryVideoInfoList.append(authorRelatedVideoInfo)\n            # BV1Cb4y1s7em\n            # []\n            # 0\n            # 这次真的燃起来了！！！\n            # 217\n            # 27911\n            # http://i2.hdslb.com/bfs/archive/c5a0d18ee077fb6a4ac0970ccb0a3788e137d14f.jpg\n    return primaryVideoInfo, secondaryVideoInfoList\ndef parseVideoRelated(videoRelatedData, debug=False):\n    data = videoRelatedData\n    # if not generator:\n    #     return generatorToList(parseVideoRelated(data, debug=debug,generator=True))\n    try:\n        for videoInfo in data:\n            try:\n                videoInfo2 = videoInfo.copy()\n                videoInfo2.update({\"author\": videoInfo[\"owner\"][\"name\"]})\n                videoInfo2.update({\"mid\": videoInfo[\"owner\"][\"mid\"]})\n                # also update the stat.\n                videoInfo2.update(videoInfo[\"stat\"])\n                try:\n                    yield parseVideoSearchItem(\n                        videoInfo2,\n                        disableList=[\"tag\", \"typeid\", \"typename\"],",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/searchDataParser.py:163-190"
    },
    "893": {
        "file_id": 57,
        "content": "This function parses video-related data and returns the primary video information and a list of secondary video information. It updates the video information with the author's name, ID, and statistics before yielding the result.",
        "type": "comment"
    },
    "894": {
        "file_id": 57,
        "content": "                        debug=debug,\n                    )\n                    # print(videoMetadata)\n                except:\n                    traceError()\n            except:\n                traceError()\n    except:\n        traceError()\nif __name__ == \"__main__\":\n    # fake tests.\n    # test_subject = \"search_video\"\n    # test_subject = \"search_all\"\n    # test_subject = 'video_related'\n    test_subject = \"video_info\"\n    # test_subject = 'extract_links'\n    if test_subject == \"search_all\":\n        with open(\"search_result_all.json\", \"r\") as f:\n            data = f.read()\n            data = json.loads(data)\n        for mresult in parseSearchAllResult(data):\n            print(\"RESULT:\")\n            sprint(mresult)\n    elif test_subject == \"search_video\":\n        with open(\"search_by_type_result_video.json\", \"r\") as f:\n            data = f.read()\n            data = json.loads(data)\n        for mresult in parseSearchVideoResult(data):\n            print(\"VIDEO SEARCH RESULT:\")\n            sprint(mresult)\n    elif test_subject == \"video_info\":",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/searchDataParser.py:191-223"
    },
    "895": {
        "file_id": 57,
        "content": "The code is running tests on a Python module for parsing search results and video information from Bilibili. It executes the main function with different test subjects, such as \"search_all\", \"search_video\", \"video_info\", and \"extract_links\". If an error occurs during execution, it calls a \"traceError\" function to log the exception.",
        "type": "comment"
    },
    "896": {
        "file_id": 57,
        "content": "        with open(\"video_info.json\", \"r\") as f:\n            data = f.read()\n            data = json.loads(data)\n        primaryVideoInfo, secondaryVideoInfoList = parseVideoInfo(data)\n        videoInfoList = [primaryVideoInfo] + secondaryVideoInfoList\n        for mVideoInfo in videoInfoList:\n            print(mVideoInfo)\n            sprint()\n    elif test_subject == \"video_related\":\n        with open(\"video_related.json\", \"r\") as f:\n            data = f.read()\n            data = json.loads(data)\n        for videoMetadata in parseVideoRelated(data):\n            print(videoMetadata)\n            sprint()\n    elif test_subject == \"extract_links\":\n        description = (\n            \"http://www.toutiao.com/a6347649852365897986/ 男子送走从小养大的狗，狗狗用泪汪汪的眼神看着他\\n\"\n            + \"https://www.youtube.com/watch?v=r724w57oXyU\"\n            + \" https://www.youtube.com/shorts/UYCy8HD1C7o\"\n        )\n        links, desc = extractLinks(description)\n        print(links)\n        print(desc)\n    else:\n        raise Exception(\"unknown test_subject:\", test_subject)",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/searchDataParser.py:224-249"
    },
    "897": {
        "file_id": 57,
        "content": "This code block handles different cases for parsing data from JSON files and extracting links from descriptions. It loads data from \"video_info.json\" or \"video_related.json\", processes it using parseVideoInfo or parseVideoRelated functions, then prints the results. If test_subject is \"extract_links\", it extracts links from a given description using extractLinks function and prints them. For any other test_subject, an Exception is raised.",
        "type": "comment"
    },
    "898": {
        "file_id": 58,
        "content": "/pyjom/platforms/bilibili/postMetadata.py",
        "type": "filepath"
    },
    "899": {
        "file_id": 58,
        "content": "The code filters videos, generates Bilibili post metadata, supports language selection and error handling, extracts video metadata, fetches related videos, applies limits, and generates covers and descriptions for dog or cat topics.",
        "type": "summary"
    }
}