{
    "1500": {
        "file_id": 115,
        "content": "        if name != False:\n            print(\"login successful:\", name)\n            return credential\n        else:\n            print(\"login failed with existing credential for user:\", oldName)\n            removeCredentialByDedeUserId(\n                dedeuserid\n            )  # warning. my credential has been removed because of that async problem. please relogin.\n    # anyway if you are here, nothing in database related to this dedeuserid now.\n    # you choose to login via SMS.\n    while True:\n        # could be troublesome.\n        result = getCredentialViaSMS()\n        if result != None:  # has type check here?\n            credential, name = result\n            if name != False:\n                print(\"登录成功\")\n                # update with this credential!\n                # next, check if this is the credential we need.\n                if credential.dedeuserid == dedeuserid:\n                    return credential\n                else:\n                    print(\"dedeuserid not right.\")\n                    print(",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/credentials.py:102-125"
    },
    "1501": {
        "file_id": 115,
        "content": "The code checks if the provided name is not False and prints \"login successful\" along with the name. If the name is False, it prints a failed login message and removes the existing credential associated with the user. The code then allows the user to log in via SMS. It retrieves the credential from SMS and checks if the dedeuserid matches the desired value. If it does, the credential is returned; otherwise, a message is printed indicating that the dedeuserid is incorrect.",
        "type": "comment"
    },
    "1502": {
        "file_id": 115,
        "content": "                        \"user %s (dedeuserid: %s) does not have dedeuserid: %s\"\n                        % (name, credential.dedeuserid, dedeuserid)\n                    )\n        else:\n            print(\"登陆失败\")\ndef bilibiliCredential(func):\n    def wrapper(*args, dedeuserid=\"397424026\", **kwargs):\n        credential = getCredentialByDedeUserId(dedeuserid)\n        if type(kwargs) != dict:\n            kwargs = {}\n        return func(*args, **(kwargs | {'credential': credential}))\n    return wrapper",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/credentials.py:126-140"
    },
    "1503": {
        "file_id": 115,
        "content": "The code defines a decorator called `bilibiliCredential` that takes a function as input and returns a new function wrapper. The wrapper retrieves the credentials for a specific `dedeuserid`, and if the user exists, it passes the function call with the credential as an argument. If the keyword arguments are not of type dictionary, it converts them into an empty dictionary.",
        "type": "comment"
    },
    "1504": {
        "file_id": 116,
        "content": "/pyjom/primitives/localPrimitives.py",
        "type": "filepath"
    },
    "1505": {
        "file_id": 116,
        "content": "The code defines a class for content reviewing, and two classes for automatic content reviewing and producing. The classes have configuration parameters and methods for file operations and topic associations. A producer instance is defined with filters, template, and template_config options.",
        "type": "summary"
    },
    "1506": {
        "file_id": 116,
        "content": "from pyjom.main import *\nclass FilesystemContentReviewer(ContentReviewer):\n    def __init__(self, filepath=None, dirpath=None, recursive=False, enable_log=True):\n        super().__init__()\n        if filepath is None:\n            assert dirpath is not None\n        else:\n            raise Exception(\"filepath and dirpath cannot both be None.\")\n        self.filepath = filepath\n        self.dirpath = dirpath\n        self.recursive = recursive\n        if enable_log:\n            self.log_location = \"logs/local/\"\n        self.identifier.typeFix(type(self).__name__)\n        self.methodsList.update(\n            {\n                \"topic\": filesystemTopicGenerator,  # how to generate this?\n                \"fetcher\": filesystemFetcher,\n                \"reviewer\": filesystemReviewer,\n            }\n        )\n    def get_one_topic(self):\n        topic, source = self.methodsList[\"topic\"](\n            filepath=self.filepath, dirpath=self.dirpath, recursive=self.recursive\n        )  # a sequence of things.\n        self.identifier.topicFix(source)",
        "type": "code",
        "location": "/pyjom/primitives/localPrimitives.py:1-29"
    },
    "1507": {
        "file_id": 116,
        "content": "This code defines a class, FilesystemContentReviewer, which is a subclass of ContentReviewer. It initializes with optional filepath or dirpath, recursive flag, and enable_log boolean. If enable_log is True, it sets the log_location. The class has a method, get_one_topic(), that retrieves one topic using specified parameters. It also defines three methods (topic, fetcher, reviewer) within its methodsList attribute.",
        "type": "comment"
    },
    "1508": {
        "file_id": 116,
        "content": "        return topic\nclass FilesystemAutoContentReviewer(FilesystemContentReviewer):\n    def __init__(\n        self,\n        filepath=None,\n        dirpath=None,\n        recursive=False,\n        enable_log=True,\n        semiauto=True,\n        dummy_auto=True,\n        template_names=[],\n        args={},\n    ):\n        super().__init__(\n            filepath=filepath,\n            dirpath=dirpath,\n            recursive=recursive,\n            enable_log=enable_log,\n        )\n        self.identifier.typeFix(type(self).__name__)\n        self.methodsList.update(\n            {\n                \"reviewer\": keywordDecorator(\n                    filesystemReviewer,\n                    auto=True,\n                    semiauto=semiauto,\n                    dummy_auto=dummy_auto,\n                    template_names=template_names,\n                    args=args,\n                )\n            }\n        )\nclass FilesystemAutoContentProducer(ContentProducer):\n    def __init__(self, filepath=None, dirpath=None, recursive=False, enable_log=T",
        "type": "code",
        "location": "/pyjom/primitives/localPrimitives.py:30-66"
    },
    "1509": {
        "file_id": 116,
        "content": "The code defines two classes, `FilesystemAutoContentReviewer` and `FilesystemAutoContentProducer`, which inherit from `FilesystemContentReviewer` and `ContentProducer` respectively. These classes have various parameters for configuration such as file/directory paths, recursive mode, logging settings, and template names. They also have methods for automatic content reviewing and producing.",
        "type": "comment"
    },
    "1510": {
        "file_id": 116,
        "content": "rue,reviewerLogs = [],processor_filters={},producer_filters={}, path_replacers = [], template=\"pets_with_music\", template_config = {}):\n        super().__init__()\n        if filepath is None:\n            assert dirpath is not None\n        else:\n            raise Exception(\"filepath and dirpath cannot both be None.\")\n        self.filepath = filepath\n        self.dirpath = dirpath\n        self.recursive = recursive\n        self.reviewerLogs = reviewerLogs\n        if enable_log:\n            self.log_location = \"logs/local/\"\n        self.identifier.typeFix(type(self).__name__)\n        self.methodsList.update(\n            {\n                \"topic\": filesystemTopicGenerator,  # how to generate this?\n                \"info\": filesystemFetcher, # can you do that?\n                \"processor\": keywordDecorator(FilesystemProcessor,reviewerLogs=self.reviewerLogs,filters=processor_filters, path_replacers = path_replacers), # this is the second thing. how do you process this?\n                # \"reviewer\": filesystemReviewer,",
        "type": "code",
        "location": "/pyjom/primitives/localPrimitives.py:66-84"
    },
    "1511": {
        "file_id": 116,
        "content": "The code represents a class with file operations. The constructor takes parameters such as filepath, dirpath, recursive flag, reviewerLogs, enable_log, and type name. If filepath is None, it checks if dirpath is not None to avoid both being None. It also sets up log location and updates methods list. \"topic\" method generates a topic, \"info\" method fetches information, and \"processor\" method processes using keyword decorator with given parameters.",
        "type": "comment"
    },
    "1512": {
        "file_id": 116,
        "content": "                \"producer\": keywordDecorator(FilesystemProducer, filters=producer_filters, template=template,template_config = template_config),\n            }\n        )\n    def get_one_topic(self):\n        topic, source = self.methodsList[\"topic\"](\n            filepath=self.filepath, dirpath=self.dirpath, recursive=self.recursive\n        )  # a sequence of things.\n        self.identifier.topicFix(source)\n        return topic\n# ctrl + shift + t: reopen closed tab in vscode",
        "type": "code",
        "location": "/pyjom/primitives/localPrimitives.py:85-95"
    },
    "1513": {
        "file_id": 116,
        "content": "This code defines a class with methods to get a topic and its associated source, using filepath, dirpath, and recursive parameters. The \"producer\" is defined as a keyword-decorated instance of the FilesystemProducer class, with filters, template, and template_config options. The get_one_topic method returns the topic after applying topicFix from the identifier object.",
        "type": "comment"
    },
    "1514": {
        "file_id": 117,
        "content": "/pyjom/primitives/__init__.py",
        "type": "filepath"
    },
    "1515": {
        "file_id": 117,
        "content": "This code imports multiple modules from the same package, likely for accessing different sets of primitives.",
        "type": "summary"
    },
    "1516": {
        "file_id": 117,
        "content": "from pyjom.primitives.localPrimitives import *\nfrom pyjom.primitives.weiboPrimitives import *\nfrom pyjom.primitives.onlinePrimitives import *",
        "type": "code",
        "location": "/pyjom/primitives/__init__.py:1-3"
    },
    "1517": {
        "file_id": 117,
        "content": "This code imports multiple modules from the same package, likely for accessing different sets of primitives.",
        "type": "comment"
    },
    "1518": {
        "file_id": 118,
        "content": "/pyjom/primitives/onlinePrimitives.py",
        "type": "filepath"
    },
    "1519": {
        "file_id": 118,
        "content": "The code defines the OnlineAutoContentProducer class, initializes variables, updates methodsList with keywordDecorator wrapped instances for content production, and creates OnlineProducer/Poster with multi-platform posting capabilities.",
        "type": "summary"
    },
    "1520": {
        "file_id": 118,
        "content": "from pyjom.main import *\nfrom typing import Generator\nfrom types import FunctionType\nclass OnlineAutoContentProducer(ContentProducer):\n    def __init__(\n        self,\n        source=None,\n        debug=False,\n        enable_log=True,\n        fast: bool = True,\n        afterPosting: FunctionType = ...,\n        postMetadataGenerator: Generator = ...,\n        processor_filters={},\n        producer_filters={},\n        platform: str = \"bilibili\",\n        template: str = \"pets_with_music_online\",\n        template_configs: list = [],  # list or 'template_config' generator\n        contentType: str = \"video\",  # for poster.\n        tempdir: str = \"/dev/shm/medialang/online\",\n        metaTopic={\n            \"static\": [[\"dog\", \"cat\", \"puppy\"], [\"funny\", \"cute\"]],\n            \"dynamic\": [[\"samoyed\", \"husky\", \"teddy\", \"chiwawa\"]],\n        },\n        dog_or_cat='dog',\n    ):  # something in this metaTopic is not droppable.\n        super().__init__()\n        # do afterPosting before even start it.\n        # now we might want to check our product before another test.",
        "type": "code",
        "location": "/pyjom/primitives/onlinePrimitives.py:1-30"
    },
    "1521": {
        "file_id": 118,
        "content": "The code defines a class called `OnlineAutoContentProducer` which extends the `ContentProducer` class. It has various parameters such as `source`, `debug`, `enable_log`, `fast`, etc., and uses functions from other modules, including `FunctionType` and `Generator`. The constructor initializes the object by calling the parent's constructor using `super().__init__()`, and there is a note that `afterPosting` should be performed before starting. The `metaTopic` dictionary contains categories for static and dynamic content.",
        "type": "comment"
    },
    "1522": {
        "file_id": 118,
        "content": "        try:\n            afterPosting()\n        except:\n            pass\n        assert source is not None\n        self.source = source\n        self.tempdir = tempdir\n        self.fast = fast\n        self.metaTopic = metaTopic  # 所谓的超话 超级话题\n        if enable_log:\n            self.log_location = \"logs/local/\"  # what location?\n        self.identifier.typeFix(type(self).__name__)\n        self.methodsList.update(\n            {\n                \"topic\": keywordDecorator(\n                    OnlineTopicGenerator, source=source, metaTopic=metaTopic\n                ),  # how to generate this?\n                \"info\": keywordDecorator(\n                    OnlineFetcher, source=source, tempdir=tempdir\n                ),  # can you do that?\n                \"processor\": keywordDecorator(\n                    OnlineProcessor, source=source, dog_or_cat=dog_or_cat\n                ),  # this is the second thing. how do you process this?\n                # \"reviewer\": filesystemReviewer,\n                \"producer\": keywordDecorator(",
        "type": "code",
        "location": "/pyjom/primitives/onlinePrimitives.py:31-55"
    },
    "1523": {
        "file_id": 118,
        "content": "This code attempts to set up various methods for a class. It initializes instance variables, handles logging location if enabled, and updates the methodsList dictionary with keywordDecorator wrapped OnlineTopicGenerator, OnlineFetcher, and OnlineProcessor instances based on provided arguments. The \"reviewer\" method is not implemented, and the \"producer\" method uses keywordDecorator with source argument for its implementation.",
        "type": "comment"
    },
    "1524": {
        "file_id": 118,
        "content": "                    OnlineProducer,  # what does this 'OnlineProducer' generate?\n                    source=source,\n                    template=template,\n                    fast=self.fast,\n                    template_configs=template_configs,\n                    debug=debug,  # overkill?\n                ),\n                \"poster\": keywordDecorator(\n                    OnlinePoster,  # you need to be prudent. this is not kids stuff. figure out how to post to multiple platforms the same time, figure out how to post to individual platform one by one.\n                    iterate=True,\n                    contentType=contentType,\n                    postMetadataGenerator=postMetadataGenerator,\n                    platform=platform,\n                    afterPosting=afterPosting,\n                )  # just for debugging.\n                # you also need to change the logic below, for other 'dummy' stuffs.\n                # 'poster':keywordDecorator(dummyPoster, iterate=True) # just for debugging.\n            }",
        "type": "code",
        "location": "/pyjom/primitives/onlinePrimitives.py:56-73"
    },
    "1525": {
        "file_id": 118,
        "content": "This code creates an instance of OnlineProducer and OnlinePoster, decorating the latter with a keywordDecorator for multi-platform posting. The OnlineProducer generates content based on source and template, while the OnlinePoster can post to multiple platforms simultaneously or individually. The debug option is used for testing purposes.",
        "type": "comment"
    },
    "1526": {
        "file_id": 118,
        "content": "        )",
        "type": "code",
        "location": "/pyjom/primitives/onlinePrimitives.py:74-74"
    },
    "1527": {
        "file_id": 118,
        "content": "This line of code is closing a parenthesis, which could potentially be part of a function call or mathematical expression. It indicates that the previous statement or operation has been completed and there are no further instructions to follow within this context.",
        "type": "comment"
    },
    "1528": {
        "file_id": 119,
        "content": "/pyjom/primitives/weiboPrimitives.py",
        "type": "filepath"
    },
    "1529": {
        "file_id": 119,
        "content": "This code defines a class `WeiboPetsReviewer` that inherits from `ContentReviewer`. It has various parameters for configuration and updates the `methodsList` with different methods like \"topic\", \"fetcher\", \"reviewer\", and \"feedback\". The reviewer is meant to automate content labeling tasks.",
        "type": "summary"
    },
    "1530": {
        "file_id": 119,
        "content": "from pyjom.main import *\nfrom pyjom.commons import *\n# this is a reviewer, not a poster.\n# you may create interface to label the content and automate the stuff altogether.\nclass WeiboPetsReviewer(ContentReviewer):\n    def __init__(self, enable_log=True, auto=False,semiauto=True, dummy_auto=True,\n        template_names=[],args={},basedir=\"/dev/shm/sina\",autopurge=True):\n        super().__init__()\n        if enable_log:\n            self.log_location = \"logs/sina/pets/\"\n        if autopurge:\n            shutil.rmtree(basedir)\n        self.identifier.typeFix(type(self).__name__)\n        self.methodsList.update(\n            {\n                \"topic\": petsTopicGenerator,\n                \"fetcher\": weiboFetcher,\n                \"reviewer\": keywordDecorator(weiboSearchReviewer, basedir=basedir,auto=auto,semiauto=semiauto,dummy_auto=dummy_auto,template_names=template_names,args=args),\n                \"feedback\": weiboFeedback,\n            }\n        )",
        "type": "code",
        "location": "/pyjom/primitives/weiboPrimitives.py:1-23"
    },
    "1531": {
        "file_id": 119,
        "content": "This code defines a class `WeiboPetsReviewer` that inherits from `ContentReviewer`. It has various parameters for configuration and updates the `methodsList` with different methods like \"topic\", \"fetcher\", \"reviewer\", and \"feedback\". The reviewer is meant to automate content labeling tasks.",
        "type": "comment"
    },
    "1532": {
        "file_id": 120,
        "content": "/pyjom/config/shared.py",
        "type": "filepath"
    },
    "1533": {
        "file_id": 120,
        "content": "The code initializes a dictionary named \"pyjom_config\" with a single key-value pair. The key is \"BEZIER_PADDLE_RESNET50_IMAGE_DOG_CAT_DETECTOR_SERVER_INSTANCE\", and its value is set to False. This configuration appears to relate to various components of an image detection system, possibly including a Bezier paddle, Paddle ResNet50 model, Dog/Cat detector, and server instance.",
        "type": "summary"
    },
    "1534": {
        "file_id": 120,
        "content": "pyjom_config=dict(BEZIER_PADDLE_RESNET50_IMAGE_DOG_CAT_DETECTOR_SERVER_INSTANCE=False)",
        "type": "code",
        "location": "/pyjom/config/shared.py:1-1"
    },
    "1535": {
        "file_id": 120,
        "content": "The code initializes a dictionary named \"pyjom_config\" with a single key-value pair. The key is \"BEZIER_PADDLE_RESNET50_IMAGE_DOG_CAT_DETECTOR_SERVER_INSTANCE\", and its value is set to False. This configuration appears to relate to various components of an image detection system, possibly including a Bezier paddle, Paddle ResNet50 model, Dog/Cat detector, and server instance.",
        "type": "comment"
    },
    "1536": {
        "file_id": 121,
        "content": "/pyjom/config/__init__.py",
        "type": "filepath"
    },
    "1537": {
        "file_id": 121,
        "content": "This code imports all functions and variables from the \"sina\" and \"medialang\" modules within the pyjom.config package. These modules may contain configurations for different components or services used in the application, potentially related to Sina Weibo and Media Language processing.",
        "type": "summary"
    },
    "1538": {
        "file_id": 121,
        "content": "from pyjom.config.sina import *\nfrom pyjom.config.medialang import *",
        "type": "code",
        "location": "/pyjom/config/__init__.py:1-2"
    },
    "1539": {
        "file_id": 121,
        "content": "This code imports all functions and variables from the \"sina\" and \"medialang\" modules within the pyjom.config package. These modules may contain configurations for different components or services used in the application, potentially related to Sina Weibo and Media Language processing.",
        "type": "comment"
    },
    "1540": {
        "file_id": 122,
        "content": "/pyjom/config/sina/__init__.py",
        "type": "filepath"
    },
    "1541": {
        "file_id": 122,
        "content": "The code imports all the functions, classes, and variables from the \"sinaWeibo\" module in the \"pyjom.config.sina\" package.",
        "type": "summary"
    },
    "1542": {
        "file_id": 122,
        "content": "from pyjom.config.sina.sinaWeibo import *",
        "type": "code",
        "location": "/pyjom/config/sina/__init__.py:1-1"
    },
    "1543": {
        "file_id": 122,
        "content": "The code imports all the functions, classes, and variables from the \"sinaWeibo\" module in the \"pyjom.config.sina\" package.",
        "type": "comment"
    },
    "1544": {
        "file_id": 123,
        "content": "/pyjom/config/sina/sinaWeibo.py",
        "type": "filepath"
    },
    "1545": {
        "file_id": 123,
        "content": "The code defines a dictionary named \"sinaWeiboApi\" with three API endpoints for interacting with Sina Weibo. The \"search_with_page\" endpoint performs search queries, \"weibo_status_by_blogid\" retrieves a specific weibo status by blog ID, and \"weibo_build_comments\" fetches comments for a given weibo status.",
        "type": "summary"
    },
    "1546": {
        "file_id": 123,
        "content": "sinaWeiboApi = {\n    \"search_with_page\": \"http://sinanews.sina.cn/interface/type_of_search.d.html?callback=initFeed&keyword={}&page={}&type=siftWb&size=20&newpage=0&chwm=&imei=&token=&did=&from=&oldchwm=\",\n    \"weibo_status_by_blogid\": \"https://www.weibo.com/ajax/statuses/show?id={}\",\n    \"weibo_build_comments\": \"https://weibo.com/ajax/statuses/buildComments?flow=0&is_reload=1&count={}&id={}&is_show_bulletin=2&is_mix=0&uid={}\",\n}",
        "type": "code",
        "location": "/pyjom/config/sina/sinaWeibo.py:1-5"
    },
    "1547": {
        "file_id": 123,
        "content": "The code defines a dictionary named \"sinaWeiboApi\" with three API endpoints for interacting with Sina Weibo. The \"search_with_page\" endpoint performs search queries, \"weibo_status_by_blogid\" retrieves a specific weibo status by blog ID, and \"weibo_build_comments\" fetches comments for a given weibo status.",
        "type": "comment"
    },
    "1548": {
        "file_id": 124,
        "content": "/pyjom/config/medialang/protocols.py",
        "type": "filepath"
    },
    "1549": {
        "file_id": 124,
        "content": "The code defines a dictionary named `medialangProtocols` with two keys: \"input\" and \"output\". The \"input\" key holds an array of protocols for input data sources, while the \"output\" key holds an array of protocols for output data destinations.",
        "type": "summary"
    },
    "1550": {
        "file_id": 124,
        "content": "medialangProtocols = {\n    \"input\": [\"http://\", \"https://\", \"text://\", \"subtitle://\", \"sinafetch://\"],\n    \"output\": [\"bilibili_post://\"],\n}",
        "type": "code",
        "location": "/pyjom/config/medialang/protocols.py:1-4"
    },
    "1551": {
        "file_id": 124,
        "content": "The code defines a dictionary named `medialangProtocols` with two keys: \"input\" and \"output\". The \"input\" key holds an array of protocols for input data sources, while the \"output\" key holds an array of protocols for output data destinations.",
        "type": "comment"
    },
    "1552": {
        "file_id": 125,
        "content": "/pyjom/config/medialang/__init__.py",
        "type": "filepath"
    },
    "1553": {
        "file_id": 125,
        "content": "This code imports all modules from the \"pyjom.config.medialang.protocols\" package into the current namespace, allowing access to various media language protocols used within the application.",
        "type": "summary"
    },
    "1554": {
        "file_id": 125,
        "content": "from pyjom.config.medialang.protocols import *",
        "type": "code",
        "location": "/pyjom/config/medialang/__init__.py:1-1"
    },
    "1555": {
        "file_id": 125,
        "content": "This code imports all modules from the \"pyjom.config.medialang.protocols\" package into the current namespace, allowing access to various media language protocols used within the application.",
        "type": "comment"
    },
    "1556": {
        "file_id": 126,
        "content": "/pyjom/templates/medialang/autoCensor/frameborder_detector.mdl.j2",
        "type": "filepath"
    },
    "1557": {
        "file_id": 126,
        "content": "This code defines a template for frameborder_detector, which takes in model and config as parameters. By default, the model is framedifference_talib, but it can be configured to be huffline_horizontal_vertical. The output includes main frame time and location, possibly from a moving object.",
        "type": "summary"
    },
    "1558": {
        "file_id": 126,
        "content": "(\".json\", processor=\"frameborder_detector\" {% if model %}, model=\"{{model}}\"{% endif %} {% if config %}, config={{config}}{% endif %}\n) # model default to be framedifference_talib, or config it to be huffline_horizontal_vertical, only output main frame time and location. might be moving. i don't know. maybe we need to eliminate all moving things.\n(\"{{ mediafile }}\")",
        "type": "code",
        "location": "/pyjom/templates/medialang/autoCensor/frameborder_detector.mdl.j2:1-4"
    },
    "1559": {
        "file_id": 126,
        "content": "This code defines a template for frameborder_detector, which takes in model and config as parameters. By default, the model is framedifference_talib, but it can be configured to be huffline_horizontal_vertical. The output includes main frame time and location, possibly from a moving object.",
        "type": "comment"
    },
    "1560": {
        "file_id": 127,
        "content": "/pyjom/templates/medialang/autoCensor/yolov5_detector.mdl.j2",
        "type": "filepath"
    },
    "1561": {
        "file_id": 127,
        "content": "This code is creating a tuple containing a JSON file with optional parameters for timestep, threshold and model name, along with the media file path.",
        "type": "summary"
    },
    "1562": {
        "file_id": 127,
        "content": "(\".json\", processor=\"yolov5_detector\"{% if timestep %}, timestep={{timestep}}{% endif %} {% if threshold %}, threshold={{threshold}}{% endif %} {% if model %}, model=\"{{model}}\"{% endif %}\n)\n(\"{{ mediafile }}\")",
        "type": "code",
        "location": "/pyjom/templates/medialang/autoCensor/yolov5_detector.mdl.j2:1-4"
    },
    "1563": {
        "file_id": 127,
        "content": "This code is creating a tuple containing a JSON file with optional parameters for timestep, threshold and model name, along with the media file path.",
        "type": "comment"
    },
    "1564": {
        "file_id": 128,
        "content": "/pyjom/templates/medialang/autoCensor/file_format_detector.mdl.j2",
        "type": "filepath"
    },
    "1565": {
        "file_id": 128,
        "content": "This code snippet defines a tuple containing the file format \"json\" and specifies the processor \"file_format_detector\". The mediafile variable is used within double curly braces to represent the file's content.",
        "type": "summary"
    },
    "1566": {
        "file_id": 128,
        "content": "(\".json\", processor=\"file_format_detector\"\n)\n(\"{{ mediafile }}\")",
        "type": "code",
        "location": "/pyjom/templates/medialang/autoCensor/file_format_detector.mdl.j2:1-4"
    },
    "1567": {
        "file_id": 128,
        "content": "This code snippet defines a tuple containing the file format \"json\" and specifies the processor \"file_format_detector\". The mediafile variable is used within double curly braces to represent the file's content.",
        "type": "comment"
    },
    "1568": {
        "file_id": 129,
        "content": "/pyjom/templates/medialang/autoCensor/subtitle_detector.mdl.j2",
        "type": "filepath"
    },
    "1569": {
        "file_id": 129,
        "content": "The code specifies a template for the \"subtitle_detector\" processor. If timestep is provided, it includes it in the output. It combines a JSON string with the media file path.",
        "type": "summary"
    },
    "1570": {
        "file_id": 129,
        "content": "(\".json\", processor=\"subtitle_detector\"{% if timestep %}, timestep={{timestep}}{% endif %}\n)\n(\"{{ mediafile }}\")",
        "type": "code",
        "location": "/pyjom/templates/medialang/autoCensor/subtitle_detector.mdl.j2:1-4"
    },
    "1571": {
        "file_id": 129,
        "content": "The code specifies a template for the \"subtitle_detector\" processor. If timestep is provided, it includes it in the output. It combines a JSON string with the media file path.",
        "type": "comment"
    },
    "1572": {
        "file_id": 130,
        "content": "/pyjom/templates/medialang/autoCensor/blackout_detector.mdl.j2",
        "type": "filepath"
    },
    "1573": {
        "file_id": 130,
        "content": "The code represents a template for the blackout_detector.mdl.j2 file in the pyjom project. It defines a processor called \"blackout_detector\" and includes optional timestep variable, as well as the mediafile path.",
        "type": "summary"
    },
    "1574": {
        "file_id": 130,
        "content": "(\".json\", processor=\"blackout_detector\"{% if timestep %}, timestep={{timestep}}{% endif %}\n)\n(\"{{ mediafile }}\")",
        "type": "code",
        "location": "/pyjom/templates/medialang/autoCensor/blackout_detector.mdl.j2:1-4"
    },
    "1575": {
        "file_id": 130,
        "content": "The code represents a template for the blackout_detector.mdl.j2 file in the pyjom project. It defines a processor called \"blackout_detector\" and includes optional timestep variable, as well as the mediafile path.",
        "type": "comment"
    },
    "1576": {
        "file_id": 131,
        "content": "/pyjom/templates/medialang/autoCensor/framediff_detector.mdl.j2",
        "type": "filepath"
    },
    "1577": {
        "file_id": 131,
        "content": "The code defines a template for the \"framediff_detector\" processor, which takes an optional \"timestep\" parameter and a media file as input. It may check moving areas, total movements, and local movements, differentiating it from frame border detector.",
        "type": "summary"
    },
    "1578": {
        "file_id": 131,
        "content": "(\".json\", processor=\"framediff_detector\"{% if timestep %}, timestep={{timestep}}{% endif %} \n) # different from frame border detector. may check moving areas, check total movements, local movements.\n(\"{{ mediafile }}\")",
        "type": "code",
        "location": "/pyjom/templates/medialang/autoCensor/framediff_detector.mdl.j2:1-4"
    },
    "1579": {
        "file_id": 131,
        "content": "The code defines a template for the \"framediff_detector\" processor, which takes an optional \"timestep\" parameter and a media file as input. It may check moving areas, total movements, and local movements, differentiating it from frame border detector.",
        "type": "comment"
    },
    "1580": {
        "file_id": 132,
        "content": "/externals/torchrec_init.sh",
        "type": "filepath"
    },
    "1581": {
        "file_id": 132,
        "content": "This script clones torchrec, modifies setup.py, installs torchrec, and fixes paths for installation in third_party/fbgemm/fbgemm_gpu directory. It also exports CUB_DIR, CUDA_BIN_PATH, and CUDACXX environment variables before the final installation.",
        "type": "summary"
    },
    "1582": {
        "file_id": 132,
        "content": "# git clone --depth 1 --recurse-submodules https://github.com/pytorch/torchrec\ncd torchrec\n# modify the freaking setup.py first. don't want no trouble.\n# python3 setup.py install\nexport CUB_DIR=/usr/include/cub\nexport CUDA_BIN_PATH=/usr/lib/nvidia-cuda-toolkit\nexport CUDACXX=/usr/bin/nvcc\ncp -R /usr/local/lib/python3.9/dist-packages/torch/include/* third_party/fbgemm/fbgemm_gpu/include # great shit.\npython3 setup.py install \n# the freaking fix.\n# cd third_party/fbgemm/fbgemm_gpu\n# cp -R /usr/local/lib/python3.9/dist-packages/torch/include/* ./include # great shit.\n# export CUB_DIR=/usr/include/cub\n# export CUDA_BIN_PATH=/usr/lib/nvidia-cuda-toolkit\n# export CUDACXX=/usr/bin/nvcc\n# python3 setup.py install ",
        "type": "code",
        "location": "/externals/torchrec_init.sh:1-17"
    },
    "1583": {
        "file_id": 132,
        "content": "This script clones torchrec, modifies setup.py, installs torchrec, and fixes paths for installation in third_party/fbgemm/fbgemm_gpu directory. It also exports CUB_DIR, CUDA_BIN_PATH, and CUDACXX environment variables before the final installation.",
        "type": "comment"
    },
    "1584": {
        "file_id": 133,
        "content": "/externals/three_init.sh",
        "type": "filepath"
    },
    "1585": {
        "file_id": 133,
        "content": "This command clones the Three.js library from GitHub, ensuring only the latest commit is downloaded for potentially faster download times.",
        "type": "summary"
    },
    "1586": {
        "file_id": 133,
        "content": "git clone --depth 1 https://github.com/mrdoob/three.js # this might be faster than shit.",
        "type": "code",
        "location": "/externals/three_init.sh:1-1"
    },
    "1587": {
        "file_id": 133,
        "content": "This command clones the Three.js library from GitHub, ensuring only the latest commit is downloaded for potentially faster download times.",
        "type": "comment"
    },
    "1588": {
        "file_id": 134,
        "content": "/externals/test_import_opencv_site.py",
        "type": "filepath"
    },
    "1589": {
        "file_id": 134,
        "content": "This code imports necessary libraries and checks for the location of OpenCV libraries. It then inserts that location into sys.path if there is only one library found, and finally imports the OpenCV library (cv2). The code then prints out the available functions and methods within cv2 using dir(cv2).",
        "type": "summary"
    },
    "1590": {
        "file_id": 134,
        "content": "import pathlib\nimport site\nimport sys\n# this is root. this is not site-packages.\n# site_path = pathlib.Path([x for x in site.getsitepackages() if \"site-packages\" in x][0])\nsite_path = pathlib.Path(\"/usr/local/lib/python3.9/site-packages\")\ncv2_libs_dir = site_path / 'cv2' / f'python-{sys.version_info.major}.{sys.version_info.minor}'\nprint(cv2_libs_dir)\ncv2_libs = sorted(cv2_libs_dir.glob(\"*.so\"))\nif len(cv2_libs) == 1:\n    print(\"INSERTING:\",cv2_libs[0].parent)\n    sys.path.insert(1, str(cv2_libs[0].parent))\nimport cv2\nprint(dir(cv2)) # shit?",
        "type": "code",
        "location": "/externals/test_import_opencv_site.py:1-18"
    },
    "1591": {
        "file_id": 134,
        "content": "This code imports necessary libraries and checks for the location of OpenCV libraries. It then inserts that location into sys.path if there is only one library found, and finally imports the OpenCV library (cv2). The code then prints out the available functions and methods within cv2 using dir(cv2).",
        "type": "comment"
    },
    "1592": {
        "file_id": 135,
        "content": "/externals/pybgs_init.sh",
        "type": "filepath"
    },
    "1593": {
        "file_id": 135,
        "content": "This code is installing the \"pybgs\" package using pip, after setting the OpenCV_DIR environment variable. It then performs a build and installation of the package in the \"bgslibrary\" directory. The PATH variable is updated to include relevant directories for proper execution.",
        "type": "summary"
    },
    "1594": {
        "file_id": 135,
        "content": "# opencvdir=\"\"\n# env OpenCV_DIR= pip3 install pybgs\nexport PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/local/games:/usr/games:/usr/local/cuda-10.2/bin:/snap/bin\ncd bgslibrary\npython3 setup.py build\npython3 setup.py install",
        "type": "code",
        "location": "/externals/pybgs_init.sh:1-6"
    },
    "1595": {
        "file_id": 135,
        "content": "This code is installing the \"pybgs\" package using pip, after setting the OpenCV_DIR environment variable. It then performs a build and installation of the package in the \"bgslibrary\" directory. The PATH variable is updated to include relevant directories for proper execution.",
        "type": "comment"
    },
    "1596": {
        "file_id": 136,
        "content": "/externals/init_ffmpeg.sh",
        "type": "filepath"
    },
    "1597": {
        "file_id": 136,
        "content": "This code downloads and configures FFmpeg libraries with options like CUDA and LibNPP for project dependencies, rebuilds from source if needed, and enables specific libraries using --enable flag.",
        "type": "summary"
    },
    "1598": {
        "file_id": 136,
        "content": "git clone --depth 1 https://git.ffmpeg.org/ffmpeg.git ffmpeg/\ngit clone https://git.videolan.org/git/ffmpeg/nv-codec-headers.git\ncd nv-codec-headers && sudo make install && cd ..\nyes | apt-get install build-essential yasm cmake libtool libc6 libc6-dev unzip wget libnuma1 libnuma-dev libchromaprint-dev frei0r-plugins-dev libaom-dev libiec61883-dev libass-dev libbluray-dev libbs2b-dev libcodec2-dev libgsm1-dev libopenjp2-7-dev librsvg2-dev libzmq3-dev libomxil-bellagio-dev libcdio-paranoia-dev libsrt-gnutls-dev libopenh264-dev\n# yes | apt-get   build-dep ffmpeg # has unmet dependencies.\n# git clone https://github.com/Haivision/srt.git libsrt\n# cd libsrt/\n# git checkout -b work v1.4.1\n# sudo apt-get install tclsh pkg-config cmake libssl-dev build-essential\n# ./configure \n# make\n# sudo make install\n# sudo ldconfig\n# cd ..\n# yes | apt install ladspa-dev\n# yes | apt install libaom-dev\n# yes | apt install libass-dev\n# yes | apt install libbluray-dev\n# yes | apt install libbs2b-dev\n# yes | apt install libcaca-dev",
        "type": "code",
        "location": "/externals/init_ffmpeg.sh:1-21"
    },
    "1599": {
        "file_id": 136,
        "content": "Code is downloading and installing the FFmpeg libraries along with dependencies, making sure necessary packages are installed, performing necessary configurations, compiling and installing SRT library.",
        "type": "comment"
    }
}