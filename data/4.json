{
    "400": {
        "file_id": 17,
        "content": "    if l1.x == r1.x or l1.y == r1.y or r2.x == l2.x or l2.y == r2.y:\n        return False\n    # If one rectangle is on left side of other\n    if l1.x >= r2.x or l2.x >= r1.x:\n        return False\n    if l1.y >= r2.y or l2.y >= r1.y:\n        return False\n    return True\ndef checkRectOverlap(rect0, rect1):\n    assert len(rect0) == 2\n    assert len(rect1) == 2\n    return doRectOverlap(\n        D2Point(*rect0[0]), D2Point(*rect0[1]), D2Point(*rect1[0]), D2Point(*rect1[1])\n    )\ndef getOverlapRect(rect0, rect1):\n    if checkRectOverlap(rect0, rect1):\n        leftXList = (rect0[0][0], rect1[0][0])\n        leftYList = (rect0[0][1], rect1[0][1])\n        rightXList = (rect0[1][0], rect1[1][0])\n        rightYList = (rect0[1][1], rect1[1][1])\n        leftX = max(leftXList)\n        leftY = max(leftYList)\n        rightX = min(rightXList)\n        rightY = min(rightYList)\n        return [(leftX, leftY), (rightX, rightY)]\n    else:\n        return None\ndef makeValueInRange(value, minVal, maxVal):\n    assert minVal < maxVal\n    return min(max(minVal, value), maxVal)",
        "type": "code",
        "location": "/pyjom/commons.py:491-526"
    },
    "401": {
        "file_id": 17,
        "content": "The code checks for rectangle overlap, returns the overlapping rectangle if exists, and clamps values within a given range.",
        "type": "comment"
    },
    "402": {
        "file_id": 17,
        "content": "# this sucks...\ndef infiniteShuffle(access_list, shuffle=True, infinite=True, endMark=True):\n    flag = True\n    while flag:\n        if shuffle:\n            random.shuffle(access_list)\n        for data in access_list:\n            yield data\n        if endMark and infinite:\n            yield None\n        if not infinite:\n            flag = False\ndef inRange(target, mRange, tolerance=1):\n    assert tolerance <= 1\n    assert tolerance > 0\n    start, end = mRange\n    start, end = start * tolerance, end / tolerance\n    return target >= start and target <= end\ndef overlapRange(range_a, range_b):\n    begin_a, end_a = range_a\n    begin_b, end_b = range_b\n    possible_overlap = (max(begin_a, begin_b), min(end_a, end_b))\n    if possible_overlap[0] < possible_overlap[1]:  # overlapping\n        return possible_overlap\n    # return common range.\nfrom lazero.utils.json import jsonWalk2, jsonify, jsonWalk, jsonLocate, jsonUpdate\njson.__dict__.update({\"walk\": jsonWalk, \"locate\": jsonLocate, \"update\": jsonUpdate})\ndef replacer(content, sources=[], target=\"\"):",
        "type": "code",
        "location": "/pyjom/commons.py:529-565"
    },
    "403": {
        "file_id": 17,
        "content": "The code defines a function \"infiniteShuffle\" that shuffles and yields data from an access list, either stopping when the list ends or if set to infinite mode. Function \"inRange\" checks if a target value falls within specified range boundaries with optional tolerance. Function \"overlapRange\" calculates the overlap between two given ranges. The code also updates JSON functions (\"walk\", \"locate\", and \"update\") under the json module. Finally, a function named \"replacer\" is defined, but its functionality isn't clear from the given code snippet.",
        "type": "comment"
    },
    "404": {
        "file_id": 17,
        "content": "    for source in sources:\n        content = content.replace(source, target)\n    return content\ndef multi_replacer(content, replacer_list=[[[], \"\"]]):\n    for sources, target in replacer_list:\n        content = replacer(content, sources=sources, target=target)\n    return content\nfrom pyjom.mathlib import extract_span, convoluted\nimport MediaInfo\nimport subprocess\ndef json_auto_float_int(jsonObj):\n    jsonObj = jsonify(jsonObj)\n    for location, content in jsonWalk(jsonObj):\n        # content = jsonLocate(jsonObj,location)\n        if type(content) == str:\n            if \"/\" in content:\n                try:\n                    content = eval(content)  # could be dangerous!\n                    if type(content) in [float, int]:\n                        jsonUpdate(jsonObj, location=location, update_content=content)\n                except:\n                    pass\n            elif \".\" in content:\n                try:\n                    content = float(content)\n                    jsonUpdate(jsonObj, location=location, update_content=content)",
        "type": "code",
        "location": "/pyjom/commons.py:566-600"
    },
    "405": {
        "file_id": 17,
        "content": "The code appears to be a combination of functions that replace specific strings within a given content, update JSON objects by converting certain string types to either float or int, and potentially include some math-related operations. It seems to involve the use of external libraries such as MediaInfo and subprocess for possibly retrieving additional information or performing computations.",
        "type": "comment"
    },
    "406": {
        "file_id": 17,
        "content": "                except:\n                    pass\n            else:\n                try:\n                    content = int(content)\n                    jsonUpdate(jsonObj, location=location, update_content=content)\n                except:\n                    pass\n    return jsonObj\ndef ffprobe_media_info(filename, video_size: Union[None, str] = None):\n    cmd = \"ffprobe{} -v quiet -print_format json -show_format -show_streams\".format(\n        \" -video_size {}\".format(video_size.strip()) if video_size else \"\"\n    )\n    cmd = cmd.split(\" \")\n    cmd = cmd + [filename]\n    output = subprocess.check_output(cmd)\n    return json_auto_float_int(json.loads(output))\ndef json_media_info(filename):\n    cmd = [\"mediainfo\", \"--Output=JSON\", filename]\n    output = subprocess.check_output(cmd)\n    return json_auto_float_int(json.loads(output))\ndef get_media_info(filename):\n    mdf = MediaInfo.MediaInfo(filename=filename)\n    return json_auto_float_int(mdf.getInfo())\ndef getTextFileLength(path):\n    with open(path, \"r\", encoding=\"utf-8\") as f:",
        "type": "code",
        "location": "/pyjom/commons.py:601-634"
    },
    "407": {
        "file_id": 17,
        "content": "The code contains functions for retrieving media information. It uses ffprobe and mediainfo commands to extract video format, codec, size, duration, bitrate, and other details from the specified file. The information is returned in JSON format after converting floating-point numbers to integers if needed. The getTextFileLength function reads a text file's length using Python's built-in open() function.",
        "type": "comment"
    },
    "408": {
        "file_id": 17,
        "content": "        return len(f.read())\ndef append_sublist(main_dict, sublist_key, item):\n    main_dict[sublist_key] = main_dict.get(sublist_key, []) + [item]\ndef update_subdict(mdict, key, subdict):\n    # print(\"UPDATING SUBDICT\", mdict,key, subdict)\n    if key not in mdict:\n        mdict[key] = subdict\n    else:\n        mdict[key].update(subdict)\n    return mdict\ndef read_json(filepath):\n    with open(filepath, \"r\") as f:\n        return json.loads(f.read())\ndef list_to_range(mlist, rangeLimit):\n    mlist = set(mlist)\n    mlist = list(sorted(mlist))\n    currentRange = []\n    lastElem = None\n    myRanges = []\n    for elem in mlist:\n        if lastElem == None:\n            lastElem = elem\n            currentRange = [elem]\n            continue\n        myRange = elem - lastElem\n        if rangeLimit >= myRange:\n            lastElem = elem\n            if len(currentRange) == 2:\n                currentRange[1] = elem\n            else:\n                currentRange.append(elem)\n        else:\n            myRanges.append(currentRange)\n            lastElem = elem",
        "type": "code",
        "location": "/pyjom/commons.py:635-676"
    },
    "409": {
        "file_id": 17,
        "content": "This code defines functions for working with dictionaries and JSON files. It includes functions to append a sublist, update a subdictionary, read a JSON file, and convert a list of elements into ranges based on their differences. These functions can be used together or separately depending on the specific task at hand.",
        "type": "comment"
    },
    "410": {
        "file_id": 17,
        "content": "            currentRange = [elem]\n    if len(myRanges) > 0:\n        if myRanges[-1] != currentRange:\n            myRanges.append(currentRange)\n    else:\n        myRanges.append(currentRange)\n    return myRanges\n# from youtube science.\ndef list_startswith(a, b):\n    value = 0\n    if len(a) < len(b):\n        return False\n    for i, v in enumerate(b):\n        v0 = a[i]\n        if v == v0:\n            value += 1\n    return value == len(b)\ndef list_endswith(a, b):\n    value = 0\n    if len(a) < len(b):\n        return False\n    c = a[-len(b) :]\n    for i, v in enumerate(b):\n        v0 = c[i]\n        if v == v0:\n            value += 1\n    return value == len(b)\ndef cv2_HWC2CHW(frame):\n    if len(frame.shape) == 3:\n        img = frame[:, :, ::-1].transpose((2, 0, 1))\n    else:\n        img = frame[np.newaxis, :, :]\n    return img\nocrCore = None\nocrConfig = {\n    \"use_angle_cls\": True,\n    \"lang\": \"ch\",\n}  # it can detect english too. but no space included.\ndef configOCR(**kwargs):\n    global ocrCore, ocrConfig\n    if ocrCore is not None:",
        "type": "code",
        "location": "/pyjom/commons.py:677-727"
    },
    "411": {
        "file_id": 17,
        "content": "This code defines several functions related to lists, image conversion, and OCR configuration. It checks if a list starts or ends with another list, converts an image's shape from HWC to CHW, and configures the OCR engine with language options. The global ocrCore and ocrConfig variables store the OCR engine and its configurations, which can be updated using the configOCR function.",
        "type": "comment"
    },
    "412": {
        "file_id": 17,
        "content": "        if kwargs == ocrConfig:\n            pass\n    else:\n        ocrConfig = kwargs\n        from paddleocr import PaddleOCR\n        # breakpoint()\n        ocrCore = PaddleOCR(**kwargs)\n        # breakpoint() # this is not the problem. maybe.\n    return ocrCore\ndef getScriptFileBaseDir(script_file):\n    basepath = os.path.abspath(script_file)\n    basepath = basepath.replace(os.path.basename(basepath), \"\")\n    return basepath\ndef getTemplateFileBaseDir(tmpDir=\"templates\"):\n    basedir = getScriptFileBaseDir(__file__)\n    basedir = os.path.join(basedir, tmpDir)\n    assert os.path.exists(basedir)\n    return basedir\nyolov5_model = None\n@lru_cache(maxsize=1)\ndef configYolov5(model=\"yolov5s\"):\n    global yolov5_model  # not the same\n    if yolov5_model == None:\n        basedir = getTemplateFileBaseDir(tmpDir=\"models/yolov5\")\n        os.environ[\"YOLOV5_MODEL_DIR\"] = basedir\n        localModelPath = os.path.join(\n            basedir, \"ultralytics_yolov5_master/\"\n        )  # required to load it. we have modified this shit somehow.",
        "type": "code",
        "location": "/pyjom/commons.py:728-764"
    },
    "413": {
        "file_id": 17,
        "content": "This code snippet defines a function \"configYolov5\" that retrieves the YOLOv5 model configuration. It first checks if the global variable \"yolov5_model\" is set, and if not, it sets it based on the given \"model\" parameter. The function also includes the paths to the YOLOv5 model directory using the \"getScriptFileBaseDir\" and \"getTemplateFileBaseDir\" functions. Finally, an LRU cache decorator ensures efficient retrieval of the model configuration.",
        "type": "comment"
    },
    "414": {
        "file_id": 17,
        "content": "        modelPath = model\n        # we set enviorment variable instead.\n        # breakpoint()\n        yolov5_model = torch.hub.load(localModelPath, modelPath, source=\"local\")\n    return yolov5_model\ndef getTemplatePath(template_dirs, template_path):\n    basedir = getTemplateFileBaseDir()\n    for template_dir in template_dirs:\n        basedir = os.path.join(basedir, template_dir)\n        assert os.path.exists(basedir)\n    template_path = os.path.join(basedir, template_path)\n    assert os.path.exists(template_path)\n    return template_path\ndef joinScriptFileBaseDir(script_file, local_file_path):\n    basepath = getScriptFileBaseDir(script_file)\n    file_path = os.path.join(basepath, local_file_path)\n    return file_path\ndef renderTemplate(template, template_args, enable_json=True):\n    template = jinja2.Template(template)\n    if enable_json:\n        for key in template_args.keys():\n            data = template_args[key]\n            if type(data) in [dict, list, tuple]:\n                try:\n                    data = json.dumps(data)",
        "type": "code",
        "location": "/pyjom/commons.py:765-795"
    },
    "415": {
        "file_id": 17,
        "content": "Code snippet defines several functions:\n- `getTemplatePath()` joins template directory paths and asserts if the resulting path exists.\n- `joinScriptFileBaseDir()` combines script file base directory with a local file path.\n- `renderTemplate()` renders a Jinja2 template, optionally converting dictionaries/lists to JSON.",
        "type": "comment"
    },
    "416": {
        "file_id": 17,
        "content": "                    template_args[key] = data\n                except:\n                    pass\n    script = template.render(**template_args)\n    return script\ndef configDecorator(func, config=\"config.json\"):\n    def mytarget(*args, **kwargs):\n        return func(*args, **(kwargs | {\"config\": config}))\n    return mytarget\ndef jsonPrettyPrint(feedback, indent=4):\n    assert type(indent) == int\n    mtype = \"json\"\n    feedback_type = type(feedback)\n    if feedback_type != str:\n        try:\n            mfeedback_content = json.dumps(feedback, indent=indent)\n        except:\n            mfeedback_content = str(feedback)\n            mtype = str(feedback_type)\n    else:\n        mfeedback_content = feedback\n        mtype = \"str\"\n    return mtype, mfeedback_content\ndef getFileType(fbase0):\n    # quick dirty fix.\n    # for gif we have a hard fix.\n    translateTable = {\"gif\": \"video\"}  # force conversion.\n    # print(\"FBASE:\", fbase0)\n    suffix = fbase0.split(\".\")[-1]\n    guessedType = translateTable.get(suffix, None)\n    # breakpoint()",
        "type": "code",
        "location": "/pyjom/commons.py:796-833"
    },
    "417": {
        "file_id": 17,
        "content": "commons.py file contains various utility functions, including a template rendering function with exception handling, a decorator that uses a specific configuration file, a function to pretty print JSON data with optional indentation, and a function for guessing the type of a file based on its extension.",
        "type": "comment"
    },
    "418": {
        "file_id": 17,
        "content": "    if guessedType:\n        return guessedType\n    mimestart = mimetypes.guess_type(fbase0)[0]\n    if mimestart != None:\n        mimestart = mimestart.split(\"/\")[0]\n        return mimestart\n    return \"unknown\"\ndef getAbsoluteFilePath(fpath):\n    assert os.path.exists(fpath)\n    if os.path.isabs(fpath):\n        return fpath\n    return os.path.abspath(fpath)\ndef getFileExtension(fpath):\n    basename = os.path.basename(fpath)\n    assert \".\" in basename\n    return basename.split(\".\")[-1]\ndef getLocalFileType(fpath):  # this is guessing, not file probing.\n    fbase = os.path.basename(fpath)\n    return getFileType(fbase)\ndef getHostname():\n    return socket.gethostname()\ndef keywordDecorator(func, **kwargs2):\n    def mytarget(*margs, **kwargs):\n        if \"trace_source\" in kwargs.keys():\n            if kwargs2[\"trace_source\"]:\n                return func(*margs, **(kwargs | kwargs2)), \".\".join(\n                    [__name__, func.__name__]\n                )\n        return func(*margs, **(kwargs | kwargs2))\n    return mytarget",
        "type": "code",
        "location": "/pyjom/commons.py:834-874"
    },
    "419": {
        "file_id": 17,
        "content": "This code includes functions for getting file types, extensions, and local file names. It also includes a decorator for tracing source locations and a function to get the hostname. The \"getFileType\" function uses the guessed type or the mimetype of the file if it exists. The \"getAbsoluteFilePath\" returns an absolute path if given, otherwise it returns the absolute path of the relative path. The \"getFileExtension\" gets the extension of a file name. The \"getLocalFileType\" guesses the file type based on its name. The \"getHostname\" function retrieves the hostname of the current machine. Finally, the \"keywordDecorator\" is used for traceable source locations.",
        "type": "comment"
    },
    "420": {
        "file_id": 17,
        "content": "def decorator(func):\n    def mytarget(*args, **kwargs):\n        return func(*args, **kwargs), \".\".join([__name__, func.__name__])\n    return mytarget\ndef chineseDetector(string):\n    base, celi = 0x4E00, 0x9FA5\n    for elem in string:\n        mydata = ord(elem)\n        if mydata >= base and mydata <= celi:\n            return True\n    return False\ndef getTimestamp():\n    return datetime.datetime.now().timestamp()\ndef dumpTrashDir(trash_dir):\n    if os.path.exists(trash_dir):\n        if os.path.isdir(trash_dir):\n            shutil.rmtree(trash_dir)\n        else:\n            os.remove(trash_dir)\ndef writeFileWithPath(path, fname, content, mode, encoding=None):\n    if not os.path.exists(path):\n        os.makedirs(path)\n    log_path = os.path.join(path, fname)\n    if \"b\" not in mode:\n        if encoding == None:\n            with open(log_path, mode) as f:\n                f.write(content)\n        else:\n            with open(log_path, mode, encoding=encoding) as f:\n                f.write(content)\n    else:\n        with open(log_path, mode) as f:",
        "type": "code",
        "location": "/pyjom/commons.py:877-917"
    },
    "421": {
        "file_id": 17,
        "content": "This code includes functions for a decorator, Chinese detector, timestamp generation, removing trash directories, and writing files. The decorator function takes a function as an argument and returns a wrapper function. The ChineseDetector function checks if a string contains Chinese characters. The getTimestamp function returns the current timestamp. The dumpTrashDir function removes the specified trash directory if it exists and is a directory. The writeFileWithPath function writes content to a file with the given path, filename, and mode.",
        "type": "comment"
    },
    "422": {
        "file_id": 17,
        "content": "            f.write(content)\n    print(\"file written at:\\n{}\".format(log_path))",
        "type": "code",
        "location": "/pyjom/commons.py:918-919"
    },
    "423": {
        "file_id": 17,
        "content": "Writes the content to a file, then prints the log path indicating successful file writing.",
        "type": "comment"
    },
    "424": {
        "file_id": 18,
        "content": "/pyjom/audiotoolbox.py",
        "type": "filepath"
    },
    "425": {
        "file_id": 18,
        "content": "This code detects audio duration and volume using audioread library, adjusts media file volume with ffmpeg, normalizes audio, and handles errors.",
        "type": "summary"
    },
    "426": {
        "file_id": 18,
        "content": "# first and foremost is the audio correction, the volume detector, the audio detector.\n# https://trac.ffmpeg.org/wiki/AudioVolume\n# but first how to get the audio duration?\n# for video we have caer. but for audio?\nimport audioread\nfrom lazero.utils.logger import sprint\nimport ffmpeg\nfrom typing import Literal\nfrom pyjom.commons import *\nimport parse\ndef getAudioBitrate(mediaPath):\n    return int(getMediaBitrate(mediaPath, audioOnly=True)[\"streams\"][0][\"bit_rate\"])\ndef getAudioDuration(audioFilePath):\n    with audioread.audio_open(audioFilePath) as f:\n        totalSeconds = f.duration\n    return totalSeconds  # is this float number or integer?\n    # how about let's test this?\ndef detect_volume_average(mediapath, debug=False):\n    # ffmpeg -i input.wav -filter:a volumedetect -f null /dev/null\n    # audio = ffmpeg.input(mediapath)\n    audio = ffmpeg.input(mediapath).audio\n    # does not have audio track, so error occurs.\n    # don't know how to capture the track. anyway, do put the audio into the test video.\n    # might have exception. what to do with it then??",
        "type": "code",
        "location": "/pyjom/audiotoolbox.py:1-32"
    },
    "427": {
        "file_id": 18,
        "content": "This code retrieves the audio duration and volume average from an input media file using the audioread library. The getAudioDuration function returns the total duration in seconds, while the detect_volume_average function processes the media path to obtain the volume average. However, it may encounter exceptions if the audio track is not available or the track cannot be captured properly.",
        "type": "comment"
    },
    "428": {
        "file_id": 18,
        "content": "    volDict = {}\n    error = False\n    try:\n        stdout, stderr = (\n            audio.filter(\"volumedetect\")\n            .output(\"/dev/null\", f=\"null\")\n            .run(capture_stdout=True, capture_stderr=True)\n        )\n        # where is the output?\n        stderr = stderr.decode(\"utf-8\")\n        stderr_lines = stderr.split(\"\\n\")\n        formatString = \"[Parsed_volumedetect{}] {volumeType}_volume: {value:g} dB\"\n        for line in stderr_lines:\n            line = line.strip()\n            result = parse.parse(formatString, line)\n            if result is not None:\n                volumeType, value = result[\"volumeType\"], result[\"value\"]\n                volDict.update({volumeType: value})\n    except:\n        import traceback\n        traceback.print_exc()\n        # print(stderr)\n        # nothing will be shown in stderr, if there is no audio in the media container.\n        print(\"error when detecting volume for: %s\" % mediapath)\n        error = True\n    if debug:\n        print(\"MEDIA PATH: %s\" % mediapath)\n        print(\"VOLUME:\", volDict)",
        "type": "code",
        "location": "/pyjom/audiotoolbox.py:33-61"
    },
    "429": {
        "file_id": 18,
        "content": "This code attempts to detect the volume of audio files and stores the volume details in a dictionary. It uses the \"volumedetect\" filter, redirects output to \"/dev/null\", captures both stdout and stderr, and parses the error output for volume information. If there's no audio in the media container, it will show an error message. Debug mode prints the media path and volume dictionary if set.",
        "type": "comment"
    },
    "430": {
        "file_id": 18,
        "content": "        sprint(\"ERROR STATUS:\", error)\n    return volDict, error\ndef adjustVolumeInMedia(\n    mediaPath,\n    outputPath,\n    targets={\n        \"mean\": -10.8,  # -13.2 fuck.\n        \"max\": 0.0,\n    },  # what is the real value anyway? we want the volume fetched from web.\n    overwrite_output=False,\n    bitrate=320000,\n    algorithm: Literal[\"rms\", \"ebu\", \"peak\"] = \"rms\",\n):  # must set target volume.\n    # use ffmpeg-normalize?\n    # use aac for mp4 output. let's do it!\n    target_level = targets.get(\"mean\", None)\n    true_peak = targets.get(\"max\", None)\n    commandline = [\n        \"ffmpeg-normalize\",\n        \"-o\",\n        outputPath,\n        \"-pr\",\n        \"-nt\",\n        algorithm,\n    ]\n    commandline += [\"-b:a\", str(bitrate)]  # the bitrate part.\n    # now much better. let's see if we have other methods.\n    # VOLUME NORMALIZATION SUCCESSFUL\n    # MEDIA PATH: normalized.mp4\n    # VOLUME: {'mean': -11.0, 'max': 0.0}\n    # ERROR STATUS: False\n    # commandline = [\"ffmpeg-normalize\", \"-o\", outputPath, \"-pr\"]\n    # VOLUME: {'mean': -13.2, 'max': 0.0}",
        "type": "code",
        "location": "/pyjom/audiotoolbox.py:62-97"
    },
    "431": {
        "file_id": 18,
        "content": "The function adjusts the volume of media files located at a specific path. It accepts parameters for output file path, target volume levels (mean and max), overwrite option, bitrate, and algorithm type. It uses ffmpeg-normalize command line tool to normalize the audio, and returns a dictionary containing mean and max volume values upon successful execution. If an error occurs, it returns the error status as well.",
        "type": "comment"
    },
    "432": {
        "file_id": 18,
        "content": "    # the 'mean' is still not correctified.\n    # ERROR STATUS: False\n    # video codec we use 'copy' if the extension name is the same.\n    outputPathExtension = outputPath.lower().split(\".\")[-1]\n    mediaPathExtension = mediaPath.lower().split(\".\")[-1]\n    outputMediaType = determineMediaTypeByExtension(outputPathExtension)\n    # treat this as a common repository.\n    if outputPathExtension == mediaPathExtension and outputMediaType == \"video\":\n        commandline += [\"-c:v\", \"copy\"]\n    # problem is, the container must be video compabible.\n    # list the thing here?\n    if outputPathExtension == \"mp4\":\n        commandline += [\"-c:a\", \"aac\"]\n    if target_level:\n        commandline += [\"-t\", str(target_level)]\n    if true_peak:\n        commandline += [\"-tp\", str(true_peak)]\n    if overwrite_output:\n        commandline += [\"-f\"]\n    commandline += [mediaPath]\n    status = subprocess.run(commandline)  # is it even successful?\n    returncode = status.returncode\n    try:\n        assert returncode == 0\n        print(\"VOLUME NORMALIZATION SUCCESSFUL\")",
        "type": "code",
        "location": "/pyjom/audiotoolbox.py:98-122"
    },
    "433": {
        "file_id": 18,
        "content": "This code is normalizing the volume of a video file and correcting its container type if necessary. It checks the input and output extensions, sets the video and audio codecs, handles target level, true peak, and overwrite settings, and runs subprocess command to execute FFmpeg for processing. The script prints \"VOLUME NORMALIZATION SUCCESSFUL\" if returncode is 0, indicating successful volume normalization.",
        "type": "comment"
    },
    "434": {
        "file_id": 18,
        "content": "        return outputPath\n    except:\n        import traceback\n        traceback.print_exc()\n        print(\"error when normalizing audio for media: %s\" % mediaPath)\n    # media = ffmpeg.input(videoPath)\n    # audio = media.audio\n    # video = media.video\n    # audio = audio.filter()",
        "type": "code",
        "location": "/pyjom/audiotoolbox.py:123-132"
    },
    "435": {
        "file_id": 18,
        "content": "This code snippet is responsible for normalizing audio for a given media file. If an error occurs during the process, it prints the error message and stack trace using the traceback module.",
        "type": "comment"
    },
    "436": {
        "file_id": 19,
        "content": "/pyjom/templates/medialang/autoCensor/yolov5_detector.mdl.j2",
        "type": "filepath"
    },
    "437": {
        "file_id": 19,
        "content": "This code is creating a tuple containing a JSON file with optional parameters for timestep, threshold and model name, along with the media file path.",
        "type": "summary"
    },
    "438": {
        "file_id": 19,
        "content": "(\".json\", processor=\"yolov5_detector\"{% if timestep %}, timestep={{timestep}}{% endif %} {% if threshold %}, threshold={{threshold}}{% endif %} {% if model %}, model=\"{{model}}\"{% endif %}\n)\n(\"{{ mediafile }}\")",
        "type": "code",
        "location": "/pyjom/templates/medialang/autoCensor/yolov5_detector.mdl.j2:1-4"
    },
    "439": {
        "file_id": 19,
        "content": "This code is creating a tuple containing a JSON file with optional parameters for timestep, threshold and model name, along with the media file path.",
        "type": "comment"
    },
    "440": {
        "file_id": 20,
        "content": "/pyjom/templates/medialang/autoCensor/subtitle_detector.mdl.j2",
        "type": "filepath"
    },
    "441": {
        "file_id": 20,
        "content": "The code specifies a template for the \"subtitle_detector\" processor. If timestep is provided, it includes it in the output. It combines a JSON string with the media file path.",
        "type": "summary"
    },
    "442": {
        "file_id": 20,
        "content": "(\".json\", processor=\"subtitle_detector\"{% if timestep %}, timestep={{timestep}}{% endif %}\n)\n(\"{{ mediafile }}\")",
        "type": "code",
        "location": "/pyjom/templates/medialang/autoCensor/subtitle_detector.mdl.j2:1-4"
    },
    "443": {
        "file_id": 20,
        "content": "The code specifies a template for the \"subtitle_detector\" processor. If timestep is provided, it includes it in the output. It combines a JSON string with the media file path.",
        "type": "comment"
    },
    "444": {
        "file_id": 21,
        "content": "/pyjom/templates/medialang/autoCensor/framediff_detector.mdl.j2",
        "type": "filepath"
    },
    "445": {
        "file_id": 21,
        "content": "The code defines a template for the \"framediff_detector\" processor, which takes an optional \"timestep\" parameter and a media file as input. It may check moving areas, total movements, and local movements, differentiating it from frame border detector.",
        "type": "summary"
    },
    "446": {
        "file_id": 21,
        "content": "(\".json\", processor=\"framediff_detector\"{% if timestep %}, timestep={{timestep}}{% endif %} \n) # different from frame border detector. may check moving areas, check total movements, local movements.\n(\"{{ mediafile }}\")",
        "type": "code",
        "location": "/pyjom/templates/medialang/autoCensor/framediff_detector.mdl.j2:1-4"
    },
    "447": {
        "file_id": 21,
        "content": "The code defines a template for the \"framediff_detector\" processor, which takes an optional \"timestep\" parameter and a media file as input. It may check moving areas, total movements, and local movements, differentiating it from frame border detector.",
        "type": "comment"
    },
    "448": {
        "file_id": 22,
        "content": "/pyjom/templates/medialang/autoCensor/frameborder_detector.mdl.j2",
        "type": "filepath"
    },
    "449": {
        "file_id": 22,
        "content": "This code defines a template for frameborder_detector, which takes in model and config as parameters. By default, the model is framedifference_talib, but it can be configured to be huffline_horizontal_vertical. The output includes main frame time and location, possibly from a moving object.",
        "type": "summary"
    },
    "450": {
        "file_id": 22,
        "content": "(\".json\", processor=\"frameborder_detector\" {% if model %}, model=\"{{model}}\"{% endif %} {% if config %}, config={{config}}{% endif %}\n) # model default to be framedifference_talib, or config it to be huffline_horizontal_vertical, only output main frame time and location. might be moving. i don't know. maybe we need to eliminate all moving things.\n(\"{{ mediafile }}\")",
        "type": "code",
        "location": "/pyjom/templates/medialang/autoCensor/frameborder_detector.mdl.j2:1-4"
    },
    "451": {
        "file_id": 22,
        "content": "This code defines a template for frameborder_detector, which takes in model and config as parameters. By default, the model is framedifference_talib, but it can be configured to be huffline_horizontal_vertical. The output includes main frame time and location, possibly from a moving object.",
        "type": "comment"
    },
    "452": {
        "file_id": 23,
        "content": "/pyjom/templates/medialang/autoCensor/file_format_detector.mdl.j2",
        "type": "filepath"
    },
    "453": {
        "file_id": 23,
        "content": "This code snippet defines a tuple containing the file format \"json\" and specifies the processor \"file_format_detector\". The mediafile variable is used within double curly braces to represent the file's content.",
        "type": "summary"
    },
    "454": {
        "file_id": 23,
        "content": "(\".json\", processor=\"file_format_detector\"\n)\n(\"{{ mediafile }}\")",
        "type": "code",
        "location": "/pyjom/templates/medialang/autoCensor/file_format_detector.mdl.j2:1-4"
    },
    "455": {
        "file_id": 23,
        "content": "This code snippet defines a tuple containing the file format \"json\" and specifies the processor \"file_format_detector\". The mediafile variable is used within double curly braces to represent the file's content.",
        "type": "comment"
    },
    "456": {
        "file_id": 24,
        "content": "/pyjom/templates/medialang/autoCensor/blackout_detector.mdl.j2",
        "type": "filepath"
    },
    "457": {
        "file_id": 24,
        "content": "The code represents a template for the blackout_detector.mdl.j2 file in the pyjom project. It defines a processor called \"blackout_detector\" and includes optional timestep variable, as well as the mediafile path.",
        "type": "summary"
    },
    "458": {
        "file_id": 24,
        "content": "(\".json\", processor=\"blackout_detector\"{% if timestep %}, timestep={{timestep}}{% endif %}\n)\n(\"{{ mediafile }}\")",
        "type": "code",
        "location": "/pyjom/templates/medialang/autoCensor/blackout_detector.mdl.j2:1-4"
    },
    "459": {
        "file_id": 24,
        "content": "The code represents a template for the blackout_detector.mdl.j2 file in the pyjom project. It defines a processor called \"blackout_detector\" and includes optional timestep variable, as well as the mediafile path.",
        "type": "comment"
    },
    "460": {
        "file_id": 25,
        "content": "/pyjom/primitives/weiboPrimitives.py",
        "type": "filepath"
    },
    "461": {
        "file_id": 25,
        "content": "This code defines a class `WeiboPetsReviewer` that inherits from `ContentReviewer`. It has various parameters for configuration and updates the `methodsList` with different methods like \"topic\", \"fetcher\", \"reviewer\", and \"feedback\". The reviewer is meant to automate content labeling tasks.",
        "type": "summary"
    },
    "462": {
        "file_id": 25,
        "content": "from pyjom.main import *\nfrom pyjom.commons import *\n# this is a reviewer, not a poster.\n# you may create interface to label the content and automate the stuff altogether.\nclass WeiboPetsReviewer(ContentReviewer):\n    def __init__(self, enable_log=True, auto=False,semiauto=True, dummy_auto=True,\n        template_names=[],args={},basedir=\"/dev/shm/sina\",autopurge=True):\n        super().__init__()\n        if enable_log:\n            self.log_location = \"logs/sina/pets/\"\n        if autopurge:\n            shutil.rmtree(basedir)\n        self.identifier.typeFix(type(self).__name__)\n        self.methodsList.update(\n            {\n                \"topic\": petsTopicGenerator,\n                \"fetcher\": weiboFetcher,\n                \"reviewer\": keywordDecorator(weiboSearchReviewer, basedir=basedir,auto=auto,semiauto=semiauto,dummy_auto=dummy_auto,template_names=template_names,args=args),\n                \"feedback\": weiboFeedback,\n            }\n        )",
        "type": "code",
        "location": "/pyjom/primitives/weiboPrimitives.py:1-23"
    },
    "463": {
        "file_id": 25,
        "content": "This code defines a class `WeiboPetsReviewer` that inherits from `ContentReviewer`. It has various parameters for configuration and updates the `methodsList` with different methods like \"topic\", \"fetcher\", \"reviewer\", and \"feedback\". The reviewer is meant to automate content labeling tasks.",
        "type": "comment"
    },
    "464": {
        "file_id": 26,
        "content": "/pyjom/primitives/onlinePrimitives.py",
        "type": "filepath"
    },
    "465": {
        "file_id": 26,
        "content": "The code defines the OnlineAutoContentProducer class, initializes variables, updates methodsList with keywordDecorator wrapped instances for content production, and creates OnlineProducer/Poster with multi-platform posting capabilities.",
        "type": "summary"
    },
    "466": {
        "file_id": 26,
        "content": "from pyjom.main import *\nfrom typing import Generator\nfrom types import FunctionType\nclass OnlineAutoContentProducer(ContentProducer):\n    def __init__(\n        self,\n        source=None,\n        debug=False,\n        enable_log=True,\n        fast: bool = True,\n        afterPosting: FunctionType = ...,\n        postMetadataGenerator: Generator = ...,\n        processor_filters={},\n        producer_filters={},\n        platform: str = \"bilibili\",\n        template: str = \"pets_with_music_online\",\n        template_configs: list = [],  # list or 'template_config' generator\n        contentType: str = \"video\",  # for poster.\n        tempdir: str = \"/dev/shm/medialang/online\",\n        metaTopic={\n            \"static\": [[\"dog\", \"cat\", \"puppy\"], [\"funny\", \"cute\"]],\n            \"dynamic\": [[\"samoyed\", \"husky\", \"teddy\", \"chiwawa\"]],\n        },\n        dog_or_cat='dog',\n    ):  # something in this metaTopic is not droppable.\n        super().__init__()\n        # do afterPosting before even start it.\n        # now we might want to check our product before another test.",
        "type": "code",
        "location": "/pyjom/primitives/onlinePrimitives.py:1-30"
    },
    "467": {
        "file_id": 26,
        "content": "The code defines a class called `OnlineAutoContentProducer` which extends the `ContentProducer` class. It has various parameters such as `source`, `debug`, `enable_log`, `fast`, etc., and uses functions from other modules, including `FunctionType` and `Generator`. The constructor initializes the object by calling the parent's constructor using `super().__init__()`, and there is a note that `afterPosting` should be performed before starting. The `metaTopic` dictionary contains categories for static and dynamic content.",
        "type": "comment"
    },
    "468": {
        "file_id": 26,
        "content": "        try:\n            afterPosting()\n        except:\n            pass\n        assert source is not None\n        self.source = source\n        self.tempdir = tempdir\n        self.fast = fast\n        self.metaTopic = metaTopic  # 所谓的超话 超级话题\n        if enable_log:\n            self.log_location = \"logs/local/\"  # what location?\n        self.identifier.typeFix(type(self).__name__)\n        self.methodsList.update(\n            {\n                \"topic\": keywordDecorator(\n                    OnlineTopicGenerator, source=source, metaTopic=metaTopic\n                ),  # how to generate this?\n                \"info\": keywordDecorator(\n                    OnlineFetcher, source=source, tempdir=tempdir\n                ),  # can you do that?\n                \"processor\": keywordDecorator(\n                    OnlineProcessor, source=source, dog_or_cat=dog_or_cat\n                ),  # this is the second thing. how do you process this?\n                # \"reviewer\": filesystemReviewer,\n                \"producer\": keywordDecorator(",
        "type": "code",
        "location": "/pyjom/primitives/onlinePrimitives.py:31-55"
    },
    "469": {
        "file_id": 26,
        "content": "This code attempts to set up various methods for a class. It initializes instance variables, handles logging location if enabled, and updates the methodsList dictionary with keywordDecorator wrapped OnlineTopicGenerator, OnlineFetcher, and OnlineProcessor instances based on provided arguments. The \"reviewer\" method is not implemented, and the \"producer\" method uses keywordDecorator with source argument for its implementation.",
        "type": "comment"
    },
    "470": {
        "file_id": 26,
        "content": "                    OnlineProducer,  # what does this 'OnlineProducer' generate?\n                    source=source,\n                    template=template,\n                    fast=self.fast,\n                    template_configs=template_configs,\n                    debug=debug,  # overkill?\n                ),\n                \"poster\": keywordDecorator(\n                    OnlinePoster,  # you need to be prudent. this is not kids stuff. figure out how to post to multiple platforms the same time, figure out how to post to individual platform one by one.\n                    iterate=True,\n                    contentType=contentType,\n                    postMetadataGenerator=postMetadataGenerator,\n                    platform=platform,\n                    afterPosting=afterPosting,\n                )  # just for debugging.\n                # you also need to change the logic below, for other 'dummy' stuffs.\n                # 'poster':keywordDecorator(dummyPoster, iterate=True) # just for debugging.\n            }",
        "type": "code",
        "location": "/pyjom/primitives/onlinePrimitives.py:56-73"
    },
    "471": {
        "file_id": 26,
        "content": "This code creates an instance of OnlineProducer and OnlinePoster, decorating the latter with a keywordDecorator for multi-platform posting. The OnlineProducer generates content based on source and template, while the OnlinePoster can post to multiple platforms simultaneously or individually. The debug option is used for testing purposes.",
        "type": "comment"
    },
    "472": {
        "file_id": 26,
        "content": "        )",
        "type": "code",
        "location": "/pyjom/primitives/onlinePrimitives.py:74-74"
    },
    "473": {
        "file_id": 26,
        "content": "This line of code is closing a parenthesis, which could potentially be part of a function call or mathematical expression. It indicates that the previous statement or operation has been completed and there are no further instructions to follow within this context.",
        "type": "comment"
    },
    "474": {
        "file_id": 27,
        "content": "/pyjom/primitives/localPrimitives.py",
        "type": "filepath"
    },
    "475": {
        "file_id": 27,
        "content": "The code defines a class for content reviewing, and two classes for automatic content reviewing and producing. The classes have configuration parameters and methods for file operations and topic associations. A producer instance is defined with filters, template, and template_config options.",
        "type": "summary"
    },
    "476": {
        "file_id": 27,
        "content": "from pyjom.main import *\nclass FilesystemContentReviewer(ContentReviewer):\n    def __init__(self, filepath=None, dirpath=None, recursive=False, enable_log=True):\n        super().__init__()\n        if filepath is None:\n            assert dirpath is not None\n        else:\n            raise Exception(\"filepath and dirpath cannot both be None.\")\n        self.filepath = filepath\n        self.dirpath = dirpath\n        self.recursive = recursive\n        if enable_log:\n            self.log_location = \"logs/local/\"\n        self.identifier.typeFix(type(self).__name__)\n        self.methodsList.update(\n            {\n                \"topic\": filesystemTopicGenerator,  # how to generate this?\n                \"fetcher\": filesystemFetcher,\n                \"reviewer\": filesystemReviewer,\n            }\n        )\n    def get_one_topic(self):\n        topic, source = self.methodsList[\"topic\"](\n            filepath=self.filepath, dirpath=self.dirpath, recursive=self.recursive\n        )  # a sequence of things.\n        self.identifier.topicFix(source)",
        "type": "code",
        "location": "/pyjom/primitives/localPrimitives.py:1-29"
    },
    "477": {
        "file_id": 27,
        "content": "This code defines a class, FilesystemContentReviewer, which is a subclass of ContentReviewer. It initializes with optional filepath or dirpath, recursive flag, and enable_log boolean. If enable_log is True, it sets the log_location. The class has a method, get_one_topic(), that retrieves one topic using specified parameters. It also defines three methods (topic, fetcher, reviewer) within its methodsList attribute.",
        "type": "comment"
    },
    "478": {
        "file_id": 27,
        "content": "        return topic\nclass FilesystemAutoContentReviewer(FilesystemContentReviewer):\n    def __init__(\n        self,\n        filepath=None,\n        dirpath=None,\n        recursive=False,\n        enable_log=True,\n        semiauto=True,\n        dummy_auto=True,\n        template_names=[],\n        args={},\n    ):\n        super().__init__(\n            filepath=filepath,\n            dirpath=dirpath,\n            recursive=recursive,\n            enable_log=enable_log,\n        )\n        self.identifier.typeFix(type(self).__name__)\n        self.methodsList.update(\n            {\n                \"reviewer\": keywordDecorator(\n                    filesystemReviewer,\n                    auto=True,\n                    semiauto=semiauto,\n                    dummy_auto=dummy_auto,\n                    template_names=template_names,\n                    args=args,\n                )\n            }\n        )\nclass FilesystemAutoContentProducer(ContentProducer):\n    def __init__(self, filepath=None, dirpath=None, recursive=False, enable_log=T",
        "type": "code",
        "location": "/pyjom/primitives/localPrimitives.py:30-66"
    },
    "479": {
        "file_id": 27,
        "content": "The code defines two classes, `FilesystemAutoContentReviewer` and `FilesystemAutoContentProducer`, which inherit from `FilesystemContentReviewer` and `ContentProducer` respectively. These classes have various parameters for configuration such as file/directory paths, recursive mode, logging settings, and template names. They also have methods for automatic content reviewing and producing.",
        "type": "comment"
    },
    "480": {
        "file_id": 27,
        "content": "rue,reviewerLogs = [],processor_filters={},producer_filters={}, path_replacers = [], template=\"pets_with_music\", template_config = {}):\n        super().__init__()\n        if filepath is None:\n            assert dirpath is not None\n        else:\n            raise Exception(\"filepath and dirpath cannot both be None.\")\n        self.filepath = filepath\n        self.dirpath = dirpath\n        self.recursive = recursive\n        self.reviewerLogs = reviewerLogs\n        if enable_log:\n            self.log_location = \"logs/local/\"\n        self.identifier.typeFix(type(self).__name__)\n        self.methodsList.update(\n            {\n                \"topic\": filesystemTopicGenerator,  # how to generate this?\n                \"info\": filesystemFetcher, # can you do that?\n                \"processor\": keywordDecorator(FilesystemProcessor,reviewerLogs=self.reviewerLogs,filters=processor_filters, path_replacers = path_replacers), # this is the second thing. how do you process this?\n                # \"reviewer\": filesystemReviewer,",
        "type": "code",
        "location": "/pyjom/primitives/localPrimitives.py:66-84"
    },
    "481": {
        "file_id": 27,
        "content": "The code represents a class with file operations. The constructor takes parameters such as filepath, dirpath, recursive flag, reviewerLogs, enable_log, and type name. If filepath is None, it checks if dirpath is not None to avoid both being None. It also sets up log location and updates methods list. \"topic\" method generates a topic, \"info\" method fetches information, and \"processor\" method processes using keyword decorator with given parameters.",
        "type": "comment"
    },
    "482": {
        "file_id": 27,
        "content": "                \"producer\": keywordDecorator(FilesystemProducer, filters=producer_filters, template=template,template_config = template_config),\n            }\n        )\n    def get_one_topic(self):\n        topic, source = self.methodsList[\"topic\"](\n            filepath=self.filepath, dirpath=self.dirpath, recursive=self.recursive\n        )  # a sequence of things.\n        self.identifier.topicFix(source)\n        return topic\n# ctrl + shift + t: reopen closed tab in vscode",
        "type": "code",
        "location": "/pyjom/primitives/localPrimitives.py:85-95"
    },
    "483": {
        "file_id": 27,
        "content": "This code defines a class with methods to get a topic and its associated source, using filepath, dirpath, and recursive parameters. The \"producer\" is defined as a keyword-decorated instance of the FilesystemProducer class, with filters, template, and template_config options. The get_one_topic method returns the topic after applying topicFix from the identifier object.",
        "type": "comment"
    },
    "484": {
        "file_id": 28,
        "content": "/pyjom/primitives/__init__.py",
        "type": "filepath"
    },
    "485": {
        "file_id": 28,
        "content": "This code imports multiple modules from the same package, likely for accessing different sets of primitives.",
        "type": "summary"
    },
    "486": {
        "file_id": 28,
        "content": "from pyjom.primitives.localPrimitives import *\nfrom pyjom.primitives.weiboPrimitives import *\nfrom pyjom.primitives.onlinePrimitives import *",
        "type": "code",
        "location": "/pyjom/primitives/__init__.py:1-3"
    },
    "487": {
        "file_id": 28,
        "content": "This code imports multiple modules from the same package, likely for accessing different sets of primitives.",
        "type": "comment"
    },
    "488": {
        "file_id": 29,
        "content": "/pyjom/config/shared.py",
        "type": "filepath"
    },
    "489": {
        "file_id": 29,
        "content": "The code initializes a dictionary named \"pyjom_config\" with a single key-value pair. The key is \"BEZIER_PADDLE_RESNET50_IMAGE_DOG_CAT_DETECTOR_SERVER_INSTANCE\", and its value is set to False. This configuration appears to relate to various components of an image detection system, possibly including a Bezier paddle, Paddle ResNet50 model, Dog/Cat detector, and server instance.",
        "type": "summary"
    },
    "490": {
        "file_id": 29,
        "content": "pyjom_config=dict(BEZIER_PADDLE_RESNET50_IMAGE_DOG_CAT_DETECTOR_SERVER_INSTANCE=False)",
        "type": "code",
        "location": "/pyjom/config/shared.py:1-1"
    },
    "491": {
        "file_id": 29,
        "content": "The code initializes a dictionary named \"pyjom_config\" with a single key-value pair. The key is \"BEZIER_PADDLE_RESNET50_IMAGE_DOG_CAT_DETECTOR_SERVER_INSTANCE\", and its value is set to False. This configuration appears to relate to various components of an image detection system, possibly including a Bezier paddle, Paddle ResNet50 model, Dog/Cat detector, and server instance.",
        "type": "comment"
    },
    "492": {
        "file_id": 30,
        "content": "/pyjom/config/__init__.py",
        "type": "filepath"
    },
    "493": {
        "file_id": 30,
        "content": "This code imports all functions and variables from the \"sina\" and \"medialang\" modules within the pyjom.config package. These modules may contain configurations for different components or services used in the application, potentially related to Sina Weibo and Media Language processing.",
        "type": "summary"
    },
    "494": {
        "file_id": 30,
        "content": "from pyjom.config.sina import *\nfrom pyjom.config.medialang import *",
        "type": "code",
        "location": "/pyjom/config/__init__.py:1-2"
    },
    "495": {
        "file_id": 30,
        "content": "This code imports all functions and variables from the \"sina\" and \"medialang\" modules within the pyjom.config package. These modules may contain configurations for different components or services used in the application, potentially related to Sina Weibo and Media Language processing.",
        "type": "comment"
    },
    "496": {
        "file_id": 31,
        "content": "/pyjom/config/sina/__init__.py",
        "type": "filepath"
    },
    "497": {
        "file_id": 31,
        "content": "The code imports all the functions, classes, and variables from the \"sinaWeibo\" module in the \"pyjom.config.sina\" package.",
        "type": "summary"
    },
    "498": {
        "file_id": 31,
        "content": "from pyjom.config.sina.sinaWeibo import *",
        "type": "code",
        "location": "/pyjom/config/sina/__init__.py:1-1"
    },
    "499": {
        "file_id": 31,
        "content": "The code imports all the functions, classes, and variables from the \"sinaWeibo\" module in the \"pyjom.config.sina\" package.",
        "type": "comment"
    }
}