{
    "400": {
        "file_id": 30,
        "content": "from types import GeneratorType\nfrom pyjom.commons import *  # really swap this shit?\nfrom pyjom.modules import *\nclass ContentProducer:\n    def __init__(self):\n        self.uuid = dummyId()\n        self.log_location = None\n        self.trash_location = None\n        self.methodsList = {\n            \"topic\": dummyTopic,\n            \"info\": dummyInfo,\n            \"processor\": dummyProcessor,\n            \"producer\": dummyProducer,\n            \"poster\": dummyPoster,\n            # below three all switched to 'auto' mode for iterating generators.\n            \"feedback\": dummyFeedback,\n            \"optimizer\": dummyOptimizer,\n            \"updator\": dummyUpdator,\n            \"identifier\": dummyIdentifier,\n        }\n        self.identifier = self.get_one_identifier(\n            self.uuid\n        )  # make sure occasionly used methods can be regenerated.\n        self.identifier.typeFix(type(self).__name__)\n    def get_one_identifier(self, uuid):\n        return self.methodsList[\"identifier\"](uuid)\n    def get_one_topic(self):",
        "type": "code",
        "location": "/pyjom/main.py:1-31"
    },
    "401": {
        "file_id": 30,
        "content": "This code initializes a ContentProducer class with various methods and identifiers, ensuring regeneration of occasionally used methods. It utilizes dummy functions for different tasks and has the ability to switch modes for certain generators.",
        "type": "comment"
    },
    "402": {
        "file_id": 30,
        "content": "        topic, source = self.methodsList[\"topic\"]()\n        self.identifier.topicFix(source)\n        return topic\n    def get_some_info(self, topic):\n        info, source = self.methodsList[\"info\"](topic)\n        self.identifier.infoFix(source)\n        return info\n    def process_some_info(self, info):\n        method = self.methodsList[\"processor\"]\n        # print(method)\n        # breakpoint()\n        # print(info)\n        processed_info, source = method(info)\n        # print(processed_info,source)\n        # breakpoint()\n        self.identifier.processorFix(source)\n        return processed_info\n    def produce_some_content(self, processed_info):\n        # print(processed_info)\n        # print(self.methodsList['producer'])\n        # breakpoint()\n        content, source = self.methodsList[\"producer\"](processed_info)\n        self.identifier.producerFix(source)\n        return content\n    def post_some_content(self, content):\n        posted_location, source = self.methodsList[\"poster\"](content)\n        self.identifier.posterFix(source)",
        "type": "code",
        "location": "/pyjom/main.py:32-62"
    },
    "403": {
        "file_id": 30,
        "content": "This code defines several methods for processing and producing content. It uses a \"methodsList\" dictionary to dynamically call different methods based on input parameters. Each method is responsible for a specific step in the processing chain, with potential fixing operations performed by \"identifier\" after each step.",
        "type": "comment"
    },
    "404": {
        "file_id": 30,
        "content": "        return posted_location\n    def collect_some_feedback(self, posted_location):\n        feedback, source = self.methodsList[\"feedback\"](posted_location)\n        self.identifier.feedbackFix(source)\n        return feedback\n    def optimize_topic_by_feedback(self, topic, feedback):\n        optimized_result, source = self.methodsList[\"optimizer\"](topic, feedback)\n        self.identifier.optimizerFix(source)\n        return feedback\n    def update_optimized_result(self, optimized_result):\n        update_result, source = self.methodsList[\"updator\"](optimized_result)\n        if type(update_result) == GeneratorType:\n            for _ in update_result:\n                ...  # to fix not iterating bug.\n        self.identifier.updatorFix(source)\n    def main(self):\n        topic = self.get_one_topic()\n        info = self.get_some_info(topic)\n        processed_info = self.process_some_info(info)\n        # print(\"PROCESSED_INFO: %s\" % processed_info)\n        # breakpoint()\n        content = self.produce_some_content(processed_info)",
        "type": "code",
        "location": "/pyjom/main.py:63-88"
    },
    "405": {
        "file_id": 30,
        "content": "This code defines several methods for collecting feedback, optimizing a topic based on feedback, updating an optimized result, and getting one topic. It also includes a main function that retrieves information, processes it, produces content, and possibly prints or debugs processed info.",
        "type": "comment"
    },
    "406": {
        "file_id": 30,
        "content": "        posted_location = self.post_some_content(content)\n        feedback = self.collect_some_feedback(posted_location)\n        optimized_result = self.optimize_topic_by_feedback(topic, feedback)\n        self.update_optimized_result(optimized_result)\nclass ContentReviewer(ContentProducer):\n    def __init__(self):\n        super().__init__()\n        self.identifier.typeFix(type(self).__name__)\n        self.methodsList.update(\n            {\n                \"fetcher\": dummyFetcher,\n                \"reviewer\": dummyReviewer,\n                \"reviewOptimizer\": dummyReviewOptimizer,\n            }\n        )\n    def fetch_some_content(self, topic):\n        (posted_location, content), source = self.methodsList[\"fetcher\"](topic)\n        self.identifier.fetcherFix(source)\n        return posted_location, content\n    def review_content(self, content):\n        review, source = self.methodsList[\"reviewer\"](content)\n        self.identifier.reviewerFix(source)\n        return review\n    def optimize_topic_by_feedback_review(self, topic, feedback, review):",
        "type": "code",
        "location": "/pyjom/main.py:89-117"
    },
    "407": {
        "file_id": 30,
        "content": "This code defines a class called ContentReviewer which inherits from ContentProducer. It has methods for fetching content, reviewing content, and optimizing topics based on feedback and review. The update_optimized_result method is used to store the optimized result. The methodsList dictionary contains predefined functions for fetching, reviewing, and optimizing content.",
        "type": "comment"
    },
    "408": {
        "file_id": 30,
        "content": "        optimized_result, source = dummyReviewOptimizer(topic, feedback, review)\n        return optimized_result  # this with instant feedback.\n    def main(self, skip_review=False):\n        if self.trash_location is not None:\n            print(\"dumping trash at:\\n{}\".format(self.trash_location))\n            dumpTrashDir(self.trash_location)\n        topic = self.get_one_topic()\n        # print(\"fetched topic:\", topic)\n        protocol, content = self.fetch_some_content(topic)  # dummy since here.\n        # print(\"fetched protocol:\", protocol)\n        # print(\"fetched content:\", content)\n        if not skip_review:\n            review = self.review_content(content)  # dummy reviewer.\n            # print(\"reviewed content:\", review)\n        else:\n            review = {key: [] for key in content.keys()}  # test feedback\n            # of course nothing will be there.\n        feedback = self.collect_some_feedback(review)  # instant feedback.\n        # print(\"fetched feedback:\", feedback)\n        # breakpoint()\n        if self.log_location is not None:",
        "type": "code",
        "location": "/pyjom/main.py:118-140"
    },
    "409": {
        "file_id": 30,
        "content": "This code fetches content and feedback for a given topic, performs a review (if skip_review is False), and returns optimized results with instant feedback. The code also handles trash location and log location settings.",
        "type": "comment"
    },
    "410": {
        "file_id": 30,
        "content": "            mtype0, mcontent = jsonPrettyPrint(review)\n            mtype1, mfeedback_content = jsonPrettyPrint(feedback)\n            mtype0 = \"log\" if mtype0 != \"json\" else mtype0\n            mtype1 = \"log\" if mtype0 != \"json\" else mtype1\n            timestamp = getTimestamp()\n            timestamp = str(timestamp).replace(\".\", \"_\")\n            logName = \"{}.{}\".format(timestamp, mtype0)\n            feedback_logName = \"{}_feedback.{}\".format(timestamp, mtype1)\n            writeFileWithPath(\n                self.log_location, logName, mcontent, \"w+\", encoding=\"utf-8\"\n            )\n            writeFileWithPath(\n                self.log_location,\n                feedback_logName,\n                mfeedback_content,\n                \"w+\",\n                encoding=\"utf-8\",\n            )\n        # feedback is non-existant for local files.\n        optimized_result = self.optimize_topic_by_feedback_review(\n            topic, feedback, review\n        )\n        self.update_optimized_result(optimized_result)",
        "type": "code",
        "location": "/pyjom/main.py:141-165"
    },
    "411": {
        "file_id": 30,
        "content": "The code is parsing review and feedback data, converting them to desired types, generating timestamps, creating log file names, writing the data to files at a specified location, and then proceeding with optimization using the parsed data.",
        "type": "comment"
    },
    "412": {
        "file_id": 31,
        "content": "/pyjom/mathlib.py",
        "type": "filepath"
    },
    "413": {
        "file_id": 31,
        "content": "This code uses a Kalman Filter for time series smoothing, provides utility functions, manages overlapping intervals, handles range merging and sorting, includes Bezier curve function, applies exponential network to multiple inputs, and has a window-based maximum average finding function.",
        "type": "summary"
    },
    "414": {
        "file_id": 31,
        "content": "# moved to lazero.utils.mathlib\nfrom lazero.utils.mathlib import *\n# # not overriding math.\n# # do some ranged stuff here...\n# from pykalman import KalmanFilter\n# import numpy as np\n# def superMean(mList:list,default=0):\n#     if len(mList) == 0: return  default\n#     return np.mean(mList)\n# def superMax(mList:list,default=0):\n#     if len(mList) == 0: return default\n#     return max(mList)\n# def superMin(mList:list,default=0):\n#     if len(mList) == 0: return default\n#     return min(mList)\n# def uniq(mList, ordered=True, random=False):\n#     if ordered:\n#         result = []\n#         for elem in mList:\n#             if elem not in result:\n#                 result.append(elem)\n#     else:\n#         result = list(set(mList))\n#     if random:\n#         import random\n#         random.shuffle(result)\n#     return result\n# def get1DArrayEMA(mArray, N=5):\n#     weights = np.exp(np.linspace(0, 1, N))\n#     weights = weights / np.sum(weights)\n#     ema = np.convolve(weights, mArray, mode=\"valid\")\n#     return ema\n# def Kalman1D(observations, damping=0.2):",
        "type": "code",
        "location": "/pyjom/mathlib.py:1-40"
    },
    "415": {
        "file_id": 31,
        "content": "This code defines several utility functions for numerical operations, including mean, max, min, unique values (with optional ordering and shuffling), Exponential Moving Average (EMA), and a Kalman Filter. It imports necessary libraries like numpy and pykalman.",
        "type": "comment"
    },
    "416": {
        "file_id": 31,
        "content": "#     # To return the smoothed time series data\n#     observation_covariance = damping\n#     initial_value_guess = observations[0]\n#     transition_matrix = 1\n#     transition_covariance = 0.1\n#     initial_value_guess\n#     kf = KalmanFilter(\n#         initial_state_mean=initial_value_guess,\n#         initial_state_covariance=observation_covariance,\n#         observation_covariance=observation_covariance,\n#         transition_covariance=transition_covariance,\n#         transition_matrices=transition_matrix,\n#     )\n#     pred_state, state_cov = kf.smooth(observations)\n#     return pred_state\n# def getContinualNonSympyMergeResult(inputMSetCandidates):\n#     # basically the same example.\n#     # assume no overlapping here.\n#     import sympy\n#     def unionToTupleList(myUnion):\n#         unionBoundaries = list(myUnion.boundary)\n#         unionBoundaries.sort()\n#         leftBoundaries = unionBoundaries[::2]\n#         rightBoundaries = unionBoundaries[1::2]\n#         return list(zip(leftBoundaries, rightBoundaries))",
        "type": "code",
        "location": "/pyjom/mathlib.py:41-66"
    },
    "417": {
        "file_id": 31,
        "content": "The code snippet initializes a KalmanFilter object for smoothing time series data. It defines the observation_covariance, transition_covariance, and other parameters before creating the KalmanFilter instance. The function then calls `kf.smooth(observations)` to perform the smoothing operation and returns the smoothed state. Additionally, there's a helper function that converts a sympy Union set to a list of (left_boundary, right_boundary) tuples.",
        "type": "comment"
    },
    "418": {
        "file_id": 31,
        "content": "#     def tupleSetToUncertain(mSet):\n#         mUncertain = None\n#         for start, end in mSet:\n#             if mUncertain is None:\n#                 mUncertain = sympy.Interval(start, end)\n#             else:\n#                 mUncertain += sympy.Interval(start, end)\n#         typeUncertain = type(mUncertain)\n#         return mUncertain, typeUncertain\n#     def mergeOverlappedInIntervalTupleList(intervalTupleList):\n#         mUncertain, _ = tupleSetToUncertain(intervalTupleList)\n#         mUncertainBoundaryList = list(mUncertain.boundary)\n#         mUncertainBoundaryList.sort()\n#         mergedIntervalTupleList = list(\n#             zip(mUncertainBoundaryList[::2], mUncertainBoundaryList[1::2])\n#         )\n#         return mergedIntervalTupleList\n#     # mSet = mergeOverlappedInIntervalTupleList([(0, 1), (2, 3)])\n#     # mSet2 = mergeOverlappedInIntervalTupleList([(0.5, 1.5), (1.6, 2.5)])\n#     # print(\"MSET\", mSet)\n#     # print(\"MSET2\", mSet2)\n#     mSetCandidates = [\n#         mergeOverlappedInIntervalTupleList(x) for x in inputMSetCandidates",
        "type": "code",
        "location": "/pyjom/mathlib.py:68-94"
    },
    "419": {
        "file_id": 31,
        "content": "This code defines two functions: \"tupleSetToUncertain\" and \"mergeOverlappedInIntervalTupleList\". The first function takes a set of intervals represented as tuples, converts them into a Sympy Interval object representing the union of these intervals, and returns both the object and its type. The second function merges overlapping intervals from a list of interval tuples and returns the merged intervals as a list of start-end pairs. It uses the first function to convert the input intervals into a Sympy Interval object, extracts the boundary points, sorts them, and then zips them back into start-end pairs for the output list.",
        "type": "comment"
    },
    "420": {
        "file_id": 31,
        "content": "#     ]\n#     mSetUnified = [x for y in mSetCandidates for x in y]\n#     leftBoundaryList = set([x[0] for x in mSetUnified])\n#     rightBoundaryList = set([x[1] for x in mSetUnified])\n#     # they may freaking overlap.\n#     # if want nearby-merge strategy, simply just expand all intervals, merge them with union and shrink the individual intervals inside union respectively.\n#     markers = {\n#         \"enter\": {k: [] for k in leftBoundaryList},\n#         \"exit\": {k: [] for k in rightBoundaryList},\n#     }\n#     for index, mSetCandidate in enumerate(mSetCandidates):\n#         leftBoundaryListOfCandidate = [x[0] for x in mSetCandidate]\n#         rightBoundaryListOfCandidate = [x[1] for x in mSetCandidate]\n#         for leftBoundaryOfCandidate in leftBoundaryListOfCandidate:\n#             markers[\"enter\"][leftBoundaryOfCandidate].append(index)  # remap this thing!\n#         for rightBoundaryOfCandidate in rightBoundaryListOfCandidate:\n#             markers[\"exit\"][rightBoundaryOfCandidate].append(index)  # remap this thing!",
        "type": "code",
        "location": "/pyjom/mathlib.py:95-113"
    },
    "421": {
        "file_id": 31,
        "content": "This code creates a dictionary of markers for left and right boundaries. It first combines all set candidates into one list, then creates sets for the left and right boundary lists. It then populates the \"enter\" and \"exit\" dictionaries with the indices where each boundary is encountered. This information can be used for further processing, such as merging nearby intervals or identifying overlapping boundaries.",
        "type": "comment"
    },
    "422": {
        "file_id": 31,
        "content": "#     # now, iterate through the boundaries of mSetUnified.\n#     unifiedBoundaryList = leftBoundaryList.union(\n#         rightBoundaryList\n#     )  # call me a set instead of a list please? now we must sort this thing\n#     unifiedBoundaryList = list(unifiedBoundaryList)\n#     unifiedBoundaryList.sort()\n#     unifiedBoundaryMarks = {}\n#     finalMappings = {}\n#     # print(\"MARKERS\", markers)\n#     # breakpoint()\n#     for index, boundary in enumerate(unifiedBoundaryList):\n#         previousMark = unifiedBoundaryMarks.get(index - 1, [])\n#         enterList = markers[\"enter\"].get(boundary, [])\n#         exitList = markers[\"exit\"].get(boundary, [])\n#         currentMark = set(previousMark + enterList).difference(set(exitList))\n#         currentMark = list(currentMark)\n#         unifiedBoundaryMarks.update({index: currentMark})\n#         # now, handle the change? or not?\n#         # let's just deal those empty ones, shall we?\n#         if previousMark == []:  # inside it is empty range.\n#             # elif currentMark == []:",
        "type": "code",
        "location": "/pyjom/mathlib.py:115-136"
    },
    "423": {
        "file_id": 31,
        "content": "This code is iterating through the boundaries of two lists, unifying them into a sorted list called `unifiedBoundaryList`. It then creates empty dictionaries `unifiedBoundaryMarks` and `finalMappings`. The `markers` dictionary is used to determine which markers correspond to the current boundary. The code calculates the current mark by combining previous markers, entering markers for the current boundary, and removing any exiting markers for the current boundary. It then updates `unifiedBoundaryMarks` with the new index and current marker list. If the previous marker list was empty (indicating an empty range), it does something (code missing).",
        "type": "comment"
    },
    "424": {
        "file_id": 31,
        "content": "#             if index == 0:\n#                 continue  # just the start, no need to note this down.\n#             else:\n#                 finalMappings.update(\n#                     {\n#                         \"empty\": finalMappings.get(\"empty\", [])\n#                         + [(unifiedBoundaryList[index - 1], boundary)]\n#                     }\n#                 )\n#             # the end of previous mark! this interval belongs to previousMark\n#         else:\n#             key = previousMark.copy()\n#             key.sort()\n#             key = tuple(key)\n#             finalMappings.update(\n#                 {\n#                     key: finalMappings.get(key, [])\n#                     + [(unifiedBoundaryList[index - 1], boundary)]\n#                 }\n#             )\n#             # also the end of previous mark! belongs to previousMark.\n#     ### NOW THE FINAL OUTPUT ###\n#     finalCats = {}\n#     for key, value in finalMappings.items():\n#         # value is an array containing subInterval tuples.\n#         value = mergeOverlappedInIntervalTupleList(value)",
        "type": "code",
        "location": "/pyjom/mathlib.py:137-163"
    },
    "425": {
        "file_id": 31,
        "content": "This code appears to be working with a list of intervals and categorizing them into different types. It checks for the start of each interval, updates a dictionary (finalMappings) accordingly, and then handles the end of an interval by assigning it to the previous category. Finally, it processes the finalMappings dictionary to create the final output (finalCats).",
        "type": "comment"
    },
    "426": {
        "file_id": 31,
        "content": "#         valueCorrected = [(mStart, mEnd) for mStart, mEnd in value if mStart < mEnd]\n#         finalCats.update({key: valueCorrected})\n#     # print(\"______________FINAL CATS______________\")\n#     # print(finalCats)\n#     return finalCats\n# def getContinualMappedNonSympyMergeResult(mRangesDict, concatSymbol=\"|\", noEmpty=True):\n#     mKeyMaps = list(mRangesDict.keys())\n#     mSetCandidates = [mRangesDict[key] for key in mKeyMaps]\n#     # the next step will automatically merge all overlapped candidates.\n#     finalCats = getContinualNonSympyMergeResult(mSetCandidates)\n#     finalCatsMapped = {\n#         concatSymbol.join([mKeyMaps[k] for k in mTuple]): finalCats[mTuple]\n#         for mTuple in finalCats.keys()\n#         if type(mTuple) == tuple\n#     }\n#     if not noEmpty:\n#         finalCatsMapped.update(\n#             {k: finalCats[k] for k in finalCats.keys() if type(k) != tuple}\n#         )\n#     return finalCatsMapped\n#     # default not to output empty set?\n# def getContinualMappedNonSympyMergeResultWithRangedEmpty(",
        "type": "code",
        "location": "/pyjom/mathlib.py:164-190"
    },
    "427": {
        "file_id": 31,
        "content": "This code defines two functions, `getContinualMappedNonSympyMergeResult` and `getContinualMappedNonSympyMergeResultWithRangedEmpty`. These functions merge overlapping ranges of values into a single range. They can be used to handle cases where the input is a list of ranges, and we want to merge all ranges that overlap. The merged result is returned as a dictionary with keys being concatenated keys (in the first function) or including non-tuple keys if `noEmpty` flag is set (in the second function).",
        "type": "comment"
    },
    "428": {
        "file_id": 31,
        "content": "#     mRangesDict, start, end, concatSymbol=\"|\"\n# ):\n#     import uuid\n#     emptySetName = str(uuid.uuid4())\n#     newRangesDict = mRangesDict.copy()\n#     newRangesDict.update({emptySetName: [(start, end)]})\n#     newRangesDict = getContinualMappedNonSympyMergeResult(\n#         newRangesDict, concatSymbol=\"|\", noEmpty=True\n#     )\n#     newRangesDict = {\n#         key: [\n#             (mStart, mEnd)\n#             for mStart, mEnd in newRangesDict[key]\n#             if mStart >= start and mEnd <= end and mStart < mEnd\n#         ]\n#         for key in newRangesDict.keys()\n#     }\n#     newRangesDict = {\n#         key: newRangesDict[key]\n#         for key in newRangesDict.keys()\n#         if newRangesDict[key] != []\n#     }\n#     finalNewRangesDict = {}\n#     for key in newRangesDict.keys():\n#         mergedEmptySetName = \"{}{}\".format(concatSymbol, emptySetName)\n#         if mergedEmptySetName in key:\n#             newKey = key.replace(mergedEmptySetName,\"\")\n#             finalNewRangesDict.update({newKey:newRangesDict[key]})",
        "type": "code",
        "location": "/pyjom/mathlib.py:191-219"
    },
    "429": {
        "file_id": 31,
        "content": "This code creates a new dictionary by filtering and merging overlapping ranges. It copies the input dictionary, adds an empty set range, filters non-overlapping ranges, removes empty sets, and finally merges overlapping empty sets.",
        "type": "comment"
    },
    "430": {
        "file_id": 31,
        "content": "#         elif key == emptySetName:\n#             finalNewRangesDict.update({'empty':newRangesDict[key]})\n#         else:\n#             finalNewRangesDict.update({key:newRangesDict[key]})\n#     return finalNewRangesDict\n# def mergedRangesToSequential(renderDict):\n#     renderList = []\n#     for renderCommandString in renderDict.keys():\n#         commandTimeSpans = renderDict[renderCommandString].copy()\n#         # commandTimeSpan.sort(key=lambda x: x[0])\n#         for commandTimeSpan in commandTimeSpans:\n#             mStart, mEnd = commandTimeSpan\n#             if mStart < mEnd:\n#                 renderList.append([renderCommandString, commandTimeSpan].copy())\n#     renderList.sort(key=lambda x: x[1][0])\n#     return renderList\n#     # for renderCommandString, commandTimeSpan in renderList:\n#     #     print(renderCommandString, commandTimeSpan)\n#     # so this is arranged as such:\n#     # [(renderCommandString, commandTimeSpan), ...]\n# def sequentialToMergedRanges(sequence):\n#     mergedRanges = {}\n#     for commandString, commandTimeSpan in sequence:",
        "type": "code",
        "location": "/pyjom/mathlib.py:220-244"
    },
    "431": {
        "file_id": 31,
        "content": "This code seems to handle the merging and sorting of ranges for a set of commands based on their start and end times. It appears that `mergedRangesToSequential` takes a dictionary of command strings and time spans, sorts the command time spans by start time, and then creates a new list with each command and its sorted time span. The code also includes functions for updating a dictionary based on specific conditions and converting a sorted sequence back into merged ranges.",
        "type": "comment"
    },
    "432": {
        "file_id": 31,
        "content": "#         mergedRanges.update({commandString: mergedRanges.get(commandString,[])+[commandTimeSpan]})\n#     mergedRanges = getContinualMappedNonSympyMergeResult(mergedRanges)\n#     return mergedRanges\n# import bezier\n# def bezierCurve(start=(0, 0), end=(1, 1), skew=0):\n#     # skew: (-0.5,0.5) otherwise this shit will look ugly.\n#     assert skew >= -0.5\n#     assert skew <= 0.5\n#     x_start, y_start = start\n#     x_end, y_end = end\n#     x_diff = x_end - x_start\n#     y_diff = y_end - y_start\n#     nodes1 = np.asfortranarray(\n#         [\n#             [x_start, x_diff * (0.5 + skew), x_end],\n#             [y_start, y_diff * (0.5 - skew), y_end],\n#         ]\n#     )\n#     curve1 = bezier.Curve(nodes1, degree=2)\n#     curve_params = {\"x_start\": x_start, \"x_diff\": x_diff, \"x_end\": x_end}\n#     return curve1, curve_params\n# def evaluateBezierCurve(input_value: float, curve, curve_params: dict):\n#     x_start = curve_params[\"x_start\"]\n#     x_end = curve_params[\"x_end\"]\n#     assert x_start <= input_value\n#     assert x_end >= input_value",
        "type": "code",
        "location": "/pyjom/mathlib.py:245-274"
    },
    "433": {
        "file_id": 31,
        "content": "This code defines a function `bezierCurve` that takes three arguments: start, end, and skew. It then uses the given values to create a Bezier curve by defining nodes based on the input parameters and returns the created curve along with a dictionary of curve parameters. The separate function `evaluateBezierCurve` is defined to evaluate a previously created Bezier curve at a specific input value, taking as arguments the input value, the created curve, and the dictionary of curve parameters. The function checks if the input value falls within the start and end points of the curve before returning the evaluated x-coordinate.",
        "type": "comment"
    },
    "434": {
        "file_id": 31,
        "content": "#     x_diff = curve_params[\"x_diff\"]\n#     s = (input_value - x_start) / x_diff\n#     points = curve.evaluate(s)\n#     # we only get the single point.\n#     point = points.T[0]\n#     x, y = point\n#     result = y\n#     return result\n# def multiParameterExponentialNetwork(\n#     *args,\n#     input_bias=0.05,\n#     curve_function=bezierCurve,\n#     curve_function_kwargs={\"start\": (0, 0), \"end\": (1, 1), \"skew\": 0},\n#     evaluate_function=evaluateBezierCurve\n# ):\n#     curve, curve_params = curve_function(**curve_function_kwargs)\n#     value = evaluate_function(input_bias, curve, curve_params)\n#     for index, input_value in enumerate(args):\n#         apply_list = [input_value] * (index + 1)\n#         for apply_item in apply_list:\n#             value += (1 - value) * evaluate_function(apply_item, curve, curve_params)\n#     return value\n# def getCursorOfMaxAverageInWindow(referenceData, windowSize, dataDuration, superSampleRate=8):\n#     assert windowSize<dataDuration\n#     # we supersample this reference data?\n#     fp = referenceData",
        "type": "code",
        "location": "/pyjom/mathlib.py:275-303"
    },
    "435": {
        "file_id": 31,
        "content": "The code defines a function `multiParameterExponentialNetwork` that takes multiple inputs and applies an exponential network function to each of them. The result is the average value after applying the function to all inputs. Another function, `getCursorOfMaxAverageInWindow`, calculates the cursor of maximum average in a given window size for a dataset, asserting that the window size is less than the data duration.",
        "type": "comment"
    },
    "436": {
        "file_id": 31,
        "content": "#     xp = np.linspace(0,dataDuration, len(fp))\n#     interpolated_xp = np.linspace(0, dataDuration, len(fp)*superSampleRate)\n#     fp = np.array(fp)\n#     interpolated_fp = []\n#     for x in interpolated_xp:\n#         interpolated_value = np.interp(x, xp, fp)\n#         interpolated_fp.append(interpolated_value)\n#     interpolated_fp = np.array(interpolated_fp)\n#     moving_sum_span = 0\n#     for index, value in enumerate(interpolated_xp):\n#         if value - windowSize >=0: break\n#         moving_sum_span = index\n#     moving_sum_span +=1\n#     moving_sum = np.convolve(interpolated_fp, np.ones(moving_sum_span),'valid')\n#     max_index = np.argmax(moving_sum)\n#     cursor = interpolated_fp[max_index]\n#     cursor = min(dataDuration-windowSize,cursor)\n#     return cursor",
        "type": "code",
        "location": "/pyjom/mathlib.py:304-322"
    },
    "437": {
        "file_id": 31,
        "content": "This code interpolates data, applies a moving average window, and returns the cursor value at the peak of the smoothed signal.",
        "type": "comment"
    },
    "438": {
        "file_id": 32,
        "content": "/pyjom/medialang/__init__.py",
        "type": "filepath"
    },
    "439": {
        "file_id": 32,
        "content": "This code imports necessary modules from 'pyjom.medialang.core' and 'pyjom.medialang.commons' to facilitate media language processing in the application.",
        "type": "summary"
    },
    "440": {
        "file_id": 32,
        "content": "from pyjom.medialang.core import *\nfrom pyjom.medialang.commons import *",
        "type": "code",
        "location": "/pyjom/medialang/__init__.py:1-2"
    },
    "441": {
        "file_id": 32,
        "content": "This code imports necessary modules from 'pyjom.medialang.core' and 'pyjom.medialang.commons' to facilitate media language processing in the application.",
        "type": "comment"
    },
    "442": {
        "file_id": 33,
        "content": "/pyjom/medialang/__main__.py",
        "type": "filepath"
    },
    "443": {
        "file_id": 33,
        "content": "The code sets up argument parsing for a medialang file path, initializes a Medialang object with the parsed script_path, and if the script_obj is not None, it prettifies the script in-place and prints the path of the prettified script.",
        "type": "summary"
    },
    "444": {
        "file_id": 33,
        "content": "from pyjom.medialang.core import *\nif __name__ == \"__main__\":\n    import argparse\n    arg_parser = argparse.ArgumentParser()\n    arg_parser.add_argument(\n        \"-f\",\n        \"--file\",\n        help=\"medialang file path that needed to be formatted.\",\n        type=str,\n        required=True,\n    )\n    parse_result = arg_parser.parse_args()\n    file_path = parse_result.file\n    mdl = Medialang(script_path=file_path)  # will be parsed.\n    if mdl.script_obj is not None:\n        mdl.prettify(inplace=True)\n        print(\"prettified: \", mdl.script_path)\n    # pass",
        "type": "code",
        "location": "/pyjom/medialang/__main__.py:1-20"
    },
    "445": {
        "file_id": 33,
        "content": "The code sets up argument parsing for a medialang file path, initializes a Medialang object with the parsed script_path, and if the script_obj is not None, it prettifies the script in-place and prints the path of the prettified script.",
        "type": "comment"
    },
    "446": {
        "file_id": 34,
        "content": "/pyjom/medialang/commons.py",
        "type": "filepath"
    },
    "447": {
        "file_id": 34,
        "content": "This code defines functions for serializing SRT objects, handling fatal errors in Medialang, and generating temporary media file names. It also sets the default temporary media directory and uses UUIDs to generate unique filenames.",
        "type": "summary"
    },
    "448": {
        "file_id": 34,
        "content": "from pyjom.commons import *\ndef serializeSRT(srtObj):\n    index = srtObj.index\n    start = srtObj.start.total_seconds()\n    end = srtObj.end.total_seconds()\n    content = srtObj.content\n    data = {\"index\": index, \"timespan\": [start, end], \"content\": content}\n    return data\ndef medialangFatalError(error_msg, script_file):\n    print(\"Medialang fatal error:\", os.path.abspath(script_file))\n    print(error_msg)\n    os.abort()\nmedialangTmpDir = \"/dev/shm/medialang\"\ndef getTmpMediaName(medialangTmpDir = medialangTmpDir):\n    while True:\n        uniq_id = str(uuid.uuid4())\n        uniq_id = uniq_id.replace(\"-\", \"\")\n        fname = \"{}.ts\".format(uniq_id)\n        fpath = os.path.join(medialangTmpDir, fname) # why no respect to the medialang config!\n        if not os.path.exists(fpath):\n            return fpath",
        "type": "code",
        "location": "/pyjom/medialang/commons.py:1-29"
    },
    "449": {
        "file_id": 34,
        "content": "This code defines functions for serializing SRT objects, handling fatal errors in Medialang, and generating temporary media file names. It also sets the default temporary media directory and uses UUIDs to generate unique filenames.",
        "type": "comment"
    },
    "450": {
        "file_id": 35,
        "content": "/pyjom/medialang/core.py",
        "type": "filepath"
    },
    "451": {
        "file_id": 35,
        "content": "The code defines classes for media language items with functionalities like script representation, validation, exception management, formatting, and executing scripts in a Medialang environment.",
        "type": "summary"
    },
    "452": {
        "file_id": 35,
        "content": "from pyjom.commons import *\nfrom pyjom.medialang.commons import *\nfrom pyjom.medialang.processors import *\nimport re\nimport traceback\nclass lexicalItem:\n    def __init__(self, path, **kwargs):\n        self.path = path\n        self.args = kwargs\n        self.indent = 0\n        self.index = 0\n    def __repr__(self):\n        indent = \"    \" * self.indent\n        mRepr = []\n        mRepr.append(\"{}___medialang_item_[{}]\".format(indent, self.index))\n        mRepr.append(\"{}item path:\".format(indent)+\"  \"+ self.path)\n        mRepr.append(\"{}item args:\".format(indent)+\"  \"+ str(self.args))\n        return \"\\n\".join(mRepr) # is this magic?\nclass lexicalGroup:\n    def __init__(self, items=[]):\n        self.items = []\n        self.index = 0\n        self.indent = 0\n        for item in items:\n            assert type(item) == lexicalItem\n            self.items.append(item)\n    def append(self, item):\n        assert type(item) == lexicalItem\n        self.items.append(item)\n    def dump(self):\n        for item in self.items:\n            yield item # you yield NONE? WTF?",
        "type": "code",
        "location": "/pyjom/medialang/core.py:1-39"
    },
    "453": {
        "file_id": 35,
        "content": "This code defines two classes, `lexicalItem` and `lexicalGroup`, used in the pyjom library for storing and manipulating media language items. The `lexicalItem` class has an `__init__` method that takes a path and optional keyword arguments, and provides an `__repr__` method to represent the item. The `lexicalGroup` class initializes with a list of items, and has methods for appending items and dumping the group's contents. The code also imports necessary modules and checks types of items in the group.",
        "type": "comment"
    },
    "454": {
        "file_id": 35,
        "content": "    def __repr__(self):\n        indent = \"    \" * self.indent\n        mRepr = []\n        mRepr.append(\"{}____________medialang_line_[{}]\".format(indent, self.index))\n        # print(\"ITEMS:\", self.items)\n        for i, item in enumerate(self.dump()):\n            item.indent = self.indent + 1\n            item.index = i\n            mRepr.append(item)\n        # should we return nothing?\n        return \"\\n\".join(mRepr)\nclass lexicalScript:\n    def __init__(self, lines=[]):\n        self.lines = []\n        self.indent = 0\n        self.index = 0\n        for line in lines:\n            assert type(line) == lexicalGroup\n            self.lines.append(line)\n    def append(self, line):\n        assert type(line) == lexicalGroup\n        self.lines.append(line)\n    def dump(self):\n        for line in self.lines:\n            yield line\n    def __repr__(self):\n        indent = \"    \" * self.indent\n        mRepr = []\n        mRepr.append(\"{}____________medialang_script_[{}]\".format(indent, self.index))\n        for i, item in enumerate(self.dump()):",
        "type": "code",
        "location": "/pyjom/medialang/core.py:41-75"
    },
    "455": {
        "file_id": 35,
        "content": "This code defines two classes, `medialang_line` and `lexicalScript`, with a `__repr__` method that represents the objects. The `__repr__` method returns an indented representation of each object's properties. The `lexicalScript` class also has an `append` method to add new lines to the script.",
        "type": "comment"
    },
    "456": {
        "file_id": 35,
        "content": "            item.indent = self.indent + 1\n            item.index = i\n            mRepr.append(item)\n        return \"\\n\".join(mRepr)\nclass Medialang:\n    def __init__(\n        self,\n        script_path=None,\n        script=None,\n        script_obj=None,\n        encoding=\"utf-8\",\n        indent=4,\n        template=False,\n        template_args={},\n        verbose=True,\n        medialangTmpdir=medialangTmpDir\n    ):\n        self.verbose = verbose\n        self.medialangTmpDir = medialangTmpDir\n        self.indent = \" \" * indent\n        self.script_path = script_path\n        self.script_obj = script_obj\n        self.script = script\n        self.encoding = encoding\n        lexList = [script_path, script, script_obj]\n        lexCheck = sum([int(x is None) for x in lexList]) == 2\n        if not lexCheck:\n            raise Exception(\n                \"Can only pass one value to either of script_path, script, script_obj:\\n{}\".format(\n                    lexList\n                )\n            )\n        if script_path is None:\n            if script is None:",
        "type": "code",
        "location": "/pyjom/medialang/core.py:76-110"
    },
    "457": {
        "file_id": 35,
        "content": "This code snippet initializes a Medialang object with various parameters, including script path, script content, and encoding. It also checks for valid input to ensure only one of these values is provided. The exception handling raises an error if the input does not meet this requirement.",
        "type": "comment"
    },
    "458": {
        "file_id": 35,
        "content": "                assert script_obj is not None\n                assert template is False\n                self.script_obj = script_obj\n            else:\n                assert type(script) == str\n                self.script = script\n        else:\n            assert type(script_path) == str\n            try:\n                abspath = getAbsoluteFilePath(script_path)\n            except:\n                medialangFatalError(\n                    \"Failed to resolve script path: {}\".format(script_path), __file__\n                )\n            self.script_path = abspath\n            extension = getFileExtension(script_path)\n            if template:\n                assert extension == \"j2\"\n            else:\n                assert extension in [\"mdl\", \"media\"]\n            with open(abspath, \"r\", encoding=encoding) as f:\n                self.script = f.read()\n        if self.script_obj is not None:\n            self.script = self.generate(self.script_obj)\n        else:\n            if template:\n                assert type(template_args) == dict",
        "type": "code",
        "location": "/pyjom/medialang/core.py:111-138"
    },
    "459": {
        "file_id": 35,
        "content": "This code ensures that the user provides a valid script or script path. It checks if the script is an object, a string, or a file path. If it's a string or a file path, it verifies its type and resolves any relative paths to absolute paths. It then loads the content of the script file and assigns it to 'self.script'. If a script object is provided, the method generates the script using the object. If a template is specified with the script, it asserts that the extension of the script is \"j2\". Otherwise, it asserts that the extension is either \"mdl\" or \"media\". Finally, if a 'template_args' dictionary is provided, it asserts its type and stores the script in 'self.script'.",
        "type": "comment"
    },
    "460": {
        "file_id": 35,
        "content": "                self.script = renderTemplate(self.script, template_args)\n            self.script_obj = self.parse(self.script)\n    def generate_item(self, item_obj, line_max_char=40, level=0):\n        # content = item_obj.content\n        path = item_obj.path\n        item_lines = ['\"{}\"'.format(path)]\n        # print(\"item_lines:\",item_lines)\n        args = item_obj.args\n        # print(\"path:\",path)\n        for key in args.keys():\n            assert not key.startswith(\"#\")\n            # print(\"key:\",key)\n            mitem = args[key]\n            if type(mitem) is str:\n                mitem = '\"{}\"'.format(mitem)\n            elif type(mitem) in [float, int]:\n                mitem = str(mitem)\n            elif mitem in [True, False]:\n                mitem = str(mitem).lower()\n            else:\n                mitem_trial = json.dumps(mitem)\n                if len(mitem_trial) < line_max_char:\n                    mitem = mitem_trial\n                else:\n                    mitem = json.dumps(mitem, indent=self.indent)",
        "type": "code",
        "location": "/pyjom/medialang/core.py:139-164"
    },
    "461": {
        "file_id": 35,
        "content": "This code defines a class that generates items from item objects, handles different data types, and formats the output within a specified line length. The class also has methods to render templates and parse scripts.",
        "type": "comment"
    },
    "462": {
        "file_id": 35,
        "content": "            mitem = \"{}={}\".format(key, mitem)\n            mitem = mitem.split(\"\\n\")\n            for mitem0 in mitem:\n                trial_item = \", \".join([item_lines[-1], mitem0])\n                if len(trial_item) < line_max_char:\n                    item_lines[-1] = trial_item\n                else:\n                    item_lines.append(mitem0)\n        item_lines = \",\\n{}\".format((1 + level) * self.indent).join(item_lines)\n        # print(\"item_lines:\",item_lines)\n        item_lines = \"{}({}\\n{})\\n\".format(\n            level * self.indent, item_lines, level * self.indent\n        )\n        item_lines = item_lines.replace(\",,\", \",\")\n        item_lines = item_lines.replace(\"[,\", \"[\")\n        item_lines = item_lines.replace(\", }\", \"}\")\n        item_lines = item_lines.replace(\", ]\", \"]\")\n        item_lines = item_lines.replace(\"{,\", \"{\")\n        return item_lines\n    def generate(self, script_obj):\n        # default prettify the target\n        script = \"\"\n        for line_obj in script_obj.dump():\n            for level, item_obj in enumerate(line_obj.dump()):",
        "type": "code",
        "location": "/pyjom/medialang/core.py:165-189"
    },
    "463": {
        "file_id": 35,
        "content": "This code is generating a formatted string from nested lists, ensuring that the lines are within character limits and properly indented. It also replaces unnecessary commas with correct formatting for a more readable output.",
        "type": "comment"
    },
    "464": {
        "file_id": 35,
        "content": "                unit = self.generate_item(item_obj, level=level)\n                # print(\"unit:\",unit)\n                script += unit\n            script += \"\\n\"\n        script = script.replace(\",,\", \",\")\n        script = script.replace(\"[,\", \"[\")\n        script = script.replace(\", }\", \"}\")\n        script = script.replace(\", ]\", \"]\")\n        script = script.replace(\"{,\", \"{\")\n        i = 0\n        maxIndent = 0\n        # script = script.replace(\"'\",'\"') # no freaking single quotes.\n        while True:\n            if i == 0:\n                script = script.replace(\",\\n]\", \"\\n]\")\n                script = script.replace(\",\\n]\", \"\\n]\")\n            else:\n                indentStr = self.indent * i\n                if indentStr in script:\n                    script = script.replace(\n                        \",\\n{}]\".format(indentStr), \"\\n{}]\".format(indentStr)\n                    )\n                    script = script.replace(\n                        \",\\n{}\".format(indentStr) + \"}\", \"\\n{}\".format(indentStr) + \"}\"\n                    )",
        "type": "code",
        "location": "/pyjom/medialang/core.py:190-215"
    },
    "465": {
        "file_id": 35,
        "content": "This code generates a script by creating units of code from item objects, adds indentation and replaces unnecessary commas and quotes. It also handles specific formatting issues like replacing multiple newlines with single ones and ensuring correct syntax for closing brackets or braces.",
        "type": "comment"
    },
    "466": {
        "file_id": 35,
        "content": "                else:\n                    maxIndent = i - 1\n                    break\n            i += 1\n        for index0 in range(maxIndent):\n            indentStr = self.indent * (maxIndent - index0)\n            if indentStr in script:\n                script = script.replace(\n                    \"{}], \".format(indentStr),\n                    \"{}],\\n{}\".format(indentStr, indentStr),\n                )\n                script = script.replace(\n                    \"{}\".format(indentStr) + \"}, \",\n                    \"{}\".format(indentStr) + \"},\\n\" + \"{}\".format(indentStr),\n                )\n        for index in range(maxIndent):\n            indentStr = self.indent * (maxIndent - index)\n            if indentStr in script:\n                # print(\"running\", len(indentStr))\n                script = script.replace(\n                    \"[{}\".format(indentStr),\n                    \"[\",\n                )\n                script = script.replace(\n                    \",{}\".format(indentStr),\n                    \",\",\n                )",
        "type": "code",
        "location": "/pyjom/medialang/core.py:216-242"
    },
    "467": {
        "file_id": 35,
        "content": "This code finds the maximum indent level in a script and replaces occurrences of newline-separated items with the appropriate indentation. It also removes extra indentation from list or tuple elements and removes extra indentation after commas.",
        "type": "comment"
    },
    "468": {
        "file_id": 35,
        "content": "                script = script.replace(\n                    \"{\" + \"{}\".format(indentStr),\n                    \"{\",\n                )\n        script = script.replace(\",,\", \",\")\n        script = script.replace(\"[,\", \"[\")\n        script = script.replace(\", }\", \"}\")\n        script = script.replace(\", ]\", \"]\")\n        script = script.replace(\"{,\", \"{\")\n        script = script.replace(\"{ {\", \"{{\")\n        script = script.replace(\"} }\", \"}}\")\n        script = script.replace(\"] ]\", \"]]\")\n        script = script.replace(\"[ [\", \"[[\")\n        script = script.replace(\"[ \", \"[\")\n        if script.endswith(\"\\n\\n\"):\n            script = script[:-2]\n        if script.startswith(\"\\n\"):\n            script = script[1:]\n        return script\n    def detectGrammar(self, line):\n        result = line.replace(\"\\n\", \"\").replace(\" \", \"\").replace(\"\\t\", \"\")\n        return len(result) != 0\n    def getItems(self, line):\n        # assume there will not be enclosed brackets in string?\n        values = {\"(\": +1, \")\": -1}\n        base = 0\n        items = []",
        "type": "code",
        "location": "/pyjom/medialang/core.py:243-271"
    },
    "469": {
        "file_id": 35,
        "content": "The code is performing a series of string replacements to ensure that the script adheres to proper syntax. It removes extra brackets and newline characters, and detects non-empty lines. The getItems function assumes no nested enclosed brackets in strings.",
        "type": "comment"
    },
    "470": {
        "file_id": 35,
        "content": "        item = \"\"\n        for char in line:\n            value = 0 if char not in values.keys() else values[char]\n            base += value\n            if base > 0:\n                item += char\n            if base == 0 and value != 0:\n                item += char\n                items.append(item)\n                item = \"\"\n        return items\n    def parseItem(self, item):\n        # have dangerous eval.\n        body = item.strip()\n        body = item[1:-1]\n        # print(\"body length:\",len(body))\n        path = re.findall(r'^\"([^\"]+)\"', body)[0]\n        # print(\"found path:\",path)\n        mdict = body[len(path) + 2 :]\n        mdict = mdict.strip()\n        if self.detectGrammar(mdict):\n            mdict = mdict[1:]  # omit the comma.\n            text = \"\"\n            mdict2 = \"\"\n            values = {\"(\": +1, \")\": -1}\n            base = 0\n            try:\n                assert mdict[-1] != \",\"\n            except:\n                raise Exception(\"Found trailing comma:\\n\", mdict)\n            for index, char in enumerate(mdict):",
        "type": "code",
        "location": "/pyjom/medialang/core.py:272-303"
    },
    "471": {
        "file_id": 35,
        "content": "This code parses a string by iterating over each character, accumulating characters that have corresponding values in a dictionary and creating items based on the accumulated value. It also includes a function to parse an item which uses regex to find a path and then processes the remaining string according to specific rules. The code raises an exception if there is a trailing comma in the processed string.",
        "type": "comment"
    },
    "472": {
        "file_id": 35,
        "content": "                lineEnd = index == (len(mdict) - 1)\n                value = 0 if char not in values.keys() else values[char]\n                base += value\n                if char == \"=\":\n                    key = text.strip()\n                    assert not key.startswith(\"#\")\n                    mdict2 += '\"{}\":'.format(key)\n                    text = \"\"\n                elif (char == \",\" and base == 0) or lineEnd:\n                    if lineEnd:\n                        text += char\n                    mtext = text.strip()\n                    # print(\"mtext:\",mtext)\n                    if mtext in [\"False\", \"True\"]:\n                        mtext = mtext.lower()\n                    mdict2 += \"{}\".format(mtext)\n                    if not lineEnd:\n                        mdict2 += \",\"\n                    text = \"\"\n                    if lineEnd:\n                        break\n                else:\n                    text += char\n            # print(\"mdict:\",mdict)\n            mdict2 = mdict2.replace(\"(\", \"[\").replace(\")\", \"]\")",
        "type": "code",
        "location": "/pyjom/medialang/core.py:304-328"
    },
    "473": {
        "file_id": 35,
        "content": "This code processes a string, line by line, and converts it into a dictionary format. It handles key-value pairs separated by \":\" and comma-separated values. If the value is not found in given keys, it defaults to 0. If the value is \"True\" or \"False\", it converts it to lowercase before adding to the dictionary. The code also handles line endings and removes leading \"#\" from keys. Finally, it replaces parentheses with square brackets before returning the processed dictionary.",
        "type": "comment"
    },
    "474": {
        "file_id": 35,
        "content": "            mdict = \"{\" + mdict2 + \"}\"  # might be empty somehow.\n            # print(mdict)\n            mdict = json.loads(mdict)\n        else:\n            mdict = {}\n        item_obj = lexicalItem(path, **mdict)\n        return item_obj\n    def parse(self, script):\n        # will raise exception on unparseable lines.\n        script_obj = lexicalScript()\n        lines = script.split(\"\\n\\n\")\n        lines = [x for x in lines if self.detectGrammar(x)]\n        for line in lines:\n            line_obj = lexicalGroup()\n            # first let's remove all comments.\n            comment_expression = re.compile(r\"#[^\\n]+\")\n            newLine = \"\"\n            for elem in comment_expression.split(line):\n                if not comment_expression.match(elem):\n                    newLine+=elem\n            line = newLine\n            line = line.replace(\"\\n\", \"\").replace(\"\\t\", \"\")\n            line = line.strip()  # have extra spacings.\n            for item in self.getItems(line):\n                if self.detectGrammar(item):\n                    # print(\"item:\",item)",
        "type": "code",
        "location": "/pyjom/medialang/core.py:329-355"
    },
    "475": {
        "file_id": 35,
        "content": "This code defines two functions, \"parse\" and \"__init__\". The \"__init__\" function initializes a class with a path argument. The \"parse\" function takes a script as input, splits it into lines, filters out unparseable lines, and creates objects for each line that is parseable. It removes comments, trims whitespace, and checks if the resulting items are parseable. If so, it adds them to a lexicalGroup object, which will then be added to a lexicalScript object. The code also contains a method to get items from a line of code.",
        "type": "comment"
    },
    "476": {
        "file_id": 35,
        "content": "                    # print(\"item length:\",len(item))\n                    # breakpoint()\n                    try:\n                        item_obj = self.parseItem(item)\n                        line_obj.append(item_obj)\n                    except:\n                        traceback.print_exc()\n                        error_msg = \"Error found in:\\n{}\".format(item)\n                        if self.script_path:\n                            error_msg += \"\\nScript at:\\n{}\".format(self.script_path)\n                        raise Exception(error_msg)\n            script_obj.append(line_obj)\n        return script_obj\n    def prettify(self, script=None, inplace=False):\n        if script == None:\n            assert self.script is not None\n            script = self.script\n        if self.script_obj is None:\n            script_obj = self.parse(script)\n        else:\n            script_obj = self.script_obj\n        script = self.generate(script_obj)\n        if self.script_path is not None:\n            if inplace:\n                with open(self.script_path, \"w+\", encoding=self.encoding) as f:",
        "type": "code",
        "location": "/pyjom/medialang/core.py:356-381"
    },
    "477": {
        "file_id": 35,
        "content": "The code is parsing a script and handling any errors that occur during the process. It appends lines to a script object, checks if the script_obj exists, generates the script based on the script_obj, and writes it to the specified file (if inplace=True).",
        "type": "comment"
    },
    "478": {
        "file_id": 35,
        "content": "                    f.write(script)\n        return script\n    def checkItemType(self, item):\n        assert type(item) == lexicalItem  # you really should learn how to rest.\n        path = item.path\n        if path.startswith(\".\"):\n            return \"output\"\n        for key in medialangProtocols:\n            for elem in medialangProtocols[key]:\n                if path.startswith(elem):\n                    return key\n        if os.path.exists(path):\n            return \"input\"\n        return \"output\"\n    def objectAssertion(self, previous, objectType):\n        assert objectType in [\"input\", \"output\"]\n        if objectType == \"output\":\n            assert previous is not None\n    def objectExecutor(self, item, previous=None):\n        objectType = self.checkItemType(item)\n        path = item.path\n        args = item.args\n        self.objectAssertion(previous, objectType)\n        result = {}  # how to ensure it will do?\n        if objectType == \"output\":\n            if path.startswith(\".\"):\n                function = dotProcessors[path]",
        "type": "code",
        "location": "/pyjom/medialang/core.py:382-411"
    },
    "479": {
        "file_id": 35,
        "content": "This code contains various utility functions used in the medialang module. The 'checkItemType' function determines if an item is an input, output, or protocol file based on its path. The 'objectAssertion' function ensures that the specified object type is either \"input\" or \"output\". Lastly, the 'objectExecutor' function executes a specific action depending on the object type by calling appropriate functions.",
        "type": "comment"
    },
    "480": {
        "file_id": 35,
        "content": "                result = function(item, previous, verbose=self.verbose, medialangTmpDir=self.medialangTmpDir)\n        else:\n            if os.path.exists(path):\n                data = fsProcessor(item, previous=previous, verbose=self.verbose, medialangTmpDir = self.medialangTmpDir)\n                result = data\n            else:\n                pass\n                # inputs. handle with protocols?\n        return result\n    def scriptStructExecutor(self, script_struct):\n        script_type = script_struct[\"type\"]\n        resources = script_struct[\"resource\"]\n        targets = script_struct[\"target\"]\n        data_array = []\n        data = None\n        print(\"Medialang script type:\", script_type)\n        if script_type == \"input\":\n            for item in targets.items:\n                data = self.objectExecutor(item, previous=data)\n            for resource in resources:\n                mdata = copy.deepcopy(data)\n                for item in resource.items:\n                    mdata = self.objectExecutor(item, previous=mdata)",
        "type": "code",
        "location": "/pyjom/medialang/core.py:412-435"
    },
    "481": {
        "file_id": 35,
        "content": "The code is implementing a script execution function. It checks the type of script and executes it accordingly, handling inputs, resources, and targets. The scriptStructExecutor function determines the type of script (input) and iterates through its targets and resources to execute objects using the objectExecutor function. If the path exists, it calls the fsProcessor function; otherwise, it does nothing.",
        "type": "comment"
    },
    "482": {
        "file_id": 35,
        "content": "                data_array.append(mdata)\n        else:\n            for index0, resource in enumerate(resources):\n                # print(\"RESOURCE ENUMERATE\",index0, resource)\n                # breakpoint()\n                mdata = None\n                mdata_array = []\n                for index1, item in enumerate(resource.items):\n                    mdata = self.objectExecutor(item, previous=mdata)\n                    if self.verbose:\n                        print(\"input {}-{}:\".format(index0, index1), mdata) # this is the wrong data array!\n                    mdata_array.append({\"item\":item, \"cache\": mdata}) # where you store all the intermediate files per clip.\n                data_array.append(copy.deepcopy(mdata_array))\n            data = copy.deepcopy(data_array) # so this is your freaking data! let's decide your approach all inside that dotProcessor instead of generating trash here!\n            for item in targets.items:\n                data = self.objectExecutor(item, previous=data)\n        return data, data_array # why you return this!",
        "type": "code",
        "location": "/pyjom/medialang/core.py:436-452"
    },
    "483": {
        "file_id": 35,
        "content": "This code appears to be part of a larger program that processes media resources. It seems to create arrays of intermediate data for each clip, deep copy them into the main data array, and then execute objects on the main data array. The function returns two values: data and data_array. The purpose or use of these returned values is unclear in this context.",
        "type": "comment"
    },
    "484": {
        "file_id": 35,
        "content": "        # currently, data is now the editly json, and data_array is the medialang items array\n        # what about the slient flag? deal with it later!\n    def execute(self):\n        script_obj_lines = self.script_obj.lines\n        assert len(script_obj_lines) >= 1\n        script_struct = {\n            \"target\": script_obj_lines[0],\n            \"resource\": script_obj_lines[1:],\n        }\n        first_target = script_struct[\"target\"].items[0]\n        script_type = self.checkItemType(first_target)\n        script_struct[\"type\"] = script_type\n        item_types = [\"input\", \"output\"]\n        for item_type in item_types:\n            if script_type == item_type:\n                # this is analysis type mediascript. all following shall be output.\n                for line in script_struct[\"resource\"]:\n                    elem = line.items[\n                        0\n                    ]  # only make sure the first item of each line is in agreement with the type rules.\n                    this_item_type = self.checkItemType(elem)",
        "type": "code",
        "location": "/pyjom/medialang/core.py:453-474"
    },
    "485": {
        "file_id": 35,
        "content": "This code defines a function that executes a script object, splits it into target and resource sections, determines the type of the script (input or output), and checks the item type for each line in the resource section.",
        "type": "comment"
    },
    "486": {
        "file_id": 35,
        "content": "                    try:\n                        assert this_item_type is not item_type\n                    except:\n                        traceback.print_exc()\n                        print(\"Medialang Error when parsing resource:\")\n                        print(line)\n                        print(\"Medialang itemtype:\", this_item_type)\n                        print(elem)\n                        if self.script_path:\n                            print(\"Medialang Script path:\", self.script_path)\n                        os.abort()\n                result = self.scriptStructExecutor(script_struct)\n                return result  # tuple (data, data_array)",
        "type": "code",
        "location": "/pyjom/medialang/core.py:475-487"
    },
    "487": {
        "file_id": 35,
        "content": "This code segment is part of a script that handles parsing resources in a Medialang environment. If the item type doesn't match, it prints an error message and aborts the script. Afterwards, it executes the script structure and returns a tuple containing data and data_array.",
        "type": "comment"
    },
    "488": {
        "file_id": 36,
        "content": "/pyjom/medialang/functions/__init__.py",
        "type": "filepath"
    },
    "489": {
        "file_id": 36,
        "content": "The code imports detectors from the medialangFunctions module and creates a dictionary of available media language functions. The getMedialangFunction function searches the dictionary for the specified function name, returns it if found, and prints its type and name. If not found, it returns None.",
        "type": "summary"
    },
    "490": {
        "file_id": 36,
        "content": "from pyjom.medialang.functions.detectors import *\nmedialangFunctions = {\"detector\": medialangDetectors}\ndef getMedialangFunction(function):\n    for key in medialangFunctions:\n        mgroup = medialangFunctions[key]\n        for key2 in mgroup:\n            if key2 == function:\n                function = mgroup[key2]\n                print(\"function type:\", key)\n                print(\"function name:\", key2)\n                return function\n    return None",
        "type": "code",
        "location": "/pyjom/medialang/functions/__init__.py:1-15"
    },
    "491": {
        "file_id": 36,
        "content": "The code imports detectors from the medialangFunctions module and creates a dictionary of available media language functions. The getMedialangFunction function searches the dictionary for the specified function name, returns it if found, and prints its type and name. If not found, it returns None.",
        "type": "comment"
    },
    "492": {
        "file_id": 37,
        "content": "/pyjom/medialang/functions/detectors/__init__.py",
        "type": "filepath"
    },
    "493": {
        "file_id": 37,
        "content": "This code imports various detector functions, defines a medialang input function, and creates a dictionary of detectors for processing media data. It handles potential problematic inputs.",
        "type": "summary"
    },
    "494": {
        "file_id": 37,
        "content": "# from pyjom.medialang.functions.detectors.mediaDetector import *\nfrom .blackoutDetector import *\nfrom .subtitleDetector import *\nfrom .videoDiffDetector import *\nfrom .yolov5_Detector import *\nfrom .frameborder_Detector import *\n# maybe these shits are gonna ruin my life...\ndef getMedialangInputFixed(medialangPathsInput):\n    for fbase0 in medialangPathsInput:\n        if type(fbase0) == str:\n            yield fbase0\n        elif (\n            type(fbase0) == list\n            and len(fbase0) == 1\n            and type(fbase0[0] == dict)\n            and \"cache\" in fbase0[0].keys()\n        ):\n            yield fbase0[0][\"cache\"]\n        else:\n            print(\"weird medialang detector input\")\n            print(fbase0)\n        # then it must be the medialang shit.\ndef processInputWrapperFunction(function, wrapperFunction):\n    def mFunction(data, *args, **kwargs):\n        return function(wrapperFunction(data), *args, **kwargs)\n    return mFunction\nmedialangDetectors = {\n    \"subtitle_detector\": mediaSubtitleDetector,",
        "type": "code",
        "location": "/pyjom/medialang/functions/detectors/__init__.py:1-36"
    },
    "495": {
        "file_id": 37,
        "content": "This code imports various detector functions, defines a function for getting medialang input, and creates a dictionary of detectors. It seems to be part of a larger program used for processing media data. The comment on line 30 suggests that the code is concerned with potentially difficult or problematic inputs.",
        "type": "comment"
    },
    "496": {
        "file_id": 37,
        "content": "    \"framediff_detector\": videoDiffDetector,\n    \"blackout_detector\": blackoutDetector,\n    \"yolov5_detector\": yolov5_Detector,\n    \"frameborder_detector\": frameborder_Detector,\n}\nmedialangDetectors = { # strange. i don't feel it.\n    key: processInputWrapperFunction(medialangDetectors[key], getMedialangInputFixed)\n    for key in medialangDetectors.keys()\n}",
        "type": "code",
        "location": "/pyjom/medialang/functions/detectors/__init__.py:37-46"
    },
    "497": {
        "file_id": 37,
        "content": "This code initializes and processes media language detectors with input wrappers. It maps detector names to corresponding functions and applies a processing function to each detector for handling inputs.",
        "type": "comment"
    },
    "498": {
        "file_id": 38,
        "content": "/pyjom/medialang/functions/detectors/blackoutDetector.py",
        "type": "filepath"
    },
    "499": {
        "file_id": 38,
        "content": "This code detects blackouts in media by calculating scores per frame block and storing results. It works for videos and images, using OpenCV or videoFrameIterator. The code updates metadata dictionaries and appends updated results to a list before returning the final list of results.",
        "type": "summary"
    }
}