{
    "4400": {
        "file_id": 564,
        "content": "from recover import recover\nfrom rewrite import rewrite\ndef recover_and_rewrite(source_old,no_rewrite=False):\n    intermediate = recover(source_old)\n    if not no_rewrite:\n        source_new = rewrite(intermediate)\n    else: source_new=intermediate\n    return source_new\nif __name__ == '__main__':\n    # from comby import Comby\n    # comby = Comby()\n    source_old = open('new_test.py','r').read()\n    source_new = recover_and_rewrite(source_old)\n    print(source_new)",
        "type": "code",
        "location": "/tests/skipexception_code_and_continue_resurrection_time_travel_debugging/test_code/recover_and_rewrite.py:1-16"
    },
    "4401": {
        "file_id": 564,
        "content": "This code imports functions from recover and rewrite modules, defines a function called recover_and_rewrite that recovers and potentially rewrites a given source code, and in the main block reads a file 'new_test.py', applies the recover_and_rewrite function to it, and prints the resulting source code.",
        "type": "comment"
    },
    "4402": {
        "file_id": 565,
        "content": "/tests/skipexception_code_and_continue_resurrection_time_travel_debugging/test_code/recover.py",
        "type": "filepath"
    },
    "4403": {
        "file_id": 565,
        "content": "This code is using the Comby library to recover a Python source file by removing any lines related to reloading or @reloading decorators. It reads the original file, removes specific keywords, and then uses Comby to rewrite the code without those keywords, resulting in a new source file without reloading-related content. The code is executed directly if the script is the main program.",
        "type": "summary"
    },
    "4404": {
        "file_id": 565,
        "content": "from comby import Comby\ncomby = Comby()\ndef recover(source_old):\n    kws = [\"from reloading import reloading\", \"@reloading\"]\n    # source_old = source_old.replace(kw,\"\") # obliterate this thing. shall we?\n    source_old = \"\\n\".join(\n        [\n            line\n            for line in source_old.split(\"\\n\")\n            if not any(line.startswith(elem) for elem in kws)\n        ]\n    )\n    match = \":[prefix~@reloading.*$]def :[functionName](:[args]):\"\n    rewrite = \"def :[functionName](:[args]):\"\n    source_new = comby.rewrite(source_old, match, rewrite, language=\".py\")\n    return source_new\nif __name__ == \"__main__\":\n    # comby = Comby()\n    source_old = open(\"new_test.py\", \"r\").read()\n    source_new = recover(source_old)\n    print(source_new)",
        "type": "code",
        "location": "/tests/skipexception_code_and_continue_resurrection_time_travel_debugging/test_code/recover.py:1-29"
    },
    "4405": {
        "file_id": 565,
        "content": "This code is using the Comby library to recover a Python source file by removing any lines related to reloading or @reloading decorators. It reads the original file, removes specific keywords, and then uses Comby to rewrite the code without those keywords, resulting in a new source file without reloading-related content. The code is executed directly if the script is the main program.",
        "type": "comment"
    },
    "4406": {
        "file_id": 566,
        "content": "/tests/skipexception_code_and_continue_resurrection_time_travel_debugging/test_code/pyjom_recover_and_rewrite.py",
        "type": "filepath"
    },
    "4407": {
        "file_id": 566,
        "content": "This code utilizes modules to change files at specified paths, walks through directories to collect .py files, applies changes using a progress bar, and stops after processing every 100 files.",
        "type": "summary"
    },
    "4408": {
        "file_id": 566,
        "content": "import sys\nsys.path.append(\"/root/Desktop/works/pyjom/tests/skipexception_code_and_continue_resurrection_time_travel_debugging/codemod_redbaron\")\nfrom pasta_test import recover_and_rewrite as rar1\nfrom recover_and_rewrite import recover_and_rewrite as rar2\nif __name__ == \"__main__\":\n    import os\n    # from comby import Comby\n    # comby = Comby()\n    dirpath = \"/root/Desktop/works/pyjom/pyjom\"\n    def change_file_at_path(path,no_rewrite=False):\n        with open(path, \"r\") as f:\n            source_old = f.read()\n            if len(source_old) < 20 or \"\\ndef \" not in source_old:\n                return\n            try:\n                source_new = rar1(source_old,no_rewrite=no_rewrite)\n            except:\n                import traceback\n                traceback.print_exc()\n                print('pasta failed to process the code at path: %s' % path)\n                source_new = rar2(source_old,no_rewrite=no_rewrite)\n        with open(path, \"w+\") as f:\n            f.write(source_new)\n    pyfiles = []\n    import progressbar",
        "type": "code",
        "location": "/tests/skipexception_code_and_continue_resurrection_time_travel_debugging/test_code/pyjom_recover_and_rewrite.py:1-30"
    },
    "4409": {
        "file_id": 566,
        "content": "Imports necessary modules and defines a function to change files at specified paths by reading the file, passing the content to two recovery functions (rar1 and rar2), and rewriting the file with the new content.",
        "type": "comment"
    },
    "4410": {
        "file_id": 566,
        "content": "    for basedir, dirs, files in os.walk(dirpath):\n        for fname in files:\n            fpath = os.path.join(basedir, fname)\n            if fname.endswith(\".py\"):\n                pyfiles.append(fpath)\n                # print(fpath)\n    mod = 100\n    for pyfile in progressbar.progressbar(pyfiles):\n        # if index % mod == 0:\n        print(\"processing file at path: %s\" % pyfile)\n        change_file_at_path(pyfile,no_rewrite=True)",
        "type": "code",
        "location": "/tests/skipexception_code_and_continue_resurrection_time_travel_debugging/test_code/pyjom_recover_and_rewrite.py:32-42"
    },
    "4411": {
        "file_id": 566,
        "content": "This code walks through a directory, collects .py files, and applies a change to each file using a progress bar. It stops processing after every 100 files.",
        "type": "comment"
    },
    "4412": {
        "file_id": 567,
        "content": "/tests/skipexception_code_and_continue_resurrection_time_travel_debugging/test_code/new_test2.py",
        "type": "filepath"
    },
    "4413": {
        "file_id": 567,
        "content": "The code is a Python function with decorators and an asynchronous function, using the 'reloading' module for reloadable functions. The main function takes multiple arguments and returns its value, while the asynchronous function remains undefined.",
        "type": "summary"
    },
    "4414": {
        "file_id": 567,
        "content": "from reloading import reloading\n# decorate here!\n# @dec # won't fix here.\n# @someRandomDecorator\n@reloading # it won't help with everything.\ndef someFunction (a,b,c,d=1,f=2\n):\n    # not touching this function!\n    # @decorator\n    # def inner_function (h,i,j,\n    # k):\n    abcdefg=1234\n    #     return hjkl\n    return abcdefg # I need you to decorate this thing.\nasync def shitfunction():\n    return shit\nif __name__ == \"__main__\":\n    someFunction(1,2,3)",
        "type": "code",
        "location": "/tests/skipexception_code_and_continue_resurrection_time_travel_debugging/test_code/new_test2.py:1-21"
    },
    "4415": {
        "file_id": 567,
        "content": "The code is a Python function with decorators and an asynchronous function, using the 'reloading' module for reloadable functions. The main function takes multiple arguments and returns its value, while the asynchronous function remains undefined.",
        "type": "comment"
    },
    "4416": {
        "file_id": 568,
        "content": "/tests/skipexception_code_and_continue_resurrection_time_travel_debugging/test_code/new_test.py",
        "type": "filepath"
    },
    "4417": {
        "file_id": 568,
        "content": "Code snippet with a function `someFunction` decorated by `@reloading`, indicating the code is using the 'reloading' module to automatically reload any changes made during runtime. The code also has an undefined variable \"shit\" in the async function, which could cause an error when executed. The main part of the script executes `someFunction(1,2,3)` when run directly.",
        "type": "summary"
    },
    "4418": {
        "file_id": 568,
        "content": "from reloading import reloading\n# decorate here!\n# @dec # won't fix here.\n# @someRandomDecorator\n@reloading # it won't help with everything. be cautious.\ndef someFunction (a,b,c,d=1,f=2\n):\n    # not touching this function!\n    # @decorator\n    # def inner_function (h,i,j,\n    # k):\n    abcdefg=1234\n    #     return hjkl\n    return abcdefg # I need you to decorate this thing.\nasync def shitfunction():\n    return shit\nif __name__ == \"__main__\":\n    someFunction(1,2,3)",
        "type": "code",
        "location": "/tests/skipexception_code_and_continue_resurrection_time_travel_debugging/test_code/new_test.py:1-21"
    },
    "4419": {
        "file_id": 568,
        "content": "Code snippet with a function `someFunction` decorated by `@reloading`, indicating the code is using the 'reloading' module to automatically reload any changes made during runtime. The code also has an undefined variable \"shit\" in the async function, which could cause an error when executed. The main part of the script executes `someFunction(1,2,3)` when run directly.",
        "type": "comment"
    },
    "4420": {
        "file_id": 569,
        "content": "/tests/skipexception_code_and_continue_resurrection_time_travel_debugging/test_code/bowler_test.py",
        "type": "filepath"
    },
    "4421": {
        "file_id": 569,
        "content": "The code is importing the bowler library and defining a pattern for identifying function definitions in a source file. It then creates a Query object with the source file, selects elements matching the pattern, and prints the selected elements along with their attributes.",
        "type": "summary"
    },
    "4422": {
        "file_id": 569,
        "content": "import bowler\nsrc ='test2.py'\npattern=\"\"\"(\n    decorated=decorated<\n        decorators=decorators\n        function_def=funcdef<\n            'def' function_name=any\n            function_parameters=parameters< '(' function_arguments=any* ')' >\n            any*\n        >\n    >\n|\n    function_def=funcdef<\n        'def' function_name=any\n        function_parameters=parameters< '(' function_arguments=any* ')' >\n        any*\n    >\n)\"\"\"\nq = bowler.Query(src)\nf = q.select(pattern).is_def()\nprint(f, dir(f))\n# for x in f:\n#     print(x)",
        "type": "code",
        "location": "/tests/skipexception_code_and_continue_resurrection_time_travel_debugging/test_code/bowler_test.py:1-26"
    },
    "4423": {
        "file_id": 569,
        "content": "The code is importing the bowler library and defining a pattern for identifying function definitions in a source file. It then creates a Query object with the source file, selects elements matching the pattern, and prints the selected elements along with their attributes.",
        "type": "comment"
    },
    "4424": {
        "file_id": 570,
        "content": "/tests/jina_multimodal_cross_modal_search_examples_apps/get_jina_hub_list.sh",
        "type": "filepath"
    },
    "4425": {
        "file_id": 570,
        "content": "This script uses curl to send an authenticated GET request to 'https://api.hubble.jina.ai/v2/rpc/executor.list' for retrieving the list of executors on Jina Hub. The request includes necessary headers and data parameters in a compressed format.",
        "type": "summary"
    },
    "4426": {
        "file_id": 570,
        "content": "# curl 'https://api.hubble.jina.ai/v2/rpc/executor.list' \\\n#   -H 'authority: api.hubble.jina.ai' \\\n#   -H 'accept: */*' \\\n#   -H 'accept-language: en-US,en;q=0.9' \\\n#   -H 'content-type: application/json' \\\n#   -H 'cookie: _ga=GA1.1.1157816225.1662091624; _ga_48WE9V68SD=GS1.1.1662457192.4.0.1662457192.0.0.0; _ga_K8DQ8TXQJH=GS1.1.1663058102.2.1.1663059426.0.0.0; _ga_E63SXVNDXZ=GS1.1.1663061381.1.1.1663063158.0.0.0; _ga_48ZDWC8GT6=GS1.1.1663064195.8.1.1663064235.0.0.0; _ga_1ESRNDCK35=GS1.1.1663064288.3.0.1663064288.0.0.0; _ga_MMEXL9VXBJ=GS1.1.1663058298.5.1.1663065624.0.0.0' \\\n#   -H 'origin: https://hub.jina.ai' \\\n#   -H 'referer: https://hub.jina.ai/' \\\n#   -H 'sec-ch-ua: \"Google Chrome\";v=\"105\", \"Not)A;Brand\";v=\"8\", \"Chromium\";v=\"105\"' \\\n#   -H 'sec-ch-ua-mobile: ?0' \\\n#   -H 'sec-ch-ua-platform: \"macOS\"' \\\n#   -H 'sec-fetch-dest: empty' \\\n#   -H 'sec-fetch-mode: cors' \\\n#   -H 'sec-fetch-site: same-site' \\\n#   -H 'user-agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36' \\",
        "type": "code",
        "location": "/tests/jina_multimodal_cross_modal_search_examples_apps/get_jina_hub_list.sh:1-15"
    },
    "4427": {
        "file_id": 570,
        "content": "This script is using curl to send a GET request to 'https://api.hubble.jina.ai/v2/rpc/executor.list' API endpoint, retrieving the list of executors available on Jina Hub. The request includes various headers for authorization, language, content type, cookies, origin, referer, user-agent, and browser details to authenticate and fetch the required information.",
        "type": "comment"
    },
    "4428": {
        "file_id": 570,
        "content": "#   --data-raw '{\"sort\":\"-activities.metaMatched\",\"pageIndex\":3,\"pageSize\":16,\"search\":\"\",\"author\":\"\",\"keywords\":[],\"withAnonymous\":true}' \\\n#   --compressed\ncurl 'https://api.hubble.jina.ai/v2/rpc/executor.list' \\\n --data-raw '{\"sort\":\"-activities.metaMatched\",\"pageIndex\":3,\"pageSize\":16,\"search\":\"\",\"author\":\"\",\"keywords\":[],\"withAnonymous\":true}' \\\n  --compressed",
        "type": "code",
        "location": "/tests/jina_multimodal_cross_modal_search_examples_apps/get_jina_hub_list.sh:16-20"
    },
    "4429": {
        "file_id": 570,
        "content": "This code is making a compressed HTTP request to 'https://api.hubble.jina.ai/v2/rpc/executor.list' with specific data parameters and a compressed format.",
        "type": "comment"
    },
    "4430": {
        "file_id": 571,
        "content": "/tests/jina_multimodal_cross_modal_search_examples_apps/get_jina_hub_list.py",
        "type": "filepath"
    },
    "4431": {
        "file_id": 571,
        "content": "This code retrieves a list of Jina Hub executors in chunks and writes them to a JSON file named \"jina_hub.json\". It first makes an API request to the Hubble server, sorts the results by activities.metaMatched, and returns the data as JSON. Then it calculates the number of pages needed based on the total number of executors and loops through each page, appending the data to a list called 'data'. Finally, it writes the list of executors (in multiple chunks) to the file \"jina_hub.json\" with proper indentation and formatting.",
        "type": "summary"
    },
    "4432": {
        "file_id": 571,
        "content": "import requests\nimport time\nimport json\ndef getJson(pageIndex=1, pageSize=16):\n    url = 'https://api.hubble.jina.ai/v2/rpc/executor.list'\n    query = {\"sort\":\"-activities.metaMatched\",\"pageIndex\":pageIndex,\"pageSize\":pageSize,\"search\":\"\",\"author\":\"\",\"keywords\":[],\"withAnonymous\":True}\n    r = requests.post(url,json=query)\n    jsonData = r.json()\n    return jsonData\npageSize = 16\njsonData = getJson(pageSize=pageSize)\ntotal = jsonData[\"meta\"][\"total\"]\nprint('total:', total)\ndata = [jsonData.copy()]\nimport math\npages = math.ceil(total/pageSize)\nimport progressbar\nfor index in progressbar.progressbar(range(2,pages+1)):\n    time.sleep(2)\n    # print('page index:',index)\n    jsonData = getJson(pageIndex=index, pageSize=pageSize)\n    data.append(jsonData.copy())\nprint(\"writing data\")\nwith open(\"jina_hub.json\", \"w\") as f:\n    f.write(json.dumps(data, indent=4, ensure_ascii=False))",
        "type": "code",
        "location": "/tests/jina_multimodal_cross_modal_search_examples_apps/get_jina_hub_list.py:1-29"
    },
    "4433": {
        "file_id": 571,
        "content": "This code retrieves a list of Jina Hub executors in chunks and writes them to a JSON file named \"jina_hub.json\". It first makes an API request to the Hubble server, sorts the results by activities.metaMatched, and returns the data as JSON. Then it calculates the number of pages needed based on the total number of executors and loops through each page, appending the data to a list called 'data'. Finally, it writes the list of executors (in multiple chunks) to the file \"jina_hub.json\" with proper indentation and formatting.",
        "type": "comment"
    },
    "4434": {
        "file_id": 572,
        "content": "/tests/bilibili_video_recommendation_server/zbar_detect_qrcode.py",
        "type": "filepath"
    },
    "4435": {
        "file_id": 572,
        "content": "This code defines 'detect_qr' function to detect and decode QR codes using pyzbar library. It prints information about each detected QR code, returns True if found. The code attempts to read a QR code from an image, resizes it for visibility, and calls the \"detect_qr\" function.",
        "type": "summary"
    },
    "4436": {
        "file_id": 572,
        "content": "# import sys\nimport cv2\n# import imutils\nfrom PIL import Image\nfrom pyzbar.pyzbar import decode, ZBarSymbol\n# @function 'detect_qr' detect and decode qrcode from frame using pyzbar lib\n# @param 'inputFrame' type <class 'numpy.ndarray'>\n# @return if detected type 'bool'\ndef detect_qr(inputFrame):\n    img = Image.fromarray(inputFrame)\n    decodedImg = decode(img, symbols=[ZBarSymbol.QRCODE])\n    # it reads the content. but where is the code?\n    print('total %d qrcode detected' % len(decodedImg))\n    # breakpoint()\n    # length: 2\n    if len(decodedImg) > 0:\n        for code in decodedImg:\n            decodedBytes = code.data\n            stringData = decodedBytes.decode(\"utf-8\")\n            print(\"QRCode content:\")\n            print(stringData)\n            polygon = code.polygon\n            print('POLYGON CONTENT:')\n            print(polygon)\n            for point in polygon:\n                print('POINT:',point.x,point.y)\n        return True\n    else:\n        return False\nimage = \"output_qrcode2.png\"\n# image = \"test_image_with_qr_code.png\" # what about this?",
        "type": "code",
        "location": "/tests/bilibili_video_recommendation_server/zbar_detect_qrcode.py:2-36"
    },
    "4437": {
        "file_id": 572,
        "content": "This code defines a function named 'detect_qr' that detects and decodes QR codes from a given input frame. It utilizes the pyzbar library to decode QR codes, converts the input frame to an Image object using PIL, and then prints information about each detected QR code such as its content and polygon coordinates. The function returns True if any QR codes are detected, otherwise it returns False. The image variable is set to \"output_qrcode2.png\", but there's a commented-out line suggesting using \"test_image_with_qr_code.png\" instead.",
        "type": "comment"
    },
    "4438": {
        "file_id": 572,
        "content": "# it fails. so we better have some other way to get the barcode.\n# if resolution is low, resize the image and make sure it will contain the qrcode, make it readable.\ninputImage = cv2.imread(image)\n# frame = imutils.resize(inputImage, width=400)\nprint(detect_qr(inputImage))\n# fantastic.\n# usually there should be no more than 1 qrcode in image to allow user to scan the code in qq.",
        "type": "code",
        "location": "/tests/bilibili_video_recommendation_server/zbar_detect_qrcode.py:37-46"
    },
    "4439": {
        "file_id": 572,
        "content": "This code attempts to read a QR code from an image. If the resolution is low, it resizes the image to ensure the QR code is visible and then calls the \"detect_qr\" function. The code assumes there's usually only one QR code per image for scanning in QQ.",
        "type": "comment"
    },
    "4440": {
        "file_id": 573,
        "content": "/tests/bilibili_video_recommendation_server/test_fastapi.sh",
        "type": "filepath"
    },
    "4441": {
        "file_id": 573,
        "content": "The code sends a HTTP GET request to the localhost server running on port 7341 and checks the response.",
        "type": "summary"
    },
    "4442": {
        "file_id": 573,
        "content": "echo 'checking server hello'\ncurl http://localhost:7341",
        "type": "code",
        "location": "/tests/bilibili_video_recommendation_server/test_fastapi.sh:1-2"
    },
    "4443": {
        "file_id": 573,
        "content": "The code sends a HTTP GET request to the localhost server running on port 7341 and checks the response.",
        "type": "comment"
    },
    "4444": {
        "file_id": 574,
        "content": "/tests/bilibili_video_recommendation_server/test.sh",
        "type": "filepath"
    },
    "4445": {
        "file_id": 574,
        "content": "This code is running a Python script named \"test.py\" using the Python 3 interpreter. The script is likely being executed as part of a test or validation process for the \"bilibili_video_recommendation_server\" project.",
        "type": "summary"
    },
    "4446": {
        "file_id": 574,
        "content": "python3 test.py ",
        "type": "code",
        "location": "/tests/bilibili_video_recommendation_server/test.sh:1-1"
    },
    "4447": {
        "file_id": 574,
        "content": "This code is running a Python script named \"test.py\" using the Python 3 interpreter. The script is likely being executed as part of a test or validation process for the \"bilibili_video_recommendation_server\" project.",
        "type": "comment"
    },
    "4448": {
        "file_id": 575,
        "content": "/tests/bilibili_video_recommendation_server/test.py",
        "type": "filepath"
    },
    "4449": {
        "file_id": 575,
        "content": "This code defines functions for a Bilibili recommendation server, performs preprocessing and searches, uses bm25 method, includes debugging breakpoints, and tests the `checkPublishedVideo` function with different video states.",
        "type": "summary"
    },
    "4450": {
        "file_id": 575,
        "content": "import sys\nsys.path.append(\"/root/Desktop/works/pyjom/\")\nfrom pyjom.platforms.bilibili.database import (\n    bilibiliRecommendationServer,\n    bootstrap,\n    textPreprocessing,\n    searchUserVideos,\n    registerUserVideo,\n    searchAndRegisterVideos,\n)\n# you should recommend by label instead of by name. but whatever.\nif __name__ == \"__main__\":\n    # objective = 'test'\n    import argparse\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"-o\", \"--objective\", type=str, default=\"server\")\n    parsed_args = parser.parse_args()\n    objective = parsed_args.objective\n    # can't specify port here.\n    # python3 -m uvicorn --port 7341 test:app\n    if objective == \"server\":\n        bilibiliRecommendationServer()\n    elif objective == \"test\":\n        bootstrap()\n        test = \"searchVideos\"\n        # test = \"searchUserVideos\"\n        # test = \"textPreprocessing\"\n        # test = 'registerMyVideo'\n        if test == \"textPreprocessing\":\n            text = \"猫  咪  钢  琴  家 searchUserVideos have a nice day 新闻联播,动物圈,汪星人,喵星人\"",
        "type": "code",
        "location": "/tests/bilibili_video_recommendation_server/test.py:1-33"
    },
    "4451": {
        "file_id": 575,
        "content": "This code is importing necessary modules and defining functions for a Bilibili recommendation server. It includes the functions bilibiliRecommendationServer, bootstrap, textPreprocessing, searchUserVideos, registerUserVideo, and searchAndRegisterVideos. The script can be run as a server or for testing purposes using the argument \"-o\" or \"--objective\". However, the port cannot be specified within the script.",
        "type": "comment"
    },
    "4452": {
        "file_id": 575,
        "content": "            result = textPreprocessing(\n                text\n            )  # shall you do the same to your search query.\n            print(\"RESULT:\", result)\n        elif test == \"searchUserVideos\":\n            query = \"猫\"\n            # for v in searchUserVideos(query):\n            for v in searchUserVideos(query, method=\"bm25\"):\n                # print(\"fetched value:\", v)\n                breakpoint()\n        elif test == \"registerMyVideo\":\n            bvid = \"BV1fR4y1w7BL\"  # that's surely yours.\n            dedeuserid = \"397424026\"\n            registerUserVideo(bvid, dedeuserid)\n        elif test == \"searchVideos\":\n            query = \"cod19\"  # recent hot videos.\n            for v in searchAndRegisterVideos(query):\n                print(v)  # warning: title containing markup language.\n                breakpoint()\n            # you want to select video after search?\n            # no keywords? are you kidding?\n            # results = getMyVideos()\n            # print(results)\n            # video_bvid_invisible = \"BV1pd4y1y7cu\"  # too fucking fast. i can't see shit.",
        "type": "code",
        "location": "/tests/bilibili_video_recommendation_server/test.py:34-57"
    },
    "4453": {
        "file_id": 575,
        "content": "The code performs text preprocessing and searches for user videos, registers a video, and searches for recent hot videos. It uses the bm25 method for searching, and the text is processed before querying. The code includes breakpoints for debugging.",
        "type": "comment"
    },
    "4454": {
        "file_id": 575,
        "content": "            # # some hard rule on this? like being invisible for how long we will disable video source for good?\n            # video_bvid_abnormal = \"BV1x84y1B7Nb\"\n            # video_bvid_visible = \"BV1Fs411k7e9\"  # 老戴的视频\n            # # 啊叻？视频不见了？\n            # checkPublishedVideo(video_bvid_invisible)\n            # checkPublishedVideo(video_bvid_visible)\n            # checkPublishedVideo(video_bvid_abnormal)\n            # 视频撞车了 需要原创视频哦",
        "type": "code",
        "location": "/tests/bilibili_video_recommendation_server/test.py:58-65"
    },
    "4455": {
        "file_id": 575,
        "content": "This code snippet seems to be testing the `checkPublishedVideo` function by passing different video BVIDs, including one that is supposedly invisible, one visible, and one with an abnormal state. The purpose of this test might be to ensure the function can handle various scenarios correctly and identify if a video has disappeared or changed its original state.",
        "type": "comment"
    },
    "4456": {
        "file_id": 576,
        "content": "/tests/bilibili_video_recommendation_server/stroke_path.py",
        "type": "filepath"
    },
    "4457": {
        "file_id": 576,
        "content": "Creates a 200x200 image with a rounded rectangle path, applies solid green paint to stroke it with a 3px width, and saves the result as 'stroke_round_rect.png' but with transparent background.",
        "type": "summary"
    },
    "4458": {
        "file_id": 576,
        "content": "import pixie\nimage = pixie.Image(200,200)\npath = pixie.Path()\npath.rounded_rect(20,20,100,100,25,25,25,25)\npaint = pixie.Paint(pixie.SOLID_PAINT)\npaint.color = pixie.Color(0,1,0,1)\nimage.stroke_path(path, paint=paint, stroke_width=3)\nimage.write_file('stroke_round_rect.png')\n# stroke on a transparent background. well shit.",
        "type": "code",
        "location": "/tests/bilibili_video_recommendation_server/stroke_path.py:1-14"
    },
    "4459": {
        "file_id": 576,
        "content": "Creates a 200x200 image with a rounded rectangle path, applies solid green paint to stroke it with a 3px width, and saves the result as 'stroke_round_rect.png' but with transparent background.",
        "type": "comment"
    },
    "4460": {
        "file_id": 577,
        "content": "/tests/bilibili_video_recommendation_server/send_video.py",
        "type": "filepath"
    },
    "4461": {
        "file_id": 577,
        "content": "This code sends a video file to a specific group chat using the CQHTTP API. The video is obtained from a local path, and the code constructs the necessary request data and URL before sending a POST request to the CQHTTP server. It then prints the JSON response received from the server.",
        "type": "summary"
    },
    "4462": {
        "file_id": 577,
        "content": "# botoy can only repost video.\n# repostVideo2Group\t转发视频到群聊\n# repostVideo2Friend\t转发视频给好友\n# getVideoURL\t获取短视频链接\n# cqhttp can post video.\n# https://docs.go-cqhttp.org/cqcode/#%E7%9F%AD%E8%A7%86%E9%A2%91\nbaseUrl = \"http://0.0.0.0:5700\"\ngroup = 543780931\nimport requests\nurl = baseUrl + \"/send_group_msg\"\nimport os\n# video_path = \"big_breast_video.mp4\"\n# video_path = \"sample_video/sample_video.mp4\" # this video have some problem. needs intro and outro. need to show some metadata on the way.\nvideo_path = \"sample_video/output.mp4\" # the 'moderated' video\nvideo_abspath = os.path.abspath(video_path)\ncontent = \"file://\"+video_abspath\nmessage = \"[CQ:video,file={}]\".format(content)\ndata = {\"group_id\": group, \"message\": message, \"auto_escape\": False}\nr = requests.post(url, data=data)\nprint(r.json())\n# cannot send json. wtf?\n# 请参考 go-cqhttp 端输出",
        "type": "code",
        "location": "/tests/bilibili_video_recommendation_server/send_video.py:1-28"
    },
    "4463": {
        "file_id": 577,
        "content": "This code sends a video file to a specific group chat using the CQHTTP API. The video is obtained from a local path, and the code constructs the necessary request data and URL before sending a POST request to the CQHTTP server. It then prints the JSON response received from the server.",
        "type": "comment"
    },
    "4464": {
        "file_id": 578,
        "content": "/tests/bilibili_video_recommendation_server/send_payment_urls.py",
        "type": "filepath"
    },
    "4465": {
        "file_id": 578,
        "content": "This code sends group message with payment URLs using the bilibili video recommendation server. It uses requests module to send POST request to specified URL with a JSON payload containing group ID and message (payment URLs) as data. The response is printed in JSON format. There seems to be an issue with sending JSON, needing further investigation.",
        "type": "summary"
    },
    "4466": {
        "file_id": 578,
        "content": "baseUrl = \"http://0.0.0.0:5700\"\ngroup = 543780931\nimport requests\nurl = baseUrl + \"/send_group_msg\"\npayment_urls = [\n    \"https://qr.alipay.com/tsx10243tdewwaxrvullge8\",\n    \"wxp://f2f0V92qUQI0aBO5PXtWezujxMm-C1KFub6qCi1Obt3cn1KjZqDPqoWKn8ICCcwdt8zU\",\n]\nmessage = \"\\n\".join(payment_urls)\ndata = {\"group_id\": group, \"message\": message, \"auto_escape\": False}\nr = requests.post(url, data=data)\nprint(r.json())\n# cannot send json. wtf?\n# 请参考 go-cqhttp 端输出",
        "type": "code",
        "location": "/tests/bilibili_video_recommendation_server/send_payment_urls.py:1-17"
    },
    "4467": {
        "file_id": 578,
        "content": "This code sends group message with payment URLs using the bilibili video recommendation server. It uses requests module to send POST request to specified URL with a JSON payload containing group ID and message (payment URLs) as data. The response is printed in JSON format. There seems to be an issue with sending JSON, needing further investigation.",
        "type": "comment"
    },
    "4468": {
        "file_id": 579,
        "content": "/tests/bilibili_video_recommendation_server/send_image_gif.py",
        "type": "filepath"
    },
    "4469": {
        "file_id": 579,
        "content": "The code is testing to broadcast a picture or gif using the botoy library. The action may fail, so it might be necessary to upload the gif instead of scanning the code within it. It reads the file, encodes it in base64, and sends it as a group message with the provided content.",
        "type": "summary"
    },
    "4470": {
        "file_id": 579,
        "content": "# test to broadcast all these things.\n# this method might fail to behave correctly.\n# maybe we need to upload the\nfrom botoy import Action\nqq = 917521610\nport = 8784\naction = Action(qq=qq, port=port, host=\"127.0.0.1\")\n# user = 1281727431\ngroup = 543780931\nlink = \"https://b23.tv/DPn1G4p\"\ntitle_text = \"真·朋克！揭秘《赛博朋克2077》屏幕之外的魔幻换弹操作\"\ncontent = \"观看视频:\\n{}\\n{}\".format(link, title_text)\nimport base64\n# picture_path = \"qrcode.gif\"\npicture_path = \"anime_masked_overlay.gif\" # how to crop this thing?\n# where is the gif? my god?\n# there is no way to scan the code in the gif. better send the link instead.\nwith open(picture_path, \"rb\") as img_file:\n    b64_string = base64.b64encode(img_file.read())\n# print(b64_string)\nresult = action.sendGroupPic(group=group, picBase64Buf=b64_string.decode(\"utf-8\"), content=content)\nprint(result)",
        "type": "code",
        "location": "/tests/bilibili_video_recommendation_server/send_image_gif.py:1-29"
    },
    "4471": {
        "file_id": 579,
        "content": "The code is testing to broadcast a picture or gif using the botoy library. The action may fail, so it might be necessary to upload the gif instead of scanning the code within it. It reads the file, encodes it in base64, and sends it as a group message with the provided content.",
        "type": "comment"
    },
    "4472": {
        "file_id": 580,
        "content": "/tests/bilibili_video_recommendation_server/send_image_botoy.py",
        "type": "filepath"
    },
    "4473": {
        "file_id": 580,
        "content": "This code uses Botoy library to send images/videos on QQ, defines specific objectives, and sends messages with action.sendFriendPic method while also allowing accompanying text with action.sendFriendText method.",
        "type": "summary"
    },
    "4474": {
        "file_id": 580,
        "content": "# test to broadcast all these things.\n# this method might fail to behave correctly.\n# maybe we need to upload the image and get url? no thanks?\n# we use jpg instead? must use cv2.\n# 暂时用不到转发消息的功能\nfrom botoy import Action\nqq = 917521610\nport = 8784\naction = Action(qq=qq, port=port, host=\"127.0.0.1\")\nuser = 1281727431\nimport base64\nobjective = \"send_image\"\nif objective == 'send_video_ad':\n    link = \"https://b23.tv/DPn1G4p\"\n    title_text = \"真·朋克！揭秘《赛博朋克2077》屏幕之外的魔幻换弹操作\"\n    content = \"观看视频:\\n{}\\n{}\".format(link, title_text)\n    picture_path = \"ad_2_standalone_cover.png\"\n    with open(picture_path, \"rb\") as img_file:\n        b64_string = base64.b64encode(img_file.read())\n    # print(b64_string)\n    result = action.sendFriendPic(user=user, picBase64Buf=b64_string.decode(\"utf-8\"))\n    print(result)\n    action.sendFriendText(user=user, content=content)\n    # send separately.\n    # result = action.sendFriendPic(user=user, picBase64Buf=b64_string.decode('utf-8'),content = content)\nelif objective == 'send_image':\n    # picture_path = \"ad_2.png\"",
        "type": "code",
        "location": "/tests/bilibili_video_recommendation_server/send_image_botoy.py:1-35"
    },
    "4475": {
        "file_id": 580,
        "content": "The code uses the Botoy library to send images or videos as messages on QQ. It requires the user to define specific objectives like 'send_video_ad' and 'send_image'. The code reads the image file, encodes it into base64, and sends it as a message using the action.sendFriendPic method. Additionally, it can also send accompanying text messages with the action.sendFriendText method.",
        "type": "comment"
    },
    "4476": {
        "file_id": 580,
        "content": "    # picture_path = \"ebegging_setu_transparent.png\"\n    picture_path = \"image_with_text_8.png\"\n    with open(picture_path, \"rb\") as img_file:\n        b64_string = base64.b64encode(img_file.read())\n    # print(b64_string)\n    result = action.sendFriendPic(\n        user=user, picBase64Buf=b64_string.decode(\"utf-8\")\n    )  # better without content.",
        "type": "code",
        "location": "/tests/bilibili_video_recommendation_server/send_image_botoy.py:36-43"
    },
    "4477": {
        "file_id": 580,
        "content": "This code opens a local image file, reads its contents in binary format, encodes the binary data to base64 string representation, and then sends it as a friend picture using the \"sendFriendPic\" function of the \"action\" module.",
        "type": "comment"
    },
    "4478": {
        "file_id": 581,
        "content": "/tests/bilibili_video_recommendation_server/remove_background.sh",
        "type": "filepath"
    },
    "4479": {
        "file_id": 581,
        "content": "This command uses ffmpeg to remove the black background from \"bilibili.png\" and save the result as \"bilibili_transparent.png\". The colorkey filter is applied with settings for black color, thresholding, and tolerance.",
        "type": "summary"
    },
    "4480": {
        "file_id": 581,
        "content": "ffmpeg -i bilibili.png -vf \"colorkey=black:0.3:0.2\" bilibili_transparent.png",
        "type": "code",
        "location": "/tests/bilibili_video_recommendation_server/remove_background.sh:1-1"
    },
    "4481": {
        "file_id": 581,
        "content": "This command uses ffmpeg to remove the black background from \"bilibili.png\" and save the result as \"bilibili_transparent.png\". The colorkey filter is applied with settings for black color, thresholding, and tolerance.",
        "type": "comment"
    },
    "4482": {
        "file_id": 582,
        "content": "/tests/bilibili_video_recommendation_server/overlay_gif.sh",
        "type": "filepath"
    },
    "4483": {
        "file_id": 582,
        "content": "This code uses FFmpeg to overlay a PNG image onto an anime GIF. It scales the GIF to 936x598 resolution, places the overlay at (0,0), and outputs a new GIF called \"anime_overlay.gif\".",
        "type": "summary"
    },
    "4484": {
        "file_id": 582,
        "content": "ffmpeg -i anime.gif -i overlay.png \\\n\t-filter_complex \"[0:v]scale=936:598[v1];[v1][1:v]overlay=0:0\" \\\n\t-c:a copy \\\n\tanime_overlay.gif",
        "type": "code",
        "location": "/tests/bilibili_video_recommendation_server/overlay_gif.sh:1-4"
    },
    "4485": {
        "file_id": 582,
        "content": "This code uses FFmpeg to overlay a PNG image onto an anime GIF. It scales the GIF to 936x598 resolution, places the overlay at (0,0), and outputs a new GIF called \"anime_overlay.gif\".",
        "type": "comment"
    },
    "4486": {
        "file_id": 583,
        "content": "/tests/bilibili_video_recommendation_server/get_text_boundaries.py",
        "type": "filepath"
    },
    "4487": {
        "file_id": 583,
        "content": "The code imports Pixie and Lazorzero libraries to draw text on an image, save it, convert the image to grayscale, and then extract the bounding rectangle using OpenCV's boundingRect function. The output is a tuple containing (top left x, top left y, width, height) values representing the bounding box of the text in the image.",
        "type": "summary"
    },
    "4488": {
        "file_id": 583,
        "content": "import pixie\ntext = 'test me please'\nexport_path = 'detect_text_bounds.png'\nimage = pixie.Image(200,200)\nfont_location = \"./wqy-microhei0.ttf\"\nfont = pixie.read_font(font_location)\nfont.size = 20\nfont.paint.color = pixie.Color(1,1,1,1)\nimage.fill_text(\n    font, text, bounds=pixie.Vector2(180, 180), transform=pixie.translate(10, 10)\n)\nimage.write_file(export_path)\nfrom lazero.utils.importers import cv2_custom_build_init\ncv2_custom_build_init()\nimport cv2\nimg = cv2.imread(export_path)\n# print(img.shape) #(200,200,3)\n# exit()\nimg_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n# print(img_gray)\nrect = cv2.boundingRect(img_gray)\n# fuck?\nprint(rect)\n# (10, 13, 130, 21)\n# x,y,w,h?",
        "type": "code",
        "location": "/tests/bilibili_video_recommendation_server/get_text_boundaries.py:1-32"
    },
    "4489": {
        "file_id": 583,
        "content": "The code imports Pixie and Lazorzero libraries to draw text on an image, save it, convert the image to grayscale, and then extract the bounding rectangle using OpenCV's boundingRect function. The output is a tuple containing (top left x, top left y, width, height) values representing the bounding box of the text in the image.",
        "type": "comment"
    },
    "4490": {
        "file_id": 584,
        "content": "/tests/bilibili_video_recommendation_server/get_masked_gif.sh",
        "type": "filepath"
    },
    "4491": {
        "file_id": 584,
        "content": "This code uses ffmpeg to resize, extract alpha channels, merge, and overlay images for a GIF. It applies an ad mask, creates an overlaid version of the GIF with a black background, and saves both as \"anime_masked.gif\" and \"anime_masked_overlay.gif\".",
        "type": "summary"
    },
    "4492": {
        "file_id": 584,
        "content": "WIDTH=936\nHEIGHT=598\n# ffmpeg -y -i anime.gif  -loop 1 -t 1 -i ad_2_mask.png -filter_complex \"[0]scale=$WIDTH:$HEIGHT[v0];[1]alphaextract[v1];[v0][v1]alphamerge[vf];color=black:d=1[c];[c][vf]scale2ref[cs][vf0];[cs][vf0]overlay\" anime_masked.gif\nffmpeg -y -i anime.gif  -loop 1 -t 1 -i ad_2_mask.png -i overlay.png -filter_complex \"[0]scale=$WIDTH:$HEIGHT[v0];[1]alphaextract[v1];[v0][v1]alphamerge[vf];color=black:d=1[c];[c][vf]scale2ref[cs][vf0];[cs][vf0]overlay[vf1];[vf1][2]overlay\" anime_masked_overlay.gif",
        "type": "code",
        "location": "/tests/bilibili_video_recommendation_server/get_masked_gif.sh:1-5"
    },
    "4493": {
        "file_id": 584,
        "content": "This code uses ffmpeg to resize, extract alpha channels, merge, and overlay images for a GIF. It applies an ad mask, creates an overlaid version of the GIF with a black background, and saves both as \"anime_masked.gif\" and \"anime_masked_overlay.gif\".",
        "type": "comment"
    },
    "4494": {
        "file_id": 585,
        "content": "/tests/bilibili_video_recommendation_server/get_bilibili_shortlink.py",
        "type": "filepath"
    },
    "4495": {
        "file_id": 585,
        "content": "This code makes an HTTP request to a Tencent API for Bilibili short links, using URL and href parameters, extracts the 'short_url' if successful (status 200), and prints it.",
        "type": "summary"
    },
    "4496": {
        "file_id": 585,
        "content": "apiUrl = \"https://service-ijd4slqi-1253419200.gz.apigw.tencentcs.com/release/short_url\"\nlongUrl = \"https://www.bilibili.com/video/BV1Wv41157Wz\"\nimport urllib.parse as urlparse\n# params = {\"url\": longUrl}\nparams = {\"url\": urlparse.quote(longUrl).replace(\"/\",\"%2F\"), 'href':\"https://xiaojuzi.fun/bili-short-url/\"}\n# print(params)\n# exit()\nheaders = {\n    \"accept\": \"*/*\",\n    \"accept-language\": \"en-US,en;q=0.9\",\n    \"if-none-match\": 'W/\"35-oPDNsqBGaZKqGe83GW6wem+lkww\"',\n    \"sec-ch-ua\": '\"Google Chrome\";v=\"105\", \"Not)A;Brand\";v=\"8\", \"Chromium\";v=\"105\"',\n    \"sec-ch-ua-mobile\": \"?0\",\n    \"sec-ch-ua-platform\": '\"macOS\"',\n    \"sec-fetch-dest\": \"empty\",\n    \"sec-fetch-mode\": \"cors\",\n    \"sec-fetch-site\": \"cross-site\",\n    \"Referer\": \"https://xiaojuzi.fun/\",\n    \"Referrer-Policy\": \"strict-origin-when-cross-origin\",\n    'user-agent':'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36' # this is important.\n}\nimport requests\nrequest_url = apiUrl+\"?url={url}&href={href}\".format(**params)",
        "type": "code",
        "location": "/tests/bilibili_video_recommendation_server/get_bilibili_shortlink.py:2-26"
    },
    "4497": {
        "file_id": 585,
        "content": "This code is making an HTTP request to the specified API endpoint for getting a Bilibili short link. It includes parameters like long URL and href, sets necessary headers, and constructs the request URL using the given parameters.",
        "type": "comment"
    },
    "4498": {
        "file_id": 585,
        "content": "# request_url = 'https://service-ijd4slqi-1253419200.gz.apigw.tencentcs.com/release/short_url?url=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1Wv41157Wz&href=https://xiaojuzi.fun/bili-short-url/'\n# print(request_url)\nr = requests.get(request_url, headers=headers)\nif r.status_code == 200:\n    # print(r.json())\n    r_json = r.json()\n    success = r_json.get('success', False)\n    if success:\n        short_url = r_json.get('short_url', None)\n        print(short_url)\n# starts with 'https://b23.tv'",
        "type": "code",
        "location": "/tests/bilibili_video_recommendation_server/get_bilibili_shortlink.py:27-37"
    },
    "4499": {
        "file_id": 585,
        "content": "This code retrieves the Bilibili video shortlink by making a GET request to the Tencent API with the URL and href parameters. If the response status code is 200, it extracts the 'short_url' from the JSON response and prints it if the 'success' flag is True. The resulting short link starts with 'https://b23.tv'.",
        "type": "comment"
    }
}