{
    "1000": {
        "file_id": 85,
        "content": "                            print(\"%s filter:\" % flag, mFilter)\n                            break\n                        else:\n                            print(\"%s test passed.\" % flag)\n                    except:\n                        import traceback\n                        traceback.print_exc()\n                        print(\"skipping due to exception during filtering\")\n                        valid = False\n                        break\n                if not valid:\n                    print(\"abandon video:\", item_id)\n                # breakpoint()\n                if not valid:\n                    if os.path.exists(local_video_location):\n                        print(\"removing abandoned video:\", local_video_location)\n                        os.remove(local_video_location)\n                else:\n                    video_width, video_height = get_res(local_video_location)\n                    yield {\n                        \"location\": local_video_location,\n                        \"item_id\": item_id,\n                        \"meta\": {",
        "type": "code",
        "location": "/pyjom/modules/informationProcessing/onlineProcessor.py:235-258"
    },
    "1001": {
        "file_id": 85,
        "content": "This code is testing a filter for an item and either passing or skipping based on exceptions. If it skips, the video file is removed. If it passes, it yields information about the video location and item ID.",
        "type": "comment"
    },
    "1002": {
        "file_id": 85,
        "content": "                            \"duration\": get_duration(local_video_location),\n                            \"width\": video_width,\n                            \"height\": video_height,\n                        },\n                    }\n                    # if you abandon that, better delete it!\n                # do time duration check, effective fps check, color centrality check, then the dog/cat check\n                # what's next? find some audio files? or just use one audio?\n                # print(\"HERE??\",3)\n                # print('flag', flag)",
        "type": "code",
        "location": "/pyjom/modules/informationProcessing/onlineProcessor.py:259-268"
    },
    "1003": {
        "file_id": 85,
        "content": "This code snippet is initializing a dictionary with key-value pairs for video duration, width, and height. It also creates another nested dictionary representing the video object. The code mentions time duration check, effective fps check, color centrality check, dog/cat check, and possibly audio file handling in future steps.",
        "type": "comment"
    },
    "1004": {
        "file_id": 86,
        "content": "/pyjom/modules/methodIdentifier/__init__.py",
        "type": "filepath"
    },
    "1005": {
        "file_id": 86,
        "content": "This code imports all the contents from the \"dummyIdentifier\" module in the \"pyjom.modules.methodIdentifier\" package.",
        "type": "summary"
    },
    "1006": {
        "file_id": 86,
        "content": "from pyjom.modules.methodIdentifier.dummyIdentifier import *",
        "type": "code",
        "location": "/pyjom/modules/methodIdentifier/__init__.py:1-1"
    },
    "1007": {
        "file_id": 86,
        "content": "This code imports all the contents from the \"dummyIdentifier\" module in the \"pyjom.modules.methodIdentifier\" package.",
        "type": "comment"
    },
    "1008": {
        "file_id": 87,
        "content": "/pyjom/modules/methodIdentifier/dummyIdentifier.py",
        "type": "filepath"
    },
    "1009": {
        "file_id": 87,
        "content": "The code defines a function `dummyId()` that generates a unique UUID and a class `dummyIdentifier` with instance variables and methods to store fix information related to various components of a system.",
        "type": "summary"
    },
    "1010": {
        "file_id": 87,
        "content": "def dummyId():\n    import uuid\n    return uuid.uuid4()\nclass dummyIdentifier:\n    def __init__(self, uuid):\n        self.uuid = uuid\n        self.data = {}\n    def typeFix(self, typeFix):\n        self.data[\"typeFix\"] = typeFix\n    def topicFix(self, topicFix):\n        self.data[\"topicFix\"] = topicFix\n    def infoFix(self, infoFix):\n        self.data[\"infoFix\"] = infoFix\n    def producerFix(self, producerFix):\n        self.data[\"producerFix\"] = producerFix\n    def posterFix(self, posterFix):\n        self.data[\"posterFix\"] = posterFix\n    def feedbackFix(self, feedbackFix):\n        self.data[\"feedbackFix\"] = feedbackFix\n    def updatorFix(self, updatorFix):\n        self.data[\"updatorFix\"] = updatorFix\n    def fetcherFix(self, fetcherFix):\n        self.data[\"fetcherFix\"] = fetcherFix\n    def processorFix(self, processorFix):\n        self.data[\"processorFix\"] = processorFix\n    def optimizerFix(self, optimizerFix):\n        self.data[\"optimizerFix\"] = optimizerFix\n    def reviewerFix(self, reviewerFix):\n        self.data[\"reviewerFix\"] = reviewerFix",
        "type": "code",
        "location": "/pyjom/modules/methodIdentifier/dummyIdentifier.py:1-43"
    },
    "1011": {
        "file_id": 87,
        "content": "The code defines a function `dummyId()` that generates a unique UUID and a class `dummyIdentifier` with instance variables and methods to store fix information related to various components of a system.",
        "type": "comment"
    },
    "1012": {
        "file_id": 88,
        "content": "/pyjom/modules/topicGenerator/__init__.py",
        "type": "filepath"
    },
    "1013": {
        "file_id": 88,
        "content": "This code imports modules from various topic generators (dummy, weibo, local, online) within the pyjom project. It appears to be related to generating topics or data for a specific purpose.",
        "type": "summary"
    },
    "1014": {
        "file_id": 88,
        "content": "from pyjom.modules.topicGenerator.dummyTopicGenerator import *\nfrom pyjom.modules.topicGenerator.weiboTopicGenerator import *\nfrom pyjom.modules.topicGenerator.localTopicGenerator import *\nfrom pyjom.modules.topicGenerator.onlineTopicGenerator import *",
        "type": "code",
        "location": "/pyjom/modules/topicGenerator/__init__.py:1-4"
    },
    "1015": {
        "file_id": 88,
        "content": "This code imports modules from various topic generators (dummy, weibo, local, online) within the pyjom project. It appears to be related to generating topics or data for a specific purpose.",
        "type": "comment"
    },
    "1016": {
        "file_id": 89,
        "content": "/pyjom/modules/topicGenerator/dummyTopicGenerator.py",
        "type": "filepath"
    },
    "1017": {
        "file_id": 89,
        "content": "The code imports the \"decorator\" function from the \"pyjom.commons\" module and defines two functions: \"dummyTopic()\" that returns the string \"pets\", and \"metaTopic(selected_source)\" which returns a list of titles based on the selected source. These functions are likely used for generating topic ideas or names.",
        "type": "summary"
    },
    "1018": {
        "file_id": 89,
        "content": "from pyjom.commons import *\n@decorator\ndef dummyTopic():\n    return \"pets\"\n@decorator\ndef metaTopic(selected_source):\n    sources = {\n        \"baidu_baijiahao\": [\"shitty title1\"],\n        \"bilibili_trending\": [\"boy with women's clothes\"],\n    }\n    return sources[selected_source]",
        "type": "code",
        "location": "/pyjom/modules/topicGenerator/dummyTopicGenerator.py:1-15"
    },
    "1019": {
        "file_id": 89,
        "content": "The code imports the \"decorator\" function from the \"pyjom.commons\" module and defines two functions: \"dummyTopic()\" that returns the string \"pets\", and \"metaTopic(selected_source)\" which returns a list of titles based on the selected source. These functions are likely used for generating topic ideas or names.",
        "type": "comment"
    },
    "1020": {
        "file_id": 90,
        "content": "/pyjom/modules/topicGenerator/localTopicGenerator.py",
        "type": "filepath"
    },
    "1021": {
        "file_id": 90,
        "content": "The filesystemTopicGenerator function generates topics from file/directory paths, checking their validity and appending to a list of file names. It returns a dictionary with protocol, path, and content (filepaths).",
        "type": "summary"
    },
    "1022": {
        "file_id": 90,
        "content": "from pyjom.commons import *\nimport os\n@decorator\ndef filesystemTopicGenerator(filepath=None, dirpath=None, recursive=False):\n    mfilelist = []\n    protocol = None\n    path = getHostname() + \"@\"\n    if filepath is not None:\n        assert os.path.isfile(filepath)\n        mpath = os.path.abspath(filepath)\n        protocol = \"file\"\n        path += mpath\n        mfilelist.append(mpath)\n    else:\n        assert dirpath is not None\n        assert os.path.isdir(dirpath)\n        dirpath = os.path.abspath(dirpath)\n        path += dirpath\n        if recursive:\n            protocol = \"dir_recursive\"\n            for _, _, files in os.walk(dirpath):\n                for fname in files:\n                    fpath = os.path.join(dirpath, fname)\n                    if os.path.isfile(fpath):\n                        # mpath = os.path.abspath(fpath)\n                        mfilelist.append(fpath)\n        else:\n            protocol = \"dir\"\n            mfiles = os.listdir(dirpath)\n            for fname in mfiles:\n                fpath = os.path.join(dirpath, fname)",
        "type": "code",
        "location": "/pyjom/modules/topicGenerator/localTopicGenerator.py:1-33"
    },
    "1023": {
        "file_id": 90,
        "content": "The code defines a filesystemTopicGenerator function that generates topics from file or directory paths. It takes filepath and dirpath as input parameters, with optional recursive flag for directories. It checks if the given filepath exists or if the dirpath is a valid directory. If so, it appends the file/directory path to a list of file names. The protocol is set based on whether a file or directory was provided and used in generating topics.",
        "type": "comment"
    },
    "1024": {
        "file_id": 90,
        "content": "                if os.path.isfile(fpath):\n                    # mpath = os.path.abspath(fpath)\n                    mfilelist.append(fpath)\n    return {\"protocol\": protocol, \"path\": path, \"content\": mfilelist}",
        "type": "code",
        "location": "/pyjom/modules/topicGenerator/localTopicGenerator.py:34-37"
    },
    "1025": {
        "file_id": 90,
        "content": "Checks if a file exists at the specified path, appends absolute file paths to list, and returns a dictionary containing protocol, path, and content (filepaths).",
        "type": "comment"
    },
    "1026": {
        "file_id": 91,
        "content": "/pyjom/modules/topicGenerator/onlineTopicGenerator.py",
        "type": "filepath"
    },
    "1027": {
        "file_id": 91,
        "content": "The code imports functions for keyword removal and topic modeling in English/Chinese, selects words by shuffling topics, fetches random keywords to request gifs/videos from a local server, and retrieves a random picture with related words using keyword and topic modeling.",
        "type": "summary"
    },
    "1028": {
        "file_id": 91,
        "content": "from pyjom.commons import *\nfrom pyjom.languagetoolbox import englishTopicModeling, chineseTopicModeling\nfrom lazero.utils.tools import flattenUnhashableList  # one of my classic methods\nimport requests\n# import jieba\nfrom typing import Literal\ndef removeKeywordDuplicates(keywords):\n    keywordsType = type(keywords)\n    inputFuncs = {\n        str: lambda x: x.split(\" \"),\n        list: lambda x: x,\n        tuple: lambda x: list(x),\n    }\n    outputFuncs = {\n        str: lambda x: \" \".join(x),\n        list: lambda x: x,\n        tuple: lambda x: tuple(x),\n    }\n    if keywordsType in inputFuncs.keys():\n        keywordsList = inputFuncs[keywordsType](keywords)\n    else:\n        raise Exception(\"Unknown keywords type: %s\" % type(keywords))\n    keywordsSet = set(keywordsList)\n    keywordsSetList = list(keywordsSet)\n    return outputFuncs[keywordsType](keywordsSetList)\ndef topicModeling(sentences: list[str], lang=\"en\"):  # specify language please?\n    # python does not enforce type checking. use third party tool such as linter instead.",
        "type": "code",
        "location": "/pyjom/modules/topicGenerator/onlineTopicGenerator.py:1-33"
    },
    "1029": {
        "file_id": 91,
        "content": "This code imports necessary modules and defines two functions: `removeKeywordDuplicates` for removing duplicate keywords in a list or string, and `topicModeling` for topic modeling with specified language (English or Chinese). It also includes an exception handling for unknown keyword types.",
        "type": "comment"
    },
    "1030": {
        "file_id": 91,
        "content": "    if lang == \"en\":\n        topics = englishTopicModeling(sentences)\n        return topics\n    elif lang == \"zh\":\n        topics = chineseTopicModeling(sentences)\n        return topics\n    else:\n        raise Exception(\"Unknown language: %s\" % lang)\ndef topicWordSelection(\n    topics,\n    core_topic_set: set,\n    selected_topic_list: list,\n    mode: Literal[\"combined\", \"separate\"] = \"combined\",\n    threshold=10,\n):\n    if len(selected_topic_list) > threshold:\n        for _ in range(len(selected_topic_list) - threshold):\n            selected_topic_list.pop(0)  # right way to remove elem from original list.\n    selected_topic_set = set(list(core_topic_set) + selected_topic_list)\n    import random\n    mTopics = topics.copy()\n    random.shuffle(mTopics)\n    for topic in mTopics:\n        words = topic[mode]\n        words = [x for x in words if x not in selected_topic_set]\n        if len(words) > 0:\n            word = random.choice(words)\n            selected_topic_list.append(word)  # no need to go elsewhere.\n            return word",
        "type": "code",
        "location": "/pyjom/modules/topicGenerator/onlineTopicGenerator.py:34-65"
    },
    "1031": {
        "file_id": 91,
        "content": "The code checks the language input and applies the appropriate topic modeling function. It then performs word selection by removing words already in the list, shuffling the remaining topics, and randomly choosing a new word to append to the selected_topic_list until it reaches a specified threshold.",
        "type": "comment"
    },
    "1032": {
        "file_id": 91,
        "content": "    print(\"no topic word this time\")\n    return None\ndef getMetaTopicString(metaTopic):\n    staticCandidates = [random.choice(x) for x in metaTopic.get(\"static\", [])]\n    optionalCandidates = [random.choice(x) for x in metaTopic.get(\"optional\", [])]\n    if len(optionalCandidates) > 0:\n        optionalCandidates = random.choice(optionalCandidates)\n    if type(optionalCandidates) != list:\n        optionalCandidates = [optionalCandidates]\n    dynamicCandidates = [random.choice(x) for x in metaTopic.get(\"dynamic\", [])]\n    samples = random.sample(\n        dynamicCandidates, random.randint(0, len(dynamicCandidates))\n    )\n    # print(staticCandidates)\n    # print(optionalCandidates)\n    # print(samples)\n    # breakpoint()\n    return \" \".join(staticCandidates + optionalCandidates + samples)\n@decorator\ndef OnlineTopicGenerator(\n    source=\"giphy\",\n    metaTopic={\n        \"static\": [[\"dog\", \"cat\"], [\"funny\", \"cute\"]],\n        \"dynamic\": [[\"samoyed\", \"husky\", \"teddy\", \"chiwawa\"]],\n    },  # this is not a matrix.\n    # sample_size = 10 # per search.",
        "type": "code",
        "location": "/pyjom/modules/topicGenerator/onlineTopicGenerator.py:66-95"
    },
    "1033": {
        "file_id": 91,
        "content": "The code defines a function called `getMetaTopicString` which takes a metaTopic dictionary as input and returns a string of topic words. It first generates static, optional, and dynamic candidates from the provided metaTopic dictionary. Then, it selects one candidate from each category and combines them into a final string. The code also includes a print statement and a breakpoint for debugging purposes. Finally, the decorator `@decorator` is used to apply some functionality to the `OnlineTopicGenerator` function.",
        "type": "comment"
    },
    "1034": {
        "file_id": 91,
        "content": "    timeout:float=20\n):\n    getKeywords = lambda: getMetaTopicString(metaTopic)\n    core_topic_set = {\n        *flattenUnhashableList([value for key, value in metaTopic.items()])\n    }  # common way to initialize a set.\n    selected_topic_list = []\n    if source == \"giphy\":\n        waitForServerUp(8902, \"nodejs giphy server\")\n        keywords = getKeywords()\n        while True:\n            import time\n            time.sleep(0.5)\n            harvestedData = []\n            try:\n                source_type = random.choice([\"videos\", \"gifs\"])\n                # source_type = 'videos' # for debugging\n                if random.random() > 0.5:\n                    with requests.get(\n                        \"http://127.0.0.1:8902/random\",\n                        params={\"q\": keywords, \"rating\": \"g\", \"type\": source_type},\n                        verify=False,\n                        proxies=None,\n                        timeout=timeout\n                    ) as mRandomPicture:  # may you get stickers?\n                        mRandomPictureJson = mRandomPicture.json()",
        "type": "code",
        "location": "/pyjom/modules/topicGenerator/onlineTopicGenerator.py:96-122"
    },
    "1035": {
        "file_id": 91,
        "content": "Code fetches random keywords from a metaTopic string and sends GET requests to a local server (running on 127.0.0.1:8902) for gifs or videos related to these keywords. If the keyword-related request is successful, it stores the result in mRandomPictureJson variable. This process continues until a timeout occurs or until another condition breaks the loop. The code also has debugging support by allowing the source_type to be hardcoded as 'videos'.",
        "type": "comment"
    },
    "1036": {
        "file_id": 91,
        "content": "                        harvestedData += mRandomPictureJson[\"data\"]\n                        randomPictureId = mRandomPictureJson[\"data\"][0][\"id\"]\n                else:\n                    with requests.get(\n                        \"http://127.0.0.1:8902/search\",\n                        params={\"q\": keywords, \"rating\": \"g\", \"type\": source_type},\n                        verify=False,\n                        proxies=None,\n                        timeout=timeout\n                    ) as mSearchPictures:\n                        mSearchPicturesJson = mSearchPictures.json()\n                        harvestedData += mSearchPicturesJson[\"data\"]\n                        randomPictureId = random.choice(mSearchPicturesJson[\"data\"])[\n                            \"id\"\n                        ]\n                selectedWord = None\n                with requests.get(\n                    \"http://127.0.0.1:8902/related\",\n                    params={\n                        \"q\": randomPictureId,\n                        \"type\": source_type,",
        "type": "code",
        "location": "/pyjom/modules/topicGenerator/onlineTopicGenerator.py:123-143"
    },
    "1037": {
        "file_id": 91,
        "content": "This code is making a request to an API, harvesting data based on keywords and type, and selecting a random picture. It also retrieves related words for the selected picture.",
        "type": "comment"
    },
    "1038": {
        "file_id": 91,
        "content": "                    },\n                    verify=False,\n                    proxies=None,  # seems not working? wtf?\n                ) as mRelatedPictures:\n                    mRelatedPicturesJson = mRelatedPictures.json()\n                    harvestedData += mRelatedPicturesJson[\"data\"]\n                    sentences = [x[\"title\"] for x in mRelatedPicturesJson[\"data\"]]\n                    topics = topicModeling(sentences)\n                    selectedWord = topicWordSelection(\n                        topics, core_topic_set, selected_topic_list\n                    )\n                if not selectedWord is None:\n                    keywords = \" \".join(\n                        [getKeywords(), selectedWord]\n                    )  # for next iteration.\n                    print(\"REFRESHING KEYWORDS:\", keywords)\n                else:\n                    keywords = getKeywords()\n                # recheck keywords!\n                keywords = removeKeywordDuplicates(keywords)\n            except:\n                import traceback",
        "type": "code",
        "location": "/pyjom/modules/topicGenerator/onlineTopicGenerator.py:144-165"
    },
    "1039": {
        "file_id": 91,
        "content": "This code segment fetches related pictures from a URL, performs topic modeling on the titles of these images, selects a word from the core topic set for further keyword generation, and handles potential exceptions.",
        "type": "comment"
    },
    "1040": {
        "file_id": 91,
        "content": "                traceback.print_exc()\n                print(\"ERROR WHEN FETCHING GIPHY TOPIC\")\n            for elem in harvestedData:\n                yield elem[\"id\"], json_auto_float_int(elem[\"media\"])",
        "type": "code",
        "location": "/pyjom/modules/topicGenerator/onlineTopicGenerator.py:167-170"
    },
    "1041": {
        "file_id": 91,
        "content": "This code block catches exceptions that may occur while fetching GIPHY topics. It prints the error trace and a descriptive message, then proceeds to iterate through the harvested data, yielding each entry's ID and media value after converting it using json_auto_float_int function.",
        "type": "comment"
    },
    "1042": {
        "file_id": 92,
        "content": "/pyjom/modules/topicGenerator/weiboTopicGenerator.py",
        "type": "filepath"
    },
    "1043": {
        "file_id": 92,
        "content": "This code imports necessary modules and defines a topic generator function for pets. It returns a fixed topic in both Chinese and English languages, demonstrating simple multilingual support.",
        "type": "summary"
    },
    "1044": {
        "file_id": 92,
        "content": "from pyjom.commons import *\n@decorator\ndef petsTopicGenerator():\n    # this is just some primitive topic, always return the same thing.\n    # topics cannot be multilingual.\n    return {\"entities\": [{\"chinese\": \"搞笑 宠物\", \"english\": \"funny pets\"}]}",
        "type": "code",
        "location": "/pyjom/modules/topicGenerator/weiboTopicGenerator.py:1-8"
    },
    "1045": {
        "file_id": 92,
        "content": "This code imports necessary modules and defines a topic generator function for pets. It returns a fixed topic in both Chinese and English languages, demonstrating simple multilingual support.",
        "type": "comment"
    },
    "1046": {
        "file_id": 93,
        "content": "/pyjom/musictoolbox.py",
        "type": "filepath"
    },
    "1047": {
        "file_id": 93,
        "content": "The code imports libraries, defines an audio analysis function using ShazamIO and Midomi API for identifying music. It handles temporary files, extracts duration, segments audio if needed, performs recognition using multiple backends until successful. The function retrieves and checks music URLs, lyrics, and downloaded files' status from NetEase API, implementing search functionality and error handling.",
        "type": "summary"
    },
    "1048": {
        "file_id": 93,
        "content": "# you will have a better name for other toolboxs.\n# for now, the musictoolbox is responsible for music/lyric retrieval/download, track separation, bpm, music recognition\n# pitch shift, speedup/slowdown is for audiotoolbox\n# voice change/synthesis is for voicetoolbox.\n# diffusion based painter, ai colorization, video editing is for artworktoolbox. maybe the naming is not right/necessary.\n# check AmadeusCore, /root/Desktop/works/pyjom/tests/music_recognization/AmadeusCore/src/components/app/models/\nfrom types import FunctionType\nfrom typing import Union\nimport audioowl\nimport math\nfrom pyjom.commons import *\nfrom pyjom.lyrictoolbox import read_lrc, getLyricNearbyBpmCandidates\nfrom pyjom.audiotoolbox import getAudioDuration\nimport ffmpeg\n# musictoolbox\ndef audioOwlAnalysis(myMusic):\n    # get sample rate\n    # info = MediaInfo(filename = myMusic)\n    # info = info.getInfo()\n    info = get_media_info(myMusic)\n    audioSampleRate = info[\"audioSamplingRate\"]\n    audioSampleRate = int(audioSampleRate)\n    waveform = audioowl.get_waveform(myMusic, sr=audioSampleRate)",
        "type": "code",
        "location": "/pyjom/musictoolbox.py:1-31"
    },
    "1049": {
        "file_id": 93,
        "content": "This code imports necessary libraries and functions, defines the `audioOwlAnalysis` function which retrieves audio sample rate from a music file using `get_media_info()`, sets the sample rate for `audioowl.get_waveform()`, and then calls the waveform function to generate a waveform representation of the audio.",
        "type": "comment"
    },
    "1050": {
        "file_id": 93,
        "content": "    data = audioowl.analyze_file(myMusic, sr=audioSampleRate)  # how fucking long?\n    a, b, c, d = [\n        data[k] for k in [\"beat_samples\", \"duration\", \"sample_rate\", \"tempo_float\"]\n    ]\n    bpm = data[\"tempo_float\"]\n    # single_bpm_time = 60/d\n    beat_times = [x / c for x in a]\n    return beat_times, bpm\n# musictoolbox\ndef getMusicCutSpansCandidates(\n    music, lyric_path, maxtime, mintime, mbeat_time_tolerance=0.8\n):\n    beats, bpm = audioOwlAnalysis(music[\"filepath\"])\n    if (\n        lyric_path is not None\n        and type(lyric_path) == str\n        and os.path.exists(lyric_path)\n    ):\n        lyric = read_lrc(lyric_path)\n        # print(lyric)\n        # breakpoint()\n        lyric_times = [x[\"time\"] for x in lyric]\n        lyric_times.sort()\n    else:\n        lyric_times = []\n    new_lyric_times = []\n    last_time = 0\n    for mtime in lyric_times:\n        if mtime - last_time > mintime:\n            new_lyric_times.append(mtime)\n            last_time = mtime\n    lyric_times = new_lyric_times\n    beat_duration = 60 / bpm",
        "type": "code",
        "location": "/pyjom/musictoolbox.py:32-68"
    },
    "1051": {
        "file_id": 93,
        "content": "The code performs audio analysis on a given music file using the audioOwlAnalysis function and obtains beat data, tempo, and beats per minute (BPM). If a lyric path is provided and exists, it reads the lyrics and sorts their timings. Then, it filters out any lyric time that is less than the minimum allowed time (mtime). Finally, it returns the list of beat times and BPM.",
        "type": "comment"
    },
    "1052": {
        "file_id": 93,
        "content": "    # this is static, not dynamic.\n    # we can make this 'standard bpm spans' into a generator instead.\n    standard_bpm_spans = [\n        x * beat_duration\n        for x in range(0, math.ceil(maxtime / beat_duration) + 1)\n        if x * beat_duration >= mintime * mbeat_time_tolerance\n        and x * beat_duration <= maxtime / mbeat_time_tolerance\n    ]\n    (\n        sorted_lyrics_nearby_bpm_candidates,\n        sorted_remained_bpm_candidates,\n    ) = getLyricNearbyBpmCandidates(lyric_times, beats)\n    candidates = sorted_lyrics_nearby_bpm_candidates + sorted_remained_bpm_candidates\n    return candidates, standard_bpm_spans\n# musictoolbox\ndef getMusicCutSpans(\n    music,\n    music_duration,\n    lyric_path,\n    maxtime,\n    mintime,\n    mbeat_time_tolerance=0.8,\n    gaussian=False,\n    gaussian_args={\"std\": 1.6674874515595588, \"mean\": 2.839698412698412},\n):\n    assert mintime > 0\n    assert maxtime > mintime\n    candidates, standard_bpm_spans = getMusicCutSpansCandidates(\n        music,\n        lyric_path,\n        maxtime,",
        "type": "code",
        "location": "/pyjom/musictoolbox.py:70-104"
    },
    "1053": {
        "file_id": 93,
        "content": "This code generates bpm spans for music and lyrics, considering a certain beat duration. It takes in music, maximum and minimum time values, lyric path, and optional parameters like mbeat_time_tolerance, gaussian function arguments. The code first calculates the standard bpm spans based on the given parameters. Then it calls getLyricNearbyBpmCandidates to get sorted nearby bpm candidates from lyrics. It combines all bpm candidates and returns them along with the calculated standard bpm spans.",
        "type": "comment"
    },
    "1054": {
        "file_id": 93,
        "content": "        mintime,\n        mbeat_time_tolerance=mbeat_time_tolerance,\n    )\n    assert len(standard_bpm_spans) >= 1\n    if gaussian:\n        from lazero.utils.mathlib import getTruncatedNormalDistribution\n        std, mean = gaussian_args[\"std\"], gaussian_args[\"mean\"]\n        # scale, loc = std, mean\n        myStart, myEnd = mintime, maxtime\n        randomFunction = getTruncatedNormalDistribution(std, mean, myStart, myEnd)\n        # myclip_a, myclip_b = mintime, maxtime\n        # from scipy.stats import truncnorm\n        # a, b = (myclip_a - loc) / scale, (myclip_b - loc) / scale\n        # randVar = truncnorm(a, b)\n        # randomFunction = lambda: randVar.rvs(1)[0] * scale + loc\n    # now we engage with the cue points.\n    demanded_cut_points = [0]\n    # startingPoint=0\n    remaining_time = music_duration\n    counter = 0\n    oldCandidateLength = None\n    while True:\n        if gaussian:\n            standard_bpm_span_min_selected = randomFunction()\n            doubleRate = max(min(2, maxtime / standard_bpm_span_min_selected), 1)",
        "type": "code",
        "location": "/pyjom/musictoolbox.py:105-133"
    },
    "1055": {
        "file_id": 93,
        "content": "This code calculates the minimum and maximum time boundaries for a piece of music. If the gaussian parameter is set, it uses a truncated normal distribution to randomly select a standard BPM span within the specified time range. The code then processes cue points based on this selected standard BPM span, possibly adjusting the rate or creating cut points.",
        "type": "comment"
    },
    "1056": {
        "file_id": 93,
        "content": "        elif len(standard_bpm_spans) == 1:\n            standard_bpm_span_min_selected = standard_bpm_spans[0]\n            doubleRate = 1.2\n        else:\n            standard_bpm_span_min_selected = random.choice(standard_bpm_spans[:-1])\n            doubleRate = max(1, min(2, maxtime / standard_bpm_span_min_selected))\n        if counter > 10000:  # some dangerous deadloop.\n            breakpoint()\n            print(\"LOOPCOUNT\", counter)\n            print(len(demanded_cut_points), remaining_time, standard_bpm_spans[0])\n        counter += 1\n        startingPoint = demanded_cut_points[-1]\n        # try:\n        selected_candidates = [\n            x for x in candidates if x > startingPoint\n        ]  # unsupported comparation between 'float' and 'list'?\n        # except:\n        #     import traceback\n        #     traceback.print_exc()\n        #     breakpoint()\n        newCandidateLength = len(selected_candidates)\n        if newCandidateLength == 0:\n            # nothing left.\n            break\n        if oldCandidateLength is None:",
        "type": "code",
        "location": "/pyjom/musictoolbox.py:134-158"
    },
    "1057": {
        "file_id": 93,
        "content": "Code selects a minimum BPM span for music processing based on the number of available options. If there's only one option, it is selected with a double rate (1.2x). If multiple options exist, it randomly selects from all but the last option and calculates the corresponding double rate. The code also checks for an excessive loop count to prevent potential deadlocks and increments a counter for tracking purposes. It then selects candidates greater than the previous cut point and continues processing if any candidates remain.",
        "type": "comment"
    },
    "1058": {
        "file_id": 93,
        "content": "            oldCandidateLength = newCandidateLength\n        else:\n            if (\n                oldCandidateLength == newCandidateLength\n            ):  # force append those points without progress\n                # demanded_cut_points.append(selected_candidates) # this is wrong.\n                demanded_cut_points.append(selected_candidates[0])\n                # no need to update the oldCandidateLength since it is the same as the new\n                continue\n            else:\n                oldCandidateLength = newCandidateLength\n        for elem in selected_candidates:\n            timespan_length = elem - startingPoint\n            if inRange(\n                timespan_length,\n                (\n                    standard_bpm_span_min_selected,\n                    standard_bpm_span_min_selected * doubleRate,\n                ),\n                tolerance=mbeat_time_tolerance,\n            ):\n                # select this element.\n                demanded_cut_points.append(elem)\n                break\n        remaining_time = music_duration - demanded_cut_points[-1]",
        "type": "code",
        "location": "/pyjom/musictoolbox.py:159-184"
    },
    "1059": {
        "file_id": 93,
        "content": "This code segment compares the old and new candidate lengths, appending selected points to demanded_cut_points based on a specified range of timespan lengths. It also updates oldCandidateLength and checks for remaining time after adding points.",
        "type": "comment"
    },
    "1060": {
        "file_id": 93,
        "content": "        if remaining_time < standard_bpm_span_min_selected:\n            break\n    demanded_cut_points = list(set(demanded_cut_points))\n    demanded_cut_points.sort()\n    for elem in demanded_cut_points.copy()[::-1]:\n        if music_duration - elem < standard_bpm_spans[0]:\n            demanded_cut_points.remove(elem)\n    demanded_cut_points.append(music_duration)\n    demanded_cut_spans = list(zip(demanded_cut_points[0:-1], demanded_cut_points[1:]))\n    # somehow it was wrong.\n    # print(\"DEMANDED MUSIC CUT SPANS GENERATED\")\n    # breakpoint()\n    return demanded_cut_spans, standard_bpm_spans\n# musictoolbox\n# fix long loading time.\n@redisLRUCache()\ndef getMusicInfoParsed(config, mintime=2, maxtime=7.8):  # these are defaults.\n    music = config[\"music\"]\n    gaussian = config.get(\n        \"gaussian\", True\n    )  # this is different. default to use gaussian instead.\n    # check if music is corrupted?\n    font = config.get(\"font\", None)\n    policy = config.get(\"policy\", {})\n    policy_names = [x for x in policy.keys()]",
        "type": "code",
        "location": "/pyjom/musictoolbox.py:185-212"
    },
    "1061": {
        "file_id": 93,
        "content": "The code segment checks if there is enough remaining time for the standard BPM spans. It removes unnecessary cut points, appends the music duration as a cut point, and generates the demanded music cut spans list. The function `getMusicInfoParsed` retrieves music information with optional configuration parameters for font, gaussian usage, policy, and defaults if not specified.",
        "type": "comment"
    },
    "1062": {
        "file_id": 93,
        "content": "    # get music duration here.\n    music_metadata = get_media_info(music[\"filepath\"])\n    music_duration = music_metadata[\"duration\"]\n    maxtime = config.get(\"maxtime\", maxtime)\n    mintime = config.get(\"mintime\", mintime)\n    lyric_path = music.get(\"lyric_path\", None)\n    if type(lyric_path) == str:\n        if not os.path.exists(lyric_path):\n            lyric_path = None\n    elif lyric_path is not None:\n        lyric_path = None\n    demanded_cut_spans, standard_bpm_spans = getMusicCutSpans(\n        music, music_duration, lyric_path, maxtime, mintime, gaussian=gaussian\n    )\n    return (\n        music,\n        font,\n        policy,\n        policy_names,\n        music_metadata,\n        music_duration,\n        maxtime,\n        mintime,\n        lyric_path,\n        demanded_cut_spans,\n        standard_bpm_spans,\n    )\n# for midomi we need to chop music apart.\n# for shazam, nope.\n# shazamio needs event loop. be careful!\nfrom typing import Literal\nimport subprocess\nimport traceback\nfrom lazero.program.subprocess import runCommandGetJson",
        "type": "code",
        "location": "/pyjom/musictoolbox.py:213-249"
    },
    "1063": {
        "file_id": 93,
        "content": "This code retrieves music metadata, including duration and lyric path. It then checks if the lyric path exists and updates it accordingly. The function `getMusicCutSpans` is called to obtain demanded cut spans and standard BPM spans for certain use cases like midomi, shazam, or shazamio. It imports necessary types and libraries for processing music information.",
        "type": "comment"
    },
    "1064": {
        "file_id": 93,
        "content": "def runCommandAndProcessSongRecognizationJson(\n    commandLine: list[str],\n    processMethod: FunctionType,\n    raw_data: bool = False,\n    debug: bool = False,\n    timeout: int = 5,\n    workingDirectory: Union[None, str] = None,\n):\n    success, data = runCommandGetJson(\n        commandLine, debug=debug, timeout=timeout, workingDirectory=workingDirectory\n    )\n    if success:\n        if not raw_data:\n            # more processing. may alter the success flag.\n            try:\n                data = processMethod(data)\n            except:\n                success = False\n                if debug:\n                    traceback.print_exc()\n    return success, data\ndef shazamSongRecognizationResultProcessMethod(data):\n    artist = data[\"track\"][\"subtitle\"]\n    trackName = data[\"track\"][\"title\"]\n    data = {\"artist\": artist, \"trackName\": trackName}\n    return data\n# you can choose to return raw data or not. which is the raw json data.\ndef recognizeMusicFromFileSongrec(filepath, raw_data=False, timeout=6, debug=False):\n    commandLine = [\"songrec\", \"audio-file-to-recognized-song\", filepath]",
        "type": "code",
        "location": "/pyjom/musictoolbox.py:252-284"
    },
    "1065": {
        "file_id": 93,
        "content": "The function `runCommandAndProcessSongRecognizationJson` takes a command line, processing method, and optional parameters, then runs the command, processes the resulting JSON data, and returns success and processed data. The `shazamSongRecognizationResultProcessMethod` extracts artist and track name from the Shazam API's JSON response for song recognition. The `recognizeMusicFromFileSongrec` function calls the previous functions to recognize music from a filepath, providing optional raw data output and timeout settings.",
        "type": "comment"
    },
    "1066": {
        "file_id": 93,
        "content": "    return runCommandAndProcessSongRecognizationJson(\n        commandLine,\n        shazamSongRecognizationResultProcessMethod,\n        raw_data=raw_data,\n        debug=debug,\n        timeout=timeout,\n    )\ndef recognizeMusicFromFileShazamIO(\n    filepath, raw_data=False, timeout=20, debug: bool = False\n):\n    # how to timeout this shit? use subprocess again?\n    # maybe yes.\n    commandLine = [\n        \"python3\",\n        \"/root/Desktop/works/pyjom/tests/soundhound_houndify_midomi_sound_recognize_music/shazamio_recognize_music.py\",\n        \"--file\",\n        filepath,\n    ]\n    return runCommandAndProcessSongRecognizationJson(\n        commandLine,\n        shazamSongRecognizationResultProcessMethod,\n        raw_data=raw_data,\n        debug=debug,\n        timeout=timeout,\n    )\ndef midomiSongRecognizationResultProcessMethod(data):\n    trackData = data[\"AllResults\"][0][\"NativeData\"][\"Tracks\"][0]\n    artist = trackData[\"ArtistName\"]\n    trackName = trackData[\"TrackName\"]\n    data = {\"artist\": artist, \"trackName\": trackName}",
        "type": "code",
        "location": "/pyjom/musictoolbox.py:285-318"
    },
    "1067": {
        "file_id": 93,
        "content": "This code uses the ShazamIO library to recognize music from a file. It takes the file path, optional raw data flag, timeout value, and debug mode as inputs. It runs a command line using subprocess to execute the shazamio_recognize_music.py script with the specified file path. The function returns the processed song recognition JSON result using the shazamSongRecognizationResultProcessMethod.",
        "type": "comment"
    },
    "1068": {
        "file_id": 93,
        "content": "    return data\n# what is the correct timeout for this one?\nfrom lazero.filesystem.temp import tmpfile, getRandomFileNameUnderDirectoryWithExtension\ndef recognizeMusicFromFileMidomi(\n    filepath,\n    raw_data=False,\n    timeout=10,\n    debug: bool = False,\n    maxRetry=3,\n    segmentLength: int = 10,\n    extension: Union[str, None] = None,\n):  # this one is different. maybe we can wait.\n    success, data = False, {}\n    if extension == None:\n        extension = \"\"\n        splitedFilePath = os.path.basename(filepath).split(\".\")\n        if len(splitedFilePath) > 1:\n            extension = splitedFilePath[-1]\n    if len(extension) == 0:\n        extension = \"mp3\"\n    musicLength = getAudioDuration(filepath)\n    needSegment = musicLength > segmentLength\n    if not needSegment:\n        maxRetry = 1\n    for index in range(maxRetry):\n        if debug:\n            print(\"trial {} for midomi\".format(index + 1))\n        segmentName = getRandomFileNameUnderDirectoryWithExtension(\n            extension, \"/dev/shm\"\n        )\n        with tmpfile(segmentName):",
        "type": "code",
        "location": "/pyjom/musictoolbox.py:319-354"
    },
    "1069": {
        "file_id": 93,
        "content": "This function recognizes music from a given file using Midomi API. It accepts the file path, optional raw data flag, timeout value, debug mode, maximum number of retries, segment length, and extension type as parameters. The function generates a random temporary file name, extracts the audio duration, segments the audio if necessary based on length, and performs the recognition for the specified number of retries. If in debug mode, it prints the trial number for Midomi API calls.",
        "type": "comment"
    },
    "1070": {
        "file_id": 93,
        "content": "            if needSegment:\n                start = random.uniform(0, musicLength - segmentLength)\n                end = start + segmentLength\n                ffmpeg.input(filepath, ss=start, to=end).output(segmentName).run(\n                    overwrite_output=True\n                )\n            else:\n                pathlib.Path(segmentName).touch()\n                segmentName = filepath\n            # you will change to given directory, will you?\n            commandLine = [\"npx\", \"ts-node\", \"midomi_music_recognize.ts\", segmentName]\n            success, data = runCommandAndProcessSongRecognizationJson(\n                commandLine,\n                midomiSongRecognizationResultProcessMethod,\n                raw_data=raw_data,\n                debug=debug,\n                timeout=timeout,\n                workingDirectory=\"/root/Desktop/works/pyjom/tests/music_recognization/AmadeusCore\",\n            )\n        if success:\n            break\n    return success, data\ndef recognizeMusicFromFile(\n    filepath,\n    backend: Literal[\"songrec\", \"shazamio\", \"midomi\", None] = None,",
        "type": "code",
        "location": "/pyjom/musictoolbox.py:355-381"
    },
    "1071": {
        "file_id": 93,
        "content": "This code segment is responsible for recognizing music from a given file using different backends. It first checks if there is a need to segment the audio and then uses FFmpeg to extract a segment or touches an existing file as the input. Next, it runs a command line with various arguments including the input file, backend type, raw data, debug mode, timeout, and working directory. The function returns success status and processed data if successful, otherwise continues trying with different backends until success is achieved.",
        "type": "comment"
    },
    "1072": {
        "file_id": 93,
        "content": "    raw_data=False,\n    debug=False,\n):  # if not returning raw_data, only track data and artist data are returned.\n    assert os.path.exists(filepath)\n    # if returning raw_data, must also return the provider name, for easy parsing.\n    # you can try all methods. but if all three methods fails, you know what to do. what indicates the recognizer has failed?\n    # you can try something erotic.\n    if backend is None:  # auto\n        musicDuration = getAudioDuration(filepath)\n        if musicDuration <= 15:\n            backend = \"midomi\"\n        else:\n            backend = \"songrec\"\n    methods = {\n        \"midomi\": recognizeMusicFromFileMidomi,\n        \"songrec\": recognizeMusicFromFileSongrec,\n        \"shazamio\": recognizeMusicFromFileShazamIO,\n    }\n    keys = list(methods.keys())\n    keys.sort(key=lambda x: -int(x == backend))\n    for key in keys:\n        method = methods[key]\n        success, data = method(filepath, debug=debug)\n        if debug:\n            print(\"DATA:\")\n            print(data)\n            print(\"RETURN FROM MUSIC RECOGNIZE METHOD: %s\" % key)",
        "type": "code",
        "location": "/pyjom/musictoolbox.py:382-408"
    },
    "1073": {
        "file_id": 93,
        "content": "This function uses a series of methods to recognize music from a file and returns track data, artist data, and raw data if specified. It checks the duration of the audio file and chooses the appropriate method (midomi, songrec, or shazamio) based on the duration. If no backend is specified, it automatically selects the best method for the given file duration. The code also prints debug information if requested.",
        "type": "comment"
    },
    "1074": {
        "file_id": 93,
        "content": "            print(\"SUCCESS:\", success)\n        if success:\n            if raw_data:\n                return success, data, key\n            else:\n                return success, data\n        if debug:\n            break  # no retry then.\n    if raw_data:\n        return False, {}, \"\"\n    return False, {}\n############ SEARCH NETEASE MUSIC, GET SIMILAR MUSIC BY ID, DOWNLOAD MUSIC AND LYRICS ############\nimport requests\nfrom lazero.program.functools import suppressException\nclass neteaseMusic:\n    def __init__(self, port: int = 4042):\n        self.baseUrl = \"http://localhost:{}\".format(port)\n    def verifyResponseCodeAndGetJson(\n        self, response, debug: bool = False, success_codes: list[int] = [200]\n    ):\n        response_json = response.json()  # check search_result.json\n        if success_codes != []:\n            code = response_json[\"code\"]\n            if not code in success_codes:\n                if debug:\n                    print(response_json)\n                import traceback\n                traceback.print_exc()",
        "type": "code",
        "location": "/pyjom/musictoolbox.py:409-443"
    },
    "1075": {
        "file_id": 93,
        "content": "Imports necessary libraries and defines a class for interacting with Netease Music. The class has a constructor to set the port, and methods to search music, get similar music by ID, download music and lyrics. It also handles exceptions and checks response codes.",
        "type": "comment"
    },
    "1076": {
        "file_id": 93,
        "content": "                raise Exception(\"ERROR CODE IN NETEASE API RESPONSE:\", code)\n        return response_json\n    def requestWithParamsGetJson(\n        self,\n        suffix: str,\n        params: dict = {},\n        debug: bool = False,\n        success_codes: list[int] = [200],\n        refresh: bool = False,\n    ):\n        if refresh:\n            params.update({\"timestamp\": getJSTimeStamp()})\n        suffix = suffix.strip()\n        if not suffix.startswith(\"/\"):\n            suffix = \"/\" + suffix\n        link = self.baseUrl + suffix\n        result = requests.get(link, params=params)\n        result_json = self.verifyResponseCodeAndGetJson(\n            result, debug=debug, success_codes=success_codes\n        )\n        return result_json\n    @suppressException(tries=2, defaultReturn={})\n    def searchNeteaseMusicByQuery(\n        self, query: Union[list, str], debug: bool = False, refresh: bool = False\n    ):\n        if type(query) == str:\n            query = query.strip()\n        else:\n            query = [elem.strip() for elem in query]",
        "type": "code",
        "location": "/pyjom/musictoolbox.py:444-474"
    },
    "1077": {
        "file_id": 93,
        "content": "This code defines a class method to request data from a Netease API using GET requests and handle the response. It takes parameters like suffix, query, debug flag, success codes, and refresh flag. The method handles refreshing timestamps if needed, constructs the URL, makes a GET request with the parameters, verifies the response code, and returns the JSON data or raises an exception if an error occurs.",
        "type": "comment"
    },
    "1078": {
        "file_id": 93,
        "content": "            query = \" \".join([elem for elem in query if len(elem) > 0])\n        assert len(query) > 0\n        search_result_json = self.requestWithParamsGetJson(\n            \"/search\",\n            params={\"keywords\": query},\n            debug=debug,\n            refresh=refresh,\n        )\n        return search_result_json\n    @suppressException(defaultReturn=[])\n    def getSimilarMusicByIdFromNetease(\n        self, music_id: int, debug: bool = False, refresh: bool = False\n    ):\n        r_json = self.requestWithParamsGetJson(\n            \"/simi/song\", params={\"id\": music_id}, debug=debug, refresh=refresh\n        )\n        song_ids = []\n        for song in r_json[\"songs\"]:\n            name = song[\"name\"]\n            song_id = song[\"id\"]\n            song_ids.append(song_id)\n            # what you want?\n        return song_ids\n    @suppressException()\n    def getMusicUrlFromNetease(\n        self, music_id: int, debug: bool = False, refresh: bool = False\n    ):\n        r_json = self.requestWithParamsGetJson(\n            \"/song/url\", params={\"id\": music_id}, debug=debug, refresh=refresh",
        "type": "code",
        "location": "/pyjom/musictoolbox.py:475-505"
    },
    "1079": {
        "file_id": 93,
        "content": "The code contains functions to search and retrieve similar music by ID, as well as fetching the URL of a specific song from the Netease API. It makes requests with parameters, handles exceptions, and returns search results or song IDs.",
        "type": "comment"
    },
    "1080": {
        "file_id": 93,
        "content": "        )  # this song might expire. warning!\n        # expire in a few seconds.\n        url = r_json[\"data\"][0].get(\"url\", None)\n        return url  # you may test this url. later.\n    @suppressException(defaultReturn=False)\n    def checkMusicFromNetEase(\n        self, music_id: int, debug: bool = False, refresh: bool = False\n    ):\n        # {\n        #   \"success\": true,\n        #   \"message\": \"ok\"\n        # }\n        # no need to check the return code.\n        r_json = self.requestWithParamsGetJson(\n            \"check/music\",\n            params={\"id\": music_id},\n            debug=debug,\n            refresh=refresh,\n            success_codes=[],\n        )\n        assert r_json[\"success\"] == True\n        assert r_json[\"message\"] == \"ok\"\n        return True\n    @suppressException()\n    def getMusicLyricFromNetease(\n        self,\n        music_id: int,\n        debug: bool = False,\n        refresh: bool = False,\n        minLyricStringLength: int = 50,\n    ):\n        r_json = self.requestWithParamsGetJson(\n            \"/lyric\",",
        "type": "code",
        "location": "/pyjom/musictoolbox.py:506-540"
    },
    "1081": {
        "file_id": 93,
        "content": "The code defines two functions: `checkMusicFromNetEase` and `getMusicLyricFromNetease`. The first function checks if a music URL exists by sending a GET request to the \"check/music\" endpoint with the given music ID. It returns True if the response is successful. The second function retrieves the lyrics of the specified music ID from the \"/lyric\" endpoint and raises exceptions for errors. Both functions use the `requestWithParamsGetJson` method, which sends a GET request to an endpoint, receives JSON data, and handles success codes or exceptions based on parameters provided.",
        "type": "comment"
    },
    "1082": {
        "file_id": 93,
        "content": "            params={\"id\": music_id},\n            debug=debug,\n            refresh=refresh,\n        )\n        # warning: the fetched lrc could be not so clean. clean it somehow!\n        lyric_string = r_json[\"lrc\"][\"lyric\"]\n        if lyric_string != None and type(lyric_string) == str:\n            if len(lyric_string) > minLyricStringLength:\n                return lyric_string\n    @suppressException(tries=2, defaultReturn=((None, None), None))\n    def getMusicAndLyricWithKeywords(\n        self,\n        keywords: str,\n        similar: bool = False,\n        debug: bool = False,\n        min_audio_length: float = 2 * 60,\n        max_audio_length: float = 5 * 60\n    ):  # minimum 2.5 minutes of music.\n        import pyjq\n        # store the downloaded file in some place please?\n        search_data_json = self.searchNeteaseMusicByQuery(keywords, debug=debug)\n        # print(search_data_json)\n        song_ids = pyjq.all(\n            \".result.songs[] | select (.id !=null) | .id\", search_data_json\n        )  # incorrect. use pyjq.all",
        "type": "code",
        "location": "/pyjom/musictoolbox.py:541-567"
    },
    "1083": {
        "file_id": 93,
        "content": "This code defines a function that searches for music and its corresponding lyrics using keywords. It also includes error suppression and checks if the downloaded file is stored or not. The function takes in parameters such as keywords, similarity flag, debug mode, minimum and maximum audio lengths. It uses Pyjq to query the music data and extracts song IDs from the search results.",
        "type": "comment"
    },
    "1084": {
        "file_id": 93,
        "content": "        # print(song_ids)\n        # breakpoint()\n        song_id = random.choice(song_ids)\n        # how to parse this shit?\n        if similar:\n            similar_song_ids = self.getSimilarMusicByIdFromNetease(song_id, debug=debug)\n            song_id = random.choice(similar_song_ids)\n        # now download the music.\n        music_url = self.getMusicUrlFromNetease(song_id, debug=debug, refresh=True)\n        # download the music right now.\n        r = requests.get(music_url)\n        if debug:\n            print(\"download music status code:\", r.status_code)\n        assert r.status_code == 200  # are you sure the code is ok?\n        music_format = music_url.split(\".\")[-1]\n        music_content = r.content\n        # how to get song duration?\n        import tempfile\n        with tempfile.NamedTemporaryFile(\n            mode=\"wb\", suffix=\".{}\".format(music_format)\n        ) as f:\n            name = f.name\n            name = os.path.abspath(name)\n            f.write(music_content)\n            song_duration = getAudioDuration(name)",
        "type": "code",
        "location": "/pyjom/musictoolbox.py:568-594"
    },
    "1085": {
        "file_id": 93,
        "content": "This code randomly selects a song, if similar music is specified, it chooses one from the similar list. It then downloads the selected music and stores it temporarily for later use. The song duration is determined using a helper function.",
        "type": "comment"
    },
    "1086": {
        "file_id": 93,
        "content": "        if song_duration < min_audio_length:\n            raise Exception(\"audio too short, total {} seconds\".format(song_duration))\n        elif song_duration > max_audio_length:\n            raise Exception(\"audio too long, total {} seconds\".format(song_duration))\n        lyric_string = self.getMusicLyricFromNetease(song_id)\n        if debug:\n            print(\"LYRICS:\", lyric_string)\n        if type(lyric_string) ==str and lyric_string.strip() !=\"\":\n            from pyjom.lyrictoolbox import (\n                cleanLrcFromWeb,\n            )  # cleaning needs song duration.\n            lyric_string = cleanLrcFromWeb(lyric_string, song_duration)\n        return (music_content, music_format), lyric_string\n############ SEARCH NETEASE MUSIC, GET SIMILAR MUSIC BY ID, DOWNLOAD MUSIC AND LYRICS ############",
        "type": "code",
        "location": "/pyjom/musictoolbox.py:595-611"
    },
    "1087": {
        "file_id": 93,
        "content": "This code checks the song duration against specified minimum and maximum audio lengths, raises exceptions if necessary, retrieves lyrics from Netease using getMusicLyricFromNetease method, prints or logs the lyric string if in debug mode, checks if the lyric string is a non-empty string, cleans the LRC from web by calling cleanLrcFromWeb function and passing song duration as argument, and returns music content, format, and cleaned lyrics.",
        "type": "comment"
    },
    "1088": {
        "file_id": 94,
        "content": "/pyjom/platforms/bilibili/credentials.py",
        "type": "filepath"
    },
    "1089": {
        "file_id": 94,
        "content": "The code handles bilibili login/logout, stores credentials in TinyDB, verifies them and provides functions for SMS-based credential input/removal. It uses a decorator `bilibiliCredential` that retrieves user credentials and wraps function calls with them.",
        "type": "summary"
    },
    "1090": {
        "file_id": 94,
        "content": "# you need to manage login/logout and credential storage.\n# first you need to get 'home' directory\nfrom lazero.search.api import getHomeDirectory\nimport os\nfrom bilibili_api import sync, Credential\nfrom bilibili_api.user import get_self_info\nfrom bilibili_api import settings\nfrom bilibili_api.login import (\n    # login_with_password,\n    login_with_sms,\n    send_sms,\n    PhoneNumber,\n    # Check,\n)\nsettings.geetest_auto_open = False\nhome = getHomeDirectory()\ndbPath = os.path.join(home, \".bilibili_api.json\")\nimport tinydb\ndb = tinydb.TinyDB(dbPath)  # is this variable shared in this module?\nUser = tinydb.Query()\ndef verifyCredential(credential, returnName=True):\n    try:\n        name = sync(get_self_info(credential))[\"name\"]\n        print(\"credential is valid for:\", name)\n        db.upsert(\n            {\n                \"name\": name,  # does not show up in credential.\n                \"dedeuserid\": credential.dedeuserid,\n                \"bili_jct\": credential.bili_jct,\n                \"buvid3\": credential.buvid3,\n                \"sessdata\": credential.sessdata,",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/credentials.py:2-38"
    },
    "1091": {
        "file_id": 94,
        "content": "The code manages login/logout and credential storage for the Bilibili API. It retrieves the 'home' directory, creates a TinyDB instance at the specified path to store user credentials, and provides a function `verifyCredential` to check if a given credential is valid. The code also sets geetest_auto_open to False and imports necessary modules for Bilibili API interaction.",
        "type": "comment"
    },
    "1092": {
        "file_id": 94,
        "content": "            },\n            User.dedeuserid == credential.dedeuserid,\n        )\n        if returnName:\n            return name\n        else:\n            return True\n    except:\n        import traceback\n        traceback.print_exc()\n        print(\"invalid credential:\", credential)\n        return False\ndef removeCredentialByDedeUserId(dedeuserid: str):\n    try:\n        db.remove(User.dedeuserid == dedeuserid)\n        return True\n    except:\n        import traceback\n        traceback.print_exc()\n        print(\n            \"error when removing credential from database for dedeuserid:\", dedeuserid\n        )\n        return False\n# from lazero.program.functools import skipException\nfrom lazero.program.functools import suppressException\n# @skipException(defaultReturn = None, breakpoint_flag=True, debug_flag=True, global_variables=globals(), local_variables=locals()) # send_sms is not definded here. WTF?\n@suppressException(defaultReturn=None, showException=True)  # trycatch based.\ndef getCredentialViaSMS():\n    phone = input(\"请输入手机号：\")",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/credentials.py:39-74"
    },
    "1093": {
        "file_id": 94,
        "content": "The code is a Python implementation for managing bilibili credentials. The `getCredentialViaSMS` function allows users to input their phone number and retrieves the corresponding credential via SMS verification. The `removeCredentialByDedeUserId` function removes a credential from the database based on the provided dedeuserid. Both functions handle exceptions using try-except blocks, providing error messages and returning False if any errors occur during execution.",
        "type": "comment"
    },
    "1094": {
        "file_id": 94,
        "content": "    print(\"正在登录。\")\n    send_sms(PhoneNumber(phone, country=\"+86\"))  # 默认设置地区为中国大陆\n    code = input(\"请输入验证码：\")\n    c = login_with_sms(PhoneNumber(phone, country=\"+86\"), code)\n    credential = c\n    # first, check if this is a valid credential.\n    name = verifyCredential(credential)\n    return credential, name\ndef getCredentialByDedeUserId(dedeuserid: str = \"397424026\"):\n    dataList = db.search(User.dedeuserid == dedeuserid)\n    if len(dataList) != 1:\n        if len(dataList) != 0:\n            # remove all related records.\n            print(\"multiple credentials found for dedeuserid:\", dedeuserid)\n            removeCredentialByDedeUserId(dedeuserid)\n        else:\n            print(\"no credential found for dedeuserid:\", dedeuserid)\n    else:\n        # check validity.\n        data = dataList[0].copy()\n        print(\"try to login credential fetched from db:\", data)\n        oldName = data.pop(\"name\")\n        print(\"previous name:\", oldName)\n        credential = Credential(**data)\n        name = verifyCredential(credential)",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/credentials.py:75-101"
    },
    "1095": {
        "file_id": 94,
        "content": "The code is responsible for logging in to a Bilibili account and retrieving the user's credentials. It first attempts to log in using an SMS verification code, then checks if the provided credential is valid by verifying it with the database. The function `getCredentialByDedeUserId` allows fetching credentials based on the given dedeuserid. If multiple or no credentials are found for the specified id, appropriate error messages are printed and potentially irrelevant records are removed from the database.",
        "type": "comment"
    },
    "1096": {
        "file_id": 94,
        "content": "        if name != False:\n            print(\"login successful:\", name)\n            return credential\n        else:\n            print(\"login failed with existing credential for user:\", oldName)\n            removeCredentialByDedeUserId(\n                dedeuserid\n            )  # warning. my credential has been removed because of that async problem. please relogin.\n    # anyway if you are here, nothing in database related to this dedeuserid now.\n    # you choose to login via SMS.\n    while True:\n        # could be troublesome.\n        result = getCredentialViaSMS()\n        if result != None:  # has type check here?\n            credential, name = result\n            if name != False:\n                print(\"登录成功\")\n                # update with this credential!\n                # next, check if this is the credential we need.\n                if credential.dedeuserid == dedeuserid:\n                    return credential\n                else:\n                    print(\"dedeuserid not right.\")\n                    print(",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/credentials.py:102-125"
    },
    "1097": {
        "file_id": 94,
        "content": "The code checks if the provided name is not False and prints \"login successful\" along with the name. If the name is False, it prints a failed login message and removes the existing credential associated with the user. The code then allows the user to log in via SMS. It retrieves the credential from SMS and checks if the dedeuserid matches the desired value. If it does, the credential is returned; otherwise, a message is printed indicating that the dedeuserid is incorrect.",
        "type": "comment"
    },
    "1098": {
        "file_id": 94,
        "content": "                        \"user %s (dedeuserid: %s) does not have dedeuserid: %s\"\n                        % (name, credential.dedeuserid, dedeuserid)\n                    )\n        else:\n            print(\"登陆失败\")\ndef bilibiliCredential(func):\n    def wrapper(*args, dedeuserid=\"397424026\", **kwargs):\n        credential = getCredentialByDedeUserId(dedeuserid)\n        if type(kwargs) != dict:\n            kwargs = {}\n        return func(*args, **(kwargs | {'credential': credential}))\n    return wrapper",
        "type": "code",
        "location": "/pyjom/platforms/bilibili/credentials.py:126-140"
    },
    "1099": {
        "file_id": 94,
        "content": "The code defines a decorator called `bilibiliCredential` that takes a function as input and returns a new function wrapper. The wrapper retrieves the credentials for a specific `dedeuserid`, and if the user exists, it passes the function call with the credential as an argument. If the keyword arguments are not of type dictionary, it converts them into an empty dictionary.",
        "type": "comment"
    }
}