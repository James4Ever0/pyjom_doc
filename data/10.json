{
    "1000": {
        "file_id": 76,
        "content": "    stepframes = []\n    for _ in progressbar.progressbar(range(frames)):\n        ret, frame = cap.read()\n        if type(frame) != np.ndarray:\n            # most likely no thing shown.\n            break\n        timecode = float(frameIndex / fps)\n        if (frameIndex % frameStep) == 0:\n            # what is this shit?\n            # print(\"frame:\",type(frame))\n            # will be replaced!\n            stepframes.append(copy.deepcopy(frame))\n            if len(stepframes) == framebatch:\n                data = data_producer(\n                    *stepframes\n                )  # usually we treat frames differently?\n                stepframes.pop(0)\n                # this is part of paddleocr.\n                mdata.append(\n                    {\n                        \"time\": timecode,\n                        \"frame\": frameIndex,\n                        keyword: copy.deepcopy(data),\n                    }\n                )\n        frameIndex += 1\n    # result[\"subtitle_result\"][\"paddleocr\"] = mdata\n    cap.release()\n    metadata = {\"fps\": float(fps), \"timestep\": timestep, \"framebatch\": framebatch}",
        "type": "code",
        "location": "/pyjom/medialang/functions/detectors/mediaDetector.py:32-60"
    },
    "1001": {
        "file_id": 76,
        "content": "This code reads frames from a video and processes them in batches using the paddleocr library. It stores metadata such as frame index, timecode, and resulting data for each processed batch. The loop stops when no object is detected or it reaches the end of the video. Finally, the captured metadata and the result are returned.",
        "type": "comment"
    },
    "1002": {
        "file_id": 76,
        "content": "    return mdata, metadata",
        "type": "code",
        "location": "/pyjom/medialang/functions/detectors/mediaDetector.py:61-61"
    },
    "1003": {
        "file_id": 76,
        "content": "This line of code is returning two variables, `mdata` and `metadata`, after the function's processing.",
        "type": "comment"
    },
    "1004": {
        "file_id": 77,
        "content": "/pyjom/medialang/functions/detectors/yolov5_Detector.py",
        "type": "filepath"
    },
    "1005": {
        "file_id": 77,
        "content": "The code introduces two functions, `yolov5_Identifier` and `yolov5_Detector`, which utilize the YOLOv5 model for object detection and identification. The functions apply the model to input frames and media paths at set intervals, storing and returning results with specified configurations.",
        "type": "summary"
    },
    "1006": {
        "file_id": 77,
        "content": "from .mediaDetector import *\n# assume you not to run many instances at once?\n# how to identify same video in a sequence?\ndef yolov5_Identifier(frame, threshold=0.4,model = \"yolov5s\"):\n    model = configYolov5(model=model)\n    # assert to be read from opencv2\n    img = cv2_HWC2CHW(frame)\n    results = model(img) # pass the image through our model\n    df = results.pandas().xyxy[0]\n    # print(df)\n    data = []\n    for _, line in df.iterrows():\n        left = (line[\"xmin\"],line[\"ymin\"])\n        right = (line[\"xmax\"],line[\"ymax\"])\n        confidence = line[\"confidence\"]\n        if confidence < threshold:\n            continue # skipping threshold too low.\n        class_ = line[\"class\"]\n        name = line[\"name\"]\n        data.append({\"location\":[left,right],\"confidence\":confidence,\"identity\":{\"class\":class_,\"name\":name}})\n    return data\ndef yolov5_Detector(mediapaths, model=\"yolov5s\", threshold=0.4, timestep=0.2):\n    # any better detectors? deeplearning?\n    results = []\n    data_key = \"yolov5\"\n    assert model i",
        "type": "code",
        "location": "/pyjom/medialang/functions/detectors/yolov5_Detector.py:1-31"
    },
    "1007": {
        "file_id": 77,
        "content": "The code defines two functions, `yolov5_Identifier` and `yolov5_Detector`, which are used for object detection and identification using the YOLOv5 model. The `yolov5_Identifier` function takes a frame as input, applies the YOLOv5 model to it, and returns the identified objects with their locations, confidences, and classes. The `yolov5_Detector` function applies the `yolov5_Identifier` function to multiple media paths at specified time intervals, storing and returning the detection results for each path.",
        "type": "comment"
    },
    "1008": {
        "file_id": 77,
        "content": "n [\"yolov5n\",\"yolov5s\",\"yolov5m\",\"yolov5l\",\"yolov5x\",\"yolov5n6\",\"yolov5s6\",\"yolov5m6\",\"yolov5l6\",\"yolov5x6\"] # increase the parameters does not sufficiently improve accuracy.\n    keyword = \"{}_detector\".format(data_key)\n    for mediapath in mediapaths:\n        print(\"mediapath:\", mediapath)\n        mediatype = getFileType(mediapath)\n        print(\"subtitle of mediatype:\", mediatype)\n        assert mediatype in [\"video\", \"image\"]  # gif? anything like that?\n        result = {\"type\": mediatype, data_key: {}}\n        config = {\"threshold\": threshold,\"model\":model}\n        if mediatype == \"image\":\n            data = cv2.imread(mediapath)\n            data = keywordDecorator(yolov5_Identifier, **config)(data)\n            result[data_key].update({keyword: data})\n            result[data_key].update({\"config\": config})\n            # results.append(result)\n        else:\n            mdata, metadata = videoFrameIterator(\n                mediapath,\n                data_producer=keywordDecorator(yolov5_Identifier, **config),",
        "type": "code",
        "location": "/pyjom/medialang/functions/detectors/yolov5_Detector.py:31-50"
    },
    "1009": {
        "file_id": 77,
        "content": "Looping through each media path, the code checks the media type (video or image) and applies YOLOv5 detection using keywordDecorator on the specified data_key. It stores the result in a dictionary and also includes the configuration used for detection.",
        "type": "comment"
    },
    "1010": {
        "file_id": 77,
        "content": "                framebatch=1,\n                timestep=timestep,\n                keyword=keyword,\n            )\n            metadata.update({\"config\": config})\n            result[data_key][keyword] = mdata\n            result[data_key].update(metadata)\n        results.append(result)\n    return results",
        "type": "code",
        "location": "/pyjom/medialang/functions/detectors/yolov5_Detector.py:51-59"
    },
    "1011": {
        "file_id": 77,
        "content": "Function is creating a data structure for YOLOv5 detector output, updating metadata with the configuration and storing it in a list.",
        "type": "comment"
    },
    "1012": {
        "file_id": 78,
        "content": "/pyjom/medialang/functions/detectors/videoDiffDetector.py",
        "type": "filepath"
    },
    "1013": {
        "file_id": 78,
        "content": "The code includes a `frameDifferential` function that computes the average or maximum difference between frames, and a `videoDiffDetector` function which calculates pixel values for each block in a video. The results are stored in a dictionary and appended to a list of results after updating metadata.",
        "type": "summary"
    },
    "1014": {
        "file_id": 78,
        "content": "from .mediaDetector import *\ndef frameDifferential(frame_a, frame_b, cut=3, absolute=True, method=\"average\"):\n    assert cut >= 1\n    # calculate average difference.\n    # you can select ROI instead.\n    # the cut is generated by the smallest side. neglect the boundary.\n    mshape = frame_a.shape\n    width, height = mshape[:2]\n    mcut = int(min(width, height) / cut)\n    result = frame_a - frame_b\n    methods = {\"average\": np.average, \"max\": np.max, \"min\": np.min}\n    # it is hard to tell where the heck does the target go. since the color difference means nothing precisely.\n    # maybe you should mark the target for us? for our training model?\n    # and again use our superduper unet? you know sometimes we get static.\n    # so use both inputs. one for static and one for motion.\n    if absolute:\n        result = np.abs(result)\n    if len(mshape) == 3:\n        result = methods[method](result, axis=2)  # just np.max\n        # i guess it is about the max value not the unified.\n    shape0 = int(width / mcut)\n    shape1 = int(height / mcut)",
        "type": "code",
        "location": "/pyjom/medialang/functions/detectors/videoDiffDetector.py:1-24"
    },
    "1015": {
        "file_id": 78,
        "content": "This code defines a function called `frameDifferential` that calculates the average difference between two frames. It takes in two frame images, a cut value to determine the size of each block, and an optional absolute parameter. The code calculates the average or maximum difference within each block, with the option to take the absolute value if necessary. The result is returned as a new image with the same shape as the input frames.",
        "type": "comment"
    },
    "1016": {
        "file_id": 78,
        "content": "    diff = np.zeros((shape0, shape1)).tolist()\n    # mapping = {}\n    for x in range(shape0):\n        for y in range(shape1):\n            diff[x][y] = float(\n                np.average(result[x * mcut : (x + 1) * mcut, y * mcut : (y + 1) * mcut])\n            )\n            # this mapping is bad.\n            # mapping.update({str((x,y)):((x*mcut,(x+1)*mcut),(y*mcut,(y+1)*mcut))})\n    return {\"diff\": diff, \"blocksize\": mcut}  # required for recovering center points.\n    # transform the frames into smaller matricies.\n    # not required all the time though.\ndef videoDiffDetector(mediapaths, cut=3, absolute=True, method=\"average\", timestep=0.2):\n    # any better detectors? deeplearning?\n    results = []\n    data_key = \"diff_result\"\n    for mediapath in mediapaths:\n        print(\"mediapath:\", mediapath)\n        mediatype = getFileType(mediapath)\n        print(\"subtitle of mediatype:\", mediatype)\n        assert mediatype in [\"video\"]  # gif? anything like that?\n        result = {\"type\": mediatype, data_key: {}}\n        config = {\"cut\": cut, \"absolute\": absolute, \"method\": method}",
        "type": "code",
        "location": "/pyjom/medialang/functions/detectors/videoDiffDetector.py:25-49"
    },
    "1017": {
        "file_id": 78,
        "content": "Code snippet defines a videoDiffDetector function that takes mediapaths as input, iterates through each path, and calculates the average pixel values of frames within each block of size mcut. The results are stored in a dictionary and returned along with the block size for recovering center points later on if needed.",
        "type": "comment"
    },
    "1018": {
        "file_id": 78,
        "content": "        keyword = \"frame_differential\"\n        mdata, metadata = videoFrameIterator(\n            mediapath,\n            data_producer=keywordDecorator(frameDifferential, **config),\n            framebatch=2,\n            timestep=timestep,\n            keyword=keyword,\n        )\n        metadata.update({\"config\": config})\n        result[data_key][keyword] = mdata\n        result[data_key].update(metadata)\n        results.append(result)\n    return results",
        "type": "code",
        "location": "/pyjom/medialang/functions/detectors/videoDiffDetector.py:50-62"
    },
    "1019": {
        "file_id": 78,
        "content": "This code calls a function to iterate over frames in a video using frame differential as the data producer, then updates metadata and appends the result to a list of results.",
        "type": "comment"
    },
    "1020": {
        "file_id": 79,
        "content": "/pyjom/config/shared.py",
        "type": "filepath"
    },
    "1021": {
        "file_id": 79,
        "content": "The code initializes a dictionary named \"pyjom_config\" with a single key-value pair. The key is \"BEZIER_PADDLE_RESNET50_IMAGE_DOG_CAT_DETECTOR_SERVER_INSTANCE\", and its value is set to False. This configuration appears to relate to various components of an image detection system, possibly including a Bezier paddle, Paddle ResNet50 model, Dog/Cat detector, and server instance.",
        "type": "summary"
    },
    "1022": {
        "file_id": 79,
        "content": "pyjom_config=dict(BEZIER_PADDLE_RESNET50_IMAGE_DOG_CAT_DETECTOR_SERVER_INSTANCE=False)",
        "type": "code",
        "location": "/pyjom/config/shared.py:1-1"
    },
    "1023": {
        "file_id": 79,
        "content": "The code initializes a dictionary named \"pyjom_config\" with a single key-value pair. The key is \"BEZIER_PADDLE_RESNET50_IMAGE_DOG_CAT_DETECTOR_SERVER_INSTANCE\", and its value is set to False. This configuration appears to relate to various components of an image detection system, possibly including a Bezier paddle, Paddle ResNet50 model, Dog/Cat detector, and server instance.",
        "type": "comment"
    },
    "1024": {
        "file_id": 80,
        "content": "/pyjom/config/__init__.py",
        "type": "filepath"
    },
    "1025": {
        "file_id": 80,
        "content": "This code imports all functions and variables from the \"sina\" and \"medialang\" modules within the pyjom.config package. These modules may contain configurations for different components or services used in the application, potentially related to Sina Weibo and Media Language processing.",
        "type": "summary"
    },
    "1026": {
        "file_id": 80,
        "content": "from pyjom.config.sina import *\nfrom pyjom.config.medialang import *",
        "type": "code",
        "location": "/pyjom/config/__init__.py:1-2"
    },
    "1027": {
        "file_id": 80,
        "content": "This code imports all functions and variables from the \"sina\" and \"medialang\" modules within the pyjom.config package. These modules may contain configurations for different components or services used in the application, potentially related to Sina Weibo and Media Language processing.",
        "type": "comment"
    },
    "1028": {
        "file_id": 81,
        "content": "/pyjom/config/sina/sinaWeibo.py",
        "type": "filepath"
    },
    "1029": {
        "file_id": 81,
        "content": "The code defines a dictionary named \"sinaWeiboApi\" with three API endpoints for interacting with Sina Weibo. The \"search_with_page\" endpoint performs search queries, \"weibo_status_by_blogid\" retrieves a specific weibo status by blog ID, and \"weibo_build_comments\" fetches comments for a given weibo status.",
        "type": "summary"
    },
    "1030": {
        "file_id": 81,
        "content": "sinaWeiboApi = {\n    \"search_with_page\": \"http://sinanews.sina.cn/interface/type_of_search.d.html?callback=initFeed&keyword={}&page={}&type=siftWb&size=20&newpage=0&chwm=&imei=&token=&did=&from=&oldchwm=\",\n    \"weibo_status_by_blogid\": \"https://www.weibo.com/ajax/statuses/show?id={}\",\n    \"weibo_build_comments\": \"https://weibo.com/ajax/statuses/buildComments?flow=0&is_reload=1&count={}&id={}&is_show_bulletin=2&is_mix=0&uid={}\",\n}",
        "type": "code",
        "location": "/pyjom/config/sina/sinaWeibo.py:1-5"
    },
    "1031": {
        "file_id": 81,
        "content": "The code defines a dictionary named \"sinaWeiboApi\" with three API endpoints for interacting with Sina Weibo. The \"search_with_page\" endpoint performs search queries, \"weibo_status_by_blogid\" retrieves a specific weibo status by blog ID, and \"weibo_build_comments\" fetches comments for a given weibo status.",
        "type": "comment"
    },
    "1032": {
        "file_id": 82,
        "content": "/pyjom/config/sina/__init__.py",
        "type": "filepath"
    },
    "1033": {
        "file_id": 82,
        "content": "The code imports all the functions, classes, and variables from the \"sinaWeibo\" module in the \"pyjom.config.sina\" package.",
        "type": "summary"
    },
    "1034": {
        "file_id": 82,
        "content": "from pyjom.config.sina.sinaWeibo import *",
        "type": "code",
        "location": "/pyjom/config/sina/__init__.py:1-1"
    },
    "1035": {
        "file_id": 82,
        "content": "The code imports all the functions, classes, and variables from the \"sinaWeibo\" module in the \"pyjom.config.sina\" package.",
        "type": "comment"
    },
    "1036": {
        "file_id": 83,
        "content": "/pyjom/config/medialang/protocols.py",
        "type": "filepath"
    },
    "1037": {
        "file_id": 83,
        "content": "The code defines a dictionary named `medialangProtocols` with two keys: \"input\" and \"output\". The \"input\" key holds an array of protocols for input data sources, while the \"output\" key holds an array of protocols for output data destinations.",
        "type": "summary"
    },
    "1038": {
        "file_id": 83,
        "content": "medialangProtocols = {\n    \"input\": [\"http://\", \"https://\", \"text://\", \"subtitle://\", \"sinafetch://\"],\n    \"output\": [\"bilibili_post://\"],\n}",
        "type": "code",
        "location": "/pyjom/config/medialang/protocols.py:1-4"
    },
    "1039": {
        "file_id": 83,
        "content": "The code defines a dictionary named `medialangProtocols` with two keys: \"input\" and \"output\". The \"input\" key holds an array of protocols for input data sources, while the \"output\" key holds an array of protocols for output data destinations.",
        "type": "comment"
    },
    "1040": {
        "file_id": 84,
        "content": "/pyjom/config/medialang/__init__.py",
        "type": "filepath"
    },
    "1041": {
        "file_id": 84,
        "content": "This code imports all modules from the \"pyjom.config.medialang.protocols\" package into the current namespace, allowing access to various media language protocols used within the application.",
        "type": "summary"
    },
    "1042": {
        "file_id": 84,
        "content": "from pyjom.config.medialang.protocols import *",
        "type": "code",
        "location": "/pyjom/config/medialang/__init__.py:1-1"
    },
    "1043": {
        "file_id": 84,
        "content": "This code imports all modules from the \"pyjom.config.medialang.protocols\" package into the current namespace, allowing access to various media language protocols used within the application.",
        "type": "comment"
    },
    "1044": {
        "file_id": 85,
        "content": "/pyjom/modules/__init__.py",
        "type": "filepath"
    },
    "1045": {
        "file_id": 85,
        "content": "Importing various modules for different functionalities in the pyjom framework.",
        "type": "summary"
    },
    "1046": {
        "file_id": 85,
        "content": "from pyjom.modules.methodIdentifier import *\nfrom pyjom.modules.topicGenerator import *\nfrom pyjom.modules.informationGathering import *\nfrom pyjom.modules.informationProcessing import *\nfrom pyjom.modules.contentProducing import *\nfrom pyjom.modules.contentPosting import *\nfrom pyjom.modules.feedbackCollecting import *\nfrom pyjom.modules.globalOptimizer import *\nfrom pyjom.modules.globalUpdator import *\nfrom pyjom.modules.contentReviewer import *\nfrom pyjom.modules.contentCensoring import *",
        "type": "code",
        "location": "/pyjom/modules/__init__.py:1-11"
    },
    "1047": {
        "file_id": 85,
        "content": "Importing various modules for different functionalities in the pyjom framework.",
        "type": "comment"
    },
    "1048": {
        "file_id": 86,
        "content": "/pyjom/modules/topicGenerator/weiboTopicGenerator.py",
        "type": "filepath"
    },
    "1049": {
        "file_id": 86,
        "content": "This code imports necessary modules and defines a topic generator function for pets. It returns a fixed topic in both Chinese and English languages, demonstrating simple multilingual support.",
        "type": "summary"
    },
    "1050": {
        "file_id": 86,
        "content": "from pyjom.commons import *\n@decorator\ndef petsTopicGenerator():\n    # this is just some primitive topic, always return the same thing.\n    # topics cannot be multilingual.\n    return {\"entities\": [{\"chinese\": \"搞笑 宠物\", \"english\": \"funny pets\"}]}",
        "type": "code",
        "location": "/pyjom/modules/topicGenerator/weiboTopicGenerator.py:1-8"
    },
    "1051": {
        "file_id": 86,
        "content": "This code imports necessary modules and defines a topic generator function for pets. It returns a fixed topic in both Chinese and English languages, demonstrating simple multilingual support.",
        "type": "comment"
    },
    "1052": {
        "file_id": 87,
        "content": "/pyjom/modules/topicGenerator/onlineTopicGenerator.py",
        "type": "filepath"
    },
    "1053": {
        "file_id": 87,
        "content": "The code imports functions for keyword removal and topic modeling in English/Chinese, selects words by shuffling topics, fetches random keywords to request gifs/videos from a local server, and retrieves a random picture with related words using keyword and topic modeling.",
        "type": "summary"
    },
    "1054": {
        "file_id": 87,
        "content": "from pyjom.commons import *\nfrom pyjom.languagetoolbox import englishTopicModeling, chineseTopicModeling\nfrom lazero.utils.tools import flattenUnhashableList  # one of my classic methods\nimport requests\n# import jieba\nfrom typing import Literal\ndef removeKeywordDuplicates(keywords):\n    keywordsType = type(keywords)\n    inputFuncs = {\n        str: lambda x: x.split(\" \"),\n        list: lambda x: x,\n        tuple: lambda x: list(x),\n    }\n    outputFuncs = {\n        str: lambda x: \" \".join(x),\n        list: lambda x: x,\n        tuple: lambda x: tuple(x),\n    }\n    if keywordsType in inputFuncs.keys():\n        keywordsList = inputFuncs[keywordsType](keywords)\n    else:\n        raise Exception(\"Unknown keywords type: %s\" % type(keywords))\n    keywordsSet = set(keywordsList)\n    keywordsSetList = list(keywordsSet)\n    return outputFuncs[keywordsType](keywordsSetList)\ndef topicModeling(sentences: list[str], lang=\"en\"):  # specify language please?\n    # python does not enforce type checking. use third party tool such as linter instead.",
        "type": "code",
        "location": "/pyjom/modules/topicGenerator/onlineTopicGenerator.py:1-33"
    },
    "1055": {
        "file_id": 87,
        "content": "This code imports necessary modules and defines two functions: `removeKeywordDuplicates` for removing duplicate keywords in a list or string, and `topicModeling` for topic modeling with specified language (English or Chinese). It also includes an exception handling for unknown keyword types.",
        "type": "comment"
    },
    "1056": {
        "file_id": 87,
        "content": "    if lang == \"en\":\n        topics = englishTopicModeling(sentences)\n        return topics\n    elif lang == \"zh\":\n        topics = chineseTopicModeling(sentences)\n        return topics\n    else:\n        raise Exception(\"Unknown language: %s\" % lang)\ndef topicWordSelection(\n    topics,\n    core_topic_set: set,\n    selected_topic_list: list,\n    mode: Literal[\"combined\", \"separate\"] = \"combined\",\n    threshold=10,\n):\n    if len(selected_topic_list) > threshold:\n        for _ in range(len(selected_topic_list) - threshold):\n            selected_topic_list.pop(0)  # right way to remove elem from original list.\n    selected_topic_set = set(list(core_topic_set) + selected_topic_list)\n    import random\n    mTopics = topics.copy()\n    random.shuffle(mTopics)\n    for topic in mTopics:\n        words = topic[mode]\n        words = [x for x in words if x not in selected_topic_set]\n        if len(words) > 0:\n            word = random.choice(words)\n            selected_topic_list.append(word)  # no need to go elsewhere.\n            return word",
        "type": "code",
        "location": "/pyjom/modules/topicGenerator/onlineTopicGenerator.py:34-65"
    },
    "1057": {
        "file_id": 87,
        "content": "The code checks the language input and applies the appropriate topic modeling function. It then performs word selection by removing words already in the list, shuffling the remaining topics, and randomly choosing a new word to append to the selected_topic_list until it reaches a specified threshold.",
        "type": "comment"
    },
    "1058": {
        "file_id": 87,
        "content": "    print(\"no topic word this time\")\n    return None\ndef getMetaTopicString(metaTopic):\n    staticCandidates = [random.choice(x) for x in metaTopic.get(\"static\", [])]\n    optionalCandidates = [random.choice(x) for x in metaTopic.get(\"optional\", [])]\n    if len(optionalCandidates) > 0:\n        optionalCandidates = random.choice(optionalCandidates)\n    if type(optionalCandidates) != list:\n        optionalCandidates = [optionalCandidates]\n    dynamicCandidates = [random.choice(x) for x in metaTopic.get(\"dynamic\", [])]\n    samples = random.sample(\n        dynamicCandidates, random.randint(0, len(dynamicCandidates))\n    )\n    # print(staticCandidates)\n    # print(optionalCandidates)\n    # print(samples)\n    # breakpoint()\n    return \" \".join(staticCandidates + optionalCandidates + samples)\n@decorator\ndef OnlineTopicGenerator(\n    source=\"giphy\",\n    metaTopic={\n        \"static\": [[\"dog\", \"cat\"], [\"funny\", \"cute\"]],\n        \"dynamic\": [[\"samoyed\", \"husky\", \"teddy\", \"chiwawa\"]],\n    },  # this is not a matrix.\n    # sample_size = 10 # per search.",
        "type": "code",
        "location": "/pyjom/modules/topicGenerator/onlineTopicGenerator.py:66-95"
    },
    "1059": {
        "file_id": 87,
        "content": "The code defines a function called `getMetaTopicString` which takes a metaTopic dictionary as input and returns a string of topic words. It first generates static, optional, and dynamic candidates from the provided metaTopic dictionary. Then, it selects one candidate from each category and combines them into a final string. The code also includes a print statement and a breakpoint for debugging purposes. Finally, the decorator `@decorator` is used to apply some functionality to the `OnlineTopicGenerator` function.",
        "type": "comment"
    },
    "1060": {
        "file_id": 87,
        "content": "    timeout:float=20\n):\n    getKeywords = lambda: getMetaTopicString(metaTopic)\n    core_topic_set = {\n        *flattenUnhashableList([value for key, value in metaTopic.items()])\n    }  # common way to initialize a set.\n    selected_topic_list = []\n    if source == \"giphy\":\n        waitForServerUp(8902, \"nodejs giphy server\")\n        keywords = getKeywords()\n        while True:\n            import time\n            time.sleep(0.5)\n            harvestedData = []\n            try:\n                source_type = random.choice([\"videos\", \"gifs\"])\n                # source_type = 'videos' # for debugging\n                if random.random() > 0.5:\n                    with requests.get(\n                        \"http://127.0.0.1:8902/random\",\n                        params={\"q\": keywords, \"rating\": \"g\", \"type\": source_type},\n                        verify=False,\n                        proxies=None,\n                        timeout=timeout\n                    ) as mRandomPicture:  # may you get stickers?\n                        mRandomPictureJson = mRandomPicture.json()",
        "type": "code",
        "location": "/pyjom/modules/topicGenerator/onlineTopicGenerator.py:96-122"
    },
    "1061": {
        "file_id": 87,
        "content": "Code fetches random keywords from a metaTopic string and sends GET requests to a local server (running on 127.0.0.1:8902) for gifs or videos related to these keywords. If the keyword-related request is successful, it stores the result in mRandomPictureJson variable. This process continues until a timeout occurs or until another condition breaks the loop. The code also has debugging support by allowing the source_type to be hardcoded as 'videos'.",
        "type": "comment"
    },
    "1062": {
        "file_id": 87,
        "content": "                        harvestedData += mRandomPictureJson[\"data\"]\n                        randomPictureId = mRandomPictureJson[\"data\"][0][\"id\"]\n                else:\n                    with requests.get(\n                        \"http://127.0.0.1:8902/search\",\n                        params={\"q\": keywords, \"rating\": \"g\", \"type\": source_type},\n                        verify=False,\n                        proxies=None,\n                        timeout=timeout\n                    ) as mSearchPictures:\n                        mSearchPicturesJson = mSearchPictures.json()\n                        harvestedData += mSearchPicturesJson[\"data\"]\n                        randomPictureId = random.choice(mSearchPicturesJson[\"data\"])[\n                            \"id\"\n                        ]\n                selectedWord = None\n                with requests.get(\n                    \"http://127.0.0.1:8902/related\",\n                    params={\n                        \"q\": randomPictureId,\n                        \"type\": source_type,",
        "type": "code",
        "location": "/pyjom/modules/topicGenerator/onlineTopicGenerator.py:123-143"
    },
    "1063": {
        "file_id": 87,
        "content": "This code is making a request to an API, harvesting data based on keywords and type, and selecting a random picture. It also retrieves related words for the selected picture.",
        "type": "comment"
    },
    "1064": {
        "file_id": 87,
        "content": "                    },\n                    verify=False,\n                    proxies=None,  # seems not working? wtf?\n                ) as mRelatedPictures:\n                    mRelatedPicturesJson = mRelatedPictures.json()\n                    harvestedData += mRelatedPicturesJson[\"data\"]\n                    sentences = [x[\"title\"] for x in mRelatedPicturesJson[\"data\"]]\n                    topics = topicModeling(sentences)\n                    selectedWord = topicWordSelection(\n                        topics, core_topic_set, selected_topic_list\n                    )\n                if not selectedWord is None:\n                    keywords = \" \".join(\n                        [getKeywords(), selectedWord]\n                    )  # for next iteration.\n                    print(\"REFRESHING KEYWORDS:\", keywords)\n                else:\n                    keywords = getKeywords()\n                # recheck keywords!\n                keywords = removeKeywordDuplicates(keywords)\n            except:\n                import traceback",
        "type": "code",
        "location": "/pyjom/modules/topicGenerator/onlineTopicGenerator.py:144-165"
    },
    "1065": {
        "file_id": 87,
        "content": "This code segment fetches related pictures from a URL, performs topic modeling on the titles of these images, selects a word from the core topic set for further keyword generation, and handles potential exceptions.",
        "type": "comment"
    },
    "1066": {
        "file_id": 87,
        "content": "                traceback.print_exc()\n                print(\"ERROR WHEN FETCHING GIPHY TOPIC\")\n            for elem in harvestedData:\n                yield elem[\"id\"], json_auto_float_int(elem[\"media\"])",
        "type": "code",
        "location": "/pyjom/modules/topicGenerator/onlineTopicGenerator.py:167-170"
    },
    "1067": {
        "file_id": 87,
        "content": "This code block catches exceptions that may occur while fetching GIPHY topics. It prints the error trace and a descriptive message, then proceeds to iterate through the harvested data, yielding each entry's ID and media value after converting it using json_auto_float_int function.",
        "type": "comment"
    },
    "1068": {
        "file_id": 88,
        "content": "/pyjom/modules/topicGenerator/localTopicGenerator.py",
        "type": "filepath"
    },
    "1069": {
        "file_id": 88,
        "content": "The filesystemTopicGenerator function generates topics from file/directory paths, checking their validity and appending to a list of file names. It returns a dictionary with protocol, path, and content (filepaths).",
        "type": "summary"
    },
    "1070": {
        "file_id": 88,
        "content": "from pyjom.commons import *\nimport os\n@decorator\ndef filesystemTopicGenerator(filepath=None, dirpath=None, recursive=False):\n    mfilelist = []\n    protocol = None\n    path = getHostname() + \"@\"\n    if filepath is not None:\n        assert os.path.isfile(filepath)\n        mpath = os.path.abspath(filepath)\n        protocol = \"file\"\n        path += mpath\n        mfilelist.append(mpath)\n    else:\n        assert dirpath is not None\n        assert os.path.isdir(dirpath)\n        dirpath = os.path.abspath(dirpath)\n        path += dirpath\n        if recursive:\n            protocol = \"dir_recursive\"\n            for _, _, files in os.walk(dirpath):\n                for fname in files:\n                    fpath = os.path.join(dirpath, fname)\n                    if os.path.isfile(fpath):\n                        # mpath = os.path.abspath(fpath)\n                        mfilelist.append(fpath)\n        else:\n            protocol = \"dir\"\n            mfiles = os.listdir(dirpath)\n            for fname in mfiles:\n                fpath = os.path.join(dirpath, fname)",
        "type": "code",
        "location": "/pyjom/modules/topicGenerator/localTopicGenerator.py:1-33"
    },
    "1071": {
        "file_id": 88,
        "content": "The code defines a filesystemTopicGenerator function that generates topics from file or directory paths. It takes filepath and dirpath as input parameters, with optional recursive flag for directories. It checks if the given filepath exists or if the dirpath is a valid directory. If so, it appends the file/directory path to a list of file names. The protocol is set based on whether a file or directory was provided and used in generating topics.",
        "type": "comment"
    },
    "1072": {
        "file_id": 88,
        "content": "                if os.path.isfile(fpath):\n                    # mpath = os.path.abspath(fpath)\n                    mfilelist.append(fpath)\n    return {\"protocol\": protocol, \"path\": path, \"content\": mfilelist}",
        "type": "code",
        "location": "/pyjom/modules/topicGenerator/localTopicGenerator.py:34-37"
    },
    "1073": {
        "file_id": 88,
        "content": "Checks if a file exists at the specified path, appends absolute file paths to list, and returns a dictionary containing protocol, path, and content (filepaths).",
        "type": "comment"
    },
    "1074": {
        "file_id": 89,
        "content": "/pyjom/modules/topicGenerator/dummyTopicGenerator.py",
        "type": "filepath"
    },
    "1075": {
        "file_id": 89,
        "content": "The code imports the \"decorator\" function from the \"pyjom.commons\" module and defines two functions: \"dummyTopic()\" that returns the string \"pets\", and \"metaTopic(selected_source)\" which returns a list of titles based on the selected source. These functions are likely used for generating topic ideas or names.",
        "type": "summary"
    },
    "1076": {
        "file_id": 89,
        "content": "from pyjom.commons import *\n@decorator\ndef dummyTopic():\n    return \"pets\"\n@decorator\ndef metaTopic(selected_source):\n    sources = {\n        \"baidu_baijiahao\": [\"shitty title1\"],\n        \"bilibili_trending\": [\"boy with women's clothes\"],\n    }\n    return sources[selected_source]",
        "type": "code",
        "location": "/pyjom/modules/topicGenerator/dummyTopicGenerator.py:1-15"
    },
    "1077": {
        "file_id": 89,
        "content": "The code imports the \"decorator\" function from the \"pyjom.commons\" module and defines two functions: \"dummyTopic()\" that returns the string \"pets\", and \"metaTopic(selected_source)\" which returns a list of titles based on the selected source. These functions are likely used for generating topic ideas or names.",
        "type": "comment"
    },
    "1078": {
        "file_id": 90,
        "content": "/pyjom/modules/topicGenerator/__init__.py",
        "type": "filepath"
    },
    "1079": {
        "file_id": 90,
        "content": "This code imports modules from various topic generators (dummy, weibo, local, online) within the pyjom project. It appears to be related to generating topics or data for a specific purpose.",
        "type": "summary"
    },
    "1080": {
        "file_id": 90,
        "content": "from pyjom.modules.topicGenerator.dummyTopicGenerator import *\nfrom pyjom.modules.topicGenerator.weiboTopicGenerator import *\nfrom pyjom.modules.topicGenerator.localTopicGenerator import *\nfrom pyjom.modules.topicGenerator.onlineTopicGenerator import *",
        "type": "code",
        "location": "/pyjom/modules/topicGenerator/__init__.py:1-4"
    },
    "1081": {
        "file_id": 90,
        "content": "This code imports modules from various topic generators (dummy, weibo, local, online) within the pyjom project. It appears to be related to generating topics or data for a specific purpose.",
        "type": "comment"
    },
    "1082": {
        "file_id": 91,
        "content": "/pyjom/modules/feedbackCollecting/weiboFeedback.py",
        "type": "filepath"
    },
    "1083": {
        "file_id": 91,
        "content": "This code fetches Weibo feedback data, extracts comment info, populates a dictionary with details, and appends meta and updated feedback to \"mfeedback\" for specified key.",
        "type": "summary"
    },
    "1084": {
        "file_id": 91,
        "content": "from pyjom.commons import *\nimport requests\nimport json\ndef weiboCheckFeedback(meta, with_user=False):\n    feedback = {\"comments\": []}\n    id_ = meta[\"id\"]\n    uid = meta[\"uid\"]\n    url = sinaWeiboApi[\"weibo_build_comments\"].format(100, id_, uid)\n    with requests.get(url) as r:# somwhow working but we usually have nothing to see.\n        mdata = r.text\n        mdata = json.loads(mdata)\n        if mdata[\"ok\"] == 1: # what is this ok?\n            for elem in mdata[\"data\"]:\n                elem0 = {}\n                elem0[\"text\"] = elem[\"text\"]\n                if with_user:\n                    userMeta = elem[\"user\"]\n                    userMeta = {k:userMeta[k] for k in [\"id\",\"name\"]}\n                    elem0[\"user\"] = userMeta\n                elem0[\"like_counts\"] = elem[\"like_counts\"]\n                elem0[\"comments\"] = []\n                for comm in elem[\n                    \"comments\"\n                ]:  # also have reply_comment, though i don't know what it really means here.\n                    comm0 = {}",
        "type": "code",
        "location": "/pyjom/modules/feedbackCollecting/weiboFeedback.py:1-27"
    },
    "1085": {
        "file_id": 91,
        "content": "The code is fetching feedback data from a Weibo API and extracting comment information. It makes requests to the API, parses JSON responses, and populates a dictionary with the comment details including text, user (if specified), and like counts. Comments are nested within each post and reply comments are also present, but their significance is unclear.",
        "type": "comment"
    },
    "1086": {
        "file_id": 91,
        "content": "                    comm0[\"text\"] = comm[\"text\"]\n                    if with_user:\n                        userMeta2 = comm[\"user\"]\n                        userMeta2 = {k:userMeta2[k] for k in [\"id\",\"name\"]} # we don't fancy things here\n                        comm0[\"user\"] = userMeta2\n                    comm0[\"like_count\"] = comm[\"like_count\"]\n                    elem0[\"comments\"].append(comm0)\n                feedback[\"comments\"].append(elem0)\n        else:\n            print(json.dumps(mdata,indent=4))\n            print(\"NOT OK WITH WEIBO FEEDBACK!\")\n        return feedback\n@decorator\ndef weiboFeedback(content,with_user=False):\n    mfeedback = {}  # ordered by the blog id.\n    # it will create shit after all. debug first.\n    for key in content:\n        mfeedback[key] = []\n        print(\"feedback key:\",key)\n        print(\"feedback value:\",content[key])\n        for blog in content[key]:\n            review = blog[\"review\"] # what is this heck?\n            meta = review[\"meta\"]\n            print(\"feedback meta:\")",
        "type": "code",
        "location": "/pyjom/modules/feedbackCollecting/weiboFeedback.py:28-53"
    },
    "1087": {
        "file_id": 91,
        "content": "Function weiboFeedback takes content and optional with_user parameter, checks if there are feedback entries for each blog, appends comment elements to corresponding keys in mfeedback dictionary, and returns the feedback data.",
        "type": "comment"
    },
    "1088": {
        "file_id": 91,
        "content": "            print(json.dumps(meta,indent=4))\n            feedback = review[\"feedback\"] # what is this update?\n            data = weiboCheckFeedback(meta,with_user=with_user)\n            feedback.update(data)\n            mfeedback[key].append({\"meta\": meta, \"feedback\": feedback})\n    return mfeedback",
        "type": "code",
        "location": "/pyjom/modules/feedbackCollecting/weiboFeedback.py:54-59"
    },
    "1089": {
        "file_id": 91,
        "content": "This code prints the JSON representation of \"meta\" with indentation, retrieves feedback from the \"review\", updates \"feedback\" with data from \"weiboCheckFeedback\", and appends meta and updated feedback to \"mfeedback\" for the specified key.",
        "type": "comment"
    },
    "1090": {
        "file_id": 92,
        "content": "/pyjom/modules/feedbackCollecting/dummyFeedback.py",
        "type": "filepath"
    },
    "1091": {
        "file_id": 92,
        "content": "The code imports necessary modules, defines a function `dummyFeedback` that takes 'content' as input, and prints the content while returning \"pending\". The decorator is used for function execution in a temporary directory.",
        "type": "summary"
    },
    "1092": {
        "file_id": 92,
        "content": "from pyjom.commons import *\nfrom lazero.program.functools import iterateWithTempDirectory # you can also switch to 'AUTO'\n@decorator\n@iterateWithTempDirectory()\ndef dummyFeedback(\n    content # i think i need another function decorator for this. really? this will break pattern, for sure. temp files will be missing? so you need some tempdir decorator?\n):  # anyway, it is dummy. i don't expect nothing.\n    print(\"from poster:\", content)\n    return \"pending\"",
        "type": "code",
        "location": "/pyjom/modules/feedbackCollecting/dummyFeedback.py:1-11"
    },
    "1093": {
        "file_id": 92,
        "content": "The code imports necessary modules, defines a function `dummyFeedback` that takes 'content' as input, and prints the content while returning \"pending\". The decorator is used for function execution in a temporary directory.",
        "type": "comment"
    },
    "1094": {
        "file_id": 93,
        "content": "/pyjom/modules/feedbackCollecting/__init__.py",
        "type": "filepath"
    },
    "1095": {
        "file_id": 93,
        "content": "The code imports all functions and classes from the 'dummyFeedback' module and 'weiboFeedback' module into the current file, allowing for their use within this module.",
        "type": "summary"
    },
    "1096": {
        "file_id": 93,
        "content": "from pyjom.modules.feedbackCollecting.dummyFeedback import *\nfrom pyjom.modules.feedbackCollecting.weiboFeedback import *",
        "type": "code",
        "location": "/pyjom/modules/feedbackCollecting/__init__.py:1-2"
    },
    "1097": {
        "file_id": 93,
        "content": "The code imports all functions and classes from the 'dummyFeedback' module and 'weiboFeedback' module into the current file, allowing for their use within this module.",
        "type": "comment"
    },
    "1098": {
        "file_id": 94,
        "content": "/pyjom/modules/contentPosting/onlinePoster.py",
        "type": "filepath"
    },
    "1099": {
        "file_id": 94,
        "content": "This code defines a decorator-like function named OnlinePoster that takes in various parameters such as content, platform, postMetadataGenerator, and afterPosting. It returns an instance of BilibiliPoster for the specified platform (default is bilibili) to handle content posting. The function also utilizes a lambda expression to generate post metadata by iterating through the provided postMetadataGenerator.",
        "type": "summary"
    }
}