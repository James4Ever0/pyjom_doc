{
    "900": {
        "file_id": 80,
        "content": "        template_args = {} if name not in args.keys() else args[name]\n        assert type(template_args) == dict\n        if name.startswith(\"meta_\"):\n            template_args.update({\"meta\": meta})  # you can access it by keys.\n        template_args.update({\"mediafile\": contentPath})\n        # print(\"template_args\")\n        # breakpoint()\n        medialang = Medialang(\n            script_path=template_path,\n            template=True,\n            template_args=template_args,  # config inside the template args. None to use the default.\n        )\n        script = medialang.prettify()\n        print(script)\n        # breakpoint()\n        data = medialang.execute()\n        # print(\"DATA\",data)\n        # breakpoint()\n        # # try:\n        data = data[0][0]  # language feature.\n        # what the fuck is wrong?\n        mdata.update({name: data})  # this is not so good, though.\n        # except:\n            # print('skipping marking data')\n    if semiauto:  # need some modification.\n        for key in semiauto_key_blacklist:",
        "type": "code",
        "location": "/pyjom/modules/contentCensoring/autoCensor.py:32-57"
    },
    "901": {
        "file_id": 80,
        "content": "This code takes a name and dictionary of arguments, checks if the name matches a specific key in the arguments dictionary. If it does, it adds \"meta\" and \"mediafile\" keys to the template_args dictionary, then creates an instance of Medialang with the script path, template set to True, and template_args. The script is prettified, executed, and the data returned. Lastly, the data is added to the mdata dictionary under the given name, unless there was an issue where it prints \"skipping marking data\". If semiauto is set, it goes through a loop for each key in semiauto_key_blacklist.",
        "type": "comment"
    },
    "902": {
        "file_id": 80,
        "content": "            mdata.pop(key)\n    return mdata",
        "type": "code",
        "location": "/pyjom/modules/contentCensoring/autoCensor.py:58-59"
    },
    "903": {
        "file_id": 80,
        "content": "Removing specified key-value pair from the dictionary and returning the updated dictionary.",
        "type": "comment"
    },
    "904": {
        "file_id": 81,
        "content": "/pyjom/modules/feedbackCollecting/weiboFeedback.py",
        "type": "filepath"
    },
    "905": {
        "file_id": 81,
        "content": "This code fetches Weibo feedback data, extracts comment info, populates a dictionary with details, and appends meta and updated feedback to \"mfeedback\" for specified key.",
        "type": "summary"
    },
    "906": {
        "file_id": 81,
        "content": "from pyjom.commons import *\nimport requests\nimport json\ndef weiboCheckFeedback(meta, with_user=False):\n    feedback = {\"comments\": []}\n    id_ = meta[\"id\"]\n    uid = meta[\"uid\"]\n    url = sinaWeiboApi[\"weibo_build_comments\"].format(100, id_, uid)\n    with requests.get(url) as r:# somwhow working but we usually have nothing to see.\n        mdata = r.text\n        mdata = json.loads(mdata)\n        if mdata[\"ok\"] == 1: # what is this ok?\n            for elem in mdata[\"data\"]:\n                elem0 = {}\n                elem0[\"text\"] = elem[\"text\"]\n                if with_user:\n                    userMeta = elem[\"user\"]\n                    userMeta = {k:userMeta[k] for k in [\"id\",\"name\"]}\n                    elem0[\"user\"] = userMeta\n                elem0[\"like_counts\"] = elem[\"like_counts\"]\n                elem0[\"comments\"] = []\n                for comm in elem[\n                    \"comments\"\n                ]:  # also have reply_comment, though i don't know what it really means here.\n                    comm0 = {}",
        "type": "code",
        "location": "/pyjom/modules/feedbackCollecting/weiboFeedback.py:1-27"
    },
    "907": {
        "file_id": 81,
        "content": "The code is fetching feedback data from a Weibo API and extracting comment information. It makes requests to the API, parses JSON responses, and populates a dictionary with the comment details including text, user (if specified), and like counts. Comments are nested within each post and reply comments are also present, but their significance is unclear.",
        "type": "comment"
    },
    "908": {
        "file_id": 81,
        "content": "                    comm0[\"text\"] = comm[\"text\"]\n                    if with_user:\n                        userMeta2 = comm[\"user\"]\n                        userMeta2 = {k:userMeta2[k] for k in [\"id\",\"name\"]} # we don't fancy things here\n                        comm0[\"user\"] = userMeta2\n                    comm0[\"like_count\"] = comm[\"like_count\"]\n                    elem0[\"comments\"].append(comm0)\n                feedback[\"comments\"].append(elem0)\n        else:\n            print(json.dumps(mdata,indent=4))\n            print(\"NOT OK WITH WEIBO FEEDBACK!\")\n        return feedback\n@decorator\ndef weiboFeedback(content,with_user=False):\n    mfeedback = {}  # ordered by the blog id.\n    # it will create shit after all. debug first.\n    for key in content:\n        mfeedback[key] = []\n        print(\"feedback key:\",key)\n        print(\"feedback value:\",content[key])\n        for blog in content[key]:\n            review = blog[\"review\"] # what is this heck?\n            meta = review[\"meta\"]\n            print(\"feedback meta:\")",
        "type": "code",
        "location": "/pyjom/modules/feedbackCollecting/weiboFeedback.py:28-53"
    },
    "909": {
        "file_id": 81,
        "content": "Function weiboFeedback takes content and optional with_user parameter, checks if there are feedback entries for each blog, appends comment elements to corresponding keys in mfeedback dictionary, and returns the feedback data.",
        "type": "comment"
    },
    "910": {
        "file_id": 81,
        "content": "            print(json.dumps(meta,indent=4))\n            feedback = review[\"feedback\"] # what is this update?\n            data = weiboCheckFeedback(meta,with_user=with_user)\n            feedback.update(data)\n            mfeedback[key].append({\"meta\": meta, \"feedback\": feedback})\n    return mfeedback",
        "type": "code",
        "location": "/pyjom/modules/feedbackCollecting/weiboFeedback.py:54-59"
    },
    "911": {
        "file_id": 81,
        "content": "This code prints the JSON representation of \"meta\" with indentation, retrieves feedback from the \"review\", updates \"feedback\" with data from \"weiboCheckFeedback\", and appends meta and updated feedback to \"mfeedback\" for the specified key.",
        "type": "comment"
    },
    "912": {
        "file_id": 82,
        "content": "/pyjom/modules/feedbackCollecting/dummyFeedback.py",
        "type": "filepath"
    },
    "913": {
        "file_id": 82,
        "content": "The code imports necessary modules, defines a function `dummyFeedback` that takes 'content' as input, and prints the content while returning \"pending\". The decorator is used for function execution in a temporary directory.",
        "type": "summary"
    },
    "914": {
        "file_id": 82,
        "content": "from pyjom.commons import *\nfrom lazero.program.functools import iterateWithTempDirectory # you can also switch to 'AUTO'\n@decorator\n@iterateWithTempDirectory()\ndef dummyFeedback(\n    content # i think i need another function decorator for this. really? this will break pattern, for sure. temp files will be missing? so you need some tempdir decorator?\n):  # anyway, it is dummy. i don't expect nothing.\n    print(\"from poster:\", content)\n    return \"pending\"",
        "type": "code",
        "location": "/pyjom/modules/feedbackCollecting/dummyFeedback.py:1-11"
    },
    "915": {
        "file_id": 82,
        "content": "The code imports necessary modules, defines a function `dummyFeedback` that takes 'content' as input, and prints the content while returning \"pending\". The decorator is used for function execution in a temporary directory.",
        "type": "comment"
    },
    "916": {
        "file_id": 83,
        "content": "/pyjom/modules/feedbackCollecting/__init__.py",
        "type": "filepath"
    },
    "917": {
        "file_id": 83,
        "content": "The code imports all functions and classes from the 'dummyFeedback' module and 'weiboFeedback' module into the current file, allowing for their use within this module.",
        "type": "summary"
    },
    "918": {
        "file_id": 83,
        "content": "from pyjom.modules.feedbackCollecting.dummyFeedback import *\nfrom pyjom.modules.feedbackCollecting.weiboFeedback import *",
        "type": "code",
        "location": "/pyjom/modules/feedbackCollecting/__init__.py:1-2"
    },
    "919": {
        "file_id": 83,
        "content": "The code imports all functions and classes from the 'dummyFeedback' module and 'weiboFeedback' module into the current file, allowing for their use within this module.",
        "type": "comment"
    },
    "920": {
        "file_id": 84,
        "content": "/pyjom/modules/methodIdentifier/dummyIdentifier.py",
        "type": "filepath"
    },
    "921": {
        "file_id": 84,
        "content": "The code defines a function `dummyId()` that generates a unique UUID and a class `dummyIdentifier` with instance variables and methods to store fix information related to various components of a system.",
        "type": "summary"
    },
    "922": {
        "file_id": 84,
        "content": "def dummyId():\n    import uuid\n    return uuid.uuid4()\nclass dummyIdentifier:\n    def __init__(self, uuid):\n        self.uuid = uuid\n        self.data = {}\n    def typeFix(self, typeFix):\n        self.data[\"typeFix\"] = typeFix\n    def topicFix(self, topicFix):\n        self.data[\"topicFix\"] = topicFix\n    def infoFix(self, infoFix):\n        self.data[\"infoFix\"] = infoFix\n    def producerFix(self, producerFix):\n        self.data[\"producerFix\"] = producerFix\n    def posterFix(self, posterFix):\n        self.data[\"posterFix\"] = posterFix\n    def feedbackFix(self, feedbackFix):\n        self.data[\"feedbackFix\"] = feedbackFix\n    def updatorFix(self, updatorFix):\n        self.data[\"updatorFix\"] = updatorFix\n    def fetcherFix(self, fetcherFix):\n        self.data[\"fetcherFix\"] = fetcherFix\n    def processorFix(self, processorFix):\n        self.data[\"processorFix\"] = processorFix\n    def optimizerFix(self, optimizerFix):\n        self.data[\"optimizerFix\"] = optimizerFix\n    def reviewerFix(self, reviewerFix):\n        self.data[\"reviewerFix\"] = reviewerFix",
        "type": "code",
        "location": "/pyjom/modules/methodIdentifier/dummyIdentifier.py:1-43"
    },
    "923": {
        "file_id": 84,
        "content": "The code defines a function `dummyId()` that generates a unique UUID and a class `dummyIdentifier` with instance variables and methods to store fix information related to various components of a system.",
        "type": "comment"
    },
    "924": {
        "file_id": 85,
        "content": "/pyjom/modules/methodIdentifier/__init__.py",
        "type": "filepath"
    },
    "925": {
        "file_id": 85,
        "content": "This code imports all the contents from the \"dummyIdentifier\" module in the \"pyjom.modules.methodIdentifier\" package.",
        "type": "summary"
    },
    "926": {
        "file_id": 85,
        "content": "from pyjom.modules.methodIdentifier.dummyIdentifier import *",
        "type": "code",
        "location": "/pyjom/modules/methodIdentifier/__init__.py:1-1"
    },
    "927": {
        "file_id": 85,
        "content": "This code imports all the contents from the \"dummyIdentifier\" module in the \"pyjom.modules.methodIdentifier\" package.",
        "type": "comment"
    },
    "928": {
        "file_id": 86,
        "content": "/pyjom/modules/informationGathering/weiboInfo.py",
        "type": "filepath"
    },
    "929": {
        "file_id": 86,
        "content": "The code fetches and parses Weibo posts related to a keyword, extracting information like title, URL, author, images, and videos. It handles topic-related video searches and uses a generator function for expiry prevention.",
        "type": "summary"
    },
    "930": {
        "file_id": 86,
        "content": "from pyjom.commons import *\nimport requests\nimport random\nimport jieba\nimport json\nimport parse\nimport urllib.parse\ndef weiboLinkSearch(keyword):\n    links = []\n    myfilter = list(jieba.cut(keyword))\n    myfilter = [x for x in myfilter if chineseDetector(x)]\n    page = random.randint(\n        1, 100\n    )  # just a demo we do not know how to handle this one just yet.\n    url = sinaWeiboApi[\"search_with_page\"].format(keyword, page)\n    with requests.get(url) as r:\n        print(\"STATUS_CODE:\", r.status_code)\n        if r.status_code == 200:\n            content = r.content.decode(\"utf-8\")\n            content = parse.parse(\"initFeed({content})\", content)\n            content = content[\"content\"]\n            # import pyperclip\n            # pyperclip.copy(content)\n            # print(content)\n            content = json.loads(content)\n            data = content[\"data\"]\n            feed1 = data[\"feed1\"]\n            for elem in feed1:\n                url = elem[\"url\"]\n                title = elem[\"title\"]\n                fsum = 0",
        "type": "code",
        "location": "/pyjom/modules/informationGathering/weiboInfo.py:1-33"
    },
    "931": {
        "file_id": 86,
        "content": "This code is fetching the latest 100 Weibo posts containing a specified keyword. It first tokenizes the keyword using jieba, removes non-Chinese characters using chineseDetector, and randomly selects a page number between 1 to 100. Then, it constructs a URL for Sina Weibo API's search endpoint with the selected page, retrieves the content from the URL using requests, parses the JSON response containing the latest feeds, and extracts the URL and title of each feed. The fetched data is stored in the variables 'url' and 'title', respectively.",
        "type": "comment"
    },
    "932": {
        "file_id": 86,
        "content": "                for f in myfilter:\n                    if f in title:\n                        fsum += 1\n                if fsum == len(myfilter):\n                    links.append(url)\n            return links\ndef weiboStatusParser(content):\n    mtitle = None\n    if \"topic_struct\" in content.keys():\n        mtopic = [(x[\"topic_title\"], x[\"topic_url\"]) for x in content[\"topic_struct\"]]\n    else:\n        mtopic = None\n    mtext_raw = content[\"text_raw\"]\n    mtext = content[\"text\"]\n    mtime = content[\"created_at\"]\n    mauthor = content[\"user\"][\"screen_name\"]\n    mid = content[\"idstr\"]  # used for fetching comments.\n    mauthor_id = content[\"user\"][\"idstr\"]\n    mblogid = content[\"mblogid\"]\n    reposts_count = content[\"reposts_count\"]\n    comments_count = content[\"comments_count\"]\n    attitudes_count = content[\"attitudes_count\"]\n    mfeedback = {\n        \"reposts_count\": reposts_count,\n        \"comments_count\": comments_count,\n        \"attitudes_count\": attitudes_count,\n    }\n    mcontent = {\n        \"video\": None,\n        \"picture\": None,",
        "type": "code",
        "location": "/pyjom/modules/informationGathering/weiboInfo.py:34-66"
    },
    "933": {
        "file_id": 86,
        "content": "This code parses a Weibo content, extracting relevant information such as title, author, text, timestamp, and feedback count. It checks for topic structures in the content and appends URLs to a list if specific filters are met. The code returns the parsed Weibo status data and related links.",
        "type": "comment"
    },
    "934": {
        "file_id": 86,
        "content": "        \"title\": mtitle,\n        \"topic\": mtopic,\n        \"text\": {\"raw\": mtext_raw, \"html\": mtext},\n        \"author\": mauthor,\n        \"meta\": {\"time\": mtime, \"id\": mid, \"mblogid\": mblogid, \"uid\": mauthor_id},\n        \"feedback\": mfeedback,\n    }\n    if len(content[\"pic_ids\"]) > 0 and content[\"pic_num\"] > 0:\n        print(\"picture count:\", content[\"pic_num\"])\n        content[\"picture\"] = []\n        for pid in content[\"pic_ids\"]:\n            pic_srcs = [\n                \"original\",\n                \"mw2000\",\n                \"largest\",\n                \"large\",\n                \"bmiddle\",\n                \"thumbnail\",\n            ]\n            picBase = content[\"pic_infos\"][pid]\n            picUrl = None\n            for src in pic_srcs:\n                if src in picBase.keys():\n                    picUrl = picBase[src]\n                    if \"url\" in picUrl.keys():\n                        picUrl = picUrl[\"url\"]\n                        if picUrl is not None:\n                            print(\"fetched picture [{}]\\n{}\".format(src, picUrl))",
        "type": "code",
        "location": "/pyjom/modules/informationGathering/weiboInfo.py:67-94"
    },
    "935": {
        "file_id": 86,
        "content": "This code is extracting and organizing information from a Weibo post. It creates a dictionary with various details including title, topic, text, author, time, id, etc. If there are pictures in the post, it fetches them based on different sizes and adds the URL to a list in the dictionary.",
        "type": "comment"
    },
    "936": {
        "file_id": 86,
        "content": "                            break\n            if picUrl is not None:\n                content[\"picture\"].append(picUrl)\n            # only select the clearest, if possible.\n    elif \"page_info\" in content.keys():\n        print(content[\"page_info\"])  # this is how you print it.\n        videoBase = content[\"page_info\"][\"media_info\"]\n        potential_links = [\n            \"stream_url_hd\",\n            \"mp4_hd_url\",\n            \"h265_mp4_hd\",\n            \"inch_4_mp4_hd\",\n            \"inch_5_mp4_hd\",\n            \"inch_5_5_mp4_hd\",\n            \"mp4_sd_url\",\n            \"stream_url\",\n            \"h265_mp4_ld\",\n            \"mp4_720p_mp4\",\n            \"hevc_mp4_720p\",\n        ]\n        h5_url = videoBase[\"h5_url\"]\n        download_link = [videoBase[x] for x in potential_links if videoBase[x] != \"\"][0]\n        mvideo_info = {\n            \"video_orientation\": videoBase[\"video_orientation\"],\n            \"h5_url\": h5_url,\n            \"download_link\": download_link,\n        }\n        mcontent[\"video\"] = mvideo_info\n        # print(list(videoBase.keys()))",
        "type": "code",
        "location": "/pyjom/modules/informationGathering/weiboInfo.py:95-123"
    },
    "937": {
        "file_id": 86,
        "content": "The code checks if \"page_info\" exists in content and then proceeds to extract potential video links from the \"videoBase\". It creates a new dictionary, mvideo_info, containing the video orientation, h5_url, and download link. Finally, it adds this new dictionary to the content under the key \"video\".",
        "type": "comment"
    },
    "938": {
        "file_id": 86,
        "content": "        if \"video_title\" not in videoBase.keys():\n            try:\n                mcontent[\"title\"] = videoBase[\"titles\"][0][\"title\"]\n            except:\n                try:\n                    mcontent[\"title\"] = videoBase[\"content2\"]\n                except:\n                    try:\n                        mcontent[\"title\"] = videoBase[\"video_title\"]\n                    except:\n                        try:\n                            mcontent[\"title\"] = videoBase[\"next_title\"]\n                        except:\n                            try:\n                                mcontent[\"title\"] = videoBase[\"cards\"][0][\"content2\"]\n                            except:\n                                mcontent[\"title\"] = videoBase[\"page_title\"]\n        else:\n            mcontent[\"title\"] = videoBase[\"video_title\"]\n    return mcontent\ndef weiboVideoSearch(keyword):\n    links = weiboLinkSearch(keyword)\n    # info = []\n    for link in links:  # use yleid here.\n        myId = link.split(\"/\")[-1]\n        # need cookie to do the job?",
        "type": "code",
        "location": "/pyjom/modules/informationGathering/weiboInfo.py:124-151"
    },
    "939": {
        "file_id": 86,
        "content": "The code attempts to fetch the video title from various possible keys in the 'videoBase' dictionary. If \"video_title\" doesn't exist, it tries alternative keys. It then returns the 'mcontent' dictionary containing the retrieved or default title. The function 'weiboVideoSearch' performs a keyword-based search for links and processes each link separately with a specific ID extraction method.",
        "type": "comment"
    },
    "940": {
        "file_id": 86,
        "content": "        videoLink = sinaWeiboApi[\"weibo_status_by_blogid\"].format(\n            myId\n        )  # sina got better grammar?\n        # videoLink = \"https://www.weibo.com/ajax/status/show?id=\"+myId\n        with requests.get(videoLink) as r:\n            print(\"fetching video link:\", videoLink)\n            print(\"STATUS_CODE:\", r.status_code)\n            if r.status_code == 200:\n                content = r.text\n                # print('response content:',content)\n                # this is not formatted. this is pure json i suppose.\n                # content = parse.parse(\"initFeed({content})\",content)\n                if content == None:\n                    print(\"skipping link:\", videoLink)\n                    continue\n                # content = content[\"content\"]\n                # with open(\"{}.json\".format(myId),\"w+\",encoding=\"utf-8\") as f:\n                #     f.write(content)\n                content = json.loads(content)\n                mcontent = weiboStatusParser(content)  # this is a generator, not a list.",
        "type": "code",
        "location": "/pyjom/modules/informationGathering/weiboInfo.py:152-171"
    },
    "941": {
        "file_id": 86,
        "content": "Code fetches the video link using the Sina Weibo API and checks if the status code is 200. If successful, it retrieves the response content and parses it as JSON to extract relevant information. The extracted information is then processed by a generator function called weiboStatusParser.",
        "type": "comment"
    },
    "942": {
        "file_id": 86,
        "content": "                yield mcontent # this is a generator, not a list. how to get our feedback?\n        # return info\n        # make it into generator so links will not expire so damn fast.\ndef weiboInfoLogic(topic):\n    infoDict = {}\n    for elem in topic[\"entities\"]:\n        keyword = elem[\"chinese\"]\n        if keyword is not None:\n            info = weiboVideoSearch(keyword)\n            infoDict.update({keyword: info})\n    return infoDict\n@decorator\ndef weiboInfo(topic):\n    infoDict = weiboInfoLogic(topic)\n    return infoDict\n@decorator\ndef weiboFetcher(topic):\n    mtopic_bytes = json.dumps(topic).encode()\n    protocol = \"sinafetch://{}\".format(\n        urllib.parse.quote(mtopic_bytes)\n    )  # this is the posted_location, submit to feedback. containing the keyword in json.\n    # which is not desired since in this way we will not get the feedback.\n    infoDict = weiboInfoLogic(topic)\n    return protocol, infoDict",
        "type": "code",
        "location": "/pyjom/modules/informationGathering/weiboInfo.py:172-201"
    },
    "943": {
        "file_id": 86,
        "content": "The code defines a function `weiboInfoLogic` that searches for videos related to a given topic and returns the results in a dictionary. It also defines a decorator (not shown) that is applied to the `weiboInfo` and `weiboFetcher` functions. The `weiboInfo` function calls `weiboInfoLogic` to gather information about the topic, while the `weiboFetcher` function constructs a protocol for submitting the topic and also calls `weiboInfoLogic`. The code uses generator to make the links not expire quickly.",
        "type": "comment"
    },
    "944": {
        "file_id": 87,
        "content": "/pyjom/modules/informationGathering/onlineFetcher.py",
        "type": "filepath"
    },
    "945": {
        "file_id": 87,
        "content": "OnlineFetcher is a decorator for retrieving online media assets with specific criteria using lazero libraries. It chains functions, fetches URLs from frame metadata, creates download paths and skips unsuccessful downloads while handling exceptions during Giphy asset fetching.",
        "type": "summary"
    },
    "946": {
        "file_id": 87,
        "content": "from pyjom.commons import *\nfrom typing import Literal\nfrom lazero.network import download\nfrom lazero.filesystem import tmpdir\n@decorator\ndef OnlineFetcher(\n    infoList,\n    source: Literal[\"giphy\"] = \"giphy\",\n    frame_size_filter: dict = {\n        \"width\": {\"min\": 150, \"max\": 1000},\n        \"height\": {\"min\": 150, \"max\": 1000},\n    },\n    tempdir=\"/dev/shm/medialang/online\",\n    threads=20,\n    # threads=-0.5,\n    use_multithread=True,\n    timeout=120\n):\n    # how do you chain this shit up?\n    assert os.path.isabs(tempdir)\n    with tmpdir(path=tempdir) as TD:\n        assert os.path.isdir(tempdir)\n        assert os.path.exists(tempdir)\n        for info in infoList:  # generator most likely\n            if source == \"giphy\":\n                (source_id, frameMeta) = info\n                width, height = frameMeta[\"width\"], frameMeta[\"height\"]\n                asset_id = \"video_[{}_{}]_[{}x{}]\".format(source, source_id, width, height)\n                flag = frameSizeFilter(frameMeta, frame_size_filter)\n                if flag:",
        "type": "code",
        "location": "/pyjom/modules/informationGathering/onlineFetcher.py:1-32"
    },
    "947": {
        "file_id": 87,
        "content": "The function, OnlineFetcher, is a decorator that takes in a list of information and retrieves online media assets based on certain criteria such as source, frame size filter, temporary directory path, number of threads for multithreading, and timeout duration. It uses the download and tmpdir functions from lazero libraries for network downloading and temporary directories respectively. The function is chained to perform these operations.",
        "type": "comment"
    },
    "948": {
        "file_id": 87,
        "content": "                    # this time it is selected.\n                    url = frameMeta[\"url\"]\n                    extension = url.split(\"?\")[0].split(\".\")[-1]\n                    basename = \".\".join([asset_id, extension])\n                    download_path = os.path.join(tempdir, basename)\n                    try:\n                        result = download(\n                            url,\n                            download_path,\n                            threads=threads,\n                            size_filter={\"min\": 0.4, \"max\": 50},\n                            use_multithread=use_multithread,\n                            timeout=timeout\n                        )\n                        if result:\n                            yield source_id, download_path\n                        else:\n                            print(\"not downloading source:\", source_id)\n                            print(\"skipping:\", frameMeta)\n                            # print(\"____WTF IS GOING ON WITH THE DOWNLOADER?____\")\n                            # breakpoint()",
        "type": "code",
        "location": "/pyjom/modules/informationGathering/onlineFetcher.py:33-53"
    },
    "949": {
        "file_id": 87,
        "content": "Code block fetches the URL from frame metadata, extracts extension and filename, creates download path, attempts to download file using specified parameters (threads, size filter, use_multithread, timeout), yields source ID and download path if successful, skips and logs if unsuccessful.",
        "type": "comment"
    },
    "950": {
        "file_id": 87,
        "content": "                    except:\n                        import traceback\n                        traceback.print_exc()\n                        print(\"error fetching assets from giphy\")",
        "type": "code",
        "location": "/pyjom/modules/informationGathering/onlineFetcher.py:54-57"
    },
    "951": {
        "file_id": 87,
        "content": "This code segment catches exceptions during asset fetching from Giphy and prints the error message along with stack trace.",
        "type": "comment"
    },
    "952": {
        "file_id": 88,
        "content": "/pyjom/modules/informationGathering/localFetcher.py",
        "type": "filepath"
    },
    "953": {
        "file_id": 88,
        "content": "This code defines a function called filesystemFetcher that takes a topic as input. The function uses the protocol and path from the topic to create a URI. It also iterates over the content in the topic, determining the file type for each item using getLocalFileType. Finally, it adds this information to a list and returns the URI and the content.",
        "type": "summary"
    },
    "954": {
        "file_id": 88,
        "content": "from pyjom.commons import *\n@decorator\ndef filesystemFetcher(topic):\n    protocol = topic[\"protocol\"]\n    path = topic[\"path\"]\n    content = []\n    for fname in topic[\"content\"]:\n        ftype = getLocalFileType(fname)\n        content.append({\"type\": ftype, \"path\": fname})\n    # maybe using this protocol is a good start to pass things around?\"\n    return \"{}://{}\".format(protocol, path), content",
        "type": "code",
        "location": "/pyjom/modules/informationGathering/localFetcher.py:1-13"
    },
    "955": {
        "file_id": 88,
        "content": "This code defines a function called filesystemFetcher that takes a topic as input. The function uses the protocol and path from the topic to create a URI. It also iterates over the content in the topic, determining the file type for each item using getLocalFileType. Finally, it adds this information to a list and returns the URI and the content.",
        "type": "comment"
    },
    "956": {
        "file_id": 89,
        "content": "/pyjom/modules/informationGathering/dummyInfoGather.py",
        "type": "filepath"
    },
    "957": {
        "file_id": 89,
        "content": "This function, dummyInfo, returns a list of animals (husky, cats, and kitten) without any context. It is likely used in a broader program as a placeholder or dummy information gathering module.",
        "type": "summary"
    },
    "958": {
        "file_id": 89,
        "content": "from pyjom.commons import *\n@decorator\ndef dummyInfo(topic):\n    return [\"husky\", \"cats\", \"kitten\"]",
        "type": "code",
        "location": "/pyjom/modules/informationGathering/dummyInfoGather.py:1-6"
    },
    "959": {
        "file_id": 89,
        "content": "This function, dummyInfo, returns a list of animals (husky, cats, and kitten) without any context. It is likely used in a broader program as a placeholder or dummy information gathering module.",
        "type": "comment"
    },
    "960": {
        "file_id": 90,
        "content": "/pyjom/modules/informationGathering/dummyFetcher.py",
        "type": "filepath"
    },
    "961": {
        "file_id": 90,
        "content": "The code defines a function \"dummyFetcher\" which takes a topic as input and returns a protocol string along with a dictionary containing information about huskies. This could be used for passing data between different parts of the application.",
        "type": "summary"
    },
    "962": {
        "file_id": 90,
        "content": "from pyjom.commons import *\n@decorator\ndef dummyFetcher(topic):\n    # maybe using this protocol is a good start to pass things around?\"\n    return \"randomprotocol://randomcontent\", {\"husky\": {\"video\": \"<cute huskies>\"}}",
        "type": "code",
        "location": "/pyjom/modules/informationGathering/dummyFetcher.py:1-7"
    },
    "963": {
        "file_id": 90,
        "content": "The code defines a function \"dummyFetcher\" which takes a topic as input and returns a protocol string along with a dictionary containing information about huskies. This could be used for passing data between different parts of the application.",
        "type": "comment"
    },
    "964": {
        "file_id": 91,
        "content": "/pyjom/modules/informationGathering/__init__.py",
        "type": "filepath"
    },
    "965": {
        "file_id": 91,
        "content": "This code imports various modules for information gathering from different sources, such as dummy, Weibo, and online services. It includes functionality for fetching data locally or from the internet.",
        "type": "summary"
    },
    "966": {
        "file_id": 91,
        "content": "from pyjom.modules.informationGathering.dummyInfoGather import *\nfrom pyjom.modules.informationGathering.dummyFetcher import *\nfrom pyjom.modules.informationGathering.weiboInfo import *\nfrom pyjom.modules.informationGathering.localFetcher import *\nfrom pyjom.modules.informationGathering.onlineFetcher import *",
        "type": "code",
        "location": "/pyjom/modules/informationGathering/__init__.py:1-5"
    },
    "967": {
        "file_id": 91,
        "content": "This code imports various modules for information gathering from different sources, such as dummy, Weibo, and online services. It includes functionality for fetching data locally or from the internet.",
        "type": "comment"
    },
    "968": {
        "file_id": 92,
        "content": "/pyjom/modules/globalUpdator/__init__.py",
        "type": "filepath"
    },
    "969": {
        "file_id": 92,
        "content": "This code imports all the functions and classes from the \"dummyUpdator\" module in the \"pyjom.modules.globalUpdator.dummyUpdator\" package, allowing them to be used within this file or other parts of the program as needed.",
        "type": "summary"
    },
    "970": {
        "file_id": 92,
        "content": "from pyjom.modules.globalUpdator.dummyUpdator import *",
        "type": "code",
        "location": "/pyjom/modules/globalUpdator/__init__.py:1-1"
    },
    "971": {
        "file_id": 92,
        "content": "This code imports all the functions and classes from the \"dummyUpdator\" module in the \"pyjom.modules.globalUpdator.dummyUpdator\" package, allowing them to be used within this file or other parts of the program as needed.",
        "type": "comment"
    },
    "972": {
        "file_id": 93,
        "content": "/pyjom/modules/globalUpdator/dummyUpdator.py",
        "type": "filepath"
    },
    "973": {
        "file_id": 93,
        "content": "The code imports necessary modules, defines a function 'dummyUpdator' decorated with an unknown decorator and wrapped in 'iterateWithTempDirectory()'. It returns the string \"updated. since it is pending we will schedule another optimization\".",
        "type": "summary"
    },
    "974": {
        "file_id": 93,
        "content": "from pyjom.commons import *\nfrom lazero.program.functools import iterateWithTempDirectory\n@decorator\n@iterateWithTempDirectory()\ndef dummyUpdator(optimized_result):\n    return \"updated. since it is pending we will schedule another optimization\"",
        "type": "code",
        "location": "/pyjom/modules/globalUpdator/dummyUpdator.py:1-7"
    },
    "975": {
        "file_id": 93,
        "content": "The code imports necessary modules, defines a function 'dummyUpdator' decorated with an unknown decorator and wrapped in 'iterateWithTempDirectory()'. It returns the string \"updated. since it is pending we will schedule another optimization\".",
        "type": "comment"
    },
    "976": {
        "file_id": 94,
        "content": "/pyjom/modules/contentReviewer/weiboSearchReviewer.py",
        "type": "filepath"
    },
    "977": {
        "file_id": 94,
        "content": "This code snippet defines a function called weiboSearchReviewer that reviews content for keywords and censors elements using the weiboCensor function. It prints details, appends reviews to a dictionary, and returns mreview.",
        "type": "summary"
    },
    "978": {
        "file_id": 94,
        "content": "from pyjom.commons import *\nfrom pyjom.modules.contentCensoring.core import weiboCensor\nimport json\n@decorator\ndef weiboSearchReviewer(content, basedir=None, auto=False, semiauto=True,dummy_auto=True,template_names=[], args={}):\n    mreview = {}\n    for key in content.keys():\n        print(\"keyword:\", key)\n        print(\"_\" * 20)\n        mreview[key] = []\n        mcontent = content[key]\n        for elem in mcontent:\n            print(\"element inside:\")\n            print(\"_\" * 20)\n            meta = elem[\"meta\"]\n            feedback = elem[\"feedback\"]\n            _, pretty_printed = jsonPrettyPrint(elem)\n            print(pretty_printed)\n            review, source = weiboCensor(\n                elem, basedir=basedir, semiauto=semiauto, auto=auto, dummy_auto=dummy_auto,template_names=template_names ,args=args\n            )  # unnoticed source.\n            review[\"meta\"] = meta\n            review[\"feedback\"] = feedback\n            print(\"review:\", review)\n            mreview[key].append({\"review\": review, \"source\": source})",
        "type": "code",
        "location": "/pyjom/modules/contentReviewer/weiboSearchReviewer.py:1-27"
    },
    "979": {
        "file_id": 94,
        "content": "This function, weiboSearchReviewer, reviews content for various keywords and calls the weiboCensor function to censor elements. It prints each keyword and element, and then appends the review and source of the review to a dictionary with the corresponding keyword as key. The reviewed content is stored in mreview.",
        "type": "comment"
    },
    "980": {
        "file_id": 94,
        "content": "    return mreview",
        "type": "code",
        "location": "/pyjom/modules/contentReviewer/weiboSearchReviewer.py:28-28"
    },
    "981": {
        "file_id": 94,
        "content": "This code snippet is returning the variable \"mreview\" after performing some operation.",
        "type": "comment"
    },
    "982": {
        "file_id": 95,
        "content": "/pyjom/modules/contentReviewer/localReviewer.py",
        "type": "filepath"
    },
    "983": {
        "file_id": 95,
        "content": "This code defines `filesystemReviewer` for content review, including `filesystemReviewerCoreAnalyzer` and `filesystemReviewerNoGenerator`. It handles analysis, censoring, and returns results. `localReviewer` is created for local processing with arguments args, template_names, and debug.",
        "type": "summary"
    },
    "984": {
        "file_id": 95,
        "content": "from pyjom.commons import jsonPrettyPrint,decorator\nfrom pyjom.modules.contentCensoring.core import localCensor\nimport json\ndef filesystemReviewerCoreAnalyzer(\n    elem, auto=False, semiauto=True, dummy_auto=True, args={}, template_names=[], debug=True\n):\n    if debug:\n        print(\"element inside:\")\n        print(\"_\" * 20)\n        _, pretty_printed = jsonPrettyPrint(elem)\n        print(pretty_printed)\n    # print(\"ELEMENT\", elem)\n    # breakpoint()\n    review, source = localCensor(\n        elem,\n        auto=auto,\n        semiauto=semiauto,\n        dummy_auto=dummy_auto,\n        args=args,\n        template_names=template_names,\n    )  # unnoticed source.\n    if debug:\n        print(\"review:\")\n        # breakpoint()\n        print(json.dumps(review, indent=4))\n    reviewResult = {\"review\": review, \"source\": source}\n    return reviewResult\ndef filesystemReviewerNoGenerator(\n    content,**kwargs\n):\n    mreview = []\n    for elem in content:\n        reviewResult = filesystemReviewerCoreAnalyzer(\n            elem,**kwargs\n        )",
        "type": "code",
        "location": "/pyjom/modules/contentReviewer/localReviewer.py:1-39"
    },
    "985": {
        "file_id": 95,
        "content": "This code defines two functions for content reviewing: `filesystemReviewerCoreAnalyzer` and `filesystemReviewerNoGenerator`. The `filesystemReviewerCoreAnalyzer` function analyzes an element, applies content censoring with optional automation settings, and returns a review result containing the review and source. The `filesystemReviewerNoGenerator` function iterates over content elements, using `filesystemReviewerCoreAnalyzer` to analyze each element and return a list of review results.",
        "type": "comment"
    },
    "986": {
        "file_id": 95,
        "content": "        mreview.append(reviewResult)\n    return mreview\ndef filesystemReviewerGenerator(\n    content, **kwargs\n):\n    # mreview = []\n    for elem in content:\n        reviewResult = filesystemReviewerCoreAnalyzer(\n            elem,**kwargs\n        )\n        yield reviewResult\n    #     mreview.append(reviewResult)\n    # return mreview\n@decorator\ndef filesystemReviewer(\n    content,\n    auto=False,\n    semiauto=True,\n    dummy_auto=True,\n    args={},\n    template_names=[],\n    generator: bool = False,\n    debug=True\n):\n    # print(content)\n    # print('generator flag', generator)\n    # link = content[\"link\"]\n    if not generator:\n        return filesystemReviewerNoGenerator(\n            content,\n            auto=auto,\n            semiauto=semiauto,\n            dummy_auto=dummy_auto,\n            args=args,\n            template_names=template_names,\n            debug=debug\n        )\n    else:\n        return filesystemReviewerGenerator(\n            content,\n            auto=auto,\n            semiauto=semiauto,\n            dummy_auto=dummy_auto,",
        "type": "code",
        "location": "/pyjom/modules/contentReviewer/localReviewer.py:40-86"
    },
    "987": {
        "file_id": 95,
        "content": "This code defines a function `filesystemReviewer` which, depending on the generator flag parameter, returns either the result of `filesystemReviewerNoGenerator` or a review generator using the `filesystemReviewerGenerator` function. The review generator iterates over content elements and yields the results from each call to the `filesystemReviewerCoreAnalyzer`.",
        "type": "comment"
    },
    "988": {
        "file_id": 95,
        "content": "            args=args,\n            template_names=template_names,\n            debug=debug\n        )",
        "type": "code",
        "location": "/pyjom/modules/contentReviewer/localReviewer.py:87-90"
    },
    "989": {
        "file_id": 95,
        "content": "Creates a class instance of localReviewer, passing arguments args, template_names, and debug for processing content review locally.",
        "type": "comment"
    },
    "990": {
        "file_id": 96,
        "content": "/pyjom/modules/contentReviewer/dummyReviewer.py",
        "type": "filepath"
    },
    "991": {
        "file_id": 96,
        "content": "This code imports necessary modules and defines a decorator-wrapped function, 'dummyReviewer', which returns the string \"fantastic. another good day's work.\"",
        "type": "summary"
    },
    "992": {
        "file_id": 96,
        "content": "from pyjom.commons import *\n@decorator\ndef dummyReviewer(content):\n    return \"fantastic. another good day's work.\"",
        "type": "code",
        "location": "/pyjom/modules/contentReviewer/dummyReviewer.py:1-6"
    },
    "993": {
        "file_id": 96,
        "content": "This code imports necessary modules and defines a decorator-wrapped function, 'dummyReviewer', which returns the string \"fantastic. another good day's work.\"",
        "type": "comment"
    },
    "994": {
        "file_id": 97,
        "content": "/pyjom/modules/contentReviewer/__init__.py",
        "type": "filepath"
    },
    "995": {
        "file_id": 97,
        "content": "The code imports different reviewer classes from various modules within the pyjom package for content reviewing purposes, including dummyReviewer, weiboSearchReviewer, and several filesystemReviewer implementations.",
        "type": "summary"
    },
    "996": {
        "file_id": 97,
        "content": "from pyjom.modules.contentReviewer.dummyReviewer import *\nfrom pyjom.modules.contentReviewer.weiboSearchReviewer import *\nfrom pyjom.modules.contentReviewer.localReviewer import (\n    filesystemReviewerGenerator,\n    filesystemReviewerNoGenerator,\n    filesystemReviewerCoreAnalyzer,\n    filesystemReviewer,\n)",
        "type": "code",
        "location": "/pyjom/modules/contentReviewer/__init__.py:1-8"
    },
    "997": {
        "file_id": 97,
        "content": "The code imports different reviewer classes from various modules within the pyjom package for content reviewing purposes, including dummyReviewer, weiboSearchReviewer, and several filesystemReviewer implementations.",
        "type": "comment"
    },
    "998": {
        "file_id": 98,
        "content": "/pyjom/modules/informationProcessing/onlineProcessor.py",
        "type": "filepath"
    },
    "999": {
        "file_id": 98,
        "content": "The OnlineProcessor function processes video elements, applies filters, and has functions for fps filtering and animal detection, with future audio handling planned.",
        "type": "summary"
    }
}