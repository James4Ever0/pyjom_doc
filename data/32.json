{
    "3200": {
        "file_id": 376,
        "content": "b will automatically build docker images in the cloud for you, act as 'docker hub' and serve apps for free? wtf?\nclass random_shell(Executor):\n    @requests\n    def foo(self, docs: DocumentArray, **kwargs):\n        try:\n            command = docs[0].text\n            commandList = command.split(\" \")\n            if commandList[0] == 'cd':\n                if len(commandList) == 2:\n                    os.chdir(commandList[1])\n                    response = os.getcwd()\n                else:\n                    response = 'usage: cd <target directory>'\n            else:\n                response = subprocess.check_output(commandList)\n            docs[0].text = response\n        # docs[1].text = 'goodbye, world!'\n        except:\n            import traceback\n            error = traceback.format_exc()\n            docs[0].text = \"\\n\".join([\"error!\", error])",
        "type": "code",
        "location": "/tests/jina_deploy_free_gpu_cpu/random_shell/executor.py:42-63"
    },
    "3201": {
        "file_id": 376,
        "content": "This code defines a class `random_shell` that extends the `Executor` class. It takes a document array as input, splits the text into commands, and executes them. If the first command is 'cd', it changes the directory accordingly. Otherwise, it runs the command using subprocess and sets the response in the first document's text field. If an error occurs, it traces the exception and adds it to the first document's text field.",
        "type": "comment"
    },
    "3202": {
        "file_id": 377,
        "content": "/tests/jina_deploy_free_gpu_cpu/random_shell/flow.yml",
        "type": "filepath"
    },
    "3203": {
        "file_id": 377,
        "content": "This code sets up a Jina Flow execution, using the 'random_shell' container from Jinahub's Dockerhub, with 1 GPU and 8G of memory allocation. The retention period for data is set to -1, indicating no deletion.",
        "type": "summary"
    },
    "3204": {
        "file_id": 377,
        "content": "jtype: Flow\njcloud:\n  retention_days: -1\nexecutors:\n  - uses: jinahub+docker://random_shell/latest\n    name: jina_shell_random\n    jcloud:\n      resources:\n        gpu: 1\n        memory: 8G",
        "type": "code",
        "location": "/tests/jina_deploy_free_gpu_cpu/random_shell/flow.yml:1-10"
    },
    "3205": {
        "file_id": 377,
        "content": "This code sets up a Jina Flow execution, using the 'random_shell' container from Jinahub's Dockerhub, with 1 GPU and 8G of memory allocation. The retention period for data is set to -1, indicating no deletion.",
        "type": "comment"
    },
    "3206": {
        "file_id": 378,
        "content": "/tests/jina_deploy_free_gpu_cpu/semantic_search_encoder_multilingual/README.md",
        "type": "filepath"
    },
    "3207": {
        "file_id": 378,
        "content": "This code appears to be a shell script for transitioning from a random shell environment to the Jina framework.",
        "type": "summary"
    },
    "3208": {
        "file_id": 378,
        "content": "# random_shell\nshell to jina",
        "type": "code",
        "location": "/tests/jina_deploy_free_gpu_cpu/semantic_search_encoder_multilingual/README.md:1-3"
    },
    "3209": {
        "file_id": 378,
        "content": "This code appears to be a shell script for transitioning from a random shell environment to the Jina framework.",
        "type": "comment"
    },
    "3210": {
        "file_id": 379,
        "content": "/tests/jina_deploy_free_gpu_cpu/semantic_search_encoder_multilingual/client.py",
        "type": "filepath"
    },
    "3211": {
        "file_id": 379,
        "content": "This code sets up a Jina client to interact with a semantic search encoder multilingual index. It takes user input, sends it as a request to the index, and prints the response or an error message if there's any failure in the request processing. The host parameter determines the server endpoint to connect to and can be set to localhost, a specific container ID on Jina's cloud service, or left empty for default behavior.",
        "type": "summary"
    },
    "3212": {
        "file_id": 379,
        "content": "from jina import Client, DocumentArray\n# host = 'grpc://0.0.0.0:54321'\n# host = 'grpcs://3fcd103a37.wolf.jina.ai'\n# container_id = '7f015443e8'\n# host = 'grpcs://{}.wolf.jina.ai'.format(container_id)\nhost = \"\"\nif __name__ == '__main__':\n    c = Client(host=host)\n    while True:\n        docArray = DocumentArray.empty(1)\n        docArray[0].text = command = input(\"jina> \")\n        if command == 'exit':\n            print('exiting jina')\n            break\n        da = c.post('/', docArray)\n        if da[0].msg == 'success':\n            response = da[0].data\n            # print(da.texts)\n            print(response)\n        else:\n            print(da[0].msg)\n            print(\"ERROR!\")",
        "type": "code",
        "location": "/tests/jina_deploy_free_gpu_cpu/semantic_search_encoder_multilingual/client.py:1-22"
    },
    "3213": {
        "file_id": 379,
        "content": "This code sets up a Jina client to interact with a semantic search encoder multilingual index. It takes user input, sends it as a request to the index, and prints the response or an error message if there's any failure in the request processing. The host parameter determines the server endpoint to connect to and can be set to localhost, a specific container ID on Jina's cloud service, or left empty for default behavior.",
        "type": "comment"
    },
    "3214": {
        "file_id": 380,
        "content": "/tests/jina_deploy_free_gpu_cpu/semantic_search_encoder_multilingual/config.yml",
        "type": "filepath"
    },
    "3215": {
        "file_id": 380,
        "content": "This configuration file specifies a semantic search encoder (multilingual) using the provided \"executor.py\" module. It has a name, description, and URL, along with relevant keywords such as 'semantic search encoder' and 'multilingual'.",
        "type": "summary"
    },
    "3216": {
        "file_id": 380,
        "content": "jtype: semantic_search_encoder_multilingual\npy_modules:\n  - executor.py\nmetas:\n  name: semantic_search_encoder_multilingual\n  description: borrowed from sentence encoder\n  url: \n  keywords: ['semantic search encoder, multilingual']",
        "type": "code",
        "location": "/tests/jina_deploy_free_gpu_cpu/semantic_search_encoder_multilingual/config.yml:1-8"
    },
    "3217": {
        "file_id": 380,
        "content": "This configuration file specifies a semantic search encoder (multilingual) using the provided \"executor.py\" module. It has a name, description, and URL, along with relevant keywords such as 'semantic search encoder' and 'multilingual'.",
        "type": "comment"
    },
    "3218": {
        "file_id": 381,
        "content": "/tests/jina_deploy_free_gpu_cpu/semantic_search_encoder_multilingual/deploy_to_jina_cloud.sh",
        "type": "filepath"
    },
    "3219": {
        "file_id": 381,
        "content": "Creates Jina Cloud deployment using `flow.yml` configuration file and optional environment file.",
        "type": "summary"
    },
    "3220": {
        "file_id": 381,
        "content": "jc deploy flow.yml\n# jc deploy flow.yml --env-file flow.env",
        "type": "code",
        "location": "/tests/jina_deploy_free_gpu_cpu/semantic_search_encoder_multilingual/deploy_to_jina_cloud.sh:1-2"
    },
    "3221": {
        "file_id": 381,
        "content": "Creates Jina Cloud deployment using `flow.yml` configuration file and optional environment file.",
        "type": "comment"
    },
    "3222": {
        "file_id": 382,
        "content": "/tests/jina_deploy_free_gpu_cpu/semantic_search_encoder_multilingual/executor.py",
        "type": "filepath"
    },
    "3223": {
        "file_id": 382,
        "content": "The code creates an Executor class for a semantic search encoder with multilingual support using sentence-transformers, and includes a `foo` method that handles document embedding, exceptions, and error handling.",
        "type": "summary"
    },
    "3224": {
        "file_id": 382,
        "content": "from jina import Executor, DocumentArray, requests\nimport numpy as np\nfrom txtai.embeddings import Embeddings\n#     raise RuntimeError(\n# RuntimeError: Cannot re-initialize CUDA in forked subprocess. To use CUDA with multiprocessing, you must use the 'spawn' start method\nclass semantic_search_encoder_multilingual(Executor):\n    embeddings = Embeddings({\n            \"path\": \"sentence-transformers/distiluse-base-multilingual-cased-v1\"\n        } )\n    @requests\n    def foo(self, docs: DocumentArray, **kwargs):\n        try:\n            command = docs[0].text\n            command = command.strip()\n            if len(command) == 0 or command == '_success':\n                raise Exception('No command')\n            response = self.embeddings.transform((None, command, None))\n            response = np.array([response])\n            docs[0].embedding = response\n            docs[0].text = '_success'\n        # docs[1].text = 'goodbye, world!'\n        except:\n            import traceback\n            error = traceback.format_exc()",
        "type": "code",
        "location": "/tests/jina_deploy_free_gpu_cpu/semantic_search_encoder_multilingual/executor.py:1-28"
    },
    "3225": {
        "file_id": 382,
        "content": "The code defines an Executor class for a semantic search encoder that utilizes the sentence-transformers library for multilingual support. It also includes a `foo` method which takes a DocumentArray, extracts the command from the first document's text, applies the embeddings transformation, updates the embedding and status of the document, and handles any exceptions during processing.",
        "type": "comment"
    },
    "3226": {
        "file_id": 382,
        "content": "            print(error)\n            docs[0].embedding = None\n            docs[0].text = \"\\n\".join([\"error!\", error])",
        "type": "code",
        "location": "/tests/jina_deploy_free_gpu_cpu/semantic_search_encoder_multilingual/executor.py:29-31"
    },
    "3227": {
        "file_id": 382,
        "content": "Error handling: Prints the error message, sets document embedding to None, and adds an error message line to the document text.",
        "type": "comment"
    },
    "3228": {
        "file_id": 383,
        "content": "/tests/jina_deploy_free_gpu_cpu/semantic_search_encoder_multilingual/flow.yml",
        "type": "filepath"
    },
    "3229": {
        "file_id": 383,
        "content": "This code defines a Jina flow with 1 executor, using the latest version of \"semantic_search_encoder_multilingual\" container from JinaHub. It has 1 GPU and 8G memory allocated, but these resources will be shut down shortly.",
        "type": "summary"
    },
    "3230": {
        "file_id": 383,
        "content": "jtype: Flow\nwith:\n  prefetch: 1\n  env:\n    JINA_MP_START_METHOD: spawn\njcloud:\n  retention_days: -1 # ignored! it will be fucked anyway.\nexecutors:\n  - uses: jinahub+docker://semantic_search_encoder_multilingual/latest\n    name: semantic_search_encoder_multilingual\n    jcloud:\n      resources:\n        gpu: 1 # which means it will be shutdown shortly\n        memory: 8G",
        "type": "code",
        "location": "/tests/jina_deploy_free_gpu_cpu/semantic_search_encoder_multilingual/flow.yml:1-14"
    },
    "3231": {
        "file_id": 383,
        "content": "This code defines a Jina flow with 1 executor, using the latest version of \"semantic_search_encoder_multilingual\" container from JinaHub. It has 1 GPU and 8G memory allocated, but these resources will be shut down shortly.",
        "type": "comment"
    },
    "3232": {
        "file_id": 384,
        "content": "/tests/jina_deploy_free_gpu_cpu/semantic_search_encoder_multilingual/push_to_jina_hub.sh",
        "type": "filepath"
    },
    "3233": {
        "file_id": 384,
        "content": "This command pushes the current directory (denoted by `.`) to Jina Hub, making it publicly accessible for others to use or collaborate on.",
        "type": "summary"
    },
    "3234": {
        "file_id": 384,
        "content": "jina hub push --public .",
        "type": "code",
        "location": "/tests/jina_deploy_free_gpu_cpu/semantic_search_encoder_multilingual/push_to_jina_hub.sh:1-1"
    },
    "3235": {
        "file_id": 384,
        "content": "This command pushes the current directory (denoted by `.`) to Jina Hub, making it publicly accessible for others to use or collaborate on.",
        "type": "comment"
    },
    "3236": {
        "file_id": 385,
        "content": "/tests/jina_deploy_free_gpu_cpu/semantic_search_encoder_multilingual/requirements.txt",
        "type": "filepath"
    },
    "3237": {
        "file_id": 385,
        "content": "These lines specify the required Python packages for the project. \"txtai\" is a package for text analysis, \"transformers\" is used for natural language processing, and \"faiss\" is an efficient library for nearest neighbors search.",
        "type": "summary"
    },
    "3238": {
        "file_id": 385,
        "content": "txtai\ntransformers\nfaiss",
        "type": "code",
        "location": "/tests/jina_deploy_free_gpu_cpu/semantic_search_encoder_multilingual/requirements.txt:1-3"
    },
    "3239": {
        "file_id": 385,
        "content": "These lines specify the required Python packages for the project. \"txtai\" is a package for text analysis, \"transformers\" is used for natural language processing, and \"faiss\" is an efficient library for nearest neighbors search.",
        "type": "comment"
    },
    "3240": {
        "file_id": 386,
        "content": "/tests/jina_deploy_free_gpu_cpu/semantic_search_encoder_multilingual/test.py",
        "type": "filepath"
    },
    "3241": {
        "file_id": 386,
        "content": "Importing semantic search encoder multilingual executor, disabling proxies, creating a Flow with 1 prefetch and 12345 port, adding the semantic search encoder to it with 1 replica, then running the Flow in blocking mode.",
        "type": "summary"
    },
    "3242": {
        "file_id": 386,
        "content": "from executor import semantic_search_encoder_multilingual\nfrom jina import Flow\nimport os\nif __name__ == \"__main__\":\n    os.environ[\"http_proxy\"] = \"\"\n    os.environ[\"https_proxy\"] = \"\"\n    f = Flow(prefetch=1,port=12345).add(uses=semantic_search_encoder_multilingual, replicas=1)\n    with f:\n        f.block()",
        "type": "code",
        "location": "/tests/jina_deploy_free_gpu_cpu/semantic_search_encoder_multilingual/test.py:1-11"
    },
    "3243": {
        "file_id": 386,
        "content": "Importing semantic search encoder multilingual executor, disabling proxies, creating a Flow with 1 prefetch and 12345 port, adding the semantic search encoder to it with 1 replica, then running the Flow in blocking mode.",
        "type": "comment"
    },
    "3244": {
        "file_id": 387,
        "content": "/tests/jina_deploy_free_gpu_cpu/semantic_search_encoder_multilingual/test.sh",
        "type": "filepath"
    },
    "3245": {
        "file_id": 387,
        "content": "This code sets the JINA_MP_START_METHOD environment variable to \"spawn\" before running a Python script. It mentions an ongoing issue with loading a model using txtai, but doesn't elaborate further on the problem or its potential solutions.",
        "type": "summary"
    },
    "3246": {
        "file_id": 387,
        "content": "env JINA_MP_START_METHOD=spawn python3 test.py\n# still we are having issue with the txtai, which cannot load our model for whatever reason.",
        "type": "code",
        "location": "/tests/jina_deploy_free_gpu_cpu/semantic_search_encoder_multilingual/test.sh:1-2"
    },
    "3247": {
        "file_id": 387,
        "content": "This code sets the JINA_MP_START_METHOD environment variable to \"spawn\" before running a Python script. It mentions an ongoing issue with loading a model using txtai, but doesn't elaborate further on the problem or its potential solutions.",
        "type": "comment"
    },
    "3248": {
        "file_id": 388,
        "content": "/tests/jina_deploy_free_gpu_cpu/semantic_search_encoder_multilingual/test_client.py",
        "type": "filepath"
    },
    "3249": {
        "file_id": 388,
        "content": "The code initializes a Jina Client, sends a document array with 'hello world' text to the client's endpoint, and retrieves the response. It then checks if the response status is 'success', prints the embedding data if it is, or otherwise prints the response message along with an error marker.",
        "type": "summary"
    },
    "3250": {
        "file_id": 388,
        "content": "from jina import Client, DocumentArray, Document\nc = Client(port=12345)\ndocArray = DocumentArray.empty(1)\ndocArray[0].text = 'hello world'\nr = c.post('/', docArray)\nr_0 = r[0]\n# print(dir(r_0))\n# print(r_0.tags)\n# breakpoint()\ntext = r[0].text\nif text == 'success':\n    data = r[0].embedding\n    print(data)\n    print(data.dtype, shape(data))\nelse:\n    print(text)\n    print(\"____________ERROR____________\")",
        "type": "code",
        "location": "/tests/jina_deploy_free_gpu_cpu/semantic_search_encoder_multilingual/test_client.py:1-18"
    },
    "3251": {
        "file_id": 388,
        "content": "The code initializes a Jina Client, sends a document array with 'hello world' text to the client's endpoint, and retrieves the response. It then checks if the response status is 'success', prints the embedding data if it is, or otherwise prints the response message along with an error marker.",
        "type": "comment"
    },
    "3252": {
        "file_id": 389,
        "content": "/tests/jina_multimodal_cross_modal_search_examples_apps/get_jina_hub_list.py",
        "type": "filepath"
    },
    "3253": {
        "file_id": 389,
        "content": "This code retrieves a list of Jina Hub executors in chunks and writes them to a JSON file named \"jina_hub.json\". It first makes an API request to the Hubble server, sorts the results by activities.metaMatched, and returns the data as JSON. Then it calculates the number of pages needed based on the total number of executors and loops through each page, appending the data to a list called 'data'. Finally, it writes the list of executors (in multiple chunks) to the file \"jina_hub.json\" with proper indentation and formatting.",
        "type": "summary"
    },
    "3254": {
        "file_id": 389,
        "content": "import requests\nimport time\nimport json\ndef getJson(pageIndex=1, pageSize=16):\n    url = 'https://api.hubble.jina.ai/v2/rpc/executor.list'\n    query = {\"sort\":\"-activities.metaMatched\",\"pageIndex\":pageIndex,\"pageSize\":pageSize,\"search\":\"\",\"author\":\"\",\"keywords\":[],\"withAnonymous\":True}\n    r = requests.post(url,json=query)\n    jsonData = r.json()\n    return jsonData\npageSize = 16\njsonData = getJson(pageSize=pageSize)\ntotal = jsonData[\"meta\"][\"total\"]\nprint('total:', total)\ndata = [jsonData.copy()]\nimport math\npages = math.ceil(total/pageSize)\nimport progressbar\nfor index in progressbar.progressbar(range(2,pages+1)):\n    time.sleep(2)\n    # print('page index:',index)\n    jsonData = getJson(pageIndex=index, pageSize=pageSize)\n    data.append(jsonData.copy())\nprint(\"writing data\")\nwith open(\"jina_hub.json\", \"w\") as f:\n    f.write(json.dumps(data, indent=4, ensure_ascii=False))",
        "type": "code",
        "location": "/tests/jina_multimodal_cross_modal_search_examples_apps/get_jina_hub_list.py:1-29"
    },
    "3255": {
        "file_id": 389,
        "content": "This code retrieves a list of Jina Hub executors in chunks and writes them to a JSON file named \"jina_hub.json\". It first makes an API request to the Hubble server, sorts the results by activities.metaMatched, and returns the data as JSON. Then it calculates the number of pages needed based on the total number of executors and loops through each page, appending the data to a list called 'data'. Finally, it writes the list of executors (in multiple chunks) to the file \"jina_hub.json\" with proper indentation and formatting.",
        "type": "comment"
    },
    "3256": {
        "file_id": 390,
        "content": "/tests/jina_multimodal_cross_modal_search_examples_apps/get_jina_hub_list.sh",
        "type": "filepath"
    },
    "3257": {
        "file_id": 390,
        "content": "This script uses curl to send an authenticated GET request to 'https://api.hubble.jina.ai/v2/rpc/executor.list' for retrieving the list of executors on Jina Hub. The request includes necessary headers and data parameters in a compressed format.",
        "type": "summary"
    },
    "3258": {
        "file_id": 390,
        "content": "# curl 'https://api.hubble.jina.ai/v2/rpc/executor.list' \\\n#   -H 'authority: api.hubble.jina.ai' \\\n#   -H 'accept: */*' \\\n#   -H 'accept-language: en-US,en;q=0.9' \\\n#   -H 'content-type: application/json' \\\n#   -H 'cookie: _ga=GA1.1.1157816225.1662091624; _ga_48WE9V68SD=GS1.1.1662457192.4.0.1662457192.0.0.0; _ga_K8DQ8TXQJH=GS1.1.1663058102.2.1.1663059426.0.0.0; _ga_E63SXVNDXZ=GS1.1.1663061381.1.1.1663063158.0.0.0; _ga_48ZDWC8GT6=GS1.1.1663064195.8.1.1663064235.0.0.0; _ga_1ESRNDCK35=GS1.1.1663064288.3.0.1663064288.0.0.0; _ga_MMEXL9VXBJ=GS1.1.1663058298.5.1.1663065624.0.0.0' \\\n#   -H 'origin: https://hub.jina.ai' \\\n#   -H 'referer: https://hub.jina.ai/' \\\n#   -H 'sec-ch-ua: \"Google Chrome\";v=\"105\", \"Not)A;Brand\";v=\"8\", \"Chromium\";v=\"105\"' \\\n#   -H 'sec-ch-ua-mobile: ?0' \\\n#   -H 'sec-ch-ua-platform: \"macOS\"' \\\n#   -H 'sec-fetch-dest: empty' \\\n#   -H 'sec-fetch-mode: cors' \\\n#   -H 'sec-fetch-site: same-site' \\\n#   -H 'user-agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36' \\",
        "type": "code",
        "location": "/tests/jina_multimodal_cross_modal_search_examples_apps/get_jina_hub_list.sh:1-15"
    },
    "3259": {
        "file_id": 390,
        "content": "This script is using curl to send a GET request to 'https://api.hubble.jina.ai/v2/rpc/executor.list' API endpoint, retrieving the list of executors available on Jina Hub. The request includes various headers for authorization, language, content type, cookies, origin, referer, user-agent, and browser details to authenticate and fetch the required information.",
        "type": "comment"
    },
    "3260": {
        "file_id": 390,
        "content": "#   --data-raw '{\"sort\":\"-activities.metaMatched\",\"pageIndex\":3,\"pageSize\":16,\"search\":\"\",\"author\":\"\",\"keywords\":[],\"withAnonymous\":true}' \\\n#   --compressed\ncurl 'https://api.hubble.jina.ai/v2/rpc/executor.list' \\\n --data-raw '{\"sort\":\"-activities.metaMatched\",\"pageIndex\":3,\"pageSize\":16,\"search\":\"\",\"author\":\"\",\"keywords\":[],\"withAnonymous\":true}' \\\n  --compressed",
        "type": "code",
        "location": "/tests/jina_multimodal_cross_modal_search_examples_apps/get_jina_hub_list.sh:16-20"
    },
    "3261": {
        "file_id": 390,
        "content": "This code is making a compressed HTTP request to 'https://api.hubble.jina.ai/v2/rpc/executor.list' with specific data parameters and a compressed format.",
        "type": "comment"
    },
    "3262": {
        "file_id": 391,
        "content": "/tests/kaggle_yt_dls/test.py",
        "type": "filepath"
    },
    "3263": {
        "file_id": 391,
        "content": "The code imports the os module and defines a list of commands. It then iterates through each command, executes it using the os.system() function, installing yt-dlp and downloading a YouTube video with its unique link.",
        "type": "summary"
    },
    "3264": {
        "file_id": 391,
        "content": "import os\ncommands = [\"pip3 install yt-dlp\",'yt-dlp \"https://m.youtube.com/watch?v=FuV63EEhS8c\"']\nfor c in commands:\n    os.system(c)",
        "type": "code",
        "location": "/tests/kaggle_yt_dls/test.py:1-5"
    },
    "3265": {
        "file_id": 391,
        "content": "The code imports the os module and defines a list of commands. It then iterates through each command, executes it using the os.system() function, installing yt-dlp and downloading a YouTube video with its unique link.",
        "type": "comment"
    },
    "3266": {
        "file_id": 392,
        "content": "/tests/kaggle_yt_dls/test_init.sh",
        "type": "filepath"
    },
    "3267": {
        "file_id": 392,
        "content": "The code initializes a Kaggle kernel, pushes code to it, checks its status, and then retrieves output after completion. Proxies are skipped, and the download speed is measured.",
        "type": "summary"
    },
    "3268": {
        "file_id": 392,
        "content": "# kaggle kernels init\n# code/jessysisca/some-yt-stuff \n# kaggle kernels push\n# kaggle kernels status jessysisca/some-yt-stuff\n# jessysisca/some-yt-stuff has status \"complete\"\n# root@alpharetta ~/android_connect_scrcpy_patch# \n# kaggle kernels status jessysisca/test-of-yt-dlp\n# jessysisca/test-of-yt-dlp has status \"running\"\n# after it is done, we pull back all shit.\n# skip all proxies.\nexport http_proxy=\"\"\nexport https_proxy=\"\"\nkaggle kernels output jessysisca/test-of-yt-dlp # what is the freaking speed?\n# not too slow.",
        "type": "code",
        "location": "/tests/kaggle_yt_dls/test_init.sh:1-14"
    },
    "3269": {
        "file_id": 392,
        "content": "The code initializes a Kaggle kernel, pushes code to it, checks its status, and then retrieves output after completion. Proxies are skipped, and the download speed is measured.",
        "type": "comment"
    },
    "3270": {
        "file_id": 393,
        "content": "/tests/kaggle_yt_dls/transcode_nvenc.sh",
        "type": "filepath"
    },
    "3271": {
        "file_id": 393,
        "content": "The code uses FFmpeg to transcode a video file, applying a hue filter and testing hardware acceleration options like CUDA, VDPAU, and Vulkan, while mentioning NVENC is not for everyone. It also includes trigonometric function comments for potential Hue effects.",
        "type": "summary"
    },
    "3272": {
        "file_id": 393,
        "content": "# ffmpeg -hwaccels\n# vdpau\n# cuda\n# vaapi\n# vulkan\n# no blood.\nffmpeg -y -vsync 0 -hwaccel_output_format cuda -i \"Wolfenstein 2 The New Colossus - Courthouse Battle ( I am death incarnate & no HUD ) 4k_60Fps [FuV63EEhS8c].webm\" -vf \"hue=h=45:s=0.7\" Wolfenstein_courthouse_battle.mp4\n# ffmpeg -y -vsync 0 -hwaccel_output_format cuda -i \"Wolfenstein 2 The New Colossus - Courthouse Battle ( I am death incarnate & no HUD ) 4k_60Fps [FuV63EEhS8c].webm\"  Wolfenstein_courthouse_battle.mp4\n# ffmpeg -y -vsync 0 -hwaccel vdpau -hwaccel_output_format vulkan -i \"Wolfenstein 2 The New Colossus - Courthouse Battle ( I am death incarnate & no HUD ) 4k_60Fps [FuV63EEhS8c].webm\"  Wolfenstein_courthouse_battle.mp4\n# ffmpeg -y -vsync 0 -hwaccel vulkan -hwaccel_output_format vulkan -i \"Wolfenstein 2 The New Colossus - Courthouse Battle ( I am death incarnate & no HUD ) 4k_60Fps [FuV63EEhS8c].webm\"  Wolfenstein_courthouse_battle.mp4\n# ffmpeg -y -vsync 0 -hwaccel cuda -hwaccel_output_format cuda -i \"Wolfenstein 2 The N",
        "type": "code",
        "location": "/tests/kaggle_yt_dls/transcode_nvenc.sh:1-11"
    },
    "3273": {
        "file_id": 393,
        "content": "This code uses FFmpeg to transcode a video file, applying a hue filter and saving the output as \"Wolfenstein_courthouse_battle.mp4\". It tests different hardware acceleration options (cuda, vdpau, vulkan) for video processing while specifying vsync 0 for disabling tearing. The code attempts to transcode the video using each of these hardware accelerations and saves the output file with the same name, overwriting previous outputs.",
        "type": "comment"
    },
    "3274": {
        "file_id": 393,
        "content": "ew Colossus - Courthouse Battle ( I am death incarnate & no HUD ) 4k_60Fps [FuV63EEhS8c].webm\"  Wolfenstein_courthouse_battle.mp4  # this is not avaliable. nvenc is not for everyone.\n# use vulkan or cuda. but vulkan is universal.\n# \"hue=H=30+10*cos(2*PI*t):s=0.2*cos(2*PI*t)+0.6\"",
        "type": "code",
        "location": "/tests/kaggle_yt_dls/transcode_nvenc.sh:11-14"
    },
    "3275": {
        "file_id": 393,
        "content": "This code specifies a video file name and mentions that NVENC is not for everyone, suggesting to use Vulkan or CUDA instead. It also includes a comment with potential Hue effects using trigonometric functions.",
        "type": "comment"
    },
    "3276": {
        "file_id": 394,
        "content": "/tests/karaoke_effects/clash_auto_update.py",
        "type": "filepath"
    },
    "3277": {
        "file_id": 394,
        "content": "This Flask application serves as a Clash proxy list server, updating every 30 minutes with two APIs. It includes three routes to manage proxies and runs on port 8677.",
        "type": "summary"
    },
    "3278": {
        "file_id": 394,
        "content": "import yaml\n# you know this source is gone for good.\n# target = \"https://openit.ml/Clash.yaml\"\n# import yaml\n# import requests\nimport os\n# yes visit this site without any proxy.\nos.environ[\"http_proxy\"] = \"\"\nos.environ[\"https_proxy\"] = \"\"\n# CLASH_CONFIG_DOWNLOAD_URL=\"https://raw.kgithub.com/yu-steven/openit/main/Clash.yaml\" # it is down!\n# ALL_PROXIES_LOCATION=[\"proxies\", \"✋ 手动选择\", \"all\"]\n# PROXY_GROUP_EXCEPTIONS = [\"👉 例外网站\"]\n# PROXY_GROUP_SPECIALS =[\"☁️ 全球直连\", \"🌐 节点选择\"]\n# CLASH_CONFIG_DOWNLOAD_URL = \"https://subconverter.speedupvpn.com/sub?target=clash&url=https%3A%2F%2Fjsd.cdn.zzko.cn%2Fgh%2FPawdroid%2FFree-servers%40main%2Fsub&insert=false&emoji=true&list=false&tfo=false&scv=false&fdn=false&sort=false&new_name=true\" # change this to the direct link you sucker.\nimport urllib.parse\n# DIRECT_LINK = \"https://github.com/Pawdroid/Free-servers\"\nDIRECT_LINK = \"https://github.com/Pawdroid/Free-servers/raw/main/sub\"\n## looking for a clash file merger.\n## merge multiple clash files into one.\n## evil!\nCLASH_CONFIG",
        "type": "code",
        "location": "/tests/karaoke_effects/clash_auto_update.py:1-30"
    },
    "3279": {
        "file_id": 394,
        "content": "This code is importing necessary libraries and environment variables to download a Clash configuration file from the internet. It updates the URL to a new direct link, removes proxy restrictions, and aims to merge multiple Clash files into one configuration.",
        "type": "comment"
    },
    "3280": {
        "file_id": 394,
        "content": "_DOWNLOAD_URL = f\"https://subconverter.speedupvpn.com/sub?target=clash&url={urllib.parse.quote_plus(DIRECT_LINK)}&insert=false&emoji=true&list=false&tfo=false&scv=false&fdn=false&sort=false&new_name=true\" # use quote_plus since the slash is not welcomed.\nALL_PROXIES_LOCATION = [\"proxies\", \"🔰 节点选择\", \"all\"]\nPROXY_GROUP_EXCEPTIONS = [\"🐟 漏网之鱼\"]\nPROXY_GROUP_SPECIALS = [\"🎯 全球直连\", \"🔰 节点选择\", \"♻️ 自动选择\"]\n# r = requests.get(target)\n# text = r.text\n# json_obj = yaml.safe_load(text)\n# port: 7890\n# socks5 port: 7891\n# controller: http://localhost:9090\n# PUT http://localhost:9090/providers/proxies/default\n# all_proxies_url = \"http://localhost:9090/proxies/\"\n# one_proxy_url = \"http://localhost:9090/proxies/{}\".format(proxy_name)\n# delay test url: http://localhost:9090/proxies/%F0%9F%87%A8%F0%9F%87%B3%20CN%2014%EF%BD%9Copenit.ml/delay?timeout=2000&url=https://www.baidu.com\nfrom loadSomeCustomClashYaml import goYamlToPyYaml, pyYamlToGoYaml\ndef jsonLocate(jsonObj, location=[]):\n    try:\n        if location != []:\n            return jsonLocate(jsonObj[location[0]], location[1:])",
        "type": "code",
        "location": "/tests/karaoke_effects/clash_auto_update.py:30-56"
    },
    "3281": {
        "file_id": 394,
        "content": "Code fetches clash configuration data from a URL, extracts necessary information like controller URL and proxy port numbers, and handles exceptions for non-matching group names. The code also defines URLs for accessing the proxy list or specific proxies, and includes a delay test URL to check connection speed. A function `jsonLocate` is used for locating values within a JSON object using a given location path.",
        "type": "comment"
    },
    "3282": {
        "file_id": 394,
        "content": "        return jsonObj\n    except:\n        print(\"KEY %s DOES NOT EXIST!\", \".\".join(location))\n        return None\ndef find_proxy_names(\n    test_url=\"http://localhost:9911/proxies/\", location=ALL_PROXIES_LOCATION\n):\n    import requests\n    r = requests.get(test_url)\n    import json\n    data = json.loads(r.text)\n    proxy_names = jsonLocate(data, location=location)\n    if proxy_names == None:\n        print(\"SOMEHOW WE FAILED TO FETCH THE PROXY LIST\")\n        return []\n    else:\n        return proxy_names\n## FIND DELAY ##\ndef find_tested_proxy_names(\n    timeout=3000,\n    urltest=\"https://m.tujia.com\",\n    test_url=\"http://localhost:9911/proxies/\",\n    location=ALL_PROXIES_LOCATION,\n    forbidden_names=[\"DIRECT\", \"REJECT\", \"GLOBAL\"],\n):\n    import requests\n    import json\n    proxy_names = find_proxy_names(test_url, location)\n    if proxy_names == []:\n        return []\n    def get_delay(name):\n        url = \"{}{}/delay?timeout={}&url={}\".format(test_url, name, timeout, urltest)\n        r = requests.get(url)\n        response_json = r.text",
        "type": "code",
        "location": "/tests/karaoke_effects/clash_auto_update.py:57-98"
    },
    "3283": {
        "file_id": 394,
        "content": "The code defines a function to find tested proxy names, utilizes the requests library for API calls, and uses JSON to locate data. The find_proxy_names function retrieves a list of proxy names from a specific URL and location. If unsuccessful, it returns an empty list. The find_tested_proxy_names function finds tested proxy names by calling find_proxy_names and then checks delays for each proxy name using the 'get_delay' function.",
        "type": "comment"
    },
    "3284": {
        "file_id": 394,
        "content": "        response_json = json.loads(response_json)\n        if \"delay\" in response_json.keys():\n            delay = response_json[\"delay\"]\n        else:\n            delay = None\n        return delay\n    direct_delay = get_delay(\"DIRECT\")\n    if direct_delay is None:\n        direct_delay = 300  # approximate delay 300ms\n    candidates = []\n    import progressbar  # 3 minutes.\n    for name in progressbar.progressbar(\n        [x for x in proxy_names if x not in forbidden_names]\n    ):\n        # if name in forbidden_names: continue\n        # delay = get_delay(name)\n        # if delay is not None:\n        candidates.append((name, 3))\n    print(\"PROXY CANDIDATES: %d\" % len(candidates))\n    for elem in candidates:\n        print(elem)\n    return candidates\ndef setClashProxy(proxy_name, control_port=9911):\n    import requests\n    import json\n    selector = \"GLOBAL\"\n    try:\n        r = requests.put(\n            \"http://localhost:{}/proxies/{}\".format(control_port, selector),\n            data=json.dumps({\"name\": proxy_name}, ensure_ascii=False).encode(),",
        "type": "code",
        "location": "/tests/karaoke_effects/clash_auto_update.py:99-133"
    },
    "3285": {
        "file_id": 394,
        "content": "Function to get proxy delay and return a list of candidates for setting the Clash proxy. First, it retrieves the delay for each proxy name from direct or API response, then creates a list of candidate proxies with a default delay of 300ms if not available. Finally, prints the number of candidate proxies and their names, returning the list.",
        "type": "comment"
    },
    "3286": {
        "file_id": 394,
        "content": "        )\n        assert r.status_code == 204\n        # assert r.status_code =\n    except:\n        import traceback\n        traceback.print_exc()\n        breakpoint()\n# with open(\"ClashBaseOpenIt.yaml\", 'r') as f:\n#     cachedDNSConfig = yaml.load(f,yaml.FullLoader)\ndef refineClashYaml(clashYamlPath=\"Clash3.yaml\", advanced=True):\n    with open(clashYamlPath, \"r\") as f:\n        data = f.read()\n    from loadSomeCustomClashYaml import goYamlToPyYaml, pyYamlToGoYaml\n    import yaml\n    data = goYamlToPyYaml(data)\n    data = yaml.safe_load(data)\n    data[\"port\"] = 8381\n    base_url = \"127.0.0.1:9911\"\n    data[\"external-controller\"] = base_url\n    if \"socks-port\" in data.keys():\n        del data[\"socks-port\"]\n    # breakpoint()\n    if advanced:\n        # print(data['proxies'])\n        key = \"proxy-groups\"\n        updatedProxy = []\n        updateIndex = 0\n        for index, proxy in enumerate(data[key]):\n            # breakpoint()\n            if proxy[\"name\"] in PROXY_GROUP_EXCEPTIONS:\n                # print(proxy)\n                # breakpoint()",
        "type": "code",
        "location": "/tests/karaoke_effects/clash_auto_update.py:134-173"
    },
    "3287": {
        "file_id": 394,
        "content": "This code defines a function `refineClashYaml` that takes a path to a Clash YAML configuration file and an optional \"advanced\" parameter. It opens the file, converts its contents from Go-style YAML to Python-friendly YAML, loads it using the `yaml.safe_load()` function, then modifies some fields (e.g., sets a new port and specifies a base URL). If \"advanced\" is True, it iterates through the \"proxy-groups\" section, removing certain proxies if they match a list of exceptions.",
        "type": "comment"
    },
    "3288": {
        "file_id": 394,
        "content": "                updateIndex = index\n                updatedProxy = proxy.copy()\n                updatedProxy[\"proxies\"] = [\n                    elem\n                    for elem in proxy[\"proxies\"]\n                    if elem not in PROXY_GROUP_SPECIALS\n                ]\n                updatedProxy[\"url\"] = \"https://media4.giphy.com\"\n                updatedProxy[\"interval\"] = 300\n                updatedProxy[\"tolerance\"] = 50\n                break\n        data[key][updateIndex] = updatedProxy\n        # for item in data['proxies']:\n        #     print(item)\n        # del data[\"rules\"]\n        # data[\"mode\"] = \"global\"\n    # data[\"dns\"] = cachedDNSConfig\n    data[\"dns\"] = {\n        \"enable\": True,\n        \"enhanced-mode\": \"redir-host\",\n        \"fake-ip-filter\": [\"*.lan\", \"localhost.ptlogin2.qq.com\"],\n        \"fake-ip-range\": \"198.18.0.1/16\",\n        \"fallback\": [\n            \"8.8.8.8\",\n            \"1.1.1.1\",\n            \"tls://dns.rubyfish.cn:853\",\n            \"tls://1.0.0.1:853\",\n            \"tls://dns.google:853\",",
        "type": "code",
        "location": "/tests/karaoke_effects/clash_auto_update.py:174-202"
    },
    "3289": {
        "file_id": 394,
        "content": "This code updates the proxy settings and DNS configuration for a program. It removes special proxies, sets new URL, interval, and tolerance values, and enables DNS with specific configurations like enhanced mode and fake IP range.",
        "type": "comment"
    },
    "3290": {
        "file_id": 394,
        "content": "            \"https://dns.rubyfish.cn/dns-query\",\n            \"https://cloudflare-dns.com/dns-query\",\n            \"https://dns.google/dns-query\",\n        ],\n        \"fallback-filter\": {\"geoip\": True, \"ipcidr\": [\"240.0.0.0/4\"]},\n        \"ipv6\": False,\n        \"listen\": \"0.0.0.0:61\",  # key?\n        \"nameserver\": [\n            \"223.5.5.5\",\n            \"180.76.76.76\",\n            \"119.29.29.29\",\n            \"117.50.10.10\",\n            \"114.114.114.114\",\n        ],\n    }\n    # data = pyYamlToGoYaml(data)\n    data_dump = yaml.safe_dump(data, allow_unicode=True)\n    data_dump = pyYamlToGoYaml(data_dump)\n    with open(clashYamlPath, \"w\") as f:\n        f.write(data_dump)\n    \"\"\"\n    import requests\n    import json\n    base_url =  \"http://127.0.0.1:9022\"\n    url = \"/proxies/\"\n    r = requests.put(base_url+url+\"GLOBAL\",data=json.dumps({\"name\":name},ensure_ascii=False).encode())\n    assert r.status_code == 204\n    \"\"\"\ndef getClashYaml(clashYamlPath=\"Clash3.yaml\", url: str = CLASH_CONFIG_DOWNLOAD_URL):\n    import requests\n    #",
        "type": "code",
        "location": "/tests/karaoke_effects/clash_auto_update.py:203-240"
    },
    "3291": {
        "file_id": 394,
        "content": "This code sets up a DNS server for Clash, a proxy tool. It provides a list of DNS servers and fallback filters to be used by the program. The data is converted to YAML format and written into a file named \"Clash3.yaml\". Then, it sends an HTTP PUT request to the Clash API endpoint to update the configuration.",
        "type": "comment"
    },
    "3292": {
        "file_id": 394,
        "content": " url = \"https://raw.githubusercontents.com/yu-steven/openit/main/Clash.yaml\" # some subtle difference!\n    # url = 'https://cdn.staticaly.com/gh/yu-steven/openit/main/Clash.yaml'\n    # url = \"https://raw.kgithub.com/yu-steven/openit/main/Clash.yaml\"\n    r = requests.get(url)\n    with open(clashYamlPath, \"w+\") as f:\n        f.write(r.text)\n    print(\"FETCHING CLASH YAML DONE.\")\n    print(\"SAVED AT %s\" % clashYamlPath)\nfrom lazero.program import asyncThread\n@asyncThread\ndef updateClashYaml(clashYamlPath=\"Clash3.yaml\", control_port=9911, advanced=True):\n    getClashYaml(clashYamlPath=clashYamlPath)\n    # if refine:\n    refineClashYaml(clashYamlPath=clashYamlPath, advanced=advanced)\n    import requests\n    import json\n    full_config_path = os.path.abspath(clashYamlPath)\n    try:\n        r = requests.put(\n            \"http://localhost:{}/configs\".format(control_port),\n            data=json.dumps({\"path\": full_config_path}, ensure_ascii=False).encode(),\n        )\n        # print('REPLY CONTENT:',r.content)\n        # breakpoint()",
        "type": "code",
        "location": "/tests/karaoke_effects/clash_auto_update.py:240-269"
    },
    "3293": {
        "file_id": 394,
        "content": "This code fetches the latest Clash YAML configuration file from a specified URL and saves it to a local file. It then updates the Clash configuration by sending the updated file path to the Clash control port. The function can be called asynchronously with optional arguments for the Clash YAML file name, control port, and advanced settings refinement.",
        "type": "comment"
    },
    "3294": {
        "file_id": 394,
        "content": "        assert r.status_code == 204\n        # might be the problem.\n        # TODO: check why the fuck clash server cannot decode the config in utf-8 'unexpected end of data'\n        print(\"SUCCESSFULLY UPDATED THIS PROXY LIST\")\n        return True\n    except:\n        import traceback\n        traceback.print_exc()\n        # breakpoint()\n        print(\"SOME ERROR WHILE FETCHING CLASH OPENIT SCRIPT\")\n        return False\n# this can act as a server as well?\n# simplicity in mind.\nimport schedule\nschedule.every(30).minutes.do(updateClashYaml)\nupdateClashYaml()\nfrom flask import Flask, request\nport = 8677\napp = Flask(__name__)\ndef checkProxyExists(proxy):\n    return proxy in find_proxy_names()\n# from typing import Union\n@app.route(\"/\", methods=[\"GET\"])\ndef serverHello():\n    try:\n        schedule.run_pending()\n    except:\n        pass\n    return \"clash update controller\"\n@app.route(\"/checkProxy\", methods=[\"GET\"])\ndef checkProxyAPI():\n    proxy = request.args[\"proxy\"]\n    print(\"CHECKING PROXY:\", proxy)\n    exists = checkProxyExists(proxy)",
        "type": "code",
        "location": "/tests/karaoke_effects/clash_auto_update.py:270-318"
    },
    "3295": {
        "file_id": 394,
        "content": "The code is a Flask application that acts as a server, updates the Clash proxy list every 30 minutes, and provides two APIs: one to check if a proxy exists in the list and another for fetching the Clash OpenIT script. An error message is displayed when there's an issue while fetching the script, and it prints the exception stack trace using traceback. The application runs on port 8677.",
        "type": "comment"
    },
    "3296": {
        "file_id": 394,
        "content": "    return {\"exists\": exists}\n@app.route(\"/useDirect\", methods=[\"GET\"])\ndef useDirectAPI():\n    proxy_name = \"DIRECT\"\n    schedule.run_pending()\n    setClashProxy(proxy_name)\n    return \"refresh proxy to %s\" % proxy_name\n@app.route(\"/refreshProxy\", methods=[\"GET\"])\ndef refreshProxyAPI():\n    suggest = None\n    if \"suggest\" in request.args.keys():\n        suggest = request.args[\"suggest\"]\n        print(\"SUGGESTED PROXY:\", suggest)\n    schedule.run_pending()\n    if suggest:\n        if checkProxyExists(suggest):\n            setClashProxy(suggest)\n            return \"refresh suggested proxy to %s\" % suggest\n    proxy_names = find_proxy_names()\n    if proxy_names == []:\n        return \"failed to find a proxy\"\n    import random\n    proxy_name = random.choice(proxy_names)\n    setClashProxy(proxy_name)\n    return \"refresh proxy to %s\" % proxy_name\nif __name__ == \"__main__\":\n    app.run(port=port, threaded=True, use_reloader=False)",
        "type": "code",
        "location": "/tests/karaoke_effects/clash_auto_update.py:319-353"
    },
    "3297": {
        "file_id": 394,
        "content": "The code defines three routes (\"/useDirect\", \"/refreshProxy\") and a function to set the Clash proxy. The \"/useDirect\" route sets the proxy directly to DIRECT. The \"/refreshProxy\" route, if a suggested proxy is provided in the request, sets it as the current proxy. If not, it randomly selects one from available proxies. The code also runs pending tasks and checks if a proxy exists before setting it.",
        "type": "comment"
    },
    "3298": {
        "file_id": 395,
        "content": "/tests/karaoke_effects/fastapi_translator.py",
        "type": "filepath"
    },
    "3299": {
        "file_id": 395,
        "content": "This code initializes a FastAPI app for translation and recognition with PaddleHub models, handles proxies, and creates API endpoints with error handling and caching. It returns a dictionary containing the result or a 400 status code.",
        "type": "summary"
    }
}