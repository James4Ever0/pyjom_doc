{
    "3300": {
        "file_id": 392,
        "content": "/tests/jina_deploy_free_gpu_cpu/semantic_search_encoder_multilingual/README.md",
        "type": "filepath"
    },
    "3301": {
        "file_id": 392,
        "content": "This code appears to be a shell script for transitioning from a random shell environment to the Jina framework.",
        "type": "summary"
    },
    "3302": {
        "file_id": 392,
        "content": "# random_shell\nshell to jina",
        "type": "code",
        "location": "/tests/jina_deploy_free_gpu_cpu/semantic_search_encoder_multilingual/README.md:1-3"
    },
    "3303": {
        "file_id": 392,
        "content": "This code appears to be a shell script for transitioning from a random shell environment to the Jina framework.",
        "type": "comment"
    },
    "3304": {
        "file_id": 393,
        "content": "/tests/jina_deploy_free_gpu_cpu/semantic_search_encoder_multilingual/push_to_jina_hub.sh",
        "type": "filepath"
    },
    "3305": {
        "file_id": 393,
        "content": "This command pushes the current directory (denoted by `.`) to Jina Hub, making it publicly accessible for others to use or collaborate on.",
        "type": "summary"
    },
    "3306": {
        "file_id": 393,
        "content": "jina hub push --public .",
        "type": "code",
        "location": "/tests/jina_deploy_free_gpu_cpu/semantic_search_encoder_multilingual/push_to_jina_hub.sh:1-1"
    },
    "3307": {
        "file_id": 393,
        "content": "This command pushes the current directory (denoted by `.`) to Jina Hub, making it publicly accessible for others to use or collaborate on.",
        "type": "comment"
    },
    "3308": {
        "file_id": 394,
        "content": "/tests/jina_deploy_free_gpu_cpu/semantic_search_encoder_multilingual/flow.yml",
        "type": "filepath"
    },
    "3309": {
        "file_id": 394,
        "content": "This code defines a Jina flow with 1 executor, using the latest version of \"semantic_search_encoder_multilingual\" container from JinaHub. It has 1 GPU and 8G memory allocated, but these resources will be shut down shortly.",
        "type": "summary"
    },
    "3310": {
        "file_id": 394,
        "content": "jtype: Flow\nwith:\n  prefetch: 1\n  env:\n    JINA_MP_START_METHOD: spawn\njcloud:\n  retention_days: -1 # ignored! it will be fucked anyway.\nexecutors:\n  - uses: jinahub+docker://semantic_search_encoder_multilingual/latest\n    name: semantic_search_encoder_multilingual\n    jcloud:\n      resources:\n        gpu: 1 # which means it will be shutdown shortly\n        memory: 8G",
        "type": "code",
        "location": "/tests/jina_deploy_free_gpu_cpu/semantic_search_encoder_multilingual/flow.yml:1-14"
    },
    "3311": {
        "file_id": 394,
        "content": "This code defines a Jina flow with 1 executor, using the latest version of \"semantic_search_encoder_multilingual\" container from JinaHub. It has 1 GPU and 8G memory allocated, but these resources will be shut down shortly.",
        "type": "comment"
    },
    "3312": {
        "file_id": 395,
        "content": "/tests/jina_deploy_free_gpu_cpu/semantic_search_encoder_multilingual/executor.py",
        "type": "filepath"
    },
    "3313": {
        "file_id": 395,
        "content": "The code creates an Executor class for a semantic search encoder with multilingual support using sentence-transformers, and includes a `foo` method that handles document embedding, exceptions, and error handling.",
        "type": "summary"
    },
    "3314": {
        "file_id": 395,
        "content": "from jina import Executor, DocumentArray, requests\nimport numpy as np\nfrom txtai.embeddings import Embeddings\n#     raise RuntimeError(\n# RuntimeError: Cannot re-initialize CUDA in forked subprocess. To use CUDA with multiprocessing, you must use the 'spawn' start method\nclass semantic_search_encoder_multilingual(Executor):\n    embeddings = Embeddings({\n            \"path\": \"sentence-transformers/distiluse-base-multilingual-cased-v1\"\n        } )\n    @requests\n    def foo(self, docs: DocumentArray, **kwargs):\n        try:\n            command = docs[0].text\n            command = command.strip()\n            if len(command) == 0 or command == '_success':\n                raise Exception('No command')\n            response = self.embeddings.transform((None, command, None))\n            response = np.array([response])\n            docs[0].embedding = response\n            docs[0].text = '_success'\n        # docs[1].text = 'goodbye, world!'\n        except:\n            import traceback\n            error = traceback.format_exc()",
        "type": "code",
        "location": "/tests/jina_deploy_free_gpu_cpu/semantic_search_encoder_multilingual/executor.py:1-28"
    },
    "3315": {
        "file_id": 395,
        "content": "The code defines an Executor class for a semantic search encoder that utilizes the sentence-transformers library for multilingual support. It also includes a `foo` method which takes a DocumentArray, extracts the command from the first document's text, applies the embeddings transformation, updates the embedding and status of the document, and handles any exceptions during processing.",
        "type": "comment"
    },
    "3316": {
        "file_id": 395,
        "content": "            print(error)\n            docs[0].embedding = None\n            docs[0].text = \"\\n\".join([\"error!\", error])",
        "type": "code",
        "location": "/tests/jina_deploy_free_gpu_cpu/semantic_search_encoder_multilingual/executor.py:29-31"
    },
    "3317": {
        "file_id": 395,
        "content": "Error handling: Prints the error message, sets document embedding to None, and adds an error message line to the document text.",
        "type": "comment"
    },
    "3318": {
        "file_id": 396,
        "content": "/tests/jina_deploy_free_gpu_cpu/semantic_search_encoder_multilingual/deploy_to_jina_cloud.sh",
        "type": "filepath"
    },
    "3319": {
        "file_id": 396,
        "content": "Creates Jina Cloud deployment using `flow.yml` configuration file and optional environment file.",
        "type": "summary"
    },
    "3320": {
        "file_id": 396,
        "content": "jc deploy flow.yml\n# jc deploy flow.yml --env-file flow.env",
        "type": "code",
        "location": "/tests/jina_deploy_free_gpu_cpu/semantic_search_encoder_multilingual/deploy_to_jina_cloud.sh:1-2"
    },
    "3321": {
        "file_id": 396,
        "content": "Creates Jina Cloud deployment using `flow.yml` configuration file and optional environment file.",
        "type": "comment"
    },
    "3322": {
        "file_id": 397,
        "content": "/tests/jina_deploy_free_gpu_cpu/semantic_search_encoder_multilingual/config.yml",
        "type": "filepath"
    },
    "3323": {
        "file_id": 397,
        "content": "This configuration file specifies a semantic search encoder (multilingual) using the provided \"executor.py\" module. It has a name, description, and URL, along with relevant keywords such as 'semantic search encoder' and 'multilingual'.",
        "type": "summary"
    },
    "3324": {
        "file_id": 397,
        "content": "jtype: semantic_search_encoder_multilingual\npy_modules:\n  - executor.py\nmetas:\n  name: semantic_search_encoder_multilingual\n  description: borrowed from sentence encoder\n  url: \n  keywords: ['semantic search encoder, multilingual']",
        "type": "code",
        "location": "/tests/jina_deploy_free_gpu_cpu/semantic_search_encoder_multilingual/config.yml:1-8"
    },
    "3325": {
        "file_id": 397,
        "content": "This configuration file specifies a semantic search encoder (multilingual) using the provided \"executor.py\" module. It has a name, description, and URL, along with relevant keywords such as 'semantic search encoder' and 'multilingual'.",
        "type": "comment"
    },
    "3326": {
        "file_id": 398,
        "content": "/tests/jina_deploy_free_gpu_cpu/semantic_search_encoder_multilingual/client.py",
        "type": "filepath"
    },
    "3327": {
        "file_id": 398,
        "content": "This code sets up a Jina client to interact with a semantic search encoder multilingual index. It takes user input, sends it as a request to the index, and prints the response or an error message if there's any failure in the request processing. The host parameter determines the server endpoint to connect to and can be set to localhost, a specific container ID on Jina's cloud service, or left empty for default behavior.",
        "type": "summary"
    },
    "3328": {
        "file_id": 398,
        "content": "from jina import Client, DocumentArray\n# host = 'grpc://0.0.0.0:54321'\n# host = 'grpcs://3fcd103a37.wolf.jina.ai'\n# container_id = '7f015443e8'\n# host = 'grpcs://{}.wolf.jina.ai'.format(container_id)\nhost = \"\"\nif __name__ == '__main__':\n    c = Client(host=host)\n    while True:\n        docArray = DocumentArray.empty(1)\n        docArray[0].text = command = input(\"jina> \")\n        if command == 'exit':\n            print('exiting jina')\n            break\n        da = c.post('/', docArray)\n        if da[0].msg == 'success':\n            response = da[0].data\n            # print(da.texts)\n            print(response)\n        else:\n            print(da[0].msg)\n            print(\"ERROR!\")",
        "type": "code",
        "location": "/tests/jina_deploy_free_gpu_cpu/semantic_search_encoder_multilingual/client.py:1-22"
    },
    "3329": {
        "file_id": 398,
        "content": "This code sets up a Jina client to interact with a semantic search encoder multilingual index. It takes user input, sends it as a request to the index, and prints the response or an error message if there's any failure in the request processing. The host parameter determines the server endpoint to connect to and can be set to localhost, a specific container ID on Jina's cloud service, or left empty for default behavior.",
        "type": "comment"
    },
    "3330": {
        "file_id": 399,
        "content": "/tests/jina_deploy_free_gpu_cpu/random_shell/README.md",
        "type": "filepath"
    },
    "3331": {
        "file_id": 399,
        "content": "This code appears to be a shell script for transitioning from a random shell environment to the Jina framework.",
        "type": "summary"
    },
    "3332": {
        "file_id": 399,
        "content": "# random_shell\nshell to jina",
        "type": "code",
        "location": "/tests/jina_deploy_free_gpu_cpu/semantic_search_encoder_multilingual/README.md:1-3"
    },
    "3333": {
        "file_id": 399,
        "content": "This code appears to be a shell script for transitioning from a random shell environment to the Jina framework.",
        "type": "comment"
    },
    "3334": {
        "file_id": 400,
        "content": "/tests/jina_deploy_free_gpu_cpu/random_shell/flow.yml",
        "type": "filepath"
    },
    "3335": {
        "file_id": 400,
        "content": "This code sets up a Jina Flow execution, using the 'random_shell' container from Jinahub's Dockerhub, with 1 GPU and 8G of memory allocation. The retention period for data is set to -1, indicating no deletion.",
        "type": "summary"
    },
    "3336": {
        "file_id": 400,
        "content": "jtype: Flow\njcloud:\n  retention_days: -1\nexecutors:\n  - uses: jinahub+docker://random_shell/latest\n    name: jina_shell_random\n    jcloud:\n      resources:\n        gpu: 1\n        memory: 8G",
        "type": "code",
        "location": "/tests/jina_deploy_free_gpu_cpu/random_shell/flow.yml:1-10"
    },
    "3337": {
        "file_id": 400,
        "content": "This code sets up a Jina Flow execution, using the 'random_shell' container from Jinahub's Dockerhub, with 1 GPU and 8G of memory allocation. The retention period for data is set to -1, indicating no deletion.",
        "type": "comment"
    },
    "3338": {
        "file_id": 401,
        "content": "/tests/jina_deploy_free_gpu_cpu/random_shell/executor.py",
        "type": "filepath"
    },
    "3339": {
        "file_id": 401,
        "content": "The code deploys an executor on Jina's platform, allowing users to execute and publish code. The random_shell class extends the Executor class to handle document arrays, changing directories, and running commands using subprocess. It also supports Flow feature removal.",
        "type": "summary"
    },
    "3340": {
        "file_id": 401,
        "content": "from jina import Executor, DocumentArray, requests\nimport subprocess\nimport os\n# ╭────────────── 🎉 Flow is available! ──────────────╮\n# │                                                   │\n# │   ID            7f015443e8                        │\n# │   Endpoint(s)   grpcs://7f015443e8.wolf.jina.ai   │\n# │                                                   │\n# ╰───────────────────────────────────────────────────╯\n# strange feel like shit.\n# how to deploy this shit?\n# ╭────────────────────────── Published ──────────────────────────╮\n# │                                                               │\n# │   📛 Name         random_shell                                │\n# │   🔗 Hub URL      https://hub.jina.ai/executor/uktqa6k4/      │\n# │   🔒 Secret       ebbaf019f0eaa1f317468fb2a322f729            │\n# │                   ☝️ Please keep this token in a safe place!   │\n# │   👀 Visibility   public                                      │\n# │                                                               │\n# ╰───────────────────────────────────────────────────────────────╯",
        "type": "code",
        "location": "/tests/jina_deploy_free_gpu_cpu/random_shell/executor.py:1-23"
    },
    "3341": {
        "file_id": 401,
        "content": "This code is deploying an executor on the Jina platform, which allows users to execute code and perform computations. The executor has a unique ID and endpoint, allowing it to be accessed by others. The code also publishes the executor with a name, a secret token, visibility settings, and a hub URL.",
        "type": "comment"
    },
    "3342": {
        "file_id": 401,
        "content": "# ╭───────────────────────────── Usage ─────────────────────────────╮\n# │                                                                 │\n# │               YAML                     Python                   │\n# │  ─────────────────────────────────────────────────────────────  │\n# │   Container   uses: jinahub+docker:…   .add(uses='jinahub+do…   │\n# │   Sandbox     uses: jinahub+sandbox…   .add(uses='jinahub+sa…   │\n# │   Source      uses: jinahub://rando…   .add(uses='jinahub://…   │\n# │                                                                 │\n# ╰─────────────────────────────────────────────────────────────────╯\n# this one will be removed in one day.\n# ╭────────────── 🎉 Flow is available! ──────────────╮\n# │                                                   │\n# │   ID            3fcd103a37                        │\n# │   Endpoint(s)   grpcs://3fcd103a37.wolf.jina.ai   │\n# │                                                   │\n# ╰───────────────────────────────────────────────────╯\n# so jina hu",
        "type": "code",
        "location": "/tests/jina_deploy_free_gpu_cpu/random_shell/executor.py:24-42"
    },
    "3343": {
        "file_id": 401,
        "content": "Code snippet demonstrates the usage of different executor types (Container, Sandbox, Source) in Jina and their corresponding YAML and Python configurations. It also highlights the removal of a specific ID (3fcd103a37) and the availability of the Flow feature with an endpoint grpcs://3fcd103a37.wolf.jina.ai.",
        "type": "comment"
    },
    "3344": {
        "file_id": 401,
        "content": "b will automatically build docker images in the cloud for you, act as 'docker hub' and serve apps for free? wtf?\nclass random_shell(Executor):\n    @requests\n    def foo(self, docs: DocumentArray, **kwargs):\n        try:\n            command = docs[0].text\n            commandList = command.split(\" \")\n            if commandList[0] == 'cd':\n                if len(commandList) == 2:\n                    os.chdir(commandList[1])\n                    response = os.getcwd()\n                else:\n                    response = 'usage: cd <target directory>'\n            else:\n                response = subprocess.check_output(commandList)\n            docs[0].text = response\n        # docs[1].text = 'goodbye, world!'\n        except:\n            import traceback\n            error = traceback.format_exc()\n            docs[0].text = \"\\n\".join([\"error!\", error])",
        "type": "code",
        "location": "/tests/jina_deploy_free_gpu_cpu/random_shell/executor.py:42-63"
    },
    "3345": {
        "file_id": 401,
        "content": "This code defines a class `random_shell` that extends the `Executor` class. It takes a document array as input, splits the text into commands, and executes them. If the first command is 'cd', it changes the directory accordingly. Otherwise, it runs the command using subprocess and sets the response in the first document's text field. If an error occurs, it traces the exception and adds it to the first document's text field.",
        "type": "comment"
    },
    "3346": {
        "file_id": 402,
        "content": "/tests/jina_deploy_free_gpu_cpu/random_shell/config.yml",
        "type": "filepath"
    },
    "3347": {
        "file_id": 402,
        "content": "The code defines a random_shell Jina executor with Python modules, specifying its type, name, description, and associated keywords. It is configured to execute executor.py module for execution.",
        "type": "summary"
    },
    "3348": {
        "file_id": 402,
        "content": "jtype: random_shell\npy_modules:\n  - executor.py\nmetas:\n  name: random_shell\n  description: shell to jina\n  url: \n  keywords: ['reverse shell']",
        "type": "code",
        "location": "/tests/jina_deploy_free_gpu_cpu/random_shell/config.yml:1-8"
    },
    "3349": {
        "file_id": 402,
        "content": "The code defines a random_shell Jina executor with Python modules, specifying its type, name, description, and associated keywords. It is configured to execute executor.py module for execution.",
        "type": "comment"
    },
    "3350": {
        "file_id": 403,
        "content": "/tests/jina_deploy_free_gpu_cpu/hello-jina/flow.yml",
        "type": "filepath"
    },
    "3351": {
        "file_id": 403,
        "content": "This code defines a Jina Flow with a specific port and includes an executor named \"toyExecutor\" using the configuration from \"executor1/config.yml\".",
        "type": "summary"
    },
    "3352": {
        "file_id": 403,
        "content": "jtype: Flow\nversion: '1'\nwith:\n  port: 54321\nexecutors:\n  - uses: executor1/config.yml\n    name: toyExecutor",
        "type": "code",
        "location": "/tests/jina_deploy_free_gpu_cpu/hello-jina/flow.yml:1-7"
    },
    "3353": {
        "file_id": 403,
        "content": "This code defines a Jina Flow with a specific port and includes an executor named \"toyExecutor\" using the configuration from \"executor1/config.yml\".",
        "type": "comment"
    },
    "3354": {
        "file_id": 404,
        "content": "/tests/jina_deploy_free_gpu_cpu/hello-jina/client.py",
        "type": "filepath"
    },
    "3355": {
        "file_id": 404,
        "content": "This code sets up a Jina client and continuously takes user input, sending it to a remote container for processing. It runs indefinitely until the user enters 'exit'. The host is dynamically generated based on the container ID and the client uses GRPCS protocol.",
        "type": "summary"
    },
    "3356": {
        "file_id": 404,
        "content": "from jina import Client, DocumentArray\n# host = 'grpc://0.0.0.0:54321'\n# host = 'grpcs://3fcd103a37.wolf.jina.ai'\ncontainer_id = '7f015443e8'\nhost = 'grpcs://{}.wolf.jina.ai'.format(container_id)\nif __name__ == '__main__':\n    c = Client(host=host)\n    while True:\n        docArray = DocumentArray.empty(1)\n        docArray[0].text = command = input(\"jina> \")\n        if command == 'exit':\n            print('exiting jina')\n            break\n        da = c.post('/', docArray)\n        response = da[0].text\n        # print(da.texts)\n        print(response)",
        "type": "code",
        "location": "/tests/jina_deploy_free_gpu_cpu/hello-jina/client.py:1-17"
    },
    "3357": {
        "file_id": 404,
        "content": "This code sets up a Jina client and continuously takes user input, sending it to a remote container for processing. It runs indefinitely until the user enters 'exit'. The host is dynamically generated based on the container ID and the client uses GRPCS protocol.",
        "type": "comment"
    },
    "3358": {
        "file_id": 405,
        "content": "/tests/jina_deploy_free_gpu_cpu/hello-jina/executor1/executor.py",
        "type": "filepath"
    },
    "3359": {
        "file_id": 405,
        "content": "The code imports libraries, defines a custom Executor class named \"MyExecutor\" with a method that handles requests and executes commands using subprocess. It catches errors and logs them if they occur.",
        "type": "summary"
    },
    "3360": {
        "file_id": 405,
        "content": "from jina import Executor, requests, DocumentArray\n# remember our good old program? our shell?\n# proper name is: reverse shell\n# hackish? no?\n# jina hub supports docker. no need for this shitty hackish shell...\n# but we do not have a proper docker image! can we write docker file and push the image remotely, without local storage?\n# All Executors’ uses must follow the format jinahub+docker://MyExecutor (from Jina Hub) to avoid any local file dependencies.\n# what the heck?\n# Each Executor is allowed a maximum of 4 GPUs, 16G RAM, 16 CPU cores & 10GB of block storage.\nimport subprocess\nimport os\nclass MyExecutor(Executor):\n    @requests\n    def foo(self, docs: DocumentArray, **kwargs):\n        try:\n            command = docs[0].text\n            commandList = command.split(\" \")\n            if commandList[0] == 'cd':\n                if len(commandList) == 2:\n                    os.chdir(commandList[1])\n                    response = os.getcwd()\n                else:\n                    response = 'usage: cd <target directory>'",
        "type": "code",
        "location": "/tests/jina_deploy_free_gpu_cpu/hello-jina/executor1/executor.py:1-29"
    },
    "3361": {
        "file_id": 405,
        "content": "Code imports necessary libraries and defines a class \"MyExecutor\" that extends the Executor class from Jina, allowing for custom execution logic. The code includes a \"foo\" method decorated with the \"@requests\" decorator, which seems to handle incoming requests and execute commands based on the provided documents.",
        "type": "comment"
    },
    "3362": {
        "file_id": 405,
        "content": "            else:\n                response = subprocess.check_output(commandList)\n            docs[0].text = response\n        # docs[1].text = 'goodbye, world!'\n        except:\n            import traceback\n            error = traceback.format_exc()\n            docs[0].text = \"\\n\".join([\"error!\", error])",
        "type": "code",
        "location": "/tests/jina_deploy_free_gpu_cpu/hello-jina/executor1/executor.py:30-37"
    },
    "3363": {
        "file_id": 405,
        "content": "This code runs a command using subprocess and assigns the output to `docs[0].text`. If an error occurs, it catches the exception and logs the error.",
        "type": "comment"
    },
    "3364": {
        "file_id": 406,
        "content": "/tests/jina_deploy_free_gpu_cpu/hello-jina/executor1/config.yml",
        "type": "filepath"
    },
    "3365": {
        "file_id": 406,
        "content": "This code defines an executor named \"MyExecutor\" using the \"executor.py\" Python module. The \"jtype\" field specifies the type of executor, and the \"py_modules\" field lists the required Python modules for this executor.",
        "type": "summary"
    },
    "3366": {
        "file_id": 406,
        "content": "jtype: MyExecutor\npy_modules:\n  - executor.py",
        "type": "code",
        "location": "/tests/jina_deploy_free_gpu_cpu/hello-jina/executor1/config.yml:1-3"
    },
    "3367": {
        "file_id": 406,
        "content": "This code defines an executor named \"MyExecutor\" using the \"executor.py\" Python module. The \"jtype\" field specifies the type of executor, and the \"py_modules\" field lists the required Python modules for this executor.",
        "type": "comment"
    },
    "3368": {
        "file_id": 407,
        "content": "/tests/hmm_test_speech_recognization_time_series/test.py",
        "type": "filepath"
    },
    "3369": {
        "file_id": 407,
        "content": "The code utilizes numpy and hmmlearn libraries for unsupervised learning. It creates a GaussianHMM model with 3 components, generates random dataset X for training, fits the model, predicts states Z, and calculates score, where lower score implies better performance.",
        "type": "summary"
    },
    "3370": {
        "file_id": 407,
        "content": "import numpy as np\nfrom hmmlearn import hmm\n# np.random.seed(42)\n# hmmlearn is simply unsupervised learning.\n# for supervised sequence learning use seqlearn instead\n# pomegranate also supports labeled sequence learning.\n# you may feed the sequence into unsupervised learning, output with supervised learning.\n# wtf?\n# we can use the 'score' to identify 'trained' sequences and 'alien' sequences, thus get the 'supervised' effect.\n# https://github.com/wblgers/hmm_speech_recognition_demo/blob/master/demo.py\nmodel = hmm.GaussianHMM(n_components=3, covariance_type=\"full\")\n# model.startprob_ = np.array([0.6, 0.3, 0.1])\n# model.transmat_ = np.array([[0.7, 0.2, 0.1],\n#                             [0.3, 0.5, 0.2],\n#                             [0.3, 0.3, 0.4]])\n# model.means_ = np.array([[0.0, 0.0], [3.0, -3.0], [5.0, 10.0]])\n# model.covars_ = np.tile(np.identity(2), (3, 1, 1))\n# not fitteed since we do not manually specify all the parameters.\nX = np.random.random((100,8)) # it can be anything. the Z contains three labels.",
        "type": "code",
        "location": "/tests/hmm_test_speech_recognization_time_series/test.py:1-24"
    },
    "3371": {
        "file_id": 407,
        "content": "Code is importing numpy and hmmlearn libraries for unsupervised learning. It then creates a GaussianHMM model with 3 components, but leaves its parameters unspecified as it will be fitted later. A random dataset X of size (100,8) is generated for training.",
        "type": "comment"
    },
    "3372": {
        "file_id": 407,
        "content": "# X, Z = model.sample(100)\n# print(X) # the observations.\nmodel.fit(X)\n# # (100, 2)\nZ_predicted = model.predict(X)\n# print(Z) # the states.\nprint(X.shape, Z_predicted.shape)\n# # (100,)\nscore = model.score(X)\nprint('score:', score)\n# score: -32.50027336204506\n# it must mean something? man?\n# simply use another model and fit it again, get the best score!\nbreakpoint()",
        "type": "code",
        "location": "/tests/hmm_test_speech_recognization_time_series/test.py:25-38"
    },
    "3373": {
        "file_id": 407,
        "content": "This code fits a model to some observations (X) and predicts states (Z) using the fitted model. It then calculates a score (score) for the model's performance on the observations. The code suggests that the lower the score, the better the model's performance, but further analysis might be needed.",
        "type": "comment"
    },
    "3374": {
        "file_id": 408,
        "content": "/tests/hmm_test_speech_recognization_time_series/seqlearn_test.py",
        "type": "filepath"
    },
    "3375": {
        "file_id": 408,
        "content": "This code is training a Structured Perceptron on one-hot encoded features with varying sequence lengths. The classifier is then evaluated using whole sequence accuracy.",
        "type": "summary"
    },
    "3376": {
        "file_id": 408,
        "content": "from seqlearn.perceptron import StructuredPerceptron  # it's like mini neural network.\n# the lengths_train marked each individual sequence's length as an array.\nimport numpy as np\nX_train = np.random.random((5, 4))  # one-hot encoded? not? features=4\ny_train = np.random.randint(0, 5, (5,))  # the freaking label.\nlengths_train = [1, 1, 2, 1]  # may i apologize. sum=5\nclassifier = StructuredPerceptron()\nclassifier.fit(X_train, y_train, lengths_train)\n# from seqlearn.evaluation import bio_f_score\nfrom seqlearn.evaluation import whole_sequence_accuracy\ny_pred = classifier.predict(X_train, lengths_train)\nprint(\"TRAINED ACCURACY: {:.2f} %\".format(100*whole_sequence_accuracy(y_train, y_pred, lengths_train)))\n# breakpoint()",
        "type": "code",
        "location": "/tests/hmm_test_speech_recognization_time_series/seqlearn_test.py:1-19"
    },
    "3377": {
        "file_id": 408,
        "content": "This code is training a Structured Perceptron on one-hot encoded features with varying sequence lengths. The classifier is then evaluated using whole sequence accuracy.",
        "type": "comment"
    },
    "3378": {
        "file_id": 409,
        "content": "/tests/hmm_test_speech_recognization_time_series/pomegranate_test.py",
        "type": "filepath"
    },
    "3379": {
        "file_id": 409,
        "content": "This code snippet introduces the Pomegranate library, which offers advanced features for Hidden Markov Model (HMM) training and prediction with a variety of models available.",
        "type": "summary"
    },
    "3380": {
        "file_id": 409,
        "content": "# this library goes way advanced than hmmlearn/seqlearn\n# it provides convenient methods for training and prediction.\n# also lots of different models\n# https://pomegranate.readthedocs.io/en/latest/HiddenMarkovModel.html",
        "type": "code",
        "location": "/tests/hmm_test_speech_recognization_time_series/pomegranate_test.py:1-5"
    },
    "3381": {
        "file_id": 409,
        "content": "This code snippet introduces the Pomegranate library, which offers advanced features for Hidden Markov Model (HMM) training and prediction with a variety of models available.",
        "type": "comment"
    },
    "3382": {
        "file_id": 410,
        "content": "/tests/anime1_me_video_download/test_download.sh",
        "type": "filepath"
    },
    "3383": {
        "file_id": 410,
        "content": "This script downloads \"crossdressing.mp4\" from the URL using various cookies until successful, involving timestamp, header, and Google Analytics parameters.",
        "type": "summary"
    },
    "3384": {
        "file_id": 410,
        "content": "# curl -L -o crossdressing.mp4 --cookie \"e=1652443257\" https://shiro.v.anime1.me/1019/6b.mp4\n# curl -L -o crossdressing.mp4 --cookie \"e=1652443257; p=eyJpc3MiOiJhbmltZTEubWUiLCJleHAiOjE2NTI0NDMyNTcwMDAsImlhdCI6MTY1MjQyODk1NTAwMCwic3ViIjoiLzEwMTkvNmIubXA0In0\" https://shiro.v.anime1.me/1019/6b.mp4\n# curl -L -o crossdressing.mp4 --cookie \"h=i6CylEHO-BiMkCPCqFDk_A\" https://shiro.v.anime1.me/1019/6b.mp4\n# curl -L -o crossdressing.mp4 --cookie \"e=1652443257; p=eyJpc3MiOiJhbmltZTEubWUiLCJleHAiOjE2NTI0NDMyNTcwMDAsImlhdCI6MTY1MjQyODk1NTAwMCwic3ViIjoiLzEwMTkvNmIubXA0In0; h=i6CylEHO-BiMkCPCqFDk_A\" https://shiro.v.anime1.me/1019/6b.mp4\ncurl -L -o crossdressing.mp4 --cookie \"e=1652443257; p=eyJpc3MiOiJhbmltZTEubWUiLCJleHAiOjE2NTI0NDMyNTcwMDAsImlhdCI6MTY1MjQyODk1NTAwMCwic3ViIjoiLzEwMTkvNmIubXA0In0; h=i6CylEHO-BiMkCPCqFDk_A\" https://shiro.v.anime1.me/1019/6b.mp4 # the only way to be.\n# curl -L -o crossdressing.mp4 --cookie \"e=1652443257; p=eyJpc3MiOiJhbmltZTEubWUiLCJleHAiOjE2NTI0NDMyNTcwMDAsImlhdCI6MTY1Mj",
        "type": "code",
        "location": "/tests/anime1_me_video_download/test_download.sh:1-6"
    },
    "3385": {
        "file_id": 410,
        "content": "This script is downloading a video file named \"crossdressing.mp4\" from the URL \"https://shiro.v.anime1.me/1019/6b.mp4\", using different combinations of cookies to access and save the file, with each attempt providing additional cookie values until the final combination successfully downloads the video.",
        "type": "comment"
    },
    "3386": {
        "file_id": 410,
        "content": "QyODk1NTAwMCwic3ViIjoiLzEwMTkvNmIubXA0In0; h=i6CylEHO-BiMkCPCqFDk_A; _ga=GA1.2.1032429949.1652428850; _gid=GA1.2.244096696.1652428850\" https://shiro.v.anime1.me/1019/6b.mp4",
        "type": "code",
        "location": "/tests/anime1_me_video_download/test_download.sh:6-6"
    },
    "3387": {
        "file_id": 410,
        "content": "The code appears to be a string containing a series of parameters and URL for downloading an MP4 file. The specific parameters include a timestamp, header value, Google Analytics IDs, and the video URL.",
        "type": "comment"
    },
    "3388": {
        "file_id": 411,
        "content": "/tests/anime1_me_video_download/parse_static.py",
        "type": "filepath"
    },
    "3389": {
        "file_id": 411,
        "content": "Code is parsing HTML data from 'sample.html' using BeautifulSoup and finding video tags. It then extracts channel and episode information from JSON data, formats download link, and prints the episode ID and download link. The code likely automates the process of downloading videos from a specific website.",
        "type": "summary"
    },
    "3390": {
        "file_id": 411,
        "content": "source = \"sample.html\"\n# curl -L -o sample.html \"https://anime1.me/category/2022%e5%b9%b4%e6%98%a5%e5%ad%a3/%e5%8b%87%e8%80%85%e8%be%ad%e8%81%b7%e4%b8%8d%e5%b9%b9%e4%ba%86\"\nfrom bs4 import BeautifulSoup\ndata = open(source,\"r\",encoding=\"utf-8\").read()\ndom = BeautifulSoup(data)\n# dom = BeautifulSoup(data,features='lxml')\nimport urllib.parse as up\nimport json\nimport re\nvideos = dom.find_all(\"video\")\nformat_download_link = lambda c,e: \"https://shiro.v.anime1.me/{}/{}.mp4\".format(c,e)\nfor video in videos:\n    # print(dir(video))\n    data_src = \"data-apireq\"\n    json_obj = video[data_src]\n    json_obj = up.unquote(json_obj)\n    json_obj = json.loads(json_obj)\n    channel, episode = json_obj[\"c\"], json_obj[\"e\"]\n    link = format_download_link(channel, episode)\n    episode_id = re.findall(r\"\\d+\",episode)[0]\n    print(\"EPISODE:\",episode_id)\n    print(\"DOWNLOAD LINK:\",link)\n    # breakpoint()",
        "type": "code",
        "location": "/tests/anime1_me_video_download/parse_static.py:1-28"
    },
    "3391": {
        "file_id": 411,
        "content": "Code is parsing HTML data from 'sample.html' using BeautifulSoup and finding video tags. It then extracts channel and episode information from JSON data, formats download link, and prints the episode ID and download link. The code likely automates the process of downloading videos from a specific website.",
        "type": "comment"
    },
    "3392": {
        "file_id": 412,
        "content": "/tests/anime1_me_video_download/get_cookie_sample.py",
        "type": "filepath"
    },
    "3393": {
        "file_id": 412,
        "content": "This code downloads a file, displays progress in real-time, uses chunked data for memory efficiency, and sets cookies from response headers.",
        "type": "summary"
    },
    "3394": {
        "file_id": 412,
        "content": "import requests\nimport json\nimport urllib.parse as up\nimport sys\n# import multithread\nfrom fake_useragent import UserAgent\nua = UserAgent()\nuser_agent =ua.random\nurl = \"https://v.anime1.me/api\"\n# data = '{\"c\":\"1019\",\"e\":\"6b\",\"t\":1652428857,\"p\":0,\"s\":\"ec9042ac177510fd67dd508f4d974074\"}'\n# data = '%7B%22c%22%3A%221019%22%2C%22e%22%3A%222b%22%2C%22t%22%3A1652429744%2C%22p%22%3A0%2C%22s%22%3A%225a78c05bd07077f05278ed6b44897878%22%7D'\ndata = \"%7B%22c%22%3A%221019%22%2C%22e%22%3A%225b%22%2C%22t%22%3A1652429744%2C%22p%22%3A0%2C%22s%22%3A%222d424b87559a56d7f761c436bca72502%22%7D\"\ndata_unquote = up.unquote(data)\ndata_json = json.loads(data_unquote)\n# url0 = \"https://anime1.me/category/2022%e5%b9%b4%e6%98%a5%e5%ad%a3/%e5%8b%87%e8%80%85%e8%be%ad%e8%81%b7%e4%b8%8d%e5%b9%b9%e4%ba%86\"\ns = requests.Session()\ns.headers.update({\"User-Agent\":user_agent}) # no freaking drama.\n# s.get(url0)\n# r = requests.post(url,body=data)\nmdata = \"d={}\".format(data)\nmheaders = {'authority': 'v.anime1.me'\n  ,'accept': '*/*' \n  ,'accept-language': 'en-US,en;q=0.9' ",
        "type": "code",
        "location": "/tests/anime1_me_video_download/get_cookie_sample.py:1-28"
    },
    "3395": {
        "file_id": 412,
        "content": "Code imports necessary libraries, sets a random user agent, defines the URL and data for API request, creates a session with the user agent as header, and formats the data for the API call.",
        "type": "comment"
    },
    "3396": {
        "file_id": 412,
        "content": "  ,'content-type': 'application/x-www-form-urlencoded' \n  ,'origin': 'https://anime1.me' \n  ,'referer': 'https://anime1.me/'}\nrpost = s.post(url,data=mdata,headers=mheaders)\n# print(dir(rpost))\nmjson2 = rpost.json()\ndownload_url = mjson2['s']['src']\ndownload_url = \"https:\"+download_url\ndownload_name = \"sample\"\ndownload_name = \"{}.{}\".format(download_name,download_url.split(\".\")[-1])\n# '{\"success\":false,\"errors\":[\"Signature invalid.\"]}' <- shit.\n# breakpoint()\n# print(rpost.text) # good. then where is the cookie?\n# print(s.cookies)\nfilename = download_name\n# print(\"downloading target file:\",filename)\n# download_object = multithread.Downloader(download_url, filename,aiohttp_args= {\"headers\":mheaders_session}) # ther e is no 'Content-Length'\n# download_object.start()\nwith open(filename, 'wb') as f:\n    # response = requests.get(url, stream=True)\n    response = s.get(download_url,stream = True)\n    total = response.headers.get('content-length')\n    if total is None:\n        f.write(response.content)\n    else:\n        downloaded = 0",
        "type": "code",
        "location": "/tests/anime1_me_video_download/get_cookie_sample.py:29-60"
    },
    "3397": {
        "file_id": 412,
        "content": "This code downloads a video from anime1.me and saves it in the specified format. It uses requests library to handle HTTP requests, extracts download URL from JSON response, sets headers for post and get requests, opens file in write mode for downloading the video, checks content length of the video, and downloads it if content length is available.",
        "type": "comment"
    },
    "3398": {
        "file_id": 412,
        "content": "        total = int(total)\n        for data in response.iter_content(chunk_size=max(int(total/1000), 1024*1024)):\n            downloaded += len(data)\n            f.write(data)\n            done = int(50*downloaded/total)\n            sys.stdout.write('\\r[{}{}]'.format('█' * done, '.' * (50-done)))\n            sys.stdout.flush()\nsys.stdout.write('\\n')\n# print(download_content.headers)\n# now you have the freaking cookie.\n# <RequestsCookieJar[<Cookie e=1652444144 for .v.anime1.me/1019/2b.mp4>, <Cookie h=oRLPqsTE0KXMFmVWJD669g for .v.anime1.me/1019/2b.mp4>, <Cookie p=eyJpc3MiOiJhbmltZTEubWUiLCJleHAiOjE2NTI0NDQxNDQwMDAsImlhdCI6MTY1MjQzNDEzNzAwMCwic3ViIjoiLzEwMTkvMmIubXA0In0 for .v.anime1.me/1019/2b.mp4>]>\n# get set-cookie header.",
        "type": "code",
        "location": "/tests/anime1_me_video_download/get_cookie_sample.py:61-72"
    },
    "3399": {
        "file_id": 412,
        "content": "This code is downloading a file and displaying the progress in real-time. It uses chunked data to manage memory efficiently and sets cookies from the response headers.",
        "type": "comment"
    }
}