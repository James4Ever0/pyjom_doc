{
    "3300": {
        "file_id": 394,
        "content": "/tests/jina_deploy_free_gpu_cpu/semantic_search_encoder_multilingual/client.py",
        "type": "filepath"
    },
    "3301": {
        "file_id": 394,
        "content": "This code sets up a Jina client to interact with a semantic search encoder multilingual index. It takes user input, sends it as a request to the index, and prints the response or an error message if there's any failure in the request processing. The host parameter determines the server endpoint to connect to and can be set to localhost, a specific container ID on Jina's cloud service, or left empty for default behavior.",
        "type": "summary"
    },
    "3302": {
        "file_id": 394,
        "content": "from jina import Client, DocumentArray\n# host = 'grpc://0.0.0.0:54321'\n# host = 'grpcs://3fcd103a37.wolf.jina.ai'\n# container_id = '7f015443e8'\n# host = 'grpcs://{}.wolf.jina.ai'.format(container_id)\nhost = \"\"\nif __name__ == '__main__':\n    c = Client(host=host)\n    while True:\n        docArray = DocumentArray.empty(1)\n        docArray[0].text = command = input(\"jina> \")\n        if command == 'exit':\n            print('exiting jina')\n            break\n        da = c.post('/', docArray)\n        if da[0].msg == 'success':\n            response = da[0].data\n            # print(da.texts)\n            print(response)\n        else:\n            print(da[0].msg)\n            print(\"ERROR!\")",
        "type": "code",
        "location": "/tests/jina_deploy_free_gpu_cpu/semantic_search_encoder_multilingual/client.py:1-22"
    },
    "3303": {
        "file_id": 394,
        "content": "This code sets up a Jina client to interact with a semantic search encoder multilingual index. It takes user input, sends it as a request to the index, and prints the response or an error message if there's any failure in the request processing. The host parameter determines the server endpoint to connect to and can be set to localhost, a specific container ID on Jina's cloud service, or left empty for default behavior.",
        "type": "comment"
    },
    "3304": {
        "file_id": 395,
        "content": "/tests/jina_deploy_free_gpu_cpu/random_shell/README.md",
        "type": "filepath"
    },
    "3305": {
        "file_id": 395,
        "content": "This code appears to be a shell script for transitioning from a random shell environment to the Jina framework.",
        "type": "summary"
    },
    "3306": {
        "file_id": 395,
        "content": "# random_shell\nshell to jina",
        "type": "code",
        "location": "/tests/jina_deploy_free_gpu_cpu/semantic_search_encoder_multilingual/README.md:1-3"
    },
    "3307": {
        "file_id": 395,
        "content": "This code appears to be a shell script for transitioning from a random shell environment to the Jina framework.",
        "type": "comment"
    },
    "3308": {
        "file_id": 396,
        "content": "/tests/jina_deploy_free_gpu_cpu/random_shell/flow.yml",
        "type": "filepath"
    },
    "3309": {
        "file_id": 396,
        "content": "This code sets up a Jina Flow execution, using the 'random_shell' container from Jinahub's Dockerhub, with 1 GPU and 8G of memory allocation. The retention period for data is set to -1, indicating no deletion.",
        "type": "summary"
    },
    "3310": {
        "file_id": 396,
        "content": "jtype: Flow\njcloud:\n  retention_days: -1\nexecutors:\n  - uses: jinahub+docker://random_shell/latest\n    name: jina_shell_random\n    jcloud:\n      resources:\n        gpu: 1\n        memory: 8G",
        "type": "code",
        "location": "/tests/jina_deploy_free_gpu_cpu/random_shell/flow.yml:1-10"
    },
    "3311": {
        "file_id": 396,
        "content": "This code sets up a Jina Flow execution, using the 'random_shell' container from Jinahub's Dockerhub, with 1 GPU and 8G of memory allocation. The retention period for data is set to -1, indicating no deletion.",
        "type": "comment"
    },
    "3312": {
        "file_id": 397,
        "content": "/tests/jina_deploy_free_gpu_cpu/random_shell/executor.py",
        "type": "filepath"
    },
    "3313": {
        "file_id": 397,
        "content": "The code deploys an executor on Jina's platform, allowing users to execute and publish code. The random_shell class extends the Executor class to handle document arrays, changing directories, and running commands using subprocess. It also supports Flow feature removal.",
        "type": "summary"
    },
    "3314": {
        "file_id": 397,
        "content": "from jina import Executor, DocumentArray, requests\nimport subprocess\nimport os\n# â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ğŸ‰ Flow is available! â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\n# â”‚                                                   â”‚\n# â”‚   ID            7f015443e8                        â”‚\n# â”‚   Endpoint(s)   grpcs://7f015443e8.wolf.jina.ai   â”‚\n# â”‚                                                   â”‚\n# â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\n# strange feel like shit.\n# how to deploy this shit?\n# â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Published â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\n# â”‚                                                               â”‚\n# â”‚   ğŸ“› Name         random_shell                                â”‚\n# â”‚   ğŸ”— Hub URL      https://hub.jina.ai/executor/uktqa6k4/      â”‚\n# â”‚   ğŸ”’ Secret       ebbaf019f0eaa1f317468fb2a322f729            â”‚\n# â”‚                   â˜ï¸ Please keep this token in a safe place!   â”‚\n# â”‚   ğŸ‘€ Visibility   public                                      â”‚\n# â”‚                                                               â”‚\n# â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯",
        "type": "code",
        "location": "/tests/jina_deploy_free_gpu_cpu/random_shell/executor.py:1-23"
    },
    "3315": {
        "file_id": 397,
        "content": "This code is deploying an executor on the Jina platform, which allows users to execute code and perform computations. The executor has a unique ID and endpoint, allowing it to be accessed by others. The code also publishes the executor with a name, a secret token, visibility settings, and a hub URL.",
        "type": "comment"
    },
    "3316": {
        "file_id": 397,
        "content": "# â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Usage â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\n# â”‚                                                                 â”‚\n# â”‚               YAML                     Python                   â”‚\n# â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚\n# â”‚   Container   uses: jinahub+docker:â€¦   .add(uses='jinahub+doâ€¦   â”‚\n# â”‚   Sandbox     uses: jinahub+sandboxâ€¦   .add(uses='jinahub+saâ€¦   â”‚\n# â”‚   Source      uses: jinahub://randoâ€¦   .add(uses='jinahub://â€¦   â”‚\n# â”‚                                                                 â”‚\n# â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\n# this one will be removed in one day.\n# â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ğŸ‰ Flow is available! â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\n# â”‚                                                   â”‚\n# â”‚   ID            3fcd103a37                        â”‚\n# â”‚   Endpoint(s)   grpcs://3fcd103a37.wolf.jina.ai   â”‚\n# â”‚                                                   â”‚\n# â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\n# so jina hu",
        "type": "code",
        "location": "/tests/jina_deploy_free_gpu_cpu/random_shell/executor.py:24-42"
    },
    "3317": {
        "file_id": 397,
        "content": "Code snippet demonstrates the usage of different executor types (Container, Sandbox, Source) in Jina and their corresponding YAML and Python configurations. It also highlights the removal of a specific ID (3fcd103a37) and the availability of the Flow feature with an endpoint grpcs://3fcd103a37.wolf.jina.ai.",
        "type": "comment"
    },
    "3318": {
        "file_id": 397,
        "content": "b will automatically build docker images in the cloud for you, act as 'docker hub' and serve apps for free? wtf?\nclass random_shell(Executor):\n    @requests\n    def foo(self, docs: DocumentArray, **kwargs):\n        try:\n            command = docs[0].text\n            commandList = command.split(\" \")\n            if commandList[0] == 'cd':\n                if len(commandList) == 2:\n                    os.chdir(commandList[1])\n                    response = os.getcwd()\n                else:\n                    response = 'usage: cd <target directory>'\n            else:\n                response = subprocess.check_output(commandList)\n            docs[0].text = response\n        # docs[1].text = 'goodbye, world!'\n        except:\n            import traceback\n            error = traceback.format_exc()\n            docs[0].text = \"\\n\".join([\"error!\", error])",
        "type": "code",
        "location": "/tests/jina_deploy_free_gpu_cpu/random_shell/executor.py:42-63"
    },
    "3319": {
        "file_id": 397,
        "content": "This code defines a class `random_shell` that extends the `Executor` class. It takes a document array as input, splits the text into commands, and executes them. If the first command is 'cd', it changes the directory accordingly. Otherwise, it runs the command using subprocess and sets the response in the first document's text field. If an error occurs, it traces the exception and adds it to the first document's text field.",
        "type": "comment"
    },
    "3320": {
        "file_id": 398,
        "content": "/tests/jina_deploy_free_gpu_cpu/random_shell/config.yml",
        "type": "filepath"
    },
    "3321": {
        "file_id": 398,
        "content": "The code defines a random_shell Jina executor with Python modules, specifying its type, name, description, and associated keywords. It is configured to execute executor.py module for execution.",
        "type": "summary"
    },
    "3322": {
        "file_id": 398,
        "content": "jtype: random_shell\npy_modules:\n  - executor.py\nmetas:\n  name: random_shell\n  description: shell to jina\n  url: \n  keywords: ['reverse shell']",
        "type": "code",
        "location": "/tests/jina_deploy_free_gpu_cpu/random_shell/config.yml:1-8"
    },
    "3323": {
        "file_id": 398,
        "content": "The code defines a random_shell Jina executor with Python modules, specifying its type, name, description, and associated keywords. It is configured to execute executor.py module for execution.",
        "type": "comment"
    },
    "3324": {
        "file_id": 399,
        "content": "/tests/jina_deploy_free_gpu_cpu/hello-jina/flow.yml",
        "type": "filepath"
    },
    "3325": {
        "file_id": 399,
        "content": "This code defines a Jina Flow with a specific port and includes an executor named \"toyExecutor\" using the configuration from \"executor1/config.yml\".",
        "type": "summary"
    },
    "3326": {
        "file_id": 399,
        "content": "jtype: Flow\nversion: '1'\nwith:\n  port: 54321\nexecutors:\n  - uses: executor1/config.yml\n    name: toyExecutor",
        "type": "code",
        "location": "/tests/jina_deploy_free_gpu_cpu/hello-jina/flow.yml:1-7"
    },
    "3327": {
        "file_id": 399,
        "content": "This code defines a Jina Flow with a specific port and includes an executor named \"toyExecutor\" using the configuration from \"executor1/config.yml\".",
        "type": "comment"
    },
    "3328": {
        "file_id": 400,
        "content": "/tests/jina_deploy_free_gpu_cpu/hello-jina/client.py",
        "type": "filepath"
    },
    "3329": {
        "file_id": 400,
        "content": "This code sets up a Jina client and continuously takes user input, sending it to a remote container for processing. It runs indefinitely until the user enters 'exit'. The host is dynamically generated based on the container ID and the client uses GRPCS protocol.",
        "type": "summary"
    },
    "3330": {
        "file_id": 400,
        "content": "from jina import Client, DocumentArray\n# host = 'grpc://0.0.0.0:54321'\n# host = 'grpcs://3fcd103a37.wolf.jina.ai'\ncontainer_id = '7f015443e8'\nhost = 'grpcs://{}.wolf.jina.ai'.format(container_id)\nif __name__ == '__main__':\n    c = Client(host=host)\n    while True:\n        docArray = DocumentArray.empty(1)\n        docArray[0].text = command = input(\"jina> \")\n        if command == 'exit':\n            print('exiting jina')\n            break\n        da = c.post('/', docArray)\n        response = da[0].text\n        # print(da.texts)\n        print(response)",
        "type": "code",
        "location": "/tests/jina_deploy_free_gpu_cpu/hello-jina/client.py:1-17"
    },
    "3331": {
        "file_id": 400,
        "content": "This code sets up a Jina client and continuously takes user input, sending it to a remote container for processing. It runs indefinitely until the user enters 'exit'. The host is dynamically generated based on the container ID and the client uses GRPCS protocol.",
        "type": "comment"
    },
    "3332": {
        "file_id": 401,
        "content": "/tests/jina_deploy_free_gpu_cpu/hello-jina/executor1/executor.py",
        "type": "filepath"
    },
    "3333": {
        "file_id": 401,
        "content": "The code imports libraries, defines a custom Executor class named \"MyExecutor\" with a method that handles requests and executes commands using subprocess. It catches errors and logs them if they occur.",
        "type": "summary"
    },
    "3334": {
        "file_id": 401,
        "content": "from jina import Executor, requests, DocumentArray\n# remember our good old program? our shell?\n# proper name is: reverse shell\n# hackish? no?\n# jina hub supports docker. no need for this shitty hackish shell...\n# but we do not have a proper docker image! can we write docker file and push the image remotely, without local storage?\n# All Executorsâ€™ uses must follow the format jinahub+docker://MyExecutor (from Jina Hub) to avoid any local file dependencies.\n# what the heck?\n# Each Executor is allowed a maximum of 4 GPUs, 16G RAM, 16 CPU cores & 10GB of block storage.\nimport subprocess\nimport os\nclass MyExecutor(Executor):\n    @requests\n    def foo(self, docs: DocumentArray, **kwargs):\n        try:\n            command = docs[0].text\n            commandList = command.split(\" \")\n            if commandList[0] == 'cd':\n                if len(commandList) == 2:\n                    os.chdir(commandList[1])\n                    response = os.getcwd()\n                else:\n                    response = 'usage: cd <target directory>'",
        "type": "code",
        "location": "/tests/jina_deploy_free_gpu_cpu/hello-jina/executor1/executor.py:1-29"
    },
    "3335": {
        "file_id": 401,
        "content": "Code imports necessary libraries and defines a class \"MyExecutor\" that extends the Executor class from Jina, allowing for custom execution logic. The code includes a \"foo\" method decorated with the \"@requests\" decorator, which seems to handle incoming requests and execute commands based on the provided documents.",
        "type": "comment"
    },
    "3336": {
        "file_id": 401,
        "content": "            else:\n                response = subprocess.check_output(commandList)\n            docs[0].text = response\n        # docs[1].text = 'goodbye, world!'\n        except:\n            import traceback\n            error = traceback.format_exc()\n            docs[0].text = \"\\n\".join([\"error!\", error])",
        "type": "code",
        "location": "/tests/jina_deploy_free_gpu_cpu/hello-jina/executor1/executor.py:30-37"
    },
    "3337": {
        "file_id": 401,
        "content": "This code runs a command using subprocess and assigns the output to `docs[0].text`. If an error occurs, it catches the exception and logs the error.",
        "type": "comment"
    },
    "3338": {
        "file_id": 402,
        "content": "/tests/jina_deploy_free_gpu_cpu/hello-jina/executor1/config.yml",
        "type": "filepath"
    },
    "3339": {
        "file_id": 402,
        "content": "This code defines an executor named \"MyExecutor\" using the \"executor.py\" Python module. The \"jtype\" field specifies the type of executor, and the \"py_modules\" field lists the required Python modules for this executor.",
        "type": "summary"
    },
    "3340": {
        "file_id": 402,
        "content": "jtype: MyExecutor\npy_modules:\n  - executor.py",
        "type": "code",
        "location": "/tests/jina_deploy_free_gpu_cpu/hello-jina/executor1/config.yml:1-3"
    },
    "3341": {
        "file_id": 402,
        "content": "This code defines an executor named \"MyExecutor\" using the \"executor.py\" Python module. The \"jtype\" field specifies the type of executor, and the \"py_modules\" field lists the required Python modules for this executor.",
        "type": "comment"
    },
    "3342": {
        "file_id": 403,
        "content": "/tests/blur_image_detection_mask/test_blur_detection.py",
        "type": "filepath"
    },
    "3343": {
        "file_id": 403,
        "content": "This code imports necessary modules, reads an image, applies blur detection algorithm using blur_detector.detectBlur(img), displays the original image and blur map using cv2.imshow(), and waits for user input before closing the windows with cv2.waitKey(0).",
        "type": "summary"
    },
    "3344": {
        "file_id": 403,
        "content": "from lazero.utils.importers import cv2_custom_build_init\ncv2_custom_build_init()\nimport blur_detector\nimport cv2\nimagePath = \"/root/Desktop/works/pyjom/samples/image/dog_blue_sky_split_line.png\"\nif __name__ == '__main__':\n    img = cv2.imread(imagePath,0)\n    blur_map = blur_detector.detectBlur(img, downsampling_factor=4, num_scales=4, scale_start=2, num_iterations_RF_filter=3)\n    cv2.imshow('ori_img', img)\n    cv2.imshow('blur_map', blur_map)\n    cv2.waitKey(0)",
        "type": "code",
        "location": "/tests/blur_image_detection_mask/test_blur_detection.py:1-12"
    },
    "3345": {
        "file_id": 403,
        "content": "This code imports necessary modules, reads an image, applies blur detection algorithm using blur_detector.detectBlur(img), displays the original image and blur map using cv2.imshow(), and waits for user input before closing the windows with cv2.waitKey(0).",
        "type": "comment"
    },
    "3346": {
        "file_id": 404,
        "content": "/tests/blur_image_detection_mask/BlurDetection_install/test.py",
        "type": "filepath"
    },
    "3347": {
        "file_id": 404,
        "content": "The code detects and removes watermarks, crops images, performs inpainting, adjusts text area ratios, and displays images. It identifies contours and draws bounding boxes for detection.",
        "type": "summary"
    },
    "3348": {
        "file_id": 404,
        "content": "# order:\n# detect if dog/cat is there, satisfying the qualification\n# remove watermark, remove text, remove potential watermark around corners using inpainting\n# use ffmpeg cropdetect, if has significant area change then no further processing\n# if no significant area change, use this blur detection to get the main area\n# remove watermark again?? around corners?\n# then reuse the dog detection and get the crop from processed/cropped image.\nimport os\n# from cv2 import waitKey\nfrom lazero.utils.importers import cv2_custom_build_init\ncv2_custom_build_init()\nimport cv2\nimport numpy\n# import logger\nimport BlurDetection\n# img_path = raw_input(\"Please Enter Image Path: \")\n# img_path = \"/root/Desktop/works/pyjom/samples/image/dog_blue_sky_split_line.png\"\n# img_path = \"/root/Desktop/works/pyjom/samples/image/blur_sample.webp\"\nimg_path = \"/root/Desktop/works/pyjom/samples/image/blur_sample_2.webp\"\n# img_path = \"/root/Desktop/works/pyjom/samples/image/dog_with_black_borders.png\"\n# ffmpeg -loop 1 -i /root/Desktop/works/pyjom/samples/image/dog_with_black_borders.png -t 15 -vf cropdetect -f null -",
        "type": "code",
        "location": "/tests/blur_image_detection_mask/BlurDetection_install/test.py:1-28"
    },
    "3349": {
        "file_id": 404,
        "content": "The code imports necessary libraries, initializes OpenCV, sets the image path, and starts by detecting if a dog or cat is present in the image. It then proceeds to remove watermarks, potentially using inpainting for corners, and checks for significant area changes with ffmpeg cropdetect. If no change, it uses blur detection for the main area. Finally, it may remove watermarks around corners again and reuses dog detection to get the final cropped image.",
        "type": "comment"
    },
    "3350": {
        "file_id": 404,
        "content": "# img_path=\"/root/Desktop/works/pyjom/samples/image/husky_cry.png\"\nassert os.path.exists(img_path), \"img_path does not exists\"\nimg = cv2.imread(img_path)\nimport sys\nsys.path.append(\"/root/Desktop/works/pyjom/\")\nfrom pyjom.imagetoolbox import imageFourCornersInpainting, getImageTextAreaRatio\nimg = imageFourCornersInpainting(img)\nimg = getImageTextAreaRatio(img, inpaint=True, edgeDetection=True)\nimg_fft, val, blurry = BlurDetection.blur_detector(img)\nprint(\"this image {0} blurry\".format([\"isn't\", \"is\"][blurry]))\nmsk, result, blurry = BlurDetection.blur_mask(img, max_thresh=120)\ninv_msk = 255 - msk\n# import numpy as np\n# print(np.max(msk), np.min(msk))\n# print(msk.shape)\n# breakpoint()\ndef display(title, img, max_size=200000):\n    assert isinstance(img, numpy.ndarray), \"img must be a numpy array\"\n    assert isinstance(title, str), \"title must be a string\"\n    scale = numpy.sqrt(min(1.0, float(max_size) / (img.shape[0] * img.shape[1])))\n    print(\"image is being scaled by a factor of {0}\".format(scale))\n    shape = (int(scale * img.shape[1]), int(scale * img.shape[0]))",
        "type": "code",
        "location": "/tests/blur_image_detection_mask/BlurDetection_install/test.py:29-57"
    },
    "3351": {
        "file_id": 404,
        "content": "This code performs blur detection and inpainting on an image. It first checks if the image path exists, reads the image using OpenCV, appends the necessary directory to the system path, applies four-corners inpainting and text area ratio adjustment, determines the blurriness of the image, and then uses the BlurDetection class for blur detection and mask generation. Finally, it displays the image with optional scaling and prints the maximum and minimum values of the mask.",
        "type": "comment"
    },
    "3352": {
        "file_id": 404,
        "content": "    img = cv2.resize(img, shape)\n    cv2.imshow(title, img)\n# BlurDetection.scripts.display('img', img)\ndisplay(\"img\", img)\n# display(\"msk\", msk)\ndisplay(\"inv_msk\", inv_msk)\n# Generate contours based on our mask\n# This function allows us to create a descending sorted list of contour areas.\n# def contour_area(contours):\n#     # create an empty list\n#     cnt_area = []\n#     # loop through all the contours\n#     for i in range(0, len(contours), 1):\n#         # for each contour, use OpenCV to calculate the area of the contour\n#         cnt_area.append(cv2.contourArea(contours[i]))\n#     # Sort our list of contour areas in descending order\n#     list.sort(cnt_area, reverse=True)\n#     return cnt_area\ndef draw_bounding_box_with_contour(\n    contours, image, area_threshold=20, debug=False\n):  # are you sure?\n    # this is the top-k approach.\n    # Call our function to get the list of contour areas\n    # cnt_area = contour_area(contours)\n    # Loop through each contour of our image\n    x0, y0, x1, y1 = [None] * 4\n    for i in range(0, len(contours), 1):",
        "type": "code",
        "location": "/tests/blur_image_detection_mask/BlurDetection_install/test.py:58-93"
    },
    "3353": {
        "file_id": 404,
        "content": "Resizes image, displays it with cv2.imshow, and calls the display function for other images. Defines a contour_area function to calculate and sort contour areas in descending order. Draws bounding boxes around the largest contours with the draw_bounding_box_with_contour function.",
        "type": "comment"
    },
    "3354": {
        "file_id": 404,
        "content": "        cnt = contours[i]\n        # Only draw the the largest number of boxes\n        if cv2.contourArea(cnt) > area_threshold:\n            # if (cv2.contourArea(cnt) > cnt_area[number_of_boxes]):\n            # Use OpenCV boundingRect function to get the details of the contour\n            x, y, w, h = cv2.boundingRect(cnt)\n            if x0 == None:\n                x0, y0, x1, y1 = x, y, x + w, y + h\n            if x < x0:\n                x0 = x\n            if y < y0:\n                y0 = y\n            if x + w > x1:\n                x1 = x + w\n            if y + h > y1:\n                y1 = y + h\n            # Draw the bounding box\n    if x0 is not None:\n        if debug:\n            image = cv2.rectangle(image, (x0, y0), (x1, y1), (0, 0, 255), 2)\n            cv2.imshow(\"with_bounding_box\", image)\n            cv2.waitKey(0)\n    if x0 is None:\n        height, width = image.shape[:2]\n        x0, y0, x1, y1 = 0, 0, width, height\n    return (x0, y0), (x1, y1)\n# BlurDetection.scripts.display('msk', msk)\ncontours, hierarchy = cv2.findContours(inv_msk, 1, 2)",
        "type": "code",
        "location": "/tests/blur_image_detection_mask/BlurDetection_install/test.py:94-126"
    },
    "3355": {
        "file_id": 404,
        "content": "This code finds contours in an image, selects the largest one based on area threshold, and calculates the bounding box coordinates. It then draws a rectangle around the detected contour (if debug is enabled) and returns the bounding box coordinates. The code also initializes the bounding box parameters if they are None.",
        "type": "comment"
    },
    "3356": {
        "file_id": 404,
        "content": "rectangle_boundingbox = draw_bounding_box_with_contour(contours, img, debug=True)\n# cv2.waitKey(0)",
        "type": "code",
        "location": "/tests/blur_image_detection_mask/BlurDetection_install/test.py:127-128"
    },
    "3357": {
        "file_id": 404,
        "content": "The code snippet detects contours and draws a bounding box around them using the function draw_bounding_box_with_contour. It also displays an image window with cv2.waitKey(0) but it is commented out, so it's not currently being executed.",
        "type": "comment"
    },
    "3358": {
        "file_id": 405,
        "content": "/tests/black_autopep8_ast_parser_formatter_skipexception/test.py",
        "type": "filepath"
    },
    "3359": {
        "file_id": 405,
        "content": "This code appears to be a mix of unrelated or incomplete fragments. It imports various modules but lacks cohesive structure, making it difficult to determine its purpose or functionality.",
        "type": "summary"
    },
    "3360": {
        "file_id": 405,
        "content": "# may be illegal.\n# use autopep8?\n# first, autopep8, next, black\n# both with 'unlimited' line of code.\n# finally, throw it to our dearly 'skipException'\n    from lib2to3.pgen2.pgen import DFAState\nfrom mimetypes import suffix_map\nfrom os import SCHED_FIFO\nfrom socket import _SendableFile\nfrom xml.dom.pulldom    import \\\n    SAX2DOM\n    print('aaa'\n        ) # there is no repairing on this bracket for autopep8\n# about the dog_or_cat recognition of our cover:\n# 1. throw away unqualified ones (using pop?)\n# 2. lower the threshold of yolo\n# 3. downscale picture before passing to yolo\n# we can go wild here.\n@redisLRUCache(dfsji,\nasdif[dfk,DFAState,\nsdfkg])\ndef shit(aaa, bbb,\nccc,ddd):\n    dd = 2314\n    ee = suffix_map[SAX2DOM,\n    df23, ddd][sdf,\n    sdf,sdf]\n    ss = efldife.dfief(_SendableFile,\n    saif,SCHED_FIFO,\n    asdif[fjisd,\n    sfdsif,sdf])",
        "type": "code",
        "location": "/tests/black_autopep8_ast_parser_formatter_skipexception/test.py:1-36"
    },
    "3361": {
        "file_id": 405,
        "content": "This code appears to be a mix of unrelated or incomplete fragments. It imports various modules but lacks cohesive structure, making it difficult to determine its purpose or functionality.",
        "type": "comment"
    },
    "3362": {
        "file_id": 406,
        "content": "/tests/black_autopep8_ast_parser_formatter_skipexception/format_test.sh",
        "type": "filepath"
    },
    "3363": {
        "file_id": 406,
        "content": "This code is formatting Python files, using autopep8 to enforce maximum line length and Black to ensure consistent formatting. It prevents changes on the original content by redirecting output to a view-only mode.",
        "type": "summary"
    },
    "3364": {
        "file_id": 406,
        "content": "# view only. no change on original content.\n# of course, for lines with long content, we will have trouble.\nMAXINT=1000000000\ncat test.py | autopep8 --max-line-length $MAXINT - | black -l $MAXINT -C - 2>/dev/null",
        "type": "code",
        "location": "/tests/black_autopep8_ast_parser_formatter_skipexception/format_test.sh:1-4"
    },
    "3365": {
        "file_id": 406,
        "content": "This code is formatting Python files, using autopep8 to enforce maximum line length and Black to ensure consistent formatting. It prevents changes on the original content by redirecting output to a view-only mode.",
        "type": "comment"
    },
    "3366": {
        "file_id": 407,
        "content": "/tests/black_autopep8_ast_parser_formatter_skipexception/format_functional.py",
        "type": "filepath"
    },
    "3367": {
        "file_id": 407,
        "content": "This code reads a Python file, encodes it, and then runs it through \"autopep8\" and \"Black\" formatting tools to ensure code follows PEP 8 style guide and is aesthetically pleasing. It also handles exceptions and prints the formatted code for further use.",
        "type": "summary"
    },
    "3368": {
        "file_id": 407,
        "content": "with open(\"test.py\", \"r\") as f:\n    code = f.read()\n# need binary data.\ncode_encoded = code.encode(\"utf-8\")\nimport subprocess\nMAXINT = 10000000000\ncommand = \"autopep8 --max-line-length {MAXINT} - | black -l {MAXINT} -C -\".format(\n    MAXINT=MAXINT\n)\ncommandLine = [\"bash\", \"-c\", command]\nresult = subprocess.run(commandLine, input=code_encoded, capture_output=True)\ntry:\n    assert result.returncode == 0\n    code_formatted = result.stdout.decode(\"utf-8\")\nexcept:\n    import traceback\n    traceback.print_exc()\n    print(\"STDOUT\", result.stdout)\n    print(\"STDERR\", result.stderr)\n    code_formatted = code\nprint(code_formatted)",
        "type": "code",
        "location": "/tests/black_autopep8_ast_parser_formatter_skipexception/format_functional.py:1-26"
    },
    "3369": {
        "file_id": 407,
        "content": "This code reads a Python file, encodes it, and then runs it through \"autopep8\" and \"Black\" formatting tools to ensure code follows PEP 8 style guide and is aesthetically pleasing. It also handles exceptions and prints the formatted code for further use.",
        "type": "comment"
    },
    "3370": {
        "file_id": 408,
        "content": "/tests/dump_python_dependencies/dump.py",
        "type": "filepath"
    },
    "3371": {
        "file_id": 408,
        "content": "This code generates a timestamp, creates a directory for storing logs, and uses os.system() to execute the \"pip3 list\" command, saving the output to a log file in the specified directory with the current timestamp as part of the filename.",
        "type": "summary"
    },
    "3372": {
        "file_id": 408,
        "content": "import datetime\nlog_dir = \"logs\"\nnow = datetime.datetime.now().isoformat().replace(\".\",\"_\").replace(\" \",\"_\")\nprint('DUMP TIME:',now)\ncmd = \"pip3 list > {}/py3_deps_{}.log\".format(log_dir,now)\nimport os\nif not os.path.exists(log_dir):\n    os.mkdir(log_dir)\nos.system(cmd)",
        "type": "code",
        "location": "/tests/dump_python_dependencies/dump.py:1-13"
    },
    "3373": {
        "file_id": 408,
        "content": "This code generates a timestamp, creates a directory for storing logs, and uses os.system() to execute the \"pip3 list\" command, saving the output to a log file in the specified directory with the current timestamp as part of the filename.",
        "type": "comment"
    },
    "3374": {
        "file_id": 409,
        "content": "/tests/editly_test_video_render_with_bgm/test.sh",
        "type": "filepath"
    },
    "3375": {
        "file_id": 409,
        "content": "This code sets up a headless Linux machine to run test cases for the Editly application using xvfb-run and specifying test parameters in a json5 file. It also discusses potential alternative methods and options for audio handling, resolution, and file playback.",
        "type": "summary"
    },
    "3376": {
        "file_id": 409,
        "content": "# run in headless linux machine! test both xvfp specs?\nxvfb-run -s \"-ac -screen 0 1280x1024x24\" editly test.json5  # this will suffice. json5 will specify all specs? or use our GUI service run specifications (envs)?\n# sometimes we have weird issues with the ffplay. use 'open' instead? does quicktime automatically repair the file by itself?\n# xvfb-run -s \"-ac -screen 0 1920x1080x24\" editly test.json5 --fast # this will suffice. json5 will specify all specs? this 'fast' setting definitely reduced the output resolution to 334x188 15fps, which just saves my time in final production or remote preview from n2n/frp\n# without --keep-source-audio, will we not hear anything from the source video?\n# json5: json for humans\n# this much likely to bring python dict and json objects into a single readable format.",
        "type": "code",
        "location": "/tests/editly_test_video_render_with_bgm/test.sh:1-11"
    },
    "3377": {
        "file_id": 409,
        "content": "This code sets up a headless Linux machine to run test cases for the Editly application using xvfb-run and specifying test parameters in a json5 file. It also discusses potential alternative methods and options for audio handling, resolution, and file playback.",
        "type": "comment"
    },
    "3378": {
        "file_id": 410,
        "content": "/tests/bilibili_tag_recommend_activities/README.md",
        "type": "filepath"
    },
    "3379": {
        "file_id": 410,
        "content": "Code snippet provides a link to another file, \"bilibili_up.py\", which contains information on how to get the 'upload_id' in bilibili API.",
        "type": "summary"
    },
    "3380": {
        "file_id": 410,
        "content": "[how to get upload_id](https://github.com/xunsword/bilibil/blob/2abf66a9771daebc12c181f88d8af82613975548/bilibili_up.py)",
        "type": "code",
        "location": "/tests/bilibili_tag_recommend_activities/README.md:1-1"
    },
    "3381": {
        "file_id": 410,
        "content": "Code snippet provides a link to another file, \"bilibili_up.py\", which contains information on how to get the 'upload_id' in bilibili API.",
        "type": "comment"
    },
    "3382": {
        "file_id": 411,
        "content": "/tests/elastic_search_engine/README.md",
        "type": "filepath"
    },
    "3383": {
        "file_id": 411,
        "content": "The code suggests that there is a need for a memory-efficient search engine, possibly due to limited resources. It also mentions Meilisearch as a potential option but expresses concerns about its memory intensity or the team's mastery of it.",
        "type": "summary"
    },
    "3384": {
        "file_id": 411,
        "content": "we need a memory efficient search engine, under limited memory.\nmeilisearch is memory intensive maybe? or just because we have not properly mastered it",
        "type": "code",
        "location": "/tests/elastic_search_engine/README.md:1-3"
    },
    "3385": {
        "file_id": 411,
        "content": "The code suggests that there is a need for a memory-efficient search engine, possibly due to limited resources. It also mentions Meilisearch as a potential option but expresses concerns about its memory intensity or the team's mastery of it.",
        "type": "comment"
    },
    "3386": {
        "file_id": 412,
        "content": "/tests/hyper_param_optimization/test.py",
        "type": "filepath"
    },
    "3387": {
        "file_id": 412,
        "content": "This code uses Hyperopt library for parameter optimization, chooses hyperparameters from different cases via choice function, and samples 10 times for each search space.",
        "type": "summary"
    },
    "3388": {
        "file_id": 412,
        "content": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\nfrom hyperopt import hp\n# usually this hyper parameter optimization is done regularlly, and the optimized parameters will be used for a while till next update.\n# but can we optimize these parameters offline?\n# if not offline then we can only use traditional machine learning instead...\n# or this trial and error process is actually a kind of offline machine learning, like random search and graph inference...\n# better use hyperopt with a discriminator ML algorithm.\n# space = hp.choice(\n#     \"a\",\n#     [(\"case 1\", 1 + hp.lognormal(\"c1\", 0, 1)), (\"case 2\", hp.uniform(\"c2\", -10, 10))],\n# )\nimport hyperopt.pyll.stochastic as stochastic\nspace = hp.choice(\"lambda\",[lambda :1, lambda:2]) # if it is lambda, function will not resolve. however, after passing this thing into the main criterion function, it will utilize the lambda function.\nfor _ in range(10):\n    sample = stochastic.sample(space)\n    print(\"SAMPLE:\", sample) # this will return the tuple. can we put some custom functions here?",
        "type": "code",
        "location": "/tests/hyper_param_optimization/test.py:1-24"
    },
    "3389": {
        "file_id": 412,
        "content": "This code uses the hyperopt library for parameter optimization. The hyperparameters are chosen from different cases using a choice function, including lambda functions. The space is sampled 10 times using stochastic sampling, and each sample is printed to the console.",
        "type": "comment"
    },
    "3390": {
        "file_id": 412,
        "content": "    # there must be some integrations with custom functions. for example: scikit-learn\nprint(\"_______________________________\") # splited.\nfrom hyperopt.pyll import scope\n@scope.define # this is how we sample the \"LAMBDA\".\ndef my_func(a,b=1):\n    print(\"running function my_func\", a,b)\n    return a*b\nspace_0 = scope.my_func(hp.choice(\"myChoice\",[1,2]))\nspace_1 = scope.my_func(hp.choice(\"myChoice\",[1,2]), hp.choice(\"myChoice2\",[2,3,4]))\nfor _ in range(10):\n    print(stochastic.sample(space_0), stochastic.sample(space_1))",
        "type": "code",
        "location": "/tests/hyper_param_optimization/test.py:25-40"
    },
    "3391": {
        "file_id": 412,
        "content": "This code defines and samples two hyperparameter search spaces using the Hyperopt library's Pyll module. The \"my_func\" function is defined within a scope, allowing for easy integration with custom functions like Scikit-Learn. It then prints and samples from these search spaces 10 times.",
        "type": "comment"
    },
    "3392": {
        "file_id": 413,
        "content": "/tests/hyper_param_optimization/README.md",
        "type": "filepath"
    },
    "3393": {
        "file_id": 413,
        "content": "This code provides a reference to the tutorials section and official documentation of the hyperopt library, found on its GitHub repository.",
        "type": "summary"
    },
    "3394": {
        "file_id": 413,
        "content": "[tutorials](https://github.com/hyperopt/hyperopt/wiki/FMin) found from [official documentation](http://hyperopt.github.io/hyperopt/) of [hyperopt](https://github.com/hyperopt/hyperopt).",
        "type": "code",
        "location": "/tests/hyper_param_optimization/README.md:1-1"
    },
    "3395": {
        "file_id": 413,
        "content": "This code provides a reference to the tutorials section and official documentation of the hyperopt library, found on its GitHub repository.",
        "type": "comment"
    },
    "3396": {
        "file_id": 414,
        "content": "/tests/hyper_param_optimization/optimize_suggest.py",
        "type": "filepath"
    },
    "3397": {
        "file_id": 414,
        "content": "Code defines a function and uses Hyperopt's Tree-structured Parzen Estimators (TPE) algorithm to optimize the given function. It sets the hyperparameter space using hp.uniform and runs 100 trials, printing the result of the best trial.",
        "type": "summary"
    },
    "3398": {
        "file_id": 414,
        "content": "from hyperopt import tpe, fmin, hp, STATUS_OK, STATUS_FAIL\nimport requests\ndef function(x):\n    print(\"trying timeout:\",x)\n    # result = x**2\n    status = STATUS_FAIL\n    try:\n        r = requests.get('https://www.baidu.com/', timeout=x)\n        if r.status_code == 200:\n            status = STATUS_OK\n    except:\n        print(\"FAILED WITH TIMEOUT:\", x) # this will rule out the unwanted ones.\n    return {\"loss\":x, \"status\":status}\nspace = hp.uniform(\"param\",0,2)\nresult = fmin(fn=function, space=space, algo=tpe.suggest, max_evals=100)\nprint(result)\n# {'param': 0.10165862536290635}\n# really working? 100ms could be so damn short...\n# by using `Trials` we could inspect results of every trial.",
        "type": "code",
        "location": "/tests/hyper_param_optimization/optimize_suggest.py:1-21"
    },
    "3399": {
        "file_id": 414,
        "content": "Code defines a function and uses Hyperopt's Tree-structured Parzen Estimators (TPE) algorithm to optimize the given function. It sets the hyperparameter space using hp.uniform and runs 100 trials, printing the result of the best trial.",
        "type": "comment"
    }
}