{
    "3300": {
        "file_id": 395,
        "content": "import os\n# before that, we need to fix cv2\nimport pathlib\nimport sys\nfrom isort import stream\nsite_path = pathlib.Path(\"/usr/local/lib/python3.9/site-packages\")\ncv2_libs_dir = (\n    site_path / \"cv2\" / f\"python-{sys.version_info.major}.{sys.version_info.minor}\"\n)\nprint(cv2_libs_dir)\ncv2_libs = sorted(cv2_libs_dir.glob(\"*.so\"))\nif len(cv2_libs) == 1:\n    print(\"INSERTING:\", cv2_libs[0].parent)\n    sys.path.insert(1, str(cv2_libs[0].parent))\nclash_http_port = 8381\n# wtf is wrong with this shit?\ndef useProxy(flag):\n    if flag:\n        os.environ[\"http_proxy\"] = \"http://127.0.0.1:{}\".format(clash_http_port)\n        os.environ[\"https_proxy\"] = \"http://127.0.0.1:{}\".format(clash_http_port)\n    else:\n        os.environ[\"http_proxy\"] = \"\"\n        os.environ[\"https_proxy\"] = \"\"\nfrom fastapi import FastAPI\napp = FastAPI()\n# import time\n# you want to wait? or you want to swap?\nimport paddlehub as hub\nlanguage_translation_model = hub.Module(name=\"baidu_translate\")\nlanguage_recognition_model = hub.Module(name=\"baidu_language_recognition\")",
        "type": "code",
        "location": "/tests/karaoke_effects/fastapi_translator.py:1-41"
    },
    "3301": {
        "file_id": 395,
        "content": "The code is importing necessary packages, fixing cv2 library path, setting a clash HTTP port, defining a function to use or unset proxies, and initializing FastAPI application along with two PaddleHub models for language translation and recognition.",
        "type": "comment"
    },
    "3302": {
        "file_id": 395,
        "content": "def baiduTranslator(text, sleep=1):  # target language must be chinese.\n    useProxy(False)\n    import filelock\n    lock = filelock.FileLock(\n        \"/root/Desktop/works/pyjom/tests/karaoke_effects/baidu_translator.lock\"\n    )\n    with lock:\n        import time\n        time.sleep(sleep)\n        try:\n            language_code = language_recognition_model.recognize(text)\n            if language_code != \"zh\":\n                text_prompts = language_translation_model.translate(\n                    text, language_code, \"zh\"\n                )\n                translatedText = text_prompts\n            else:\n                translatedText = text\n            return translatedText\n        except:\n            import traceback\n            traceback.print_exc()\n            print(\"ERROR ON BAIDU TRANSLATOR\")\n            return None\nfrom lazero.network.proxy.clash import (\n    getTestedProxyList,\n    setProxyWithSelector,\n    clashProxyStateManager,\n)\nproxyList = []\nrefreshProxyCounter = 0\ndef deeplTranslator(text, sleep=2, timeout=5, mod=40):",
        "type": "code",
        "location": "/tests/karaoke_effects/fastapi_translator.py:44-83"
    },
    "3303": {
        "file_id": 395,
        "content": "This code defines two translation functions, `baiduTranslator` and `deeplTranslator`, which use the Baidu and DeepL APIs respectively. The `baiduTranslator` function requires the target language to be in Chinese. It uses a file lock for synchronization, performs language recognition and translation, and handles any exceptions that may occur during translation. The `deeplTranslator` function also performs translation using the DeepL API but with additional options for sleep time, timeout, and modification mode. Both functions return translated text or None if an error occurs.",
        "type": "comment"
    },
    "3304": {
        "file_id": 395,
        "content": "    global proxyList, refreshProxyCounter\n    useProxy(False)\n    import random\n    if (\n        refreshProxyCounter % mod == 0\n    ):  # make sure it will be launched at the first request.\n        proxyList = getTestedProxyList()\n        refreshProxyCounter %= mod\n    refreshProxyCounter += 1\n    proxyName = random.choice([proxy[\"name\"] for proxy in proxyList] + [\"DIRECT\"])\n    setProxyWithSelector(proxyName)\n    # better use proxy instead. you need to config it here, and make sure the deepl adaptor uses the proxy.\n    import requests\n    import time\n    import filelock\n    lock = filelock.FileLock(\n        \"/root/Desktop/works/pyjom/tests/karaoke_effects/deepl_translator.lock\"\n    )\n    with clashProxyStateManager(\"Global\", \"Rule\"):\n        with lock:\n            time.sleep(sleep)\n            port = 8281\n            # env ROCKET_PORT=8281 ./executable_deepl\n            url = \"http://127.0.0.1:{}/translate\".format(port)\n            data = {\"text\": text, \"source_lang\": \"auto\", \"target_lang\": \"ZH\"}\n            r = requests.post(url, json=data, timeout=timeout)",
        "type": "code",
        "location": "/tests/karaoke_effects/fastapi_translator.py:84-111"
    },
    "3305": {
        "file_id": 395,
        "content": "Sets a random proxy from the list or skips proxy usage. Updates the proxy list and counter modulo. Uses a file lock for access control. Makes a POST request to a local DeepL translator service using the selected proxy, if any.",
        "type": "comment"
    },
    "3306": {
        "file_id": 395,
        "content": "            response = r.json()\n            code = response[\"code\"]\n            if code == 200:\n                translatedText = response[\"data\"]\n                return translatedText\n            else:\n                print(\"DEEPL RESPONSE ERROR. PLEASE CHECK\")\n                print(response)\n                proxyList = getTestedProxyList()\n                refreshProxyCounter = 1\n                # breakpoint()\n                return None\n# use suggest mechanism\nworkingProxies = set()\ndef checkWorkingProxies():\n    global workingProxies\n    useProxy(False)\n    url = \"http://127.0.0.1:8677/checkProxy\"\n    import requests\n    for proxy in list(workingProxies):\n        # proxy could be None.\n        # print([proxy])\n        # breakpoint()\n        r = requests.get(url, params={\"proxy\": proxy})\n        response = r.json()\n        if not response[\"exists\"]:\n            print(\"REMOVING PROXY %s NOW\" % useProxy)\n            workingProxies.remove(proxy)\ndef changeProxy(useDirect=False, suggestSingleElemProbability=0.1):\n    useProxy(False)",
        "type": "code",
        "location": "/tests/karaoke_effects/fastapi_translator.py:112-148"
    },
    "3307": {
        "file_id": 395,
        "content": "The code snippet is responsible for making requests to a Deepl API and handling the response. If the response has a 200 status code, the translated text is returned; otherwise, it prints an error message and checks the working proxies. The workingProxies set stores valid proxies for making requests, and functions checkWorkingProxies() and changeProxy() manage proxy usage.",
        "type": "comment"
    },
    "3308": {
        "file_id": 395,
        "content": "    global workingProxies\n    checkWorkingProxies()\n    import requests\n    if useDirect:\n        path = \"useDirect\"\n    else:\n        path = \"refreshProxy\"\n    print(\"PATH\", path)\n    if path == \"refreshProxy\":\n        import random\n        prob = random.random() < len(workingProxies) * suggestSingleElemProbability\n        if prob:\n            suggestedProxy = random.choice(list(workingProxies))\n            params = {\"suggest\": suggestedProxy}\n            print(\"SUGGESGING PROXY:\", suggestedProxy)\n        else:\n            params = {}\n            # params = {\"suggest\": None}\n        r = requests.get(\"http://127.0.0.1:8677/{}\".format(path), params=params)\n    else:\n        r = requests.get(\"http://127.0.0.1:8677/{}\".format(path))\n    print(\"RESPONSE:\", r.text)\n    import parse\n    proxyName = parse.parse(\"refresh proxy to {text}\", r.text)\n    if proxyName == None:\n        # using suggested proxy here.\n        print(\"USING SUGGESTED PROXY\")\n    else:\n        proxyName = proxyName[\"text\"]\n    print(\"PROXY REFRESHED\")",
        "type": "code",
        "location": "/tests/karaoke_effects/fastapi_translator.py:149-181"
    },
    "3309": {
        "file_id": 395,
        "content": "This code checks if a working proxy is available, then randomly selects one to use or suggests a new one. It makes a request to the server to update the proxy and handles the response. If no proxy name is found in the response, it uses the previously suggested proxy. Finally, it updates the proxy and prints a success message.",
        "type": "comment"
    },
    "3310": {
        "file_id": 395,
        "content": "    return proxyName\ndef metaTranslator(text, backend=\"baidu\", max_tries: int = 3):\n    global workingProxies\n    backendList = [\"baidu\", \"deepl\"]\n    assert backend in backendList\n    # translator = None\n    import random\n    getUseDirect = lambda: False\n    backends = {\n        \"baidu\": (baiduTranslator, lambda: True),\n        # \"deepl\": (deeplTranslator, lambda: False), # use direct? no proxy?\n        \"deepl\": (\n            deeplTranslator,\n            lambda: True,\n        ),  # the proxy is used by deepl client, not here!\n    }\n    translator, getUseDirect = backends[backend]\n    proxyName = None\n    firstTime = True\n    for _ in range(max_tries):\n        try:\n            if not firstTime:  # after first 'failed' trial we will change the strategy.\n                key = random.choice(backendList)\n                translator, getUseDirect = backends[key]\n                proxyName = changeProxy(useDirect=getUseDirect())\n            else:\n                firstTime = False\n            result = translator(text)\n            if result:",
        "type": "code",
        "location": "/tests/karaoke_effects/fastapi_translator.py:182-213"
    },
    "3311": {
        "file_id": 395,
        "content": "This code is a function that translates text using different backends (Baidu and DeepL) with the option to use a proxy. It uses a max number of tries for translation attempts, randomly selects a backend if previous attempts failed, and handles direct connections or proxies based on backend settings.",
        "type": "comment"
    },
    "3312": {
        "file_id": 395,
        "content": "                if proxyName:\n                    workingProxies.add(proxyName)\n                return result\n            else:\n                if proxyName in workingProxies:\n                    workingProxies.remove(proxyName)\n                print(\"SOME ERROR DURING FETCHING TRANSLATION\")\n        except:\n            import traceback\n            traceback.print_exc()\n            print(\"ERROR FETCHING TRANSLATION\")\n# def waitForServerUp(port, message, timeout=1):\n#     import requests\n#     while True:\n#         try:\n#             url = \"http://localhost:{}\".format(port)\n#             r = requests.get(url, timeout=timeout)\n#             text = r.text.strip('\"').strip(\"'\")\n#             print(\"SERVER AT PORT %d RESPONDS:\" % port, [text])\n#             assert text == message\n#             print(\"SERVER AT PORT %d IS UP\" % port)\n#             break\n#         except:\n#             import traceback\n#             traceback.print_exc()\n#             print(\"SERVER AT PORT %d MIGHT NOT BE UP\")\n#             print(\"EXPECTED MESSAGE:\", [message])",
        "type": "code",
        "location": "/tests/karaoke_effects/fastapi_translator.py:214-245"
    },
    "3313": {
        "file_id": 395,
        "content": "This code checks if a given proxy name is present in the working proxies list and performs actions accordingly. If there's an error during fetching translation, it prints an error message. The \"waitForServerUp\" function tests if a server at a specific port is up by sending requests and checking its response.",
        "type": "comment"
    },
    "3314": {
        "file_id": 395,
        "content": "#             import time\n#             time.sleep(1)\n@app.get(\"/\")\ndef read_root():\n    # waitForServerUp(8677, \"clash update controller\")  # probe the clash updator\n    return \"unified translator hooked on some clash server\"\ntranslatedDict = {}\ntranslatedDictCacheLimit = 100\n@app.get(\"/translate\")\ndef read_item(backend: str, text: str):\n    global translatedDict\n    if len(list(translatedDict.keys())) > translatedDictCacheLimit:\n        mkeys = list(translatedDict.keys())\n        import random\n        random.shuffle(mkeys)\n        for key in mkeys[:translatedDictCacheLimit]:\n            del translatedDict[key]\n    code = 200\n    if not backend in [\"deepl\", \"baidu\"]:\n        code = 400\n        result = \"INVALID BACKEND\"\n    else:\n        if len(text) < 30 and text in translatedDict.keys():\n            result = translatedDict[text]\n        else:\n            result = metaTranslator(text, backend=backend)\n            if type(result) == str:\n                if len(result) < 30 and len(text) < 30:\n                    translatedDict.update({text: result})",
        "type": "code",
        "location": "/tests/karaoke_effects/fastapi_translator.py:246-283"
    },
    "3315": {
        "file_id": 395,
        "content": "The code defines two API endpoints: a root endpoint returning \"unified translator hooked on some clash server\" and a \"/translate\" endpoint accepting a \"backend\" parameter (\"deepl\" or \"baidu\") and text to be translated. It caches up to 100 translations in a global dictionary, deleting the least recently used if exceeding cache limit. If the backend is invalid, it returns status code 400 with message \"INVALID BACKEND\". If the input text length is less than 30 and already translated, it returns that translation from cache; otherwise, it uses `metaTranslator` function to translate the text, storing the result in cache if valid.",
        "type": "comment"
    },
    "3316": {
        "file_id": 395,
        "content": "    return {\n        \"code\": (code if result not in [None, False, True, \"\"] else 400),\n        \"result\": (result if type(result) == str and result != \"\" else None),\n    }",
        "type": "code",
        "location": "/tests/karaoke_effects/fastapi_translator.py:284-287"
    },
    "3317": {
        "file_id": 395,
        "content": "This code snippet returns a dictionary containing the \"code\" and \"result\" keys. If the \"result\" is not None, False, True, or an empty string, it will be included in the result dictionary; otherwise, the code will be 400.",
        "type": "comment"
    },
    "3318": {
        "file_id": 396,
        "content": "/tests/karaoke_effects/in2.ass.j2",
        "type": "filepath"
    },
    "3319": {
        "file_id": 396,
        "content": "This code specifies styles, font sizes, and effects for text in an .ass file, containing dialogue entries with timings, styles, and translations in a SubRip subtitle format. It includes Japanese dialogues with English translations, defining positioning, style, and timing for each text element.",
        "type": "summary"
    },
    "3320": {
        "file_id": 396,
        "content": "﻿[Script Info]\n; Script generated by Aegisub 8975-master-8d77da3\n; http://www.aegisub.org/\nTitle: Default Aegisub file\nScriptType: v4.00+\nWrapStyle: 0\nScaledBorderAndShadow: yes\nYCbCr Matrix: TV.601\nPlayResX: 1600\nPlayResY: 900\n[Aegisub Project Garbage]\nLast Style Storage: Default\nVideo File: ?dummy:23.976000:2250:1920:1080:11:135:226:c\nVideo AR Value: 1.777778\nVideo Zoom Percent: 0.500000\nVideo Position: 349\n[V4+ Styles]\nFormat: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding\nStyle: Default,{{defaultFontname or 'Arial'}},{{defaultFontsize or 48}},&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,0,8,25,25,25,1\nStyle: Romaji,{{romajiFontname or 'Migu 1P'}},{{romajiFontsize or 48}},&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,2,0,8,25,25,25,1\nStyle: Translation,{{translationFontname or 'M",
        "type": "code",
        "location": "/tests/karaoke_effects/in2.ass.j2:1-23"
    },
    "3321": {
        "file_id": 396,
        "content": "This code is an Aegisub script containing the file's title, script type, and other relevant information. It includes styles for default text, Romaji, and translation, specifying their names, font types, sizes, colors, alignments, and margins.",
        "type": "comment"
    },
    "3322": {
        "file_id": 396,
        "content": "igu 1P'}},{{translationFontsize or 46}},&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,2,0,2,25,25,25,1\nStyle: Kanji,{{kanjiFontname or 'Migu 1P'}},{{kanjiFontsize or 38}},&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,1.8,0,4,25,25,25,1\n[Events]\nFormat: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text\nDialogue: 3,0:00:14.54,0:00:20.72,Romaji,,0,0,0,,{\\k45\\-m1}da{\\k22}re{\\k13}mo {\\k75\\-m1}ga {\\k11}sa{\\k11}ka{\\k46}ra{\\k21}e{\\k8}zu {\\k39}ni {\\k22}mo{\\k25}gu{\\k19}t{\\k66\\-m1}te {\\k15}i{\\k180\\-m1}ku\nDialogue: 3,0:00:21.60,0:00:26.95,Romaji,,0,0,0,,{\\k50}so{\\k21}no {\\k13}me {\\k73\\-m2}o {\\k10}to{\\k10}mo{\\k29}shi{\\k24}bi {\\k19}yo{\\k11}ri {\\k37}ka{\\k22}ga{\\k19}ya{\\k23}ka{\\k44\\-m2}se{\\k130\\-m2}te\nDialogue: 3,0:00:28.52,0:00:31.60,Romaji,,0,0,0,,{\\k13}me{\\k12}za{\\k29\\-m1}su {\\k35\\-m2}sa{\\k26}ki {\\k32}wa {\\k32\\-m1}fu{\\k23\\-m2}ka{\\k106\\-m1}ku\nDialogue: 1,0:00:14.54,0:00:20.72,Kanji,,0,0,0,,{\\k67}誰{\\k13}も{\\k75}が{\\k22}逆{\\k46}ら{\\k21}え{\\k8}ず{\\k39}に{\\k47}潜{\\k19}っ{\\k66}て{\\k15}い{\\k180}く",
        "type": "code",
        "location": "/tests/karaoke_effects/in2.ass.j2:23-31"
    },
    "3323": {
        "file_id": 396,
        "content": "This code defines styles, font sizes, and effects for text in an .ass file, specifying layer, timing, style, and content. It contains four dialogue entries with various texts and styles, including kanji and romaji, with specific timing and positioning on the screen.",
        "type": "comment"
    },
    "3324": {
        "file_id": 396,
        "content": "Dialogue: 0,0:00:21.60,0:00:26.95,Kanji,,0,0,0,m2,{\\k50}そ{\\k21}の{\\k13}目{\\k83}を{\\k39}灯{\\k24}火{\\k19}よ{\\k11}り{\\k78}輝{\\k23}か{\\k44}せ{\\k130}て\nDialogue: 0,0:00:28.52,0:00:31.60,Kanji,,0,0,0,m1,{\\k13}目{\\k12}指{\\k29}す{\\k61}先{\\k32}は{\\k55}深{\\k106}く\nDialogue: 1,0:00:14.54,0:00:20.72,Translation,,0,0,0,,{\\t(-2001,-2000,\\1c&HC7FFB0&\\3c&H1B5306&)\\t(4062,4292,\\1c&HA7B5DC&\\3c&H0C1F57&)\\t(4938,5300,\\1c&HC7FFB0&\\3c&H1B5306&)}Ciò che abbiamo sempre desiderato è sepolto in profondità.\nDialogue: 1,0:00:21.60,0:00:26.95,Translation,,0,0,0,,{\\t(87,87,\\1c&HA7B5DC&\\3c&H0C1F57&)}Malgrado le nostre paure, i nostri occhi brillano più del fuoco.\nDialogue: 1,0:00:28.52,0:00:31.60,Translation,,0,0,0,,{\\t(258,258,\\1c&HFFC390&\\3c&H672414&)}Il nostro obbiettivo è raggiungere quel luogo recondito,",
        "type": "code",
        "location": "/tests/karaoke_effects/in2.ass.j2:32-36"
    },
    "3325": {
        "file_id": 396,
        "content": "This code contains dialogue entries with timings, styles, and translations in a SubRip subtitle file. It includes two dialogues in Japanese and their respective English translations, indicating the positioning, style, and timing of each text element in the subtitle.",
        "type": "comment"
    },
    "3326": {
        "file_id": 397,
        "content": "/tests/karaoke_effects/launch_clash.sh",
        "type": "filepath"
    },
    "3327": {
        "file_id": 397,
        "content": "This script sets proxy environment variables, downloads the latest Clash configuration file from two sources and executes clash with the downloaded configuration.",
        "type": "summary"
    },
    "3328": {
        "file_id": 397,
        "content": "export http_proxy=\"\"\nexport https_proxy=\"\"\n# env http_proxy=\"http://localhost:38457\" https_proxy=\"http://localhost:38457\" curl -O https://openit.ml/Clash.yaml\n##########FETCHING LATEST YAML############\n# env http_proxy=\"http://localhost:38457\" https_proxy=\"http://localhost:38457\" curl -O https://raw.githubusercontent.com/yu-steven/openit/main/Clash.yaml\n# python3 get_clash_yaml.py\n##########FETCHING LATEST YAML############\n# refreshing can be ignored since it is not needed.\nclash -f ClashBaseOpenIt.yaml",
        "type": "code",
        "location": "/tests/karaoke_effects/launch_clash.sh:1-10"
    },
    "3329": {
        "file_id": 397,
        "content": "This script sets proxy environment variables, downloads the latest Clash configuration file from two sources and executes clash with the downloaded configuration.",
        "type": "comment"
    },
    "3330": {
        "file_id": 398,
        "content": "/tests/karaoke_effects/loadLingua_jpype.py",
        "type": "filepath"
    },
    "3331": {
        "file_id": 398,
        "content": "This code uses Jpype and Lingua to detect languages from Python, interacting with Java classes via a JVM. It prints language detection results and performs math operations. The code may not shut down the JVM properly, but context is missing.",
        "type": "summary"
    },
    "3332": {
        "file_id": 398,
        "content": "from jpype import *\nimport jpype.imports  # this is needed! shit.\naddClassPath(\"/root/Desktop/works/pyjom/tests/karaoke_effects/classpath/lingua.jar\")\nstartJVM(getDefaultJVMPath())\njava.lang.System.out.println(\"Calling Java Print from Python using Jpype!\")\nfrom com.github.pemistahl.lingua.api import *\n# detector = LanguageDetectorBuilder.fromAllLanguages().withLowAccuracyMode().build()\nlinguaDetector = (\n    LanguageDetectorBuilder.fromAllLanguages().build()\n)  # 3.5GB just for detecting language! it is somehow crazy.\ndef getLinguaDetectedLanguageLabel(sample):\n    result = linguaDetector.detectLanguageOf(sample)\n    # print(result, type(result)) # <java class 'com.github.pemistahl.lingua.api.Language'>\n    # but we can convert it into string.\n    strResult = str(result)\n    return strResult\nif __name__ == \"__main__\":\n    sample = \"hello world\"\n    # sample = 'lina你吃早饭了没有'\n    result = linguaDetector.detectLanguageOf(sample)\n    print(\n        result, type(result)\n    )  # <java class 'com.github.pemistahl.lingua.api.Language'>",
        "type": "code",
        "location": "/tests/karaoke_effects/loadLingua_jpype.py:1-34"
    },
    "3333": {
        "file_id": 398,
        "content": "This code uses the Jpype library to interact with Java classes from Python. It sets up a Java Virtual Machine (JVM), imports necessary packages, and uses a large language detection library called Lingua to identify the language of text samples. The function getLinguaDetectedLanguageLabel takes an input sample, detects its language using Lingua's detector, and returns the detected language as a string.",
        "type": "comment"
    },
    "3334": {
        "file_id": 398,
        "content": "    # but we can convert it into string.\n    strResult = str(result)\n    print(strResult, type(strResult))\n    import math\n    print(\"CALLING MATH: %d\" % math.sqrt(4))\n    # shutdownJVM()\n    # what if we do not shut this down?",
        "type": "code",
        "location": "/tests/karaoke_effects/loadLingua_jpype.py:35-42"
    },
    "3335": {
        "file_id": 398,
        "content": "Code converts a result into a string and prints it along with its type. Then, the math module is imported and used to calculate the square root of 4, also printed. The code comments mention potentially not shutting down JVM but does not explain further or provide context.",
        "type": "comment"
    },
    "3336": {
        "file_id": 399,
        "content": "/tests/karaoke_effects/loadLingua_jpype_fastapi.py",
        "type": "filepath"
    },
    "3337": {
        "file_id": 399,
        "content": "The code uses JPype to interact with Java from Python and FastAPI, imports necessary packages, sets up a Java virtual machine, creates an instance of the language detector, defines a function to detect languages using Lingua API, and handles exceptions while analyzing text language with LangID.",
        "type": "summary"
    },
    "3338": {
        "file_id": 399,
        "content": "from jpype import *\nimport jpype.imports  # this is needed! shit.\naddClassPath(\"/root/Desktop/works/pyjom/tests/karaoke_effects/classpath/lingua.jar\")\nstartJVM(getDefaultJVMPath())\njava.lang.System.out.println(\"Calling Java Print from Python using Jpype!\")\nfrom com.github.pemistahl.lingua.api import *\n# detector = LanguageDetectorBuilder.fromAllLanguages().withLowAccuracyMode().build()\nlinguaDetector = (\n    LanguageDetectorBuilder.fromAllLanguages().build()\n)  # 3.5GB just for detecting language! it is somehow crazy.\ndef getLinguaDetectedLanguageLabel(sample):\n    result = linguaDetector.detectLanguageOf(sample)\n    # print(result, type(result)) # <java class 'com.github.pemistahl.lingua.api.Language'>\n    # but we can convert it into string.\n    strResult = str(result)\n    return strResult\n# shutdownJVM()\nfrom fastapi import FastAPI\napp = FastAPI()\n@app.get(\"/\")\ndef server_hello():\n    return \"say hello to jpype fastapi server\"\n@app.get(\"/langid\")\ndef read_item(text: str):\n    code = 200\n    try:\n        result = getLinguaDetectedLanguageLabel(text)",
        "type": "code",
        "location": "/tests/karaoke_effects/loadLingua_jpype_fastapi.py:1-42"
    },
    "3339": {
        "file_id": 399,
        "content": "This code uses the JPype library to interact with Java from Python and FastAPI. It imports necessary packages, sets up a Java virtual machine, creates an instance of the language detector, defines a function to detect languages using Lingua API, and sets up two endpoints in a FastAPI server.",
        "type": "comment"
    },
    "3340": {
        "file_id": 399,
        "content": "    except:\n        code = 400\n        import traceback\n        traceback.print_exc()\n        print(\"ERROR ANALYSING TEXT LANGID %s\" % text)\n        result = \"ERROR\"\n    return {\"code\": code, \"result\": result}",
        "type": "code",
        "location": "/tests/karaoke_effects/loadLingua_jpype_fastapi.py:43-50"
    },
    "3341": {
        "file_id": 399,
        "content": "This code snippet handles exceptions while analyzing text language using the LangID library. It sets a 400 HTTP code, prints exception traceback and error message, and returns an \"ERROR\" result.",
        "type": "comment"
    },
    "3342": {
        "file_id": 400,
        "content": "/tests/karaoke_effects/loadLingua_pyjnius.py",
        "type": "filepath"
    },
    "3343": {
        "file_id": 400,
        "content": "This code imports necessary modules, sets Java classpath, prints a message, creates a language detector object, defines a function to detect language from a sample text, and tests the detector with a sample input.",
        "type": "summary"
    },
    "3344": {
        "file_id": 400,
        "content": "import jnius_config\n# jnius_config.add_options('-Xrs', '-Xmx4096')\njnius_config.set_classpath(\n    \".\", \"/root/Desktop/works/pyjom/tests/karaoke_effects/classpath/lingua.jar\"\n)\nimport jnius\njnius.autoclass(\"java.lang.System\").out.println(\"Running Java Program Using Pyjnius!\")\npyjniusLinguaDetector = (\n    jnius.autoclass(\"com.github.pemistahl.lingua.api.LanguageDetectorBuilder\")\n    .fromAllLanguages()\n    .build()\n)\ndef pyjniusLinguaDetectLanguageLabel(sample):\n    result = pyjniusLinguaDetector.detectLanguageOf(sample)\n    # print(result, type(result))\n    # breakpoint()\n    strResult = result.toString()\n    return strResult\nif __name__ == \"__main__\":\n    sample = \"hello world\"\n    result = pyjniusLinguaDetector.detectLanguageOf(sample)\n    print(result, type(result))\n    # breakpoint()\n    strResult = result.toString()\n    print(strResult, type(strResult))",
        "type": "code",
        "location": "/tests/karaoke_effects/loadLingua_pyjnius.py:1-32"
    },
    "3345": {
        "file_id": 400,
        "content": "This code imports necessary modules, sets Java classpath, prints a message, creates a language detector object, defines a function to detect language from a sample text, and tests the detector with a sample input.",
        "type": "comment"
    },
    "3346": {
        "file_id": 401,
        "content": "/tests/karaoke_effects/loadSomeCustomClashYaml.py",
        "type": "filepath"
    },
    "3347": {
        "file_id": 401,
        "content": "This code imports yaml and defines two functions for converting YAML strings between Python-friendly and Go-compatible formats. It then loads a file (Clash.yaml) using a custom loader, converts the string, and prints the loaded data.",
        "type": "summary"
    },
    "3348": {
        "file_id": 401,
        "content": "import yaml\n# yaml.add_constructor(mCustomLoaderTag, create_ref, Loader)\ndef goYamlToPyYaml(docString):\n    docString = docString.replace(\"!<str>\", \"!!str\")\n    return docString\ndef pyYamlToGoYaml(docString):\n    docString = docString.replace(\"!!str\", \"!<str>\")\n    return docString\nif __name__ == \"__main__\":\n    fileName = \"Clash.yaml\"\n    docString = open(fileName, \"r\").read()\n    mCustomLoaderTag = \"!<str>\"\n    class Ref(object):\n        def __init__(self, data):\n            self.data = data\n        def __repr__(self):\n            return '\"%s\"' % self.data\n    def create_ref(loader, node):\n        # print(dir(loader))\n        # breakpoint()\n        value = loader.costruct_string(node)\n        return Ref(value)\n    class Loader(yaml.SafeLoader):\n        pass\n    docString = goYamlToPyYaml(docString)\n    a = yaml.load(docString)\n    print(a)",
        "type": "code",
        "location": "/tests/karaoke_effects/loadSomeCustomClashYaml.py:1-41"
    },
    "3349": {
        "file_id": 401,
        "content": "This code imports yaml and defines two functions for converting YAML strings between Python-friendly and Go-compatible formats. It then loads a file (Clash.yaml) using a custom loader, converts the string, and prints the loaded data.",
        "type": "comment"
    },
    "3350": {
        "file_id": 402,
        "content": "/tests/karaoke_effects/load_translator.sh",
        "type": "filepath"
    },
    "3351": {
        "file_id": 402,
        "content": "This code snippet is used to terminate a Tmux session named \"translator\" and then load the configuration file \"translator.yml\" using Tmuxp, likely for testing purposes in the pyjom/tests/karaoke_effects folder.",
        "type": "summary"
    },
    "3352": {
        "file_id": 402,
        "content": "tmux kill-session -t translator\ntmuxp load -y translator.yml",
        "type": "code",
        "location": "/tests/karaoke_effects/load_translator.sh:1-2"
    },
    "3353": {
        "file_id": 402,
        "content": "This code snippet is used to terminate a Tmux session named \"translator\" and then load the configuration file \"translator.yml\" using Tmuxp, likely for testing purposes in the pyjom/tests/karaoke_effects folder.",
        "type": "comment"
    },
    "3354": {
        "file_id": 403,
        "content": "/tests/karaoke_effects/lrc2ass_py3/README.md",
        "type": "filepath"
    },
    "3355": {
        "file_id": 403,
        "content": "This Python 3 script converts LRC files to ASS format with karaoke effects, supports multiple timing tags, and auto-chooses end timings. It is primarily for Chinese but may encounter errors in non-Chinese languages or wrong text codings. Future improvements include English support, annotations, file list input, reusability, and debugging.",
        "type": "summary"
    },
    "3356": {
        "file_id": 403,
        "content": "# lrc2ass_py3\nA simple Python 3.x script is used for changing your LRC file into ASS subtitle with karaoke effect tags\n一个用于将LRC歌词文件转换为ASS字幕文件的简单Python脚本。\nThe first full python script written by myself.\n我自己编写的第一个完整的Python脚本\nCopyright(c) 2020 yyfll (MIT)\n# WON'T UPDATE IN THE FUTURE\n# Dependent\n* chardet (lrc2ass_py3 >= 1.0.0c)\n# Update\n## 1.0.0c\n* Support chardet character encoding detector.\n* A few improvements\n## 1.0.0b\n* Support LRC offset tag.\n* Default LRC offset can be set.\n* Simplify program.\n# English Readme\nPoor English.\n## What can lrc2ass_py3 do?\n* Change your LRC script to ASS script.\n* Very easy to use.\n* Support Multi timing tags in a single line.\n* Support auto choose end timing if can't find timing in the end of the line.\n* Support LRC offset tag.\n## What will cause error?\n* A lrc file in wrong text coding (such as use utf-8 read gbk file.)\n* A lrc line without the timing tag in the line ahead. (haven't tested)\n## WARNING\n* Only CHINESE are supported.\n> All the information show in console and the annotations in python script are written in CHINESE,",
        "type": "code",
        "location": "/tests/karaoke_effects/lrc2ass_py3/README.md:1-41"
    },
    "3357": {
        "file_id": 403,
        "content": "This is a simple Python 3 script for converting LRC files to ASS with karaoke effects. It requires the chardet library, supports multiple timing tags, and auto-chooses end timings if not specified. However, it's only for Chinese and may encounter errors if the LRC file is in the wrong text coding or lacks a timing tag on certain lines.",
        "type": "comment"
    },
    "3358": {
        "file_id": 403,
        "content": ">\n> It doesn't mean lrc2ass_py3 can't work on your LRC in English.\n>\n> So it doesn't have any influence on output a correct ASS script if you use English or any other language.\n# 简体中文 Readme\n## lrc2ass_py3可以做什么？\n* 将你的LRC歌词文件转换为ASS字幕文件\n* 使用起来非常简单\n* 支持一个歌词行多个时间标签（即卡拉OK效果）\n* 支持在找不到歌词行的结束时间时，自动选择结束时间\n* 支持时间偏移标签（offset）\n## 有什么可能会导致错误的？\n* 读取了非指定文本编码的LRC歌词文件（比如像用utf-8编码读取gbk编码的文件）\n* 歌词行开头没有指定起始时间的时间标签（这还没有经过测试）\n## 警告\n* 只支持中文\n> 所有的控制台输出及文件内注释都是用中文写的\n>\n> 这并不意味着lrc2ass_py3不能处理非中文的LRC文件\n>\n> 所以这并不会对输出一个正确ASS字幕文件产生任何影响\n# To do\n* Full English supported\n* Full Chinese annotation\n* File list input\n* Reusable\n* Endless debugging",
        "type": "code",
        "location": "/tests/karaoke_effects/lrc2ass_py3/README.md:42-72"
    },
    "3359": {
        "file_id": 403,
        "content": "This code is a README file for the lrc2ass_py3 tool, which converts LRC karaoke files to ASS format. It supports English and other languages, but has warnings and limitations related to non-Chinese languages and specific encoding formats. The code also includes a To Do list with additional features such as full English support, improved annotations, file list input, reusability, and debugging.",
        "type": "comment"
    },
    "3360": {
        "file_id": 404,
        "content": "/tests/karaoke_effects/lrc2ass_py3/localTest.sh",
        "type": "filepath"
    },
    "3361": {
        "file_id": 404,
        "content": "Code is running mpv player with no audio and loading an .ass subtitle file to display over a video. The user is experiencing issues with the output.",
        "type": "summary"
    },
    "3362": {
        "file_id": 404,
        "content": "rootpath=/root/Desktop/works/pyjom\nmpv --fs --no-audio --sub-file=\"$rootpath/tests/karaoke_effects/lrc2ass_py3/output.s2.ass\" \"$rootpath/samples/video/karaoke_effects_source.mp4\"\n## NOT OK! THIS DUMB SHIT LIBRARY FUCKED MY MIND ##\n## the effect is bad. the time is not right. everything fucked. ##",
        "type": "code",
        "location": "/tests/karaoke_effects/lrc2ass_py3/localTest.sh:1-5"
    },
    "3363": {
        "file_id": 404,
        "content": "Code is running mpv player with no audio and loading an .ass subtitle file to display over a video. The user is experiencing issues with the output.",
        "type": "comment"
    },
    "3364": {
        "file_id": 405,
        "content": "/tests/karaoke_effects/lrc2ass_py3/test.sh",
        "type": "filepath"
    },
    "3365": {
        "file_id": 405,
        "content": "The code is running an MPV player with no audio, using a subtitle file and video source. It seems that the video's effect is bad, and the time synchronization is incorrect, causing dissatisfaction with the result.",
        "type": "summary"
    },
    "3366": {
        "file_id": 405,
        "content": "rootpath=/Users/jamesbrown/desktop/works/pyjom_remote/\nmpv --fs --no-audio --sub-file=\"$rootpath/tests/karaoke_effects/lrc2ass_py3/output.s2.ass\" \"$rootpath/samples/video/karaoke_effects_source.mp4\"\n## NOT OK! THIS DUMB SHIT LIBRARY FUCKED MY MIND ##\n## the effect is bad. the time is not right. everything fucked. ##",
        "type": "code",
        "location": "/tests/karaoke_effects/lrc2ass_py3/test.sh:1-5"
    },
    "3367": {
        "file_id": 405,
        "content": "The code is running an MPV player with no audio, using a subtitle file and video source. It seems that the video's effect is bad, and the time synchronization is incorrect, causing dissatisfaction with the result.",
        "type": "comment"
    },
    "3368": {
        "file_id": 406,
        "content": "/tests/karaoke_effects/lyricToAss_test.py",
        "type": "filepath"
    },
    "3369": {
        "file_id": 406,
        "content": "This code imports necessary functions and utilizes them to generate an animated .ass file from a music file and its corresponding .lrc file, then previews it with a sample video.",
        "type": "summary"
    },
    "3370": {
        "file_id": 406,
        "content": "# this is the complete process.\nfrom lyrictoolbox import *\n# from .lyrictoolbox import previewAssWithVideo\n# from .lyrictoolbox import getTextListTranslated\nif __name__ == \"__main__\":\n    musicPath = \"/root/Desktop/works/pyjom/tests/music_analysis/exciting_bgm.mp3\"\n    lrcPath = \"/root/Desktop/works/pyjom/tests/music_analysis/exciting_bgm.lrc\"\n    sample_video = \"/root/Desktop/works/pyjom/samples/video/karaoke_effects_source.mp4\"\n    import os\n    assPath = os.path.abspath(\"test.ass\")\n    lrcToAnimatedAss(musicPath, lrcPath, assPath)\n    previewAssWithVideo(sample_video, assPath)",
        "type": "code",
        "location": "/tests/karaoke_effects/lyricToAss_test.py:1-15"
    },
    "3371": {
        "file_id": 406,
        "content": "This code imports necessary functions and utilizes them to generate an animated .ass file from a music file and its corresponding .lrc file, then previews it with a sample video.",
        "type": "comment"
    },
    "3372": {
        "file_id": 407,
        "content": "/tests/karaoke_effects/pyonfx_test/first_try.py",
        "type": "filepath"
    },
    "3373": {
        "file_id": 407,
        "content": "This code imports the \"pyonfx\" library and uses it to open an ASS file. It then retrieves the file's metadata, styles, and lines of text. The first line's text is modified, and the modified line is written back into the file. The code also attempts to open Aegisub but fails as there isn't one available.",
        "type": "summary"
    },
    "3374": {
        "file_id": 407,
        "content": "from pyonfx import *\nio = Ass(\"in.ass\")\nmeta, styles, lines = io.get_data()\nlines[0].text = \"I am a new line!\"\nio.write_line(lines[0])\nio.save()\n# io.open_aegisub()\n# there's no aegisub.",
        "type": "code",
        "location": "/tests/karaoke_effects/pyonfx_test/first_try.py:1-11"
    },
    "3375": {
        "file_id": 407,
        "content": "This code imports the \"pyonfx\" library and uses it to open an ASS file. It then retrieves the file's metadata, styles, and lines of text. The first line's text is modified, and the modified line is written back into the file. The code also attempts to open Aegisub but fails as there isn't one available.",
        "type": "comment"
    },
    "3376": {
        "file_id": 408,
        "content": "/tests/karaoke_effects/pyonfx_test/macos_view_best_example.sh",
        "type": "filepath"
    },
    "3377": {
        "file_id": 408,
        "content": "This script opens a video file with an ASS subtitle file, using mpv player in full screen and without audio. The ASS file contains karaoke effects for the associated video, sourced from pyjom_remote/tests/karaoke_effects/pyonfx_test/examples/2 - Beginner folder.",
        "type": "summary"
    },
    "3378": {
        "file_id": 408,
        "content": "rootpath=/Users/jamesbrown/desktop/works/pyjom_remote/\nmpv --fs --no-audio --sub-file=\"$rootpath/tests/karaoke_effects/pyonfx_test/examples/2 - Beginner/Output.ass\" \"$rootpath/samples/video/karaoke_effects_source.mp4\"",
        "type": "code",
        "location": "/tests/karaoke_effects/pyonfx_test/macos_view_best_example.sh:1-2"
    },
    "3379": {
        "file_id": 408,
        "content": "This script opens a video file with an ASS subtitle file, using mpv player in full screen and without audio. The ASS file contains karaoke effects for the associated video, sourced from pyjom_remote/tests/karaoke_effects/pyonfx_test/examples/2 - Beginner folder.",
        "type": "comment"
    },
    "3380": {
        "file_id": 409,
        "content": "/tests/karaoke_effects/pyonfx_test/render_ass_video.sh",
        "type": "filepath"
    },
    "3381": {
        "file_id": 409,
        "content": "This command uses FFmpeg to extract a 60-second segment from the input video \"karaoke_effects_source.mp4\", applying the embedded ASS subtitles from \"Output.ass\" as effects, and saves the result as \"out.mp4\".",
        "type": "summary"
    },
    "3382": {
        "file_id": 409,
        "content": "ffmpeg -y -i \"/root/Desktop/works/pyjom/samples/video/karaoke_effects_source.mp4\" -ss 0 -to 60 -vf \"ass='/root/Desktop/works/pyjom/tests/karaoke_effects/pyonfx_test/examples/2 - Beginner/Output.ass'\" out.mp4",
        "type": "code",
        "location": "/tests/karaoke_effects/pyonfx_test/render_ass_video.sh:1-1"
    },
    "3383": {
        "file_id": 409,
        "content": "This command uses FFmpeg to extract a 60-second segment from the input video \"karaoke_effects_source.mp4\", applying the embedded ASS subtitles from \"Output.ass\" as effects, and saves the result as \"out.mp4\".",
        "type": "comment"
    },
    "3384": {
        "file_id": 410,
        "content": "/tests/karaoke_effects/pyonfx_test/test.py",
        "type": "filepath"
    },
    "3385": {
        "file_id": 410,
        "content": "The code initializes a variable 'lyricPath' with the path to the LRC file and imports modules 'pyonfx' and 'pylrc'.",
        "type": "summary"
    },
    "3386": {
        "file_id": 410,
        "content": "lyricPath = \"/root/Desktop/works/pyjom/tests/music_analysis/exciting_bgm.lrc\"\nimport pyonfx\nimport pylrc",
        "type": "code",
        "location": "/tests/karaoke_effects/pyonfx_test/test.py:1-3"
    },
    "3387": {
        "file_id": 410,
        "content": "The code initializes a variable 'lyricPath' with the path to the LRC file and imports modules 'pyonfx' and 'pylrc'.",
        "type": "comment"
    },
    "3388": {
        "file_id": 411,
        "content": "/tests/karaoke_effects/pyonfx_test/view_best_example.sh",
        "type": "filepath"
    },
    "3389": {
        "file_id": 411,
        "content": "This command starts mpv player to display a karaoke video with subtitles. The \"Output.ass\" file contains the lyrics and timing information, and the \"karaoke_effects_source.mp4\" is the video being displayed.",
        "type": "summary"
    },
    "3390": {
        "file_id": 411,
        "content": "mpv --fs --no-audio --sub-file=\"/root/Desktop/works/pyjom/tests/karaoke_effects/pyonfx_test/examples/2 - Beginner/Output.ass\" \"/root/Desktop/works/pyjom/samples/video/karaoke_effects_source.mp4\"",
        "type": "code",
        "location": "/tests/karaoke_effects/pyonfx_test/view_best_example.sh:1-1"
    },
    "3391": {
        "file_id": 411,
        "content": "This command starts mpv player to display a karaoke video with subtitles. The \"Output.ass\" file contains the lyrics and timing information, and the \"karaoke_effects_source.mp4\" is the video being displayed.",
        "type": "comment"
    },
    "3392": {
        "file_id": 412,
        "content": "/tests/karaoke_effects/starJumping.py",
        "type": "filepath"
    },
    "3393": {
        "file_id": 412,
        "content": "The code creates a karaoke-style animation by calculating syllable positions, applying colors and effects, and using alpha blending and timing utilities for playback.",
        "type": "summary"
    },
    "3394": {
        "file_id": 412,
        "content": "\"\"\"\nInline effects is a method to define exclusive effects for syllables.\nFields \"Actor\" and \"Effect\" can also be used to define exclusive effects, but you will define them for the whole line.\nIn this example, romajis are looking for inline effects\n\"m1\" and \"m2\" to choose a main effect to apply to syls' text.\nKanjis are looking for lines' field \"Effect\", to choose what kind of effect we want to apply.\nIn addition, for romaji there's a star jumping over syls by frame-per-frame positioning.\nIn this example we can also see in action another utility provided by PyonFX: ColorUtility.\nIt is used to extract color changes from some lines and interpolate them for each generated line without effort.\nColors will add a really nice touch to your KFXs, so it is important to have a comfy way to set up them and use them in your effects.\nIn the translation lines we will create some clipped text colorated as an example of the application.\nYou can also make some simpler usage, like just applying color changes to the whole line, which is what karaokers normally do.",
        "type": "code",
        "location": "/tests/karaoke_effects/starJumping.py:1-14"
    },
    "3395": {
        "file_id": 412,
        "content": "This code defines a method for inline effects, allowing exclusive effects to be applied to syllables. It uses the \"Actor\" and \"Effect\" fields to define effects for whole lines. Romajis look for \"m1\" and \"m2\" to choose main effects, while kanjis search for line's field \"Effect\". Star jumping is applied using frame-per-frame positioning. The code also demonstrates the use of ColorUtility for extracting color changes and interpolating them for each generated line.",
        "type": "comment"
    },
    "3396": {
        "file_id": 412,
        "content": "It could look like much code for such a simple effect, but it's needed and an easy method with much potential for extensions.\n\"\"\"\n### THIS VARIANT IS GREAT. ###\n# from tkinter import CENTER\nfrom pyonfx import *\nimport random\nimport math\nio = Ass(\n    \"/root/Desktop/works/pyjom/tests/karaoke_effects/in2.ass\",\n    path_output=\"starJumping.ass\",\n)\nmeta, styles, lines = io.get_data()\n# Creating the star and extracting all the color changes from the input file\nstar = Shape.star(5, 4, 10)\nCU = ColorUtility(lines)\ndef romaji(line, l):\n    # Setting up a delay, we will use it as duration time of the leadin and leadout effects\n    delay = 100\n    # Setting up offset variables, we will use them for the \\move in leadin and leadout effects\n    off_x = 35\n    off_y = 15\n    # Leadin Effect\n    mDelay = 0\n    # lastStartTime = line.start_time\n    for syl in Utils.all_non_empty(line.syls):\n        l.layer = 0\n        # l.start_time = syl.end_time\n        l.start_time = line.start_time\n        # l.start_time = (\n        #     line.start_time + 25 * syl.i - delay - 80",
        "type": "code",
        "location": "/tests/karaoke_effects/starJumping.py:16-53"
    },
    "3397": {
        "file_id": 412,
        "content": "Creating a star shape and extracting color changes from an input file, setting up delay and offset variables for leadin and leadout effects.",
        "type": "comment"
    },
    "3398": {
        "file_id": 412,
        "content": "        # )  # Remove 80 to start_time to let leadin finish a little bit earlier than the main effect of the first syllable\n        # l.end_time = lastStartTime # wtf?\n        # lastStartTime = syl.start_time\n        l.end_time = syl.start_time\n        # l.end_time = line.start_time + syl.start_time # wtf?\n        l.dur = l.end_time - l.start_time\n        if l.dur <= 0:\n            continue\n        l.text = (\n            \"{\\\\an5\\\\move(%.3f,%.3f,%.3f,%.3f,0,%d)\\\\blur2\\\\t(0,%d,\\\\blur0)\\\\fad(%d,0)}%s\"\n            % (\n                syl.center + math.cos(syl.i / 2) * off_x,\n                syl.middle + math.sin(syl.i / 4) * off_y,\n                syl.center,\n                syl.middle,\n                delay,\n                delay,\n                delay,\n                syl.text,\n            )\n        )\n        io.write_line(l)\n    # Main Effect\n    for syl in Utils.all_non_empty(line.syls):\n        l.layer = 1\n        l.start_time = syl.start_time\n        # l.start_time = line.start_time + syl.start_time\n        l.end_time = syl.end_time + 100",
        "type": "code",
        "location": "/tests/karaoke_effects/starJumping.py:54-85"
    },
    "3399": {
        "file_id": 412,
        "content": "This code defines a karaoke effect for star jumping animation. It calculates the layer position, duration, and text formatting for each syllable in a line of lyrics. The main effect starts after the lead-in, with an optional delay, and continues for an additional 100 milliseconds after the end of each syllable.",
        "type": "comment"
    }
}