{
    "500": {
        "file_id": 32,
        "content": "/pyjom/config/sina/sinaWeibo.py",
        "type": "filepath"
    },
    "501": {
        "file_id": 32,
        "content": "The code defines a dictionary named \"sinaWeiboApi\" with three API endpoints for interacting with Sina Weibo. The \"search_with_page\" endpoint performs search queries, \"weibo_status_by_blogid\" retrieves a specific weibo status by blog ID, and \"weibo_build_comments\" fetches comments for a given weibo status.",
        "type": "summary"
    },
    "502": {
        "file_id": 32,
        "content": "sinaWeiboApi = {\n    \"search_with_page\": \"http://sinanews.sina.cn/interface/type_of_search.d.html?callback=initFeed&keyword={}&page={}&type=siftWb&size=20&newpage=0&chwm=&imei=&token=&did=&from=&oldchwm=\",\n    \"weibo_status_by_blogid\": \"https://www.weibo.com/ajax/statuses/show?id={}\",\n    \"weibo_build_comments\": \"https://weibo.com/ajax/statuses/buildComments?flow=0&is_reload=1&count={}&id={}&is_show_bulletin=2&is_mix=0&uid={}\",\n}",
        "type": "code",
        "location": "/pyjom/config/sina/sinaWeibo.py:1-5"
    },
    "503": {
        "file_id": 32,
        "content": "The code defines a dictionary named \"sinaWeiboApi\" with three API endpoints for interacting with Sina Weibo. The \"search_with_page\" endpoint performs search queries, \"weibo_status_by_blogid\" retrieves a specific weibo status by blog ID, and \"weibo_build_comments\" fetches comments for a given weibo status.",
        "type": "comment"
    },
    "504": {
        "file_id": 33,
        "content": "/pyjom/config/medialang/protocols.py",
        "type": "filepath"
    },
    "505": {
        "file_id": 33,
        "content": "The code defines a dictionary named `medialangProtocols` with two keys: \"input\" and \"output\". The \"input\" key holds an array of protocols for input data sources, while the \"output\" key holds an array of protocols for output data destinations.",
        "type": "summary"
    },
    "506": {
        "file_id": 33,
        "content": "medialangProtocols = {\n    \"input\": [\"http://\", \"https://\", \"text://\", \"subtitle://\", \"sinafetch://\"],\n    \"output\": [\"bilibili_post://\"],\n}",
        "type": "code",
        "location": "/pyjom/config/medialang/protocols.py:1-4"
    },
    "507": {
        "file_id": 33,
        "content": "The code defines a dictionary named `medialangProtocols` with two keys: \"input\" and \"output\". The \"input\" key holds an array of protocols for input data sources, while the \"output\" key holds an array of protocols for output data destinations.",
        "type": "comment"
    },
    "508": {
        "file_id": 34,
        "content": "/pyjom/config/medialang/__init__.py",
        "type": "filepath"
    },
    "509": {
        "file_id": 34,
        "content": "This code imports all modules from the \"pyjom.config.medialang.protocols\" package into the current namespace, allowing access to various media language protocols used within the application.",
        "type": "summary"
    },
    "510": {
        "file_id": 34,
        "content": "from pyjom.config.medialang.protocols import *",
        "type": "code",
        "location": "/pyjom/config/medialang/__init__.py:1-1"
    },
    "511": {
        "file_id": 34,
        "content": "This code imports all modules from the \"pyjom.config.medialang.protocols\" package into the current namespace, allowing access to various media language protocols used within the application.",
        "type": "comment"
    },
    "512": {
        "file_id": 35,
        "content": "/pyjom/medialang/core.py",
        "type": "filepath"
    },
    "513": {
        "file_id": 35,
        "content": "The code defines classes for media language items with functionalities like script representation, validation, exception management, formatting, and executing scripts in a Medialang environment.",
        "type": "summary"
    },
    "514": {
        "file_id": 35,
        "content": "from pyjom.commons import *\nfrom pyjom.medialang.commons import *\nfrom pyjom.medialang.processors import *\nimport re\nimport traceback\nclass lexicalItem:\n    def __init__(self, path, **kwargs):\n        self.path = path\n        self.args = kwargs\n        self.indent = 0\n        self.index = 0\n    def __repr__(self):\n        indent = \"    \" * self.indent\n        mRepr = []\n        mRepr.append(\"{}___medialang_item_[{}]\".format(indent, self.index))\n        mRepr.append(\"{}item path:\".format(indent)+\"  \"+ self.path)\n        mRepr.append(\"{}item args:\".format(indent)+\"  \"+ str(self.args))\n        return \"\\n\".join(mRepr) # is this magic?\nclass lexicalGroup:\n    def __init__(self, items=[]):\n        self.items = []\n        self.index = 0\n        self.indent = 0\n        for item in items:\n            assert type(item) == lexicalItem\n            self.items.append(item)\n    def append(self, item):\n        assert type(item) == lexicalItem\n        self.items.append(item)\n    def dump(self):\n        for item in self.items:\n            yield item # you yield NONE? WTF?",
        "type": "code",
        "location": "/pyjom/medialang/core.py:1-39"
    },
    "515": {
        "file_id": 35,
        "content": "This code defines two classes, `lexicalItem` and `lexicalGroup`, used in the pyjom library for storing and manipulating media language items. The `lexicalItem` class has an `__init__` method that takes a path and optional keyword arguments, and provides an `__repr__` method to represent the item. The `lexicalGroup` class initializes with a list of items, and has methods for appending items and dumping the group's contents. The code also imports necessary modules and checks types of items in the group.",
        "type": "comment"
    },
    "516": {
        "file_id": 35,
        "content": "    def __repr__(self):\n        indent = \"    \" * self.indent\n        mRepr = []\n        mRepr.append(\"{}____________medialang_line_[{}]\".format(indent, self.index))\n        # print(\"ITEMS:\", self.items)\n        for i, item in enumerate(self.dump()):\n            item.indent = self.indent + 1\n            item.index = i\n            mRepr.append(item)\n        # should we return nothing?\n        return \"\\n\".join(mRepr)\nclass lexicalScript:\n    def __init__(self, lines=[]):\n        self.lines = []\n        self.indent = 0\n        self.index = 0\n        for line in lines:\n            assert type(line) == lexicalGroup\n            self.lines.append(line)\n    def append(self, line):\n        assert type(line) == lexicalGroup\n        self.lines.append(line)\n    def dump(self):\n        for line in self.lines:\n            yield line\n    def __repr__(self):\n        indent = \"    \" * self.indent\n        mRepr = []\n        mRepr.append(\"{}____________medialang_script_[{}]\".format(indent, self.index))\n        for i, item in enumerate(self.dump()):",
        "type": "code",
        "location": "/pyjom/medialang/core.py:41-75"
    },
    "517": {
        "file_id": 35,
        "content": "This code defines two classes, `medialang_line` and `lexicalScript`, with a `__repr__` method that represents the objects. The `__repr__` method returns an indented representation of each object's properties. The `lexicalScript` class also has an `append` method to add new lines to the script.",
        "type": "comment"
    },
    "518": {
        "file_id": 35,
        "content": "            item.indent = self.indent + 1\n            item.index = i\n            mRepr.append(item)\n        return \"\\n\".join(mRepr)\nclass Medialang:\n    def __init__(\n        self,\n        script_path=None,\n        script=None,\n        script_obj=None,\n        encoding=\"utf-8\",\n        indent=4,\n        template=False,\n        template_args={},\n        verbose=True,\n        medialangTmpdir=medialangTmpDir\n    ):\n        self.verbose = verbose\n        self.medialangTmpDir = medialangTmpDir\n        self.indent = \" \" * indent\n        self.script_path = script_path\n        self.script_obj = script_obj\n        self.script = script\n        self.encoding = encoding\n        lexList = [script_path, script, script_obj]\n        lexCheck = sum([int(x is None) for x in lexList]) == 2\n        if not lexCheck:\n            raise Exception(\n                \"Can only pass one value to either of script_path, script, script_obj:\\n{}\".format(\n                    lexList\n                )\n            )\n        if script_path is None:\n            if script is None:",
        "type": "code",
        "location": "/pyjom/medialang/core.py:76-110"
    },
    "519": {
        "file_id": 35,
        "content": "This code snippet initializes a Medialang object with various parameters, including script path, script content, and encoding. It also checks for valid input to ensure only one of these values is provided. The exception handling raises an error if the input does not meet this requirement.",
        "type": "comment"
    },
    "520": {
        "file_id": 35,
        "content": "                assert script_obj is not None\n                assert template is False\n                self.script_obj = script_obj\n            else:\n                assert type(script) == str\n                self.script = script\n        else:\n            assert type(script_path) == str\n            try:\n                abspath = getAbsoluteFilePath(script_path)\n            except:\n                medialangFatalError(\n                    \"Failed to resolve script path: {}\".format(script_path), __file__\n                )\n            self.script_path = abspath\n            extension = getFileExtension(script_path)\n            if template:\n                assert extension == \"j2\"\n            else:\n                assert extension in [\"mdl\", \"media\"]\n            with open(abspath, \"r\", encoding=encoding) as f:\n                self.script = f.read()\n        if self.script_obj is not None:\n            self.script = self.generate(self.script_obj)\n        else:\n            if template:\n                assert type(template_args) == dict",
        "type": "code",
        "location": "/pyjom/medialang/core.py:111-138"
    },
    "521": {
        "file_id": 35,
        "content": "This code ensures that the user provides a valid script or script path. It checks if the script is an object, a string, or a file path. If it's a string or a file path, it verifies its type and resolves any relative paths to absolute paths. It then loads the content of the script file and assigns it to 'self.script'. If a script object is provided, the method generates the script using the object. If a template is specified with the script, it asserts that the extension of the script is \"j2\". Otherwise, it asserts that the extension is either \"mdl\" or \"media\". Finally, if a 'template_args' dictionary is provided, it asserts its type and stores the script in 'self.script'.",
        "type": "comment"
    },
    "522": {
        "file_id": 35,
        "content": "                self.script = renderTemplate(self.script, template_args)\n            self.script_obj = self.parse(self.script)\n    def generate_item(self, item_obj, line_max_char=40, level=0):\n        # content = item_obj.content\n        path = item_obj.path\n        item_lines = ['\"{}\"'.format(path)]\n        # print(\"item_lines:\",item_lines)\n        args = item_obj.args\n        # print(\"path:\",path)\n        for key in args.keys():\n            assert not key.startswith(\"#\")\n            # print(\"key:\",key)\n            mitem = args[key]\n            if type(mitem) is str:\n                mitem = '\"{}\"'.format(mitem)\n            elif type(mitem) in [float, int]:\n                mitem = str(mitem)\n            elif mitem in [True, False]:\n                mitem = str(mitem).lower()\n            else:\n                mitem_trial = json.dumps(mitem)\n                if len(mitem_trial) < line_max_char:\n                    mitem = mitem_trial\n                else:\n                    mitem = json.dumps(mitem, indent=self.indent)",
        "type": "code",
        "location": "/pyjom/medialang/core.py:139-164"
    },
    "523": {
        "file_id": 35,
        "content": "This code defines a class that generates items from item objects, handles different data types, and formats the output within a specified line length. The class also has methods to render templates and parse scripts.",
        "type": "comment"
    },
    "524": {
        "file_id": 35,
        "content": "            mitem = \"{}={}\".format(key, mitem)\n            mitem = mitem.split(\"\\n\")\n            for mitem0 in mitem:\n                trial_item = \", \".join([item_lines[-1], mitem0])\n                if len(trial_item) < line_max_char:\n                    item_lines[-1] = trial_item\n                else:\n                    item_lines.append(mitem0)\n        item_lines = \",\\n{}\".format((1 + level) * self.indent).join(item_lines)\n        # print(\"item_lines:\",item_lines)\n        item_lines = \"{}({}\\n{})\\n\".format(\n            level * self.indent, item_lines, level * self.indent\n        )\n        item_lines = item_lines.replace(\",,\", \",\")\n        item_lines = item_lines.replace(\"[,\", \"[\")\n        item_lines = item_lines.replace(\", }\", \"}\")\n        item_lines = item_lines.replace(\", ]\", \"]\")\n        item_lines = item_lines.replace(\"{,\", \"{\")\n        return item_lines\n    def generate(self, script_obj):\n        # default prettify the target\n        script = \"\"\n        for line_obj in script_obj.dump():\n            for level, item_obj in enumerate(line_obj.dump()):",
        "type": "code",
        "location": "/pyjom/medialang/core.py:165-189"
    },
    "525": {
        "file_id": 35,
        "content": "This code is generating a formatted string from nested lists, ensuring that the lines are within character limits and properly indented. It also replaces unnecessary commas with correct formatting for a more readable output.",
        "type": "comment"
    },
    "526": {
        "file_id": 35,
        "content": "                unit = self.generate_item(item_obj, level=level)\n                # print(\"unit:\",unit)\n                script += unit\n            script += \"\\n\"\n        script = script.replace(\",,\", \",\")\n        script = script.replace(\"[,\", \"[\")\n        script = script.replace(\", }\", \"}\")\n        script = script.replace(\", ]\", \"]\")\n        script = script.replace(\"{,\", \"{\")\n        i = 0\n        maxIndent = 0\n        # script = script.replace(\"'\",'\"') # no freaking single quotes.\n        while True:\n            if i == 0:\n                script = script.replace(\",\\n]\", \"\\n]\")\n                script = script.replace(\",\\n]\", \"\\n]\")\n            else:\n                indentStr = self.indent * i\n                if indentStr in script:\n                    script = script.replace(\n                        \",\\n{}]\".format(indentStr), \"\\n{}]\".format(indentStr)\n                    )\n                    script = script.replace(\n                        \",\\n{}\".format(indentStr) + \"}\", \"\\n{}\".format(indentStr) + \"}\"\n                    )",
        "type": "code",
        "location": "/pyjom/medialang/core.py:190-215"
    },
    "527": {
        "file_id": 35,
        "content": "This code generates a script by creating units of code from item objects, adds indentation and replaces unnecessary commas and quotes. It also handles specific formatting issues like replacing multiple newlines with single ones and ensuring correct syntax for closing brackets or braces.",
        "type": "comment"
    },
    "528": {
        "file_id": 35,
        "content": "                else:\n                    maxIndent = i - 1\n                    break\n            i += 1\n        for index0 in range(maxIndent):\n            indentStr = self.indent * (maxIndent - index0)\n            if indentStr in script:\n                script = script.replace(\n                    \"{}], \".format(indentStr),\n                    \"{}],\\n{}\".format(indentStr, indentStr),\n                )\n                script = script.replace(\n                    \"{}\".format(indentStr) + \"}, \",\n                    \"{}\".format(indentStr) + \"},\\n\" + \"{}\".format(indentStr),\n                )\n        for index in range(maxIndent):\n            indentStr = self.indent * (maxIndent - index)\n            if indentStr in script:\n                # print(\"running\", len(indentStr))\n                script = script.replace(\n                    \"[{}\".format(indentStr),\n                    \"[\",\n                )\n                script = script.replace(\n                    \",{}\".format(indentStr),\n                    \",\",\n                )",
        "type": "code",
        "location": "/pyjom/medialang/core.py:216-242"
    },
    "529": {
        "file_id": 35,
        "content": "This code finds the maximum indent level in a script and replaces occurrences of newline-separated items with the appropriate indentation. It also removes extra indentation from list or tuple elements and removes extra indentation after commas.",
        "type": "comment"
    },
    "530": {
        "file_id": 35,
        "content": "                script = script.replace(\n                    \"{\" + \"{}\".format(indentStr),\n                    \"{\",\n                )\n        script = script.replace(\",,\", \",\")\n        script = script.replace(\"[,\", \"[\")\n        script = script.replace(\", }\", \"}\")\n        script = script.replace(\", ]\", \"]\")\n        script = script.replace(\"{,\", \"{\")\n        script = script.replace(\"{ {\", \"{{\")\n        script = script.replace(\"} }\", \"}}\")\n        script = script.replace(\"] ]\", \"]]\")\n        script = script.replace(\"[ [\", \"[[\")\n        script = script.replace(\"[ \", \"[\")\n        if script.endswith(\"\\n\\n\"):\n            script = script[:-2]\n        if script.startswith(\"\\n\"):\n            script = script[1:]\n        return script\n    def detectGrammar(self, line):\n        result = line.replace(\"\\n\", \"\").replace(\" \", \"\").replace(\"\\t\", \"\")\n        return len(result) != 0\n    def getItems(self, line):\n        # assume there will not be enclosed brackets in string?\n        values = {\"(\": +1, \")\": -1}\n        base = 0\n        items = []",
        "type": "code",
        "location": "/pyjom/medialang/core.py:243-271"
    },
    "531": {
        "file_id": 35,
        "content": "The code is performing a series of string replacements to ensure that the script adheres to proper syntax. It removes extra brackets and newline characters, and detects non-empty lines. The getItems function assumes no nested enclosed brackets in strings.",
        "type": "comment"
    },
    "532": {
        "file_id": 35,
        "content": "        item = \"\"\n        for char in line:\n            value = 0 if char not in values.keys() else values[char]\n            base += value\n            if base > 0:\n                item += char\n            if base == 0 and value != 0:\n                item += char\n                items.append(item)\n                item = \"\"\n        return items\n    def parseItem(self, item):\n        # have dangerous eval.\n        body = item.strip()\n        body = item[1:-1]\n        # print(\"body length:\",len(body))\n        path = re.findall(r'^\"([^\"]+)\"', body)[0]\n        # print(\"found path:\",path)\n        mdict = body[len(path) + 2 :]\n        mdict = mdict.strip()\n        if self.detectGrammar(mdict):\n            mdict = mdict[1:]  # omit the comma.\n            text = \"\"\n            mdict2 = \"\"\n            values = {\"(\": +1, \")\": -1}\n            base = 0\n            try:\n                assert mdict[-1] != \",\"\n            except:\n                raise Exception(\"Found trailing comma:\\n\", mdict)\n            for index, char in enumerate(mdict):",
        "type": "code",
        "location": "/pyjom/medialang/core.py:272-303"
    },
    "533": {
        "file_id": 35,
        "content": "This code parses a string by iterating over each character, accumulating characters that have corresponding values in a dictionary and creating items based on the accumulated value. It also includes a function to parse an item which uses regex to find a path and then processes the remaining string according to specific rules. The code raises an exception if there is a trailing comma in the processed string.",
        "type": "comment"
    },
    "534": {
        "file_id": 35,
        "content": "                lineEnd = index == (len(mdict) - 1)\n                value = 0 if char not in values.keys() else values[char]\n                base += value\n                if char == \"=\":\n                    key = text.strip()\n                    assert not key.startswith(\"#\")\n                    mdict2 += '\"{}\":'.format(key)\n                    text = \"\"\n                elif (char == \",\" and base == 0) or lineEnd:\n                    if lineEnd:\n                        text += char\n                    mtext = text.strip()\n                    # print(\"mtext:\",mtext)\n                    if mtext in [\"False\", \"True\"]:\n                        mtext = mtext.lower()\n                    mdict2 += \"{}\".format(mtext)\n                    if not lineEnd:\n                        mdict2 += \",\"\n                    text = \"\"\n                    if lineEnd:\n                        break\n                else:\n                    text += char\n            # print(\"mdict:\",mdict)\n            mdict2 = mdict2.replace(\"(\", \"[\").replace(\")\", \"]\")",
        "type": "code",
        "location": "/pyjom/medialang/core.py:304-328"
    },
    "535": {
        "file_id": 35,
        "content": "This code processes a string, line by line, and converts it into a dictionary format. It handles key-value pairs separated by \":\" and comma-separated values. If the value is not found in given keys, it defaults to 0. If the value is \"True\" or \"False\", it converts it to lowercase before adding to the dictionary. The code also handles line endings and removes leading \"#\" from keys. Finally, it replaces parentheses with square brackets before returning the processed dictionary.",
        "type": "comment"
    },
    "536": {
        "file_id": 35,
        "content": "            mdict = \"{\" + mdict2 + \"}\"  # might be empty somehow.\n            # print(mdict)\n            mdict = json.loads(mdict)\n        else:\n            mdict = {}\n        item_obj = lexicalItem(path, **mdict)\n        return item_obj\n    def parse(self, script):\n        # will raise exception on unparseable lines.\n        script_obj = lexicalScript()\n        lines = script.split(\"\\n\\n\")\n        lines = [x for x in lines if self.detectGrammar(x)]\n        for line in lines:\n            line_obj = lexicalGroup()\n            # first let's remove all comments.\n            comment_expression = re.compile(r\"#[^\\n]+\")\n            newLine = \"\"\n            for elem in comment_expression.split(line):\n                if not comment_expression.match(elem):\n                    newLine+=elem\n            line = newLine\n            line = line.replace(\"\\n\", \"\").replace(\"\\t\", \"\")\n            line = line.strip()  # have extra spacings.\n            for item in self.getItems(line):\n                if self.detectGrammar(item):\n                    # print(\"item:\",item)",
        "type": "code",
        "location": "/pyjom/medialang/core.py:329-355"
    },
    "537": {
        "file_id": 35,
        "content": "This code defines two functions, \"parse\" and \"__init__\". The \"__init__\" function initializes a class with a path argument. The \"parse\" function takes a script as input, splits it into lines, filters out unparseable lines, and creates objects for each line that is parseable. It removes comments, trims whitespace, and checks if the resulting items are parseable. If so, it adds them to a lexicalGroup object, which will then be added to a lexicalScript object. The code also contains a method to get items from a line of code.",
        "type": "comment"
    },
    "538": {
        "file_id": 35,
        "content": "                    # print(\"item length:\",len(item))\n                    # breakpoint()\n                    try:\n                        item_obj = self.parseItem(item)\n                        line_obj.append(item_obj)\n                    except:\n                        traceback.print_exc()\n                        error_msg = \"Error found in:\\n{}\".format(item)\n                        if self.script_path:\n                            error_msg += \"\\nScript at:\\n{}\".format(self.script_path)\n                        raise Exception(error_msg)\n            script_obj.append(line_obj)\n        return script_obj\n    def prettify(self, script=None, inplace=False):\n        if script == None:\n            assert self.script is not None\n            script = self.script\n        if self.script_obj is None:\n            script_obj = self.parse(script)\n        else:\n            script_obj = self.script_obj\n        script = self.generate(script_obj)\n        if self.script_path is not None:\n            if inplace:\n                with open(self.script_path, \"w+\", encoding=self.encoding) as f:",
        "type": "code",
        "location": "/pyjom/medialang/core.py:356-381"
    },
    "539": {
        "file_id": 35,
        "content": "The code is parsing a script and handling any errors that occur during the process. It appends lines to a script object, checks if the script_obj exists, generates the script based on the script_obj, and writes it to the specified file (if inplace=True).",
        "type": "comment"
    },
    "540": {
        "file_id": 35,
        "content": "                    f.write(script)\n        return script\n    def checkItemType(self, item):\n        assert type(item) == lexicalItem  # you really should learn how to rest.\n        path = item.path\n        if path.startswith(\".\"):\n            return \"output\"\n        for key in medialangProtocols:\n            for elem in medialangProtocols[key]:\n                if path.startswith(elem):\n                    return key\n        if os.path.exists(path):\n            return \"input\"\n        return \"output\"\n    def objectAssertion(self, previous, objectType):\n        assert objectType in [\"input\", \"output\"]\n        if objectType == \"output\":\n            assert previous is not None\n    def objectExecutor(self, item, previous=None):\n        objectType = self.checkItemType(item)\n        path = item.path\n        args = item.args\n        self.objectAssertion(previous, objectType)\n        result = {}  # how to ensure it will do?\n        if objectType == \"output\":\n            if path.startswith(\".\"):\n                function = dotProcessors[path]",
        "type": "code",
        "location": "/pyjom/medialang/core.py:382-411"
    },
    "541": {
        "file_id": 35,
        "content": "This code contains various utility functions used in the medialang module. The 'checkItemType' function determines if an item is an input, output, or protocol file based on its path. The 'objectAssertion' function ensures that the specified object type is either \"input\" or \"output\". Lastly, the 'objectExecutor' function executes a specific action depending on the object type by calling appropriate functions.",
        "type": "comment"
    },
    "542": {
        "file_id": 35,
        "content": "                result = function(item, previous, verbose=self.verbose, medialangTmpDir=self.medialangTmpDir)\n        else:\n            if os.path.exists(path):\n                data = fsProcessor(item, previous=previous, verbose=self.verbose, medialangTmpDir = self.medialangTmpDir)\n                result = data\n            else:\n                pass\n                # inputs. handle with protocols?\n        return result\n    def scriptStructExecutor(self, script_struct):\n        script_type = script_struct[\"type\"]\n        resources = script_struct[\"resource\"]\n        targets = script_struct[\"target\"]\n        data_array = []\n        data = None\n        print(\"Medialang script type:\", script_type)\n        if script_type == \"input\":\n            for item in targets.items:\n                data = self.objectExecutor(item, previous=data)\n            for resource in resources:\n                mdata = copy.deepcopy(data)\n                for item in resource.items:\n                    mdata = self.objectExecutor(item, previous=mdata)",
        "type": "code",
        "location": "/pyjom/medialang/core.py:412-435"
    },
    "543": {
        "file_id": 35,
        "content": "The code is implementing a script execution function. It checks the type of script and executes it accordingly, handling inputs, resources, and targets. The scriptStructExecutor function determines the type of script (input) and iterates through its targets and resources to execute objects using the objectExecutor function. If the path exists, it calls the fsProcessor function; otherwise, it does nothing.",
        "type": "comment"
    },
    "544": {
        "file_id": 35,
        "content": "                data_array.append(mdata)\n        else:\n            for index0, resource in enumerate(resources):\n                # print(\"RESOURCE ENUMERATE\",index0, resource)\n                # breakpoint()\n                mdata = None\n                mdata_array = []\n                for index1, item in enumerate(resource.items):\n                    mdata = self.objectExecutor(item, previous=mdata)\n                    if self.verbose:\n                        print(\"input {}-{}:\".format(index0, index1), mdata) # this is the wrong data array!\n                    mdata_array.append({\"item\":item, \"cache\": mdata}) # where you store all the intermediate files per clip.\n                data_array.append(copy.deepcopy(mdata_array))\n            data = copy.deepcopy(data_array) # so this is your freaking data! let's decide your approach all inside that dotProcessor instead of generating trash here!\n            for item in targets.items:\n                data = self.objectExecutor(item, previous=data)\n        return data, data_array # why you return this!",
        "type": "code",
        "location": "/pyjom/medialang/core.py:436-452"
    },
    "545": {
        "file_id": 35,
        "content": "This code appears to be part of a larger program that processes media resources. It seems to create arrays of intermediate data for each clip, deep copy them into the main data array, and then execute objects on the main data array. The function returns two values: data and data_array. The purpose or use of these returned values is unclear in this context.",
        "type": "comment"
    },
    "546": {
        "file_id": 35,
        "content": "        # currently, data is now the editly json, and data_array is the medialang items array\n        # what about the slient flag? deal with it later!\n    def execute(self):\n        script_obj_lines = self.script_obj.lines\n        assert len(script_obj_lines) >= 1\n        script_struct = {\n            \"target\": script_obj_lines[0],\n            \"resource\": script_obj_lines[1:],\n        }\n        first_target = script_struct[\"target\"].items[0]\n        script_type = self.checkItemType(first_target)\n        script_struct[\"type\"] = script_type\n        item_types = [\"input\", \"output\"]\n        for item_type in item_types:\n            if script_type == item_type:\n                # this is analysis type mediascript. all following shall be output.\n                for line in script_struct[\"resource\"]:\n                    elem = line.items[\n                        0\n                    ]  # only make sure the first item of each line is in agreement with the type rules.\n                    this_item_type = self.checkItemType(elem)",
        "type": "code",
        "location": "/pyjom/medialang/core.py:453-474"
    },
    "547": {
        "file_id": 35,
        "content": "This code defines a function that executes a script object, splits it into target and resource sections, determines the type of the script (input or output), and checks the item type for each line in the resource section.",
        "type": "comment"
    },
    "548": {
        "file_id": 35,
        "content": "                    try:\n                        assert this_item_type is not item_type\n                    except:\n                        traceback.print_exc()\n                        print(\"Medialang Error when parsing resource:\")\n                        print(line)\n                        print(\"Medialang itemtype:\", this_item_type)\n                        print(elem)\n                        if self.script_path:\n                            print(\"Medialang Script path:\", self.script_path)\n                        os.abort()\n                result = self.scriptStructExecutor(script_struct)\n                return result  # tuple (data, data_array)",
        "type": "code",
        "location": "/pyjom/medialang/core.py:475-487"
    },
    "549": {
        "file_id": 35,
        "content": "This code segment is part of a script that handles parsing resources in a Medialang environment. If the item type doesn't match, it prints an error message and aborts the script. Afterwards, it executes the script structure and returns a tuple containing data and data_array.",
        "type": "comment"
    },
    "550": {
        "file_id": 36,
        "content": "/pyjom/medialang/commons.py",
        "type": "filepath"
    },
    "551": {
        "file_id": 36,
        "content": "This code defines functions for serializing SRT objects, handling fatal errors in Medialang, and generating temporary media file names. It also sets the default temporary media directory and uses UUIDs to generate unique filenames.",
        "type": "summary"
    },
    "552": {
        "file_id": 36,
        "content": "from pyjom.commons import *\ndef serializeSRT(srtObj):\n    index = srtObj.index\n    start = srtObj.start.total_seconds()\n    end = srtObj.end.total_seconds()\n    content = srtObj.content\n    data = {\"index\": index, \"timespan\": [start, end], \"content\": content}\n    return data\ndef medialangFatalError(error_msg, script_file):\n    print(\"Medialang fatal error:\", os.path.abspath(script_file))\n    print(error_msg)\n    os.abort()\nmedialangTmpDir = \"/dev/shm/medialang\"\ndef getTmpMediaName(medialangTmpDir = medialangTmpDir):\n    while True:\n        uniq_id = str(uuid.uuid4())\n        uniq_id = uniq_id.replace(\"-\", \"\")\n        fname = \"{}.ts\".format(uniq_id)\n        fpath = os.path.join(medialangTmpDir, fname) # why no respect to the medialang config!\n        if not os.path.exists(fpath):\n            return fpath",
        "type": "code",
        "location": "/pyjom/medialang/commons.py:1-29"
    },
    "553": {
        "file_id": 36,
        "content": "This code defines functions for serializing SRT objects, handling fatal errors in Medialang, and generating temporary media file names. It also sets the default temporary media directory and uses UUIDs to generate unique filenames.",
        "type": "comment"
    },
    "554": {
        "file_id": 37,
        "content": "/pyjom/medialang/__main__.py",
        "type": "filepath"
    },
    "555": {
        "file_id": 37,
        "content": "The code sets up argument parsing for a medialang file path, initializes a Medialang object with the parsed script_path, and if the script_obj is not None, it prettifies the script in-place and prints the path of the prettified script.",
        "type": "summary"
    },
    "556": {
        "file_id": 37,
        "content": "from pyjom.medialang.core import *\nif __name__ == \"__main__\":\n    import argparse\n    arg_parser = argparse.ArgumentParser()\n    arg_parser.add_argument(\n        \"-f\",\n        \"--file\",\n        help=\"medialang file path that needed to be formatted.\",\n        type=str,\n        required=True,\n    )\n    parse_result = arg_parser.parse_args()\n    file_path = parse_result.file\n    mdl = Medialang(script_path=file_path)  # will be parsed.\n    if mdl.script_obj is not None:\n        mdl.prettify(inplace=True)\n        print(\"prettified: \", mdl.script_path)\n    # pass",
        "type": "code",
        "location": "/pyjom/medialang/__main__.py:1-20"
    },
    "557": {
        "file_id": 37,
        "content": "The code sets up argument parsing for a medialang file path, initializes a Medialang object with the parsed script_path, and if the script_obj is not None, it prettifies the script in-place and prints the path of the prettified script.",
        "type": "comment"
    },
    "558": {
        "file_id": 38,
        "content": "/pyjom/medialang/__init__.py",
        "type": "filepath"
    },
    "559": {
        "file_id": 38,
        "content": "This code imports necessary modules from 'pyjom.medialang.core' and 'pyjom.medialang.commons' to facilitate media language processing in the application.",
        "type": "summary"
    },
    "560": {
        "file_id": 38,
        "content": "from pyjom.medialang.core import *\nfrom pyjom.medialang.commons import *",
        "type": "code",
        "location": "/pyjom/medialang/__init__.py:1-2"
    },
    "561": {
        "file_id": 38,
        "content": "This code imports necessary modules from 'pyjom.medialang.core' and 'pyjom.medialang.commons' to facilitate media language processing in the application.",
        "type": "comment"
    },
    "562": {
        "file_id": 39,
        "content": "/pyjom/medialang/processors/__init__.py",
        "type": "filepath"
    },
    "563": {
        "file_id": 39,
        "content": "This code imports the \"dotProcessor\" and \"mediaProcessor\" modules from the \"pyjom.medialang.processors\" package. These processors may be used for processing data related to dots or media in the medialang context.",
        "type": "summary"
    },
    "564": {
        "file_id": 39,
        "content": "from pyjom.medialang.processors.dotProcessor import *\nfrom pyjom.medialang.processors.mediaProcessor import *",
        "type": "code",
        "location": "/pyjom/medialang/processors/__init__.py:1-2"
    },
    "565": {
        "file_id": 39,
        "content": "This code imports the \"dotProcessor\" and \"mediaProcessor\" modules from the \"pyjom.medialang.processors\" package. These processors may be used for processing data related to dots or media in the medialang context.",
        "type": "comment"
    },
    "566": {
        "file_id": 40,
        "content": "/pyjom/medialang/processors/mediaProcessor/filesystemProcessor.py",
        "type": "filepath"
    },
    "567": {
        "file_id": 40,
        "content": "This code segment processes media files based on type (video, audio, or image) and returns the processed file path. It handles media processing by selecting appropriate function and printing media type if verbose is True.",
        "type": "summary"
    },
    "568": {
        "file_id": 40,
        "content": "from pyjom.medialang.commons import *\nimport ffmpeg\ndef videoFsProcessor(videoPath,args={},previous = None, medialangTmpDir = medialangTmpDir):\n    if args == {}:\n        return videoPath\n    newVideoPath = getTmpMediaName(medialangTmpDir = medialangTmpDir)\n    return newVideoPath\ndef audioFsProcessor(audioPath,args={},previous = None, medialangTmpDir = medialangTmpDir):\n    if args == {}:\n        return audioPath\n    newAudioPath = getTmpMediaName(medialangTmpDir = medialangTmpDir)\n    return newAudioPath\ndef imageFsProcessor(imagePath,args={},previous = None, medialangTmpDir = medialangTmpDir):\n    if args == {}:\n        return imagePath\n    newImagePath = getTmpMediaName(medialangTmpDir = medialangTmpDir)\n    return newImagePath\ndef fsProcessor(item,previous=None, verbose=True, medialangTmpDir = medialangTmpDir):\n    path = item.path # it exists!\n    fbase = os.path.basename(path)\n    args = item.args\n    mediatype = getFileType(fbase) # mediatype not sure yet.\n    if verbose:\n        print(\"media path:\",path)",
        "type": "code",
        "location": "/pyjom/medialang/processors/mediaProcessor/filesystemProcessor.py:1-28"
    },
    "569": {
        "file_id": 40,
        "content": "The code contains three functions: videoFsProcessor, audioFsProcessor, and imageFsProcessor. Each function takes a media file path, optional arguments, and temporary directory as inputs. If the arguments are empty, the function returns the original file path; otherwise, it generates a new temporary file path using getTmpMediaName and returns that instead. The fsProcessor function determines the media type (video, audio, or image) based on the file's extension, selects the appropriate processor function, and applies it to the file path. If verbose is True, it prints the media path.",
        "type": "comment"
    },
    "570": {
        "file_id": 40,
        "content": "        print(\"media type:\",mediatype)\n    # handle to ffmpeg.\n    mediaFunctions = {\"video\":videoFsProcessor,\"audio\":audioFsProcessor,\"image\":imageFsProcessor}\n    data = mediaFunctions[mediatype](path,args=args,previous=previous, medialangTmpDir = medialangTmpDir)\n    return data",
        "type": "code",
        "location": "/pyjom/medialang/processors/mediaProcessor/filesystemProcessor.py:29-33"
    },
    "571": {
        "file_id": 40,
        "content": "This code segment handles media processing based on the type. It prints the media type, creates a dictionary of function handlers for video, audio, and image, processes the media using the corresponding function, and returns the result.",
        "type": "comment"
    },
    "572": {
        "file_id": 41,
        "content": "/pyjom/medialang/processors/mediaProcessor/__init__.py",
        "type": "filepath"
    },
    "573": {
        "file_id": 41,
        "content": "Importing filesystemProcessor module from pyjom.medialang.processors.mediaProcessor package.",
        "type": "summary"
    },
    "574": {
        "file_id": 41,
        "content": "from pyjom.medialang.processors.mediaProcessor.filesystemProcessor import *",
        "type": "code",
        "location": "/pyjom/medialang/processors/mediaProcessor/__init__.py:1-1"
    },
    "575": {
        "file_id": 41,
        "content": "Importing filesystemProcessor module from pyjom.medialang.processors.mediaProcessor package.",
        "type": "comment"
    },
    "576": {
        "file_id": 42,
        "content": "/pyjom/medialang/processors/dotProcessor/videoProcessor.py",
        "type": "filepath"
    },
    "577": {
        "file_id": 42,
        "content": "The code utilizes Editly and Fmpeg for video filtering, detects text/logos, crop regions, and handles errors while generating UUIDs, storing temp videos, modifying clip properties, setting layer durations, adding clips to templates, and executes with formatted output.",
        "type": "summary"
    },
    "578": {
        "file_id": 42,
        "content": "from pyjom.medialang.functions import *\nfrom pyjom.medialang.commons import *\nfrom pyjom.mathlib import *\nfrom pyjom.videotoolbox import *\nimport tempfile\nimport ffmpeg\ndef executeEditlyScript(medialangTmpDir, editly_json):\n    editlyJsonSavePath = os.path.join(medialangTmpDir, \"editly.json\")\n    with open(editlyJsonSavePath, \"w+\", encoding=\"utf8\") as f:\n        f.write(json.dumps(editly_json, ensure_ascii=False))\n    print(\"EXECUTING EDITLY JSON AT %s\" % editlyJsonSavePath)\n    commandline = [\"xvfb-run\", \"editly\", \"--json\", editlyJsonSavePath]\n    print(commandline)\n    status = subprocess.run(commandline)  # is it even successful?\n    returncode = status.returncode\n    assert returncode == 0\n    print(\"RENDER SUCCESSFUL\")\nfrom typing import Literal, List\ndef ffmpegVideoPreProductionFilter(\n    filepath,  # this is actually a video path. must be video here.\n    start=None,\n    end=None,\n    cachePath=None,\n    audio=False,\n    epsilon=0.000001,\n    filters: List[\n        Literal[\n            \"minterpolate\",  # add time-saver option for this shit. use 'blend' instead of motion vector based compensation.",
        "type": "code",
        "location": "/pyjom/medialang/processors/dotProcessor/videoProcessor.py:1-34"
    },
    "579": {
        "file_id": 42,
        "content": "The code is a Python script that contains functions for video processing using the Editly library and FFmpeg. It defines the `executeEditlyScript` function which takes a temporary directory and an Editly JSON object, saves it to disk, executes the Editly command line tool with the saved JSON file, and asserts that the operation was successful. The script also includes the `ffmpegVideoPreProductionFilter` function which processes video files using FFmpeg filters, optional start/end time parameters, audio flag, and a list of filter options like \"minterpolate\".",
        "type": "comment"
    },
    "580": {
        "file_id": 42,
        "content": "            \"removegrain\",\n            \"bilateral\",\n            \"randomFlip\",\n            \"superResolution\",\n            \"pipCrop\",\n            \"textRemoval\",\n            \"logoRemoval\",\n            \"minterpolate_mi_mode=blend\",\n        ]\n    ] = [  # what is slowing us down?\n        \"pipCrop\",\n        \"textRemoval\",  # we got a problem here?\n        \"logoRemoval\",\n        \"randomFlip\",  # these are common\n        \"superResolution\",  # optional below\n        # \"minterpolate\",\n        # \"minterpolate_mi_mode=blend\", # this might be the problem.\n        # \"removegrain\",\n        # \"bilateral\",\n    ],\n    preview=True,\n    # padding=True,\n    paddingBlur=True,\n    output_width: int = 1920,\n    output_height: int = 1080,\n):  # what is the type of this shit?\n    # enable that 'fast' flag? or we use low_resolution ones? not good since that will ruin our detection system!\n    # anyway it will get processed? or not?\n    # uncertain. very uncertain.\n    def paddingBlurFilter(stream, mWidth=1920, mHeight=1080):\n        # video_stream = stream.video",
        "type": "code",
        "location": "/pyjom/medialang/processors/dotProcessor/videoProcessor.py:35-65"
    },
    "581": {
        "file_id": 42,
        "content": "This code defines a function `paddingBlurFilter` that takes a video stream as input and applies padding and blur effects if the `paddingBlur` parameter is set to `True`. The video stream's width and height are set to 1920x1080 unless specified otherwise. The code also provides a list of processing steps, where some are marked as common, optional, or potentially causing problems.",
        "type": "comment"
    },
    "582": {
        "file_id": 42,
        "content": "        video_stream = stream\n        video_stream_split = video_stream.split()\n        output_width = mWidth\n        output_height = mHeight\n        layer_0 = (\n            video_stream_split[0]\n            .filter(\"scale\", w=output_width, h=output_height)\n            .filter(\"gblur\", sigma=9)\n        )\n        layer_1 = video_stream_split[1].filter(\n            \"scale\",\n            w=\"min(floor(iw*{}/ih),{})\".format(output_height, output_width),\n            h=\"min(floor(ih*{}/iw),{})\".format(output_width, output_height),\n        )\n        output_stream = layer_0.overlay(layer_1, x=\"floor((W-w)/2)\", y=\"floor((H-h)/2)\")\n        return output_stream\n    def paddingFilter(stream, mWidth=1920, mHeight=1080):\n        width = \"max(iw, ceil(ih*max({}/{}, iw/ih)))\".format(mWidth, mHeight)\n        height = \"max(ih, ceil(iw*max({}/{}, ih/iw)))\".format(mHeight, mWidth)\n        x = \"max(0,floor(({}-iw)/2))\".format(width)\n        y = \"max(0,floor(({}-ih)/2))\".format(height)\n        return (\n            stream.filter(\n                \"pad\", width=width, height=height, x=x, y=y, color=\"black\"",
        "type": "code",
        "location": "/pyjom/medialang/processors/dotProcessor/videoProcessor.py:66-90"
    },
    "583": {
        "file_id": 42,
        "content": "This code defines two functions: `videoProcessor` and `paddingFilter`. The `videoProcessor` function takes a video stream, scales and blurs the first layer of the split video, scales the second layer maintaining aspect ratio, then overlays both layers with padding. The `paddingFilter` function calculates the width and height for padding to center the video. Both functions take optional parameters `mWidth` and `mHeight` for the output resolution.",
        "type": "comment"
    },
    "584": {
        "file_id": 42,
        "content": "            )  # here to control the padding logic, decide how to 'blur' the thing!\n            .filter(\"scale\", w=mWidth, h=mHeight)\n            .filter(\"setsar\", 1)\n        )\n    assert cachePath is not None\n    assert start is not None\n    assert end is not None\n    # from 4 to 10 seconds?\n    defaultWidth, defaultHeight = getVideoWidthHeight(filepath)\n    previewRatio = 1\n    if preview:\n        previewWidth, previewHeight = getVideoPreviewPixels(filepath)\n        previewRatio = previewWidth / defaultWidth\n        def previewFilter(stream):\n            # maintain original ratio?\n            return stream.filter(\n                \"scale\",\n                \"ceil((iw*{})/4)*4\".format(previewRatio),\n                \"ceil((ih*{})/4)*4\".format(previewRatio),\n            )\n    # stream = ffmpeg.hflip(stream)\n    # this fliping may be useful for copyright evasion, but not very useful for filtering. it just adds more computational burden.\n    # we just need to crop this.\n    # stream = ffmpeg.output(stream, cachePath)",
        "type": "code",
        "location": "/pyjom/medialang/processors/dotProcessor/videoProcessor.py:91-117"
    },
    "585": {
        "file_id": 42,
        "content": "Code snippet performs video processing operations including scaling, setting aspect ratio, and potentially applying a preview filter based on the input filepath. It also considers cropping instead of flipping for improved efficiency and removes any unnecessary computational burden.",
        "type": "comment"
    },
    "586": {
        "file_id": 42,
        "content": "    # ffmpeg.run(stream, overwrite_output=True)\n    # procedureList = []\n    # stream = ffmpeg.input\n    # no_processing = True # change this flag if anything need to change in original video according to filter results.\n    # logo removal/text removal first, pipCrop last.\n    # if overlap, we sort things.\n    # if not, no sorting is needed.\n    mDict = {}\n    def delogoFilter(stream, commandParams):\n        return stream.filter(\n            \"delogo\",\n            x=commandParams[\"x\"],\n            y=commandParams[\"y\"],\n            w=commandParams[\"w\"],\n            h=commandParams[\"h\"],\n        )\n    def cropFilter(stream, commandParams):\n        return stream.filter(\n            \"crop\",\n            x=commandParams[\"x\"],\n            y=commandParams[\"y\"],\n            w=commandParams[\"w\"],\n            h=commandParams[\"h\"],\n        )\n    def filterCommandStringParser(filterCommandString):\n        args_with_kwargs = filterCommandString.split(\":\")\n        args = []\n        kwargs = {}\n        for elem in args_with_kwargs:",
        "type": "code",
        "location": "/pyjom/medialang/processors/dotProcessor/videoProcessor.py:118-151"
    },
    "587": {
        "file_id": 42,
        "content": "This code defines functions for applying filters to video streams using ffmpeg. It defines delogoFilter() and cropFilter() functions that take stream and commandParams as input, apply respective filters using ffmpeg, and return the filtered stream. The filterCommandStringParser() function parses filter command strings into arguments and keyword arguments.",
        "type": "comment"
    },
    "588": {
        "file_id": 42,
        "content": "            if \"=\" in elem:\n                key, value = elem.split(\"=\")\n                kwargs.update({key: value})\n            else:\n                args.append(elem)\n        return args, kwargs\n    def ffmpegStringFilter(stream, commandString):\n        filterName = commandString.split(\"_\")[0]\n        filterPrefix = \"{}_\".format(filterName)\n        filterCommandString = commandString[len(filterPrefix) :]\n        args, kwargs = filterCommandStringParser(filterCommandString)\n        # print(commandString)\n        # print(args, kwargs)\n        # breakpoint()\n        return stream.filter(\"scale\", *args, **kwargs)\n    # TODO: FIX THIS SHIT!\n    # raise Exception(\"TODO: FIX THIS SHIT!\")\n    # these things are ordered to be the last ones. just flags.\n    from caer.video.frames_and_fps import get_duration\n    video_start = 0\n    video_end = get_duration(filepath)\n    if \"randomFlip\" in filters:\n        if random.random() > 0.5:\n            mDict.update({\"hflip\": [(start, end)]})\n    if \"superResolution\" in filters:",
        "type": "code",
        "location": "/pyjom/medialang/processors/dotProcessor/videoProcessor.py:152-180"
    },
    "589": {
        "file_id": 42,
        "content": "The code defines a function `ffmpegStringFilter` which takes in a stream and command string. It splits the command string into its filter name, filter prefix, and filter command string. Then it calls another function `filterCommandStringParser` to parse the filter command string into arguments (args) and keyword arguments (kwargs). Finally, it returns the filtered video stream using the parsed arguments. Additionally, there are two TODO comments to fix some issues later on.",
        "type": "comment"
    },
    "590": {
        "file_id": 42,
        "content": " # not working for extremely poor quality images. however, we can fetch these video elsewhere. no need to repair.\n        mDict.update({\"scale_w=iw*2:h=ih*2:flags=lanczos\": [(start, end)]})\n        # how to parse this shit?\n    simpleFilters = [\"minterpolate\", \"removegrain\", \"bilateral\"]\n    for filterName in simpleFilters:\n        for myFilter in filters:\n            if myFilter.startswith(filterName):\n                # if filterName == \"minterpolate\":\n                # filterName += \"_mi_mode=blend\"\n                # print(\"FILTER NAME:\", filterName)\n                # breakpoint()\n                mDict.update({filterName: [(start, end)]})\n    pipCropDicts = None\n    if \"pipCrop\" in filters:\n        # remember: if pip crop makes any of our logoRemoval or textRemoval filters invalid, we do not execute them.\n        # also it will affect parameters of logoRemoval.\n        pipCropDicts = detectPipRegionOverTime(filepath, start, end)\n        mDict.update(pipCropDicts)  # using default settings?\n        # pass",
        "type": "code",
        "location": "/pyjom/medialang/processors/dotProcessor/videoProcessor.py:180-199"
    },
    "591": {
        "file_id": 42,
        "content": "Code snippet is updating a dictionary with specified filters and their corresponding time intervals. It checks if any 'pipCrop' filter is present, and if so, it retrieves the PIP crop regions over time using a separate function 'detectPipRegionOverTime'. The retrieved crop regions are then added to the dictionary using default settings.",
        "type": "comment"
    },
    "592": {
        "file_id": 42,
        "content": "    if \"textRemoval\" in filters:\n        # process the video, during that duration. fast seek avaliable?\n        mDict.update(detectTextRegionOverTime(filepath, start, end))\n        # pass\n    if \"logoRemoval\" in filters:\n        # dual safe? no?\n        # the dict is not hashable. warning!\n        stationaryLogoDicts = detectStationaryLogoOverTime(\n            filepath, start, end, pipCropDicts=pipCropDicts\n        )  # this need to be improvised. if it is long, we need to do another check.\n        if video_end > 30:\n            stationaryLogoDicts.update(\n                detectStationaryLogoOverTime(\n                    filepath, video_start, video_end, cornersOnly=False, top_k=5\n                )  # are you sure? wtf?\n                # i mean area size similar than one of the corners.\n            )\n        # reprocess these things. really?\n        mDict.update(stationaryLogoDicts)  # output logo mask. or not.\n        # estimate the shape with multiple rectangles? packing algorithm?\n        # polygon to rectangle? decomposition?",
        "type": "code",
        "location": "/pyjom/medialang/processors/dotProcessor/videoProcessor.py:200-220"
    },
    "593": {
        "file_id": 42,
        "content": "The code checks if \"textRemoval\" and \"logoRemoval\" are in the filters. If \"textRemoval\" is present, it detects text regions over time for the given video filepath, start, and end duration. If \"logoRemoval\" is present, it detects stationary logos using detectStationaryLogoOverTime function and updates mDict with the results, but only if the video length is greater than 30 seconds. It also considers updating mDict with additional stationary logos if needed by calling detectStationaryLogoOverTime again. Finally, it updates mDict with the stationary logo dictionaries and suggests using a packing algorithm to estimate shapes with multiple rectangles.",
        "type": "comment"
    },
    "594": {
        "file_id": 42,
        "content": "        # pass\n    MAX_INT = 999999\n    commandValueMap = {\n        \"empty\": -1,\n        \"delogo\": 0,\n        \"crop\": 1,\n        \"removegrain\": 2,\n        \"bilateral\": 2,\n        \"scale\": 3,  ## wtf?\n        \"minterpolate\": 4,\n        \"hflip\": MAX_INT,\n        \"vflip\": MAX_INT,\n    }  # no scale filter shall present. we do not provide such creep. editly will handle it.\n    # commandValueMap.update(simpleFiltersValueMap)\n    renderDict = getContinualMappedNonSympyMergeResultWithRangedEmpty(mDict, start, end)\n    # now we consider the rendering process. how?\n    # shall we line it up?\n    if (\n        list(renderDict.keys()) == [\"empty\"] and not preview\n    ):  # not preview! so we need not to downscale this thing.\n        # nothing happens. just return the original shit.\n        return filepath\n    renderList = mergedRangesToSequential(renderDict)\n    renderVideoStreamList = []\n    if audio:\n        # we may want audio sometime, but not this time.\n        renderAudioStream = ffmpeg.input(filepath, ss=start, to=end).audio",
        "type": "code",
        "location": "/pyjom/medialang/processors/dotProcessor/videoProcessor.py:221-248"
    },
    "595": {
        "file_id": 42,
        "content": "The code defines a commandValueMap for different video processing commands and checks if the renderDict contains only \"empty\" key. If it does, it returns the original file path without any processing. If not, it converts merged rendering ranges into sequential format and creates a list of renderVideoStreams (excluding audio if specified).",
        "type": "comment"
    },
    "596": {
        "file_id": 42,
        "content": "    # for elem in renderList:\n    #     print(elem)\n    # breakpoint()\n    # videoDuration = getVideoDuration(videoPath)\n    for renderCommandIndex, (renderCommandString, commandTimeSpan) in enumerate(\n        renderList\n    ):\n        print(\"#{}\".format(renderCommandIndex), renderCommandString, commandTimeSpan)\n        mStart, mEnd = commandTimeSpan\n        mStart = max(start, mStart)\n        mEnd = min(mEnd, end)\n        clipDuration = mEnd - mStart\n        if clipDuration < epsilon:\n            continue  # if so, this clip is shit.\n        # print(\"CLIP TIMESPAN:\", mStart, mEnd)\n        stream = ffmpeg.input(\n            filepath, ss=mStart, to=mEnd, hwaccel=\"vulkan\"\n        ).video  # no audio? seriously?\n        # this is video stream.\n        if renderCommandString == \"empty\":\n            pass  # do not continue since maybe we have preview filter below?\n            # still need to append shit below. we cannot skip this loop.\n        # do nothing.\n        else:\n            renderCommands = renderCommandString.split(\"|\")",
        "type": "code",
        "location": "/pyjom/medialang/processors/dotProcessor/videoProcessor.py:249-274"
    },
    "597": {
        "file_id": 42,
        "content": "The code iterates through a list of render commands, each with a time span. It prints each command and the corresponding timespan, skips any clip duration less than epsilon, and gets the video stream using ffmpeg for specified start and end times. If the command is \"empty\", it does nothing; otherwise, it splits the command into separate render commands.",
        "type": "comment"
    },
    "598": {
        "file_id": 42,
        "content": "            # sort all commands?\n            renderCommands.sort(\n                key=lambda command: commandValueMap[command.split(\"_\")[0]]\n            )\n            from pyjom.mathlib import uniq\n            for renderCommand in uniq(renderCommands):\n                # print('RENDER COMMAND:',renderCommand, \"SPAN\", mStart, mEnd)\n                # breakpoint()\n                if renderCommand == \"empty\":\n                    # yeah we have failsafe.\n                    continue\n                if \"_\" not in renderCommand:\n                    stream = stream.filter(renderCommand)\n                elif \"=\" in renderCommand:\n                    stream = ffmpegStringFilter(\n                        stream, renderCommand\n                    )  # do not check for validity!\n                else:\n                    # non standard filter formats below. be warned.\n                    for prefix, keyword in [\n                        (\"{}_\".format(k), k) for k in [\"delogo\", \"crop\"]\n                    ]:\n                        if renderCommand.startswith(prefix):",
        "type": "code",
        "location": "/pyjom/medialang/processors/dotProcessor/videoProcessor.py:275-298"
    },
    "599": {
        "file_id": 42,
        "content": "Code is sorting commands based on a given key and applying them to the stream. If a command doesn't have an operator or contains non-standard filter formats, it applies prefix-based actions. The code handles different types of filters including 'delogo', 'crop', etc., and applies them accordingly to the stream.",
        "type": "comment"
    }
}