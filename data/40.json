{
    "4000": {
        "file_id": 505,
        "content": "        # no_loop()\n        # clear\n    # s0 = stemp0\n        # end all evil.\n    counterx+=1\n    # load_font(\"SimHei.ttf\")\n    print(\"text w/h:\",tw,th)\n    # for l, text9 in enumerate(s0):\n    text9 = s0[-1][-1]\n    l = len(s0)-1\n    text(text9, (xcoord+text_width(s0[-1][:-1]), ycoord+ l*(tsize*1.2)))  # add str() to key\n    save_frame(\"screenshot.png\")\nrun()\nprint(\"EXITED.\")",
        "type": "code",
        "location": "/tests/bilibili_practices/bilibili_tarot/generate_typography.py:49-64"
    },
    "4001": {
        "file_id": 505,
        "content": "The code snippet seems to be responsible for generating typography using a specific font and displaying it on the screen. It tracks the length of the text being displayed, calculates the position based on that length, and saves a screenshot after each iteration. The loop continues until all elements in 's0' are processed, and then it exits.",
        "type": "comment"
    },
    "4002": {
        "file_id": 506,
        "content": "/tests/bilibili_practices/bilibili_tarot/generate_demo_tarot.py",
        "type": "filepath"
    },
    "4003": {
        "file_id": 506,
        "content": "The code imports libraries, creates a video clip from an image, applies filters, saves it, and then resizes/pads the file using ffmpeg.",
        "type": "summary"
    },
    "4004": {
        "file_id": 506,
        "content": "import os\nfrom vidpy import Clip, Composition  #many shitty things...\ntarot_target = \"/root/Desktop/works/bilibili_tarot/tarot_pictures/0_THE_FOOL.jpg\"\nos.system(\"rm tarot_demo.mp4\")\nfps =60\nmyprofile = {'width': 1320, 'height': 2644}\n# just create profile from it. are you sure?\nclip = Clip(tarot_target, output_fps=fps,start=0, end=16, profile_override=myprofile,override=False)\n# clip.edgeglow()\n# clip.crop\n# 1320x2645 # unbelievable.\n# clip.fx(\"\",{})\n# clip.resize(w=1920, h=1080, distort=True)\n# distort=False\nc_w = clip.width\nc_h = clip.height\n# comp = Composition([clip])\nclip.dither(amount=0.2) # the greater the better.\nclip.fadein(0.5)      # fade the clip in over 1 second\n# clip.fadeout(3.5)   # fade the clip over 0.5 seconds\n# clip.glow(3.5)         # add a glow effect\nclip.spin(4, axis=\"z\")\n# clip.crop(right=c_w,bottom=c_h)\nclip.save(\"tarot_demo.mp4\", fps=60,duration = 3,width=c_w,height=c_h) # good.\n# print(c_w,c_h)\n# 720 576\nr1 = c_w/c_h\ntarget_w, target_h = 1920, 1080\nr2 = target_w/ target_h\nif r1 < r2:\n  ",
        "type": "code",
        "location": "/tests/bilibili_practices/bilibili_tarot/generate_demo_tarot.py:1-32"
    },
    "4005": {
        "file_id": 506,
        "content": "The code imports necessary libraries, defines a tarot image file path and removes an existing mp4 file. It then creates a video clip object from the image using specific parameters, applies various filters and transformations to the clip, saves the modified clip as \"tarot_demo.mp4\" with specified duration, width, and height.",
        "type": "comment"
    },
    "4006": {
        "file_id": 506,
        "content": "  os.system('ffmpeg -y -i tarot_demo.mp4  -vf \"scale=-1:{},pad={}:ih:(ow-iw)/2\"  tarot_demo2.mp4'.format(target_h,target_w))\nelse:\n    os.system('ffmpeg -y -i tarot_demo.mp4  -vf \"scale={}:-1,pad=iw:{}:0:(oh-ih)/2\"  tarot_demo2.mp4'.format(target_w,target_h))",
        "type": "code",
        "location": "/tests/bilibili_practices/bilibili_tarot/generate_demo_tarot.py:32-34"
    },
    "4007": {
        "file_id": 506,
        "content": "This code uses ffmpeg to resize and pad tarot_demo.mp4 video file into tarot_demo2.mp4, adjusting dimensions based on target_h and target_w variables.",
        "type": "comment"
    },
    "4008": {
        "file_id": 507,
        "content": "/tests/bilibili_practices/bilibili_tarot/gen_typo_video_seq.py",
        "type": "filepath"
    },
    "4009": {
        "file_id": 507,
        "content": "Generates a video sequence by splitting images into clips with adjusted duration and fps, appends background music clip, composes the clips into a single composition, and saves it as \"typography_demo.mp4\".",
        "type": "summary"
    },
    "4010": {
        "file_id": 507,
        "content": "seq = [0,1,2,3,4,5,6] # 7\nduration = 4\nmduration = duration / len(seq)\nfrom vidpy import Composition, Clip\nclips = []\nwidth,height =1920,1080\nfps=60\norig_fps = 24\nshift = fps/orig_fps\nfor i,s in enumerate(seq):\n    codec = str(s)\n    codec = \"0\"*(4-len(codec)) + codec\n    path = \"/root/Desktop/works/bilibili_tarot/demo_typography/screenshot{}.png\".format(codec)\n    start = i*mduration\n    end = start + mduration\n    print(start,end)\n    clip = Clip(path,output_fps=fps,start=0,end=mduration*shift,offset = start*shift,profile_override = {\"fps\":60,\"width\": width, \"height\": height})\n    clips.append(clip)\n# breakpoint()\nbgm_path = \"/root/Desktop/works/bilibili_tarot/some_bgm.mp3\"\n# maybe some other bgm.\nbgm = Clip(bgm_path,start=0)\nclips.append(bgm)\n# breakpoint()\ncomp = Composition(clips,duration=duration,fps=fps,width=width,height=height)\ncomp.save(\"typography_demo.mp4\",fps=60,duration = duration,width=width,height=height)",
        "type": "code",
        "location": "/tests/bilibili_practices/bilibili_tarot/gen_typo_video_seq.py:1-35"
    },
    "4011": {
        "file_id": 507,
        "content": "Generates a video sequence by splitting images into clips with adjusted duration and fps, appends background music clip, composes the clips into a single composition, and saves it as \"typography_demo.mp4\".",
        "type": "comment"
    },
    "4012": {
        "file_id": 508,
        "content": "/tests/bilibili_practices/bilibili_tarot/functional_voice_with_pictures.py",
        "type": "filepath"
    },
    "4013": {
        "file_id": 508,
        "content": "This code generates typography for videos using TTS, external tools, and FFMPEG, performing directory operations, merging audio/video, exporting, calculating tempo, and applying it to the audio track.",
        "type": "summary"
    },
    "4014": {
        "file_id": 508,
        "content": "import os\nfrom test_common import *\nimport shutil\ndef split_sentences(sent):\n    spliters = \"\\n，。、？： \"\n    cursent = \"\"\n    results = []\n    for elem in sent:\n        cursent += elem\n        if elem in spliters:\n            results.append(cursent)\n            cursent = \"\"\n    if len(cursent) > 0:\n        results.append(cursent)\n    return results\ndef get_speech(sent,output):\n    assert output.endswith(\".wav\")\n    os.system(\"bash kill_pdspc.sh\")\n    with open(\"temp.txt\", \"w+\",encoding=\"utf-8\") as f:\n        f.write(sent.replace(\"\\n\",\"\")) # important.\n    os.system(\"cat temp.txt | paddlespeech tts --output {}\".format(output))\nfrom pydub import AudioSegment\nfrom functional_gen_typo_video_seq import gen_video\n# import matplotlib # doing this before importing moviepy editor. or we will fail.\n# matplotlib.use(\"TkAgg\")\n# from moviepy.editor import VideoFileClip\n# cannot mix moviepy with vidpy or we get fucked.\nfrom MediaInfo import MediaInfo\ndef merge_audio(asegs):\n    audio_3 = AudioSegment.empty() #shit\n    for seg in asegs:",
        "type": "code",
        "location": "/tests/bilibili_practices/bilibili_tarot/functional_voice_with_pictures.py:1-35"
    },
    "4015": {
        "file_id": 508,
        "content": "The code imports necessary libraries and defines functions for handling sentences, obtaining speech output, and merging audio segments. It also sets up a function that generates a video using the functional_gen_typo_video_seq module. The code uses bash scripts and external tools like PaddleSpeech and MediaInfo to manipulate text-to-speech and audio/video files.",
        "type": "comment"
    },
    "4016": {
        "file_id": 508,
        "content": "        try:\n            audio_3 = audio_3.append(seg,crossfade=100) # also shit.\n        except:\n            audio_3 = audio_3.append(seg,crossfade=0) # also shit.\n    return audio_3\n    # audio_3.export(\"audio_3.wav\", format=\"wav\")\ndef gen_typography_part2(intro_text, bgm_path,target_video):\n    # intro_text = \"\"\"塔罗牌，由“TAROT”一词音译而来，被称为“大自然的奥秘库”。抽取一张塔罗牌，今天的你会是怎样的呢？\"\"\"\n    os.system(\"bash kill_pdspc.sh\")\n    sents = split_sentences(intro_text)\n    # breakpoint()\n    voice_dir = \"voice\"\n    video_dir = \"video\"\n    os.system(\"rm -rf {}\".format(voice_dir))\n    os.system(\"rm -rf {}\".format(video_dir))\n    os.mkdir(\"{}\".format(voice_dir))\n    os.mkdir(\"{}\".format(video_dir))\n    index = 0\n    voice_clips = []\n    video_names = []\n    for i,sent in enumerate(sents):\n        print(\"READING:\",sent)\n        aname = \"{}/{}.wav\".format(voice_dir,i)\n        get_speech(sent,aname)\n        lsent = len(sent)\n        # if no audio then just skip.\n        if not os.path.exists(aname):\n            index += lsent\n            continue",
        "type": "code",
        "location": "/tests/bilibili_practices/bilibili_tarot/functional_voice_with_pictures.py:36-66"
    },
    "4017": {
        "file_id": 508,
        "content": "This code is attempting to generate typography for a video using voice and pictures. It first clears the existing voice and video directories, then creates new ones. It splits the input text into sentences, and for each sentence, it attempts to get speech audio from that sentence and create a corresponding picture. If no audio is found, it skips that sentence. Finally, it returns the generated audio.",
        "type": "comment"
    },
    "4018": {
        "file_id": 508,
        "content": "        seg = AudioSegment.from_wav(aname)\n        duration = seg.duration_seconds\n        voice_clips.append(seg)\n        # get the duration you fuck.\n        # breakpoint()\n        current_indexs = list(range(index,index+lsent))\n        # you can generate video for it.\n        index += lsent\n        vname = \"{}/{}.mp4\".format(video_dir,i)\n        gen_video(vname,current_indexs,duration) # where from?\n        video_names.append(vname)\n    # and finally?\n    final_video = \"{}/final_video.mp4\".format(video_dir)\n    final_audio = \"{}/final_audio.wav\".format(voice_dir)\n    audio_merged = merge_audio(voice_clips)\n    # bgm_path = \"/root/Desktop/works/bilibili_tarot/some_bgm.mp3\"\n    bgm = AudioSegment.from_mp3(bgm_path)\n    # duration2 = audio_merged.duration_seconds\n    # bgm = bgm[:duration2*1000] # really?\n    # breakpoint()\n    # audio_merged = audio_merged.overlay(audio_merged,bgm,loop=True)  #wtf?\n    audio_merged = audio_merged.overlay(bgm,loop=True)\n    # audio_merged = audio_merged.normalize()\n    # is it needed?",
        "type": "code",
        "location": "/tests/bilibili_practices/bilibili_tarot/functional_voice_with_pictures.py:67-91"
    },
    "4019": {
        "file_id": 508,
        "content": "This code generates videos for each segment of audio and appends the video names to a list. It then combines all audio clips into one merged audio file, overlays background music, and saves the final audio and video files. The code also includes debugging tools like breakpoint() to help with troubleshooting.",
        "type": "comment"
    },
    "4020": {
        "file_id": 508,
        "content": "    # shit.\n    audio_merged.export(final_audio, format=\"wav\")\n    final_video2 = \"{}/final_video2.mp4\".format(video_dir)\n    with open(\"mylist.txt\",\"w+\") as f:\n        for n in video_names:\n            f.write(\"file \"+n+\"\\n\")\n    os.system(\"ffmpeg -f concat -safe 0 -i mylist.txt -c copy {}\".format(final_video))\n    # output_length = VideoFileClip(final_video).duration\n    output_length = MediaInfo(filename=final_video).getInfo()[\"videoDuration\"]\n    output_length = float(output_length)\n    input_length = AudioSegment.from_wav(final_audio).duration_seconds\n    tempo = input_length/output_length\n    t_a,t_b = tempo.as_integer_ratio()\n    os.system('ffmpeg -i {} -i {} -c:v copy -c:a aac -filter:a \"atempo={}/{}\" -map 0:v:0 -map 1:a:0 {}'.format(final_video,final_audio,t_a,t_b,final_video2))\n    shutil.move(final_video2,target_video)\ndef gen_typography_part3(intro_text, target_video): #slient\n    # intro_text = \"\"\"塔罗牌，由“TAROT”一词音译而来，被称为“大自然的奥秘库”。抽取一张塔罗牌，今天的你会是怎样的呢？\"\"\"\n    os.system(\"bash kill_pdspc.sh\")\n    sents = split_sentences(intro_text)",
        "type": "code",
        "location": "/tests/bilibili_practices/bilibili_tarot/functional_voice_with_pictures.py:92-114"
    },
    "4021": {
        "file_id": 508,
        "content": "This code performs video and audio processing, using ffmpeg commands to merge and manipulate the files. It exports an audio file in wav format, creates a mylist.txt file with video names, concatenates videos using ffmpeg, calculates the tempo between audio and video duration, applies the tempo to the final audio track, and finally moves the final video to the target location. This function also includes a shell command to kill pdspc process when finished.",
        "type": "comment"
    },
    "4022": {
        "file_id": 508,
        "content": "    # breakpoint()\n    voice_dir = \"voice\"\n    video_dir = \"video\"\n    os.system(\"rm -rf {}\".format(voice_dir))\n    os.system(\"rm -rf {}\".format(video_dir))\n    os.mkdir(\"{}\".format(voice_dir))\n    os.mkdir(\"{}\".format(video_dir))\n    index = 0\n    voice_clips = []\n    video_names = []\n    for i,sent in enumerate(sents):\n        print(\"READING:\",sent)\n        aname = \"{}/{}.wav\".format(voice_dir,i)\n        get_speech(sent,aname)\n        lsent = len(sent)\n        # if no audio then just skip.\n        if not os.path.exists(aname):\n            index += lsent\n            continue\n        seg = AudioSegment.from_wav(aname)\n        duration = seg.duration_seconds\n        voice_clips.append(seg)\n        # get the duration you fuck.\n        # breakpoint()\n        current_indexs = list(range(index,index+lsent))\n        # you can generate video for it.\n        index += lsent\n        vname = \"{}/{}.mp4\".format(video_dir,i)\n        gen_video(vname,current_indexs,duration) # where from?\n        video_names.append(vname)\n    # and finally?",
        "type": "code",
        "location": "/tests/bilibili_practices/bilibili_tarot/functional_voice_with_pictures.py:115-147"
    },
    "4023": {
        "file_id": 508,
        "content": "This code removes existing voice and video directories, creates new ones, reads sentences, saves corresponding audio files for each sentence, checks if audio files are generated correctly, generates videos based on the sentences and their respective positions in the text, and stores the names of generated videos.",
        "type": "comment"
    },
    "4024": {
        "file_id": 508,
        "content": "    final_video = \"{}/final_video.mp4\".format(video_dir)\n    final_audio = \"{}/final_audio.wav\".format(voice_dir)\n    audio_merged = merge_audio(voice_clips)\n    # bgm_path = \"/root/Desktop/works/bilibili_tarot/some_bgm.mp3\"\n    # bgm = AudioSegment.from_mp3(bgm_path)\n    # duration2 = audio_merged.duration_seconds\n    # bgm = bgm[:duration2*1000] # really?\n    # breakpoint()\n    # audio_merged = audio_merged.overlay(audio_merged,bgm,loop=True)  #wtf?\n    # audio_merged = audio_merged.overlay(bgm,loop=True)\n    # audio_merged = audio_merged.normalize()\n    # is it needed?\n    # shit.\n    audio_merged.export(final_audio, format=\"wav\")\n    final_video2 = \"{}/final_video2.mp4\".format(video_dir)\n    with open(\"mylist.txt\",\"w+\") as f:\n        for n in video_names:\n            f.write(\"file \"+n+\"\\n\")\n    os.system(\"ffmpeg -f concat -safe 0 -i mylist.txt -c copy {}\".format(final_video))\n    # output_length = VideoFileClip(final_video).duration\n    output_length = MediaInfo(filename=final_video).getInfo()[\"videoDuration\"]",
        "type": "code",
        "location": "/tests/bilibili_practices/bilibili_tarot/functional_voice_with_pictures.py:148-170"
    },
    "4025": {
        "file_id": 508,
        "content": "This code is performing audio and video merging, exporting the final audio file, creating a mylist.txt file for ffmpeg concatenation, and determining the output length of the final video. The code seems to have undergone revisions as there are comments stating \"wtf?\", \"shit.\", and \"is it needed?\" suggesting possible confusion or uncertainty about certain parts of the code.",
        "type": "comment"
    },
    "4026": {
        "file_id": 508,
        "content": "    output_length = float(output_length)\n    input_length = AudioSegment.from_wav(final_audio).duration_seconds\n    tempo = input_length/output_length\n    t_a,t_b = tempo.as_integer_ratio()\n    os.system('ffmpeg -i {} -i {} -c:v copy -c:a aac -filter:a \"atempo={}/{}\" -map 0:v:0 -map 1:a:0 {}'.format(final_video,final_audio,t_a,t_b,final_video2))\n    shutil.move(final_video2,target_video)",
        "type": "code",
        "location": "/tests/bilibili_practices/bilibili_tarot/functional_voice_with_pictures.py:171-176"
    },
    "4027": {
        "file_id": 508,
        "content": "This code calculates the tempo of an audio file and then applies it to another audio-video file using FFMPEG. It then moves the resulting file to a specified target location.",
        "type": "comment"
    },
    "4028": {
        "file_id": 509,
        "content": "/tests/bilibili_practices/bilibili_tarot/functional_generate_demo_tarot.py",
        "type": "filepath"
    },
    "4029": {
        "file_id": 509,
        "content": "This code generates a tarot image sequence, applies various filters and effects, resizes videos, pads them if necessary, compresses audio, and merges videos using FFmpeg commands.",
        "type": "summary"
    },
    "4030": {
        "file_id": 509,
        "content": "import os\nfrom vidpy import Clip, Composition  #many shitty things...\n# tarot_target = \"/root/Desktop/works/bilibili_tarot/tarot_pictures/0_THE_FOOL.jpg\"\nimport random\ndef gen_tarot(tarot_target,bgm_path,final_output):\n    os.system(\"rm tarot_demo.mp4\")\n    fps =60\n    # myprofile = {'width': 1320, 'height': 2644} # wtf?\n    # just create profile from it. are you sure?\n    clip = Clip(tarot_target, output_fps=fps,start=0, end=16,override=True)\n    # clip.edgeglow()\n    # clip.crop\n    # 1320x2645 # unbelievable.\n    # clip.fx(\"\",{})\n    # clip.resize(w=1920, h=1080, distort=True)\n    # distort=False\n    c_w = clip.width\n    c_h = clip.height\n    # comp = Composition([clip])\n    clip.dither(amount=0.07) # the greater the better.\n    clip.fadein(0.5)      # fade the clip in over 1 second\n    # clip.fadeout(3.5)   # fade the clip over 0.5 seconds\n    # clip.glow(3.5)         # add a glow effect\n    clip.spin(4, axis=\"z\")\n    clip.vignette()\n    clip.dust()\n    clip.hue(shift = 1-random.random()*0.5)\n    clip.pixelize(width = 0.005,height=0.01)",
        "type": "code",
        "location": "/tests/bilibili_practices/bilibili_tarot/functional_generate_demo_tarot.py:1-30"
    },
    "4031": {
        "file_id": 509,
        "content": "Code snippet imports necessary libraries, defines a function for generating a tarot image sequence, and applies various filters and effects to the input image. The function generates a random hue shift, pixelizes the image, adds a vignette effect, spins the image on the z-axis, and fades the clip in and out. The code uses overridden parameters for output resolution and aspect ratio, potentially causing inconsistencies or errors.",
        "type": "comment"
    },
    "4032": {
        "file_id": 509,
        "content": "    # clip.invert()\n    # clip.luminance\n    # clip.charcoal()\n    # clip.crop(right=c_w,bottom=c_h)\n    clip.save(\"tarot_demo.mp4\", fps=60,duration = 3,width=c_w,height=c_h) # good.\n    # print(c_w,c_h)\n    # 720 576\n    r1 = c_w/c_h\n    target_w, target_h = 1920, 1080\n    r2 = target_w/ target_h\n    if r1 < r2:\n        os.system('ffmpeg -y -i tarot_demo.mp4  -vf \"scale=-1:{},pad={}:ih:(ow-iw)/2\"  tarot_demo2.mp4'.format(target_h,target_w))\n    else:\n        os.system('ffmpeg -y -i tarot_demo.mp4  -vf \"scale={}:-1,pad=iw:{}:0:(oh-ih)/2\"  tarot_demo2.mp4'.format(target_w,target_h))\n    os.system(\"ffmpeg -y -i {} -i {} -c:v copy -c:a aac -map 0:v:0 -map 1:a:0 -shortest {}\".format(\"tarot_demo2.mp4\",bgm_path,final_output))\n    os.system(\"rm -rf tarot_demo2.mp4\")\n    os.system(\"rm -rf tarot_demo.mp4\")",
        "type": "code",
        "location": "/tests/bilibili_practices/bilibili_tarot/functional_generate_demo_tarot.py:31-49"
    },
    "4033": {
        "file_id": 509,
        "content": "The code resizes and pads a video, applies audio compression, then deletes intermediate files. It uses FFmpeg commands to scale the video, pad it if necessary, compress audio, and merge videos.",
        "type": "comment"
    },
    "4034": {
        "file_id": 510,
        "content": "/tests/bilibili_practices/bilibili_tarot/functional_gen_typo_video_seq.py",
        "type": "filepath"
    },
    "4035": {
        "file_id": 510,
        "content": "This function generates a video sequence with input \"seq\" and duration, applies filters to each clip, uses vidpy library for handling video composition, and saves the final composition as a video file.",
        "type": "summary"
    },
    "4036": {
        "file_id": 510,
        "content": "# seq = [0,1,2,3,4,5,6] # 7\n# duration = 4\nfrom vidpy import Composition, Clip\ndef gen_video(vname, seq, duration):\n    mduration = duration / len(seq)\n    clips = []\n    width,height =1920,1080\n    fps=60\n    orig_fps = 24\n    shift = fps/orig_fps\n    for i,s in enumerate(seq):\n        codec = str(s)\n        codec = \"0\"*(4-len(codec)) + codec\n        path = \"/root/Desktop/works/bilibili_tarot/demo_typography/screenshot{}.png\".format(codec)\n        start = i*mduration\n        end = start + mduration\n        print(start,end)\n        clip = Clip(path,output_fps=fps,start=0,end=mduration*shift,offset = start*shift,profile_override = {\"fps\":60,\"width\": width, \"height\": height})\n        clip.vignette()\n        clip.dust()\n        # clip.charcoal()\n        clip.dither(amount=0.10)\n        # clip.\n        # clip.pixelize()\n        clip.pixelize(width = 0.002,height=0.002)\n        clips.append(clip)\n    # breakpoint()\n    # # maybe some other bgm.\n    # bgm = Clip(bgm_path,start=0)\n    # clips.append(bgm)\n    # breakpoint()",
        "type": "code",
        "location": "/tests/bilibili_practices/bilibili_tarot/functional_gen_typo_video_seq.py:1-39"
    },
    "4037": {
        "file_id": 510,
        "content": "This function generates a video sequence based on input \"seq\" and duration, with each clip corresponding to a number in the sequence. It reads image files from \"/root/Desktop/works/bilibili_tarot/demo_typography/\" and applies various filters (vignette, dust, dithering, pixelize) to each clip before adding it to the list of clips. The function uses vidpy library for handling video composition and Clip class for each image frame.",
        "type": "comment"
    },
    "4038": {
        "file_id": 510,
        "content": "    comp = Composition(clips,duration=duration,fps=fps,width=width,height=height)\n    comp.save(vname,fps=60,duration = duration,width=width,height=height)",
        "type": "code",
        "location": "/tests/bilibili_practices/bilibili_tarot/functional_gen_typo_video_seq.py:40-42"
    },
    "4039": {
        "file_id": 510,
        "content": "The code above creates a Composition object with the specified clips, duration, fps, width, and height. Then, it saves this composition as a video file under the given 'vname' while maintaining the same settings.",
        "type": "comment"
    },
    "4040": {
        "file_id": 511,
        "content": "/tests/bilibili_practices/bilibili_tarot/flipcards.py",
        "type": "filepath"
    },
    "4041": {
        "file_id": 511,
        "content": "This code generates flipcards for Major and Minor Arcana in Tarot. It first clears directories, creates them, and then iterates over dictionaries to generate flipcard videos with specified background music, storing them accordingly.",
        "type": "summary"
    },
    "4042": {
        "file_id": 511,
        "content": "# generate all flipcards.\nfrom tarot_correspondences import *\nfrom functional_generate_demo_tarot import gen_tarot\n# mtarget_0, mtarget_1\ndir_0 = \"major\"\ndir_1 = \"minor\"\nos.system(\"rm -rf {}\".format(dir_0))\nos.system(\"rm -rf {}\".format(dir_1))\nos.mkdir(dir_0)\nos.mkdir(dir_1)\nbgm_path = \"/root/Desktop/works/bilibili_tarot/some_bgm.mp3\"\nfor k in mtarget_0.keys():\n    value = mtarget_0[k]\n    videoPath = \"/\".join([dir_0,\"{}.mp4\".format(k)])\n    picture_path = value\n    gen_tarot(picture_path,bgm_path,videoPath)\nfor k in mtarget_1.keys():\n    value = mtarget_1[k]\n    videoPath = \"/\".join([dir_1,\"{}.mp4\".format(k)])\n    picture_path = value\n    gen_tarot(picture_path,bgm_path,videoPath)",
        "type": "code",
        "location": "/tests/bilibili_practices/bilibili_tarot/flipcards.py:1-27"
    },
    "4043": {
        "file_id": 511,
        "content": "This code generates flipcards for Major and Minor Arcana in Tarot. It first clears directories, creates them, and then iterates over dictionaries to generate flipcard videos with specified background music, storing them accordingly.",
        "type": "comment"
    },
    "4044": {
        "file_id": 512,
        "content": "/tests/bilibili_practices/bilibili_tarot/all_typography_underline_subtitle.py",
        "type": "filepath"
    },
    "4045": {
        "file_id": 512,
        "content": "The code removes files, uses external scripts and programs to generate typography for a bilibili video, and is part of a larger video editing or manipulation process.",
        "type": "summary"
    },
    "4046": {
        "file_id": 512,
        "content": "from tarot_descriptions import *\n# mdict, smdict2\nimport os\ndef gen_typography_part1(content):\n    with open(\"demo_text.log\",\"w+\",encoding=\"utf8\") as f:\n        f.write(content)\n    os.system(\"xvfb-run -s '-screen 0 1920x1080x24' python3 scriptable_generate_typography_with_voice_underline_subtitle.py\")\ndef kill_script():\n    os.system(\"bash kill_xb.sh\")\ntyp_0 = \"typo_0\"\ntyp_1 = \"typo_1\"\n# os.system(\"rm -rf {}\".format(typ_0))\n# os.system(\"rm -rf {}\".format(typ_1))\n# os.mkdir(typ_0)\n# os.mkdir(typ_1)\nfrom functional_voice_with_pictures import gen_typography_part3\n# intro_text = \"\"\"塔罗牌，是一种针对人、事、物进行分析、预测和提供建议的工具，被称为“大自然的奥秘库”。\n# 抽取一张塔罗牌，今天的你会是怎样的呢？\"\"\"\nintro_text = \"\"\"奥拓是只猫～\"\"\"\n# bgm_path = \"/root/Desktop/works/bilibili_tarot/tarot_random_shuffle.mp3\"\ntarget_video = \"cat_intro_video.mp4\"\nos.system(\"rm {}\".format(target_video))\nkill_script()\n# v = mdict[k]\nv = intro_text\ngen_typography_part1(v)\n# target_video = \"/\".join([typ_0,\"{}.mp4\".format(k)])\ngen_typography_part3(v,target_video)\nkill_script()\nintro_text = \"\"\"喜欢本期视频的话 点个关注再走吧～\"\"\"",
        "type": "code",
        "location": "/tests/bilibili_practices/bilibili_tarot/all_typography_underline_subtitle.py:1-43"
    },
    "4047": {
        "file_id": 512,
        "content": "This code generates typography for a bilibili video, involves creating directories and removing files, uses os.system to run external scripts and programs, and has an introductory message followed by an ending message for the video.",
        "type": "comment"
    },
    "4048": {
        "file_id": 512,
        "content": "# bgm_path = \"/root/Desktop/works/bilibili_tarot/tarot_random_shuffle.mp3\"\ntarget_video = \"cat_outro_video.mp4\"\nos.system(\"rm {}\".format(target_video))\nkill_script()\n# v = mdict[k]\nv = intro_text\ngen_typography_part1(v)\n# target_video = \"/\".join([typ_0,\"{}.mp4\".format(k)])\ngen_typography_part3(v,target_video)\nkill_script()",
        "type": "code",
        "location": "/tests/bilibili_practices/bilibili_tarot/all_typography_underline_subtitle.py:45-56"
    },
    "4049": {
        "file_id": 512,
        "content": "This code removes the target video file, terminates a script, generates typography for a specific text using functions gen_typography_part1 and gen_typography_part3, and then terminates another script. It seems to be part of a process involving video editing or manipulation.",
        "type": "comment"
    },
    "4050": {
        "file_id": 513,
        "content": "/tests/bilibili_practices/bilibili_tarot/scriptable_generate_typography_with_voice_underline_subtitle.py",
        "type": "filepath"
    },
    "4051": {
        "file_id": 513,
        "content": "This code imports necessary modules and sets up the environment for typography generation using voice underscore subtitle. It reads a demo text, creates a directory to save generated images, sets font and size, and draws each character on the screen with optional rotation and filling options.",
        "type": "summary"
    },
    "4052": {
        "file_id": 513,
        "content": "from p5 import *\nimport os\n# from test_common import demo_text\ndemo_text = open(\"demo_text.log\",\"r\",encoding=\"utf-8\").read()\nos.system(\"rm screenshot*\")\ntarget_dir = \"demo_typography\"\nos.system(\"rm -rf {}\".format(target_dir))\nos.system(\"mkdir {}\".format(target_dir))\ntsize = 100\ncounterx = 0\nscrwidth = 1920\nxcoord = int(scrwidth/2) # how to get this shit?\nscrheight = 1080\nycoord = scrheight - tsize - 75\nlineNum = 0\n# what fucking ever.\ns = demo_text\ns0 = [\"\"]\ndef setup():\n    size(scrwidth,scrheight)\n    # text_font(create_font('./fonts/Fonts/博洋行书3500.ttf', size=tsize))\n    # text_font(create_font('./fonts/Fonts/书体坊兰亭体I.ttf', size=tsize))\n    text_font(create_font('./SimHei.ttf', size=tsize))\nimport random\ndef draw():\n    global counterx,xcoord,ycoord,s,s0,scrheight,scrwidth,lineNum,target_dir\n    #force override.\n    background(0)\n    if counterx > len(s)-1:\n        exit()\n    s1 = s[:counterx]\n    counterx+=1\n    mtext_width = text_width(s1)\n    try:\n        text9 = s1\n        # else:\n        #     text9 = \" \"\n        # l = len(s0)-1",
        "type": "code",
        "location": "/tests/bilibili_practices/bilibili_tarot/scriptable_generate_typography_with_voice_underline_subtitle.py:1-46"
    },
    "4053": {
        "file_id": 513,
        "content": "This code is importing necessary modules and setting up the environment for generating typography with voice underscore subtitle. It reads a demo text, creates a directory to save the generated images, sets up font and size, and begins drawing each character from the text on the screen.",
        "type": "comment"
    },
    "4054": {
        "file_id": 513,
        "content": "        # rotate = random.randint(-15,15)\n        # rotate = random.choice([random.randint(-20,-10),random.randint(10,20)])\n        rotate = 0\n        # r1 = random.randint(220,255)\n        # r2 = random.randint(220,255)\n        # r3 = random.randint(220,255)\n        # r4 = random.randint(220,255)\n        r1 = r2 = r3 = r4 = 255\n        fill(red=r1, green=r2, blue=r3, alpha=r4)\n        text(text9, (xcoord-int(mtext_width/2), ycoord,),rotate = rotate)  # add str() to key\n    except:\n        import traceback\n        traceback.print_exc()\n        print(\"SHIT HAPPENED\")\n        pass\n    save_frame(\"{}/screenshot.png\".format(target_dir))\nrun()\nprint(\"EXITED.\")",
        "type": "code",
        "location": "/tests/bilibili_practices/bilibili_tarot/scriptable_generate_typography_with_voice_underline_subtitle.py:47-65"
    },
    "4055": {
        "file_id": 513,
        "content": "This code sets the rotate value to 0 and RGB values to 255 for filling text. It then displays the text at specified coordinates with optional rotation. If an exception occurs, it prints the traceback and a message before saving a screenshot. The program exits and prints \"EXITED.\"",
        "type": "comment"
    },
    "4056": {
        "file_id": 514,
        "content": "/tests/bilibili_practices/bilibili_tarot/scriptable_generate_typography_with_voice.py",
        "type": "filepath"
    },
    "4057": {
        "file_id": 514,
        "content": "The code manages text display, handles line wrapping and background color updates, reads a file for processing, generates typography text with voice, applies random rotation and colors, saves screenshot or displays error message, then exits.",
        "type": "summary"
    },
    "4058": {
        "file_id": 514,
        "content": "from p5 import *\nimport os\n# from test_common import demo_text\ndemo_text = open(\"demo_text.log\",\"r\",encoding=\"utf-8\").read()\nos.system(\"rm screenshot*\")\ntarget_dir = \"demo_typography\"\nos.system(\"rm -rf {}\".format(target_dir))\nos.system(\"mkdir {}\".format(target_dir))\ntsize = 70\ncounterx = 0\nxcoord = 20\nycoord = 75\nscrwidth = 1920\nscrheight = 1080\nlineNum = 0\n# what fucking ever.\ns = demo_text\ns0 = [\"\"]\ndef setup():\n    size(scrwidth,scrheight)\n    # text_font(create_font('./fonts/Fonts/博洋行书3500.ttf', size=tsize))\n    text_font(create_font('./fonts/Fonts/书体坊兰亭体I.ttf', size=tsize))\n    # text_font(create_font('./SimHei.ttf', size=tsize))\nimport random\ndef draw():\n    global counterx,xcoord,ycoord,s,s0,scrheight,scrwidth,lineNum,target_dir\n    if len(s0) ==1:\n        if len(s0[0]) == 0:\n            background(0)\n    if counterx > len(s)-1:\n        exit()\n    s1 = s[counterx]\n    returnFlag = False\n    if s1 == \"\\n\":\n        # this is return!\n        returnFlag = True\n        lineNum +=1\n        stemp0 = \"\" # this is nothing.\n        tw = text_width(stemp0)",
        "type": "code",
        "location": "/tests/bilibili_practices/bilibili_tarot/scriptable_generate_typography_with_voice.py:1-47"
    },
    "4059": {
        "file_id": 514,
        "content": "The code reads a text file, clears the target directory, sets up the screen size and font, and starts drawing characters onto the screen. It checks for line breaks and keeps track of the current position and text content. If there is no more text to process, it exits.",
        "type": "comment"
    },
    "4060": {
        "file_id": 514,
        "content": "        th = tsize*(lineNum+1) + tsize*0.2*(lineNum)\n        if (ycoord+th> scrheight):\n            # stemp0 = s1\n            s0 = [stemp0]\n            clear()\n            background(0)\n            lineNum = 0\n        else:\n            s0.append(stemp0)\n    else:\n        stemp0 = s0[-1]+s1\n        tw = text_width(stemp0)\n        th = tsize*(lineNum+1) + tsize*0.2*lineNum\n        if (tw + xcoord+ tsize*0.5> scrwidth):\n            stemp0 = s1\n            s0.append(stemp0)\n            lineNum +=1\n            th = tsize*(lineNum+1) + tsize*0.2*lineNum\n            if (ycoord+th> scrheight):\n                # stemp0 = s1\n                s0 = [stemp0]\n                background(0)\n                lineNum = 0\n        else:\n            s0[-1]= stemp0\n        # no_loop()\n        # clear\n    # s0 = stemp0\n        # end all evil.\n    counterx+=1\n    # load_font(\"SimHei.ttf\")\n    # print(\"text w/h:\",tw,th)\n    # for l, text9 in enumerate(s0):\n    if len(s0) == 1 and len(s0[0])<=1: # whatever.\n        # breakpoint()\n        clear()\n        background(0)",
        "type": "code",
        "location": "/tests/bilibili_practices/bilibili_tarot/scriptable_generate_typography_with_voice.py:48-85"
    },
    "4061": {
        "file_id": 514,
        "content": "This code is handling text wrapping and line breaking for a text display system. It checks the text width and height, splitting lines when necessary and adjusting the number of lines based on available space. The code also clears the screen and updates the background color when needed to ensure proper visuals.",
        "type": "comment"
    },
    "4062": {
        "file_id": 514,
        "content": "    # if not returnFlag:\n    # print(s0)\n    try:\n        text9 = s0[-1][-1]\n        # else:\n        #     text9 = \" \"\n        l = len(s0)-1\n        # rotate = random.randint(-15,15)\n        rotate = random.choice([random.randint(-20,-10),random.randint(10,20)])\n        r1 = random.randint(200,255)\n        r2 = random.randint(200,255)\n        r3 = random.randint(200,255)\n        r4 = random.randint(200,255)\n        fill(red=r1, green=r2, blue=r3, alpha=r4)\n        text(text9, (xcoord+text_width(s0[-1][:-1]), ycoord+ l*(tsize*1.2),),rotate = rotate)  # add str() to key\n    except:\n        import traceback\n        traceback.print_exc()\n        print(\"SHIT HAPPENED\")\n        pass\n    save_frame(\"{}/screenshot.png\".format(target_dir))\nrun()\nprint(\"EXITED.\")",
        "type": "code",
        "location": "/tests/bilibili_practices/bilibili_tarot/scriptable_generate_typography_with_voice.py:86-109"
    },
    "4063": {
        "file_id": 514,
        "content": "This code generates a typography text with voice and applies random rotation, colors, and adjusts position based on the length of the text. It saves a screenshot if no exception occurs, otherwise prints \"SHIT HAPPENED\" and continues. Finally, it exits and prints \"EXITED.\"",
        "type": "comment"
    },
    "4064": {
        "file_id": 515,
        "content": "/tests/bilibili_practices/bilibili_tarot/pooling.py",
        "type": "filepath"
    },
    "4065": {
        "file_id": 515,
        "content": "This code creates a \"final_output\" directory and moves files from specified directories (\"major\", \"minor\", \"typo_0\", and \"typo_1\") to it, appending their filenames with the directory name. It also moves two specific video files to the same directory.",
        "type": "summary"
    },
    "4066": {
        "file_id": 515,
        "content": "dirs = [\"major\",\"minor\",\"typo_0\",\"typo_1\"]\nimport os\nimport shutil\nos.system(\"mkdir final_output\")\nfor d in dirs:\n    files = os.listdir(d)\n    for f in files:\n        fname = \"{}_{}\".format(d,f)\n        shutil.move(os.path.join(d,f),os.path.join(\"final_output\",fname))\nfor x in [\"intro_video.mp4\",\"outro_video.mp4\"]:\n    shutil.move(x,os.path.join(\"final_output\",x))",
        "type": "code",
        "location": "/tests/bilibili_practices/bilibili_tarot/pooling.py:1-15"
    },
    "4067": {
        "file_id": 515,
        "content": "This code creates a \"final_output\" directory and moves files from specified directories (\"major\", \"minor\", \"typo_0\", and \"typo_1\") to it, appending their filenames with the directory name. It also moves two specific video files to the same directory.",
        "type": "comment"
    },
    "4068": {
        "file_id": 516,
        "content": "/tests/bilibili_practices/bilibili_tarot/mylist.txt",
        "type": "filepath"
    },
    "4069": {
        "file_id": 516,
        "content": "This code appears to be a text file listing videos in a specific order, potentially for a media player or organization system. The video files are named \"video/0.mp4\" and \"video/1.mp4\".",
        "type": "summary"
    },
    "4070": {
        "file_id": 516,
        "content": "file video/0.mp4\nfile video/1.mp4",
        "type": "code",
        "location": "/tests/bilibili_practices/bilibili_tarot/mylist.txt:1-2"
    },
    "4071": {
        "file_id": 516,
        "content": "This code appears to be a text file listing videos in a specific order, potentially for a media player or organization system. The video files are named \"video/0.mp4\" and \"video/1.mp4\".",
        "type": "comment"
    },
    "4072": {
        "file_id": 517,
        "content": "/tests/bilibili_practices/bilibili_tarot/kill_xb.sh",
        "type": "filepath"
    },
    "4073": {
        "file_id": 517,
        "content": "This script kills processes named \"xvfb\" and \"scriptable_generate_typography\" by first listing all processes, filtering out grep processes, searching for the desired process names, printing their PIDs, and then sending a TERM signal to kill them.",
        "type": "summary"
    },
    "4074": {
        "file_id": 517,
        "content": "ps aux | grep -v grep | grep xvfb | awk '{print $2}' | xargs -iabc kill -s TERM abc\nps aux | grep -v grep | grep scriptable_generate_typography | awk '{print $2}' | xargs -iabc kill -s TERM abc",
        "type": "code",
        "location": "/tests/bilibili_practices/bilibili_tarot/kill_xb.sh:1-2"
    },
    "4075": {
        "file_id": 517,
        "content": "This script kills processes named \"xvfb\" and \"scriptable_generate_typography\" by first listing all processes, filtering out grep processes, searching for the desired process names, printing their PIDs, and then sending a TERM signal to kill them.",
        "type": "comment"
    },
    "4076": {
        "file_id": 518,
        "content": "/tests/bilibili_practices/bilibili_tarot/kill_pdspc.sh",
        "type": "filepath"
    },
    "4077": {
        "file_id": 518,
        "content": "This command finds processes named \"paddlespeech\", gets their process IDs, and then kills them using the KILL signal.",
        "type": "summary"
    },
    "4078": {
        "file_id": 518,
        "content": "ps aux | grep -v grep | grep paddlespeech | awk '{print $2}' | xargs -iabc kill -s KILL abc",
        "type": "code",
        "location": "/tests/bilibili_practices/bilibili_tarot/kill_pdspc.sh:1-1"
    },
    "4079": {
        "file_id": 518,
        "content": "This command finds processes named \"paddlespeech\", gets their process IDs, and then kills them using the KILL signal.",
        "type": "comment"
    },
    "4080": {
        "file_id": 519,
        "content": "/tests/bilibili_practices/bilibili_tarot/get_tarots.py",
        "type": "filepath"
    },
    "4081": {
        "file_id": 519,
        "content": "The code retrieves Tarot card images from \"i0.hdslb.com\" domain, uses PaddleOCR for recognition, saves high certainty recognized files with new names.",
        "type": "summary"
    },
    "4082": {
        "file_id": 519,
        "content": "links = [\"https://i0.hdslb.com/bfs/article/231a2286704d13675c25df228abed3d2ddbf2d00.jpg\",\"https://i0.hdslb.com/bfs/article/c841534b39133e4e96f8bbb19a4471843243c5d4.jpg\",\"https://i0.hdslb.com/bfs/article/7913498bb634b8a13c1b60dbdcaed4463fa17f50.jpg\",\"https://i0.hdslb.com/bfs/article/ec07923700f633578a681c56a008505893cf47a6.jpg\",\"https://i0.hdslb.com/bfs/article/c2691feff128c0b982d9d28ce798b3a3327fd161.jpg\",\"https://i0.hdslb.com/bfs/article/78d92d8abac6fbb8a1a3c9bcf44b76b9e2b709c9.jpg\",\"https://i0.hdslb.com/bfs/article/1d8bc016bd9593a1ffc7c6ace7a0b6e2795ba24a.jpg\",\"https://i0.hdslb.com/bfs/article/e9a3e50378caf80fa7f1584813e7d88ea5f4e4f3.jpg\",\"https://i0.hdslb.com/bfs/article/b73f8a8bc1f215af7e181e1e5f4a682d353dd7f5.jpg\",\"https://i0.hdslb.com/bfs/article/9ebb2bf93fcd4bf0c0dd413c378ebe6b6c4b436a.jpg\",\"https://i0.hdslb.com/bfs/article/063b2dee6bb57a5de4fd518d671e2fc384089705.jpg\",\"https://i0.hdslb.com/bfs/article/9061adbc1f3fe0a6a591e64972feeef126d405bd.jpg\",\"https://i0.hdslb.com/bfs/artic",
        "type": "code",
        "location": "/tests/bilibili_practices/bilibili_tarot/get_tarots.py:1-1"
    },
    "4083": {
        "file_id": 519,
        "content": "The code contains a list of URLs to images.",
        "type": "comment"
    },
    "4084": {
        "file_id": 519,
        "content": "le/16a5af1e204e9d99e29ce567da625fe4cbf97654.jpg\",\"https://i0.hdslb.com/bfs/article/064628af3ba2caad6da4f256c1203a2e5abc84d5.jpg\",\"https://i0.hdslb.com/bfs/article/e91f4d2080851dcd3b7d95b5899c3819379e7419.jpg\",\"https://i0.hdslb.com/bfs/article/ed7503d3465cc98c4f33c7269d4003dff5c0e30e.jpg\",\"https://i0.hdslb.com/bfs/article/30ead312e5de86bab22b1408cfd7e343f7a444ba.jpg\",\"https://i0.hdslb.com/bfs/article/8f099a8a276dcc0304d5ab8032bcca6df92fad45.jpg\",\"https://i0.hdslb.com/bfs/article/d64bde431d4696dc049ccc156689d00f8b56d3e4.jpg\",\"https://i0.hdslb.com/bfs/article/e7b7805ffb07eee969a18b543a342290e847a488.jpg\",\"https://i0.hdslb.com/bfs/article/f6aad92efa9a9db5ab650cc9d958899d3eb0ccc5.jpg\",\"https://i0.hdslb.com/bfs/article/e0ef8a4a11c3451a81e8f8a4aea0460f308aed6d.jpg\",\"https://i0.hdslb.com/bfs/article/7000095230b4d1e4e9c82f596228342a38fceb3b.jpg\"]\n# links = [\"https://i0.hdslb.com/bfs/article/328165fb5c73e4b9a11eb335a6ccbad144606495.jpg\",\"https://i0.hdslb.com/bfs/article/02db465212d3c374a43c60fa26",
        "type": "code",
        "location": "/tests/bilibili_practices/bilibili_tarot/get_tarots.py:1-4"
    },
    "4085": {
        "file_id": 519,
        "content": "Code is listing a series of URLs for images, possibly used for retrieving image resources from the internet.",
        "type": "comment"
    },
    "4086": {
        "file_id": 519,
        "content": "25cc1caeaab796.png\",\"https://i0.hdslb.com/bfs/article/ef99b038b6c254b5ee3c77641a2d24523b2f2549.jpg\",\"https://i0.hdslb.com/bfs/article/6831c04615d8c2656bf9edb260b2692600506b12.jpg\",\"https://i0.hdslb.com/bfs/article/b6e798cc616440a2d8f0e3da08f2e47deb3dea5e.jpg\",\"https://i0.hdslb.com/bfs/article/d6a352ed8ef2662b249b31617d16cb7b49012980.jpg\",\"https://i0.hdslb.com/bfs/article/3ece6a53ffc6d1b934830771861087477def3754.jpg\",\"https://i0.hdslb.com/bfs/article/f0207ebb2a7d120ebd22cec39cf242888747f1aa.jpg\",\"https://i0.hdslb.com/bfs/article/fe80a0fcaecbca438a28dcf6d64b2fdfcf0395dd.jpg\",\"https://i0.hdslb.com/bfs/article/6b60f9321e1c902983020925b9cd77eeb90b0d37.jpg\",\"https://i0.hdslb.com/bfs/article/0e4460990f511fdbdd035872d9e4019d1a91a1c2.jpg\",\"https://i0.hdslb.com/bfs/article/92746eb9f9b399b7f959040e4e108099282c7e78.jpg\",\"https://i0.hdslb.com/bfs/article/41cbd61a4ff091d8a812f2c156b41a42e7cfbcee.jpg\",\"https://i0.hdslb.com/bfs/article/419c0b63e00243fd36a664625528817c5e9b56f9.jpg\",\"https://i0.hdslb.co",
        "type": "code",
        "location": "/tests/bilibili_practices/bilibili_tarot/get_tarots.py:4-4"
    },
    "4087": {
        "file_id": 519,
        "content": "This code contains a list of URLs for images, possibly used to display Tarot card art in an application.",
        "type": "comment"
    },
    "4088": {
        "file_id": 519,
        "content": "m/bfs/article/920f5219d12369d35025f415456a1c8f17af80f0.jpg\",\"https://i0.hdslb.com/bfs/article/f06e85b771817651287a5550a52ab2d407b9bdfd.jpg\",\"https://i0.hdslb.com/bfs/article/4c24e5879af822216e609aa6d7e0aab35fdea868.jpg\",\"https://i0.hdslb.com/bfs/article/3a016ea4f11e086547d5b3cafae7ab4014934415.jpg\",\"https://i0.hdslb.com/bfs/article/57185c84c272c0f9ee70a18a5a969236c43da5d9.jpg\",\"https://i0.hdslb.com/bfs/article/8d2de4ec7b46001041b1b9434f80a4db48cb0182.jpg\",\"https://i0.hdslb.com/bfs/article/780aef80d7246206a5bb4927e2834dc55286fb19.jpg\",\"https://i0.hdslb.com/bfs/article/246967f4d22e55c70666b4ac41205dd2c6cd3cde.jpg\",\"https://i0.hdslb.com/bfs/article/84f521382f7c02e6e4ea0daabb6e93192134372a.jpg\",\"https://i0.hdslb.com/bfs/article/7fd2ad226c81b31d397323891c8194d67f2fdf2b.jpg\",\"https://i0.hdslb.com/bfs/article/eee197d9172b1c38218ab642596b2990afcc383c.jpg\",\"https://i0.hdslb.com/bfs/article/736b5609c526379a8089a7741e19586eebeeb3e2.jpg\",\"https://i0.hdslb.com/bfs/article/93b97faaaa5a14242d21a2e592",
        "type": "code",
        "location": "/tests/bilibili_practices/bilibili_tarot/get_tarots.py:4-4"
    },
    "4089": {
        "file_id": 519,
        "content": "This code is a list of URLs for different images, likely used in a web context. Each URL corresponds to an image file hosted on the \"i0.hdslb.com\" domain. The exact purpose or application context is not clear from this snippet alone.",
        "type": "comment"
    },
    "4090": {
        "file_id": 519,
        "content": "b03b87fa0c5ff3.jpg\",\"https://i0.hdslb.com/bfs/article/ea528dc4bc964eaf9960fdc9d399b03f87db9ddb.jpg\"]\nimport requests\nimport cv2 # will it work?\nimport uuid\nimport shutil\nfrom test_common import *\n# import paddleocr\nfrom paddleocr import PaddleOCR,draw_ocr\nbasepath = \"tarot_pictures\"\n# basepath = \"tarot_pictures2\"\n# Paddleocr supports Chinese, English, French, German, Korean and Japanese.\n# You can set the parameter `lang` as `ch`, `en`, `french`, `german`, `korean`, `japan`\n# to switch the language model in order.\nocr = PaddleOCR(use_angle_cls=True, lang='en') # need to run only once to download and load model into memory\n# img_path = 'PaddleOCR/doc/imgs_en/img_12.jpg'\n# result = ocr.ocr(img_path, cls=True)\n# for line in result:\n#     print(line)\nos.system(\"rm -rf {}\".format(basepath))\nos.system(\"mkdir {}\".format(basepath))\nfor imglink in links:\n    print(\"DOWNLOADING:\",imglink)\n    while True:\n        try:\n            r = requests.get(imglink)\n            break\n        except:\n            continue\n    data = r.content # save as picture.",
        "type": "code",
        "location": "/tests/bilibili_practices/bilibili_tarot/get_tarots.py:4-36"
    },
    "4091": {
        "file_id": 519,
        "content": "The code imports necessary libraries and initializes a PaddleOCR object. It then clears the specified directory and downloads images from provided links, one by one, until successful download is achieved.",
        "type": "comment"
    },
    "4092": {
        "file_id": 519,
        "content": "    tmpname = \"{}.jpg\".format(str(uuid.uuid4()))\n    tmpname = os.path.join(basepath,tmpname)\n    with open(tmpname,\"wb\") as f:\n        f.write(data)\n    new_name = []\n    picture = cv2.imread(tmpname)\n    result = ocr.ocr(picture, cls=True)\n    for line in result:\n        ((x1,y1),(x2,y2),(x3,y3),(x4,y4)), (string,certainty) = line\n        if certainty > 0.7:\n            new_name.append(string)\n    new_name = \"_\".join(new_name)\n    switch = len(new_name)>3\n    if switch:\n        new_name = \"{}.jpg\".format(new_name)\n        new_name = os.path.join(basepath,new_name)\n        print(\"NEWNAME:\",new_name)\n        shutil.move(tmpname,new_name)",
        "type": "code",
        "location": "/tests/bilibili_practices/bilibili_tarot/get_tarots.py:37-54"
    },
    "4093": {
        "file_id": 519,
        "content": "This code generates a temporary file name, reads image data from 'data' variable into the file, and uses OpenCV to read the image. It then performs OCR (optical character recognition) on the image using the 'ocr' function. The recognized text lines are checked for certainty, and if it exceeds 0.7, the string is added to a new_name list. If the length of the new name is greater than 3 characters, it generates a final file name and moves the temporary file to its permanent location using 'shutil.move()'. It also prints \"NEWNAME:\" followed by the new file name to the console.",
        "type": "comment"
    },
    "4094": {
        "file_id": 520,
        "content": "/tests/bilibili_practices/bilibili_tarot/tarot_descriptions.py",
        "type": "filepath"
    },
    "4095": {
        "file_id": 520,
        "content": "This code provides Tarot card interpretations for Rider-Waite deck, focusing on career, relationships, and personal growth. The Tower (XVI) represents change and urging embracing it for a better future.",
        "type": "summary"
    },
    "4096": {
        "file_id": 520,
        "content": "mdict = {0: \"\"\"【0】愚者（The Fool，0)\n正位释义：\n事情的开始，行动的改变，熟练的技术及技巧，贯彻我的意志，运用自然的力量来达到野心。\n逆位释义：\n意志力薄弱，起头难，走入错误的方向，知识不足，被骗和失败。\"\"\", 1: \"\"\"【1】魔术师（The Magician，I)\n牌面为罗马神话的诸神传信使墨丘利，有着自信的笑容和炯炯有神的眼睛。 牌的桌面摆了宇宙四要素∶权杖（火）、剑（风）、星币（土）、圣杯（水）魔术师头顶上有个无限的符号，腰带为一头尾相接的蛇，是精神永恒的象征。\n魔术师右手拿着权杖指向天空，左手指着地面，代表权力的交流和精神的赠与。魔术师脚底下为玫瑰和百合，表示人类的动机，反映神的意志，指挥天地。 玫瑰代表生，百合代表死亡。 魔术师为第一张牌，也暗示着你本身也是个魔术师，自己能操纵宇宙的力量。白色长袍代表纯洁的内心，深红色斗篷代表魔术师的活动意义深远。\"\"\", 2: \"\"\"【2】女祭司（The High Priestess，II)\n开发出内在的神秘潜力，前途将有所变化的预言，深刻地思考，敏锐的洞察力，准确的直觉。\n过于洁癖，无知，贪心，目光短浅，自尊心过高，偏差的判断，有勇无谋，自命不凡。\"\"\", 3: \"\"\"【3】女皇（The Empress，III)\n幸福，成功，收获，无忧无虑，圆满的家庭生活，良好的环境，美貌，艺术，与大自然接触，愉快的旅行，休闲。\n倒转解释：\n不活泼，缺乏上进心，散漫的生活习惯，无法解决的事情，不能看到成果，担于享乐，环境险恶，与家人发生纠纷。\"\"\", 4: \"\"\"【4】皇帝（The Emperor，IV)\n光荣，权力，胜利，握有领导权，坚强的意志，达成目标，父亲的责任，精神上的孤单。\n幼稚，无力，独裁，撒娇任性，平凡，没有自信，行动力不足，意志薄弱，被支配。\"\"\", 5: \"\"\"【5】教皇（The Hierophant，or the Pope，V)\n援助，同情，宽宏大量，可信任的人给予的劝告，良好的商量对象，得到精神上的满足，遵守规则，志愿者。信心十足，能正确理解事物本质，工作上外来压力过多，使你有被束缚的感觉。寻找新的工作方法，尽管会面对很大的阻力，但结果会证明这样做是值得的。爱情上屈从于他人的压力，只会按照对方的要求来盲目改变自己，自以为这是必要的付出，其实不过是被迫的选择。伴侣也不会对你保持忠诚，并很难满足双方真实的需要。\n错",
        "type": "code",
        "location": "/tests/bilibili_practices/bilibili_tarot/tarot_descriptions.py:1-31"
    },
    "4097": {
        "file_id": 520,
        "content": "```python\n# tarot descriptions, each key-value pair represents a tarot card with its meaning and interpretations\nmdict = {\n    0: \"Tarot 0: The Fool - start of something, change, mastery, will, natural power\",\n    1: \"Tarot 1: The Magician - magic, confidence, universal connection, command\",\n    2: \"Tarot 2: The High Priestess - intuition, inner potential, insight, misguided pride\",\n    3: \"Tarot 3: The Empress - harmony, success, fulfillment, family, environment, beauty\",\n    4: \"Tarot 4: The Emperor - authority, strength, victory, fatherhood, isolation\",\n    5: \"Tarot 5: The Hierophant - guidance, compassion, spiritual growth, rule-following, sacrifice\"\n}\n```",
        "type": "comment"
    },
    "4098": {
        "file_id": 520,
        "content": "误的讯息，恶意的规劝，上当，援助被中断，愿望无法达成，被人利用，被放弃。事业上多了些灵活的态度，不再刻板遵循旧有的方式，勇于创新形成自己独特的理念，为自己的真实想法而活、而工作。感情上开始正视自己对感情的真实感受与做法，尽管依旧会听取对方的意见，但以不会全盘接受。当你感到无法接受对方的意见时，会及时与其沟通，找出改善关系的做法。\"\"\", 6: \"\"\"【6】恋人（The Lovers，VI)\n撮合，爱情，流行，兴趣，充满希望的未来，魅力，增加朋友。感情和肉体对爱的渴望，它暗示恋情将向彼此关系更亲密的方向发展。事业上将面临重大的抉择，它将关系到你的未来前途。\n禁不起诱惑，纵欲过度，反覆无常，友情变淡，厌倦，争吵，华丽的打扮，优柔寡断。感情上表现幼稚，对成长虽有期待与希望，却希望永远躲避危险，逃避责任。事业上总保持着很高的戒心，让人感到很不舒服，不愿同你合作。\"\"\", 7: \"\"\"【7】战车（The Chariot，VII)\n努力而获得成功，胜利，克服障碍，行动力，自立，尝试，自我主张，年轻男子，交通工具，旅行运大吉。事业上显示出才能，办事卓有成效。自信而富理智的你将让客户更有信心，愿意与你共同合作。在感情上正在努力控制自己的情绪，而且控制得很好，这让你的感情发展得更顺利。\n争论失败，发生纠纷，阻滞，违返规则，诉诸暴力，顽固的男子，突然的失败，不良少年，挫折和自私自利。放弃以往在事业上所坚持的，结局将会更加完美。感情上失去方向，你已经没有以往的冷静，这让对方在心中产生了不信任感，也许你要反省一下自己的所作所为了。\"\"\", 8: \"\"\"【8】力量（Strength，VIII）\n大胆的行动，有勇气的决断，新发展，大转机，异动，以意志力战胜困难，健壮的女人。在事业上你不断突破自我，上司和客户都对你有充分的信心，成就接踵而来。在爱情上，你将发展一段真正亲密的感情，你们全心投入，相互倾诉，丝毫没有距离感。\n胆小，输给强者，经不起诱惑，屈服在权威与常识之下，没有实践便告放弃，虚荣，懦弱，没有耐性。内心的恐惧使你畏首畏尾，进而遭遇事业的瓶颈，感到失去了自信。在爱情上患得患失，失去清醒的判断。\"\"\", 9: \"\"\"【9】隐者（The Hermit，IX)\n隐藏的事实，个别的行动，倾听他人的意见，享受孤独，自己的丢化，有益的警戒，年长者，避开危险，祖父，乡间生活。你在事业黄金时期引退，旁人都不了解这不过是你在为下一次黄金时期的到来进行休息。感情方面你将深刻思考自己在这段感情中的角色和地位，并探索彼此之间的关系。",
        "type": "code",
        "location": "/tests/bilibili_practices/bilibili_tarot/tarot_descriptions.py:31-45"
    },
    "4099": {
        "file_id": 520,
        "content": "Code represents tarot card descriptions for the Rider-Waite tarot deck, with each numbered section corresponding to a specific tarot card. The descriptions provide insights into areas of life such as career, relationships, and personal growth based on the card's symbolism and interpretation.",
        "type": "comment"
    }
}